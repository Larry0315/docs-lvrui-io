<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>etcd 灾难恢复</title>
    <url>/2020/04/14/etcd-%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<blockquote>
<p>etcd的灾难恢复, 需要使用到快照文件, 本质是一次恢复快照的操作. 当etcd集群的大多数节点永久失联或短时间内无法继续正常使用时, 要想恢复etcd集群的服务, 需要执行etcd的快照恢复操作. 注意v2和v3版本数据恢复是两码事儿, 本篇重点介绍v3版本的数据备份和恢复</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>前篇文章中留存的实验环境:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1161d5b4260241e3, started, lv-etcd-research-alpha-1, http:&#x2F;&#x2F;192.168.149.63:2380, http:&#x2F;&#x2F;192.168.149.63:2379</span><br><span class="line">2145c204a51dbbc7, started, lv-etcd-research-alpha-0, http:&#x2F;&#x2F;192.168.149.60:2380, http:&#x2F;&#x2F;192.168.149.60:2379</span><br><span class="line">4252aec339d438d9, started, lv-etcd-research-alpha-3, http:&#x2F;&#x2F;192.168.149.62:2380, http:&#x2F;&#x2F;192.168.149.62:2379</span><br><span class="line">e26482910894af8d, started, lv-etcd-research-alpha-2, http:&#x2F;&#x2F;192.168.149.61:2380, http:&#x2F;&#x2F;192.168.149.61:2379</span><br><span class="line">ea04db3353b9fd4e, started, lv-etcd-research-alpha-4, http:&#x2F;&#x2F;192.168.149.64:2380, http:&#x2F;&#x2F;192.168.149.64:2379</span><br></pre></td></tr></table></figure>

<p>本篇文章将以此环境为基础, 使用备份的快照文件, 创建新的集群</p>
<h2 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h2><ul>
<li>创建快照文件</li>
<li>将快照文件分发到新集群的每一台主机上</li>
<li>使用 etcdctl snapshot restore 命令启动临时逻辑集群, 在新的数据目录中恢复数据</li>
<li>使用新的数据目录, 启动etcd服务</li>
</ul>
<h3 id="创建快照文件"><a href="#创建快照文件" class="headerlink" title="创建快照文件"></a>创建快照文件</h3><p>在此假设集群中的5个节点, 仅剩<code>192.168.149.60</code>存活, 我们需要首先在存活的节点, 将数据导出(快照)</p>
<p>当然, 正常情况下, 生产环境会定期对etcd做快照备份, 对于这种情况, 直接拿最新的一份快照恢复即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.60:2379 snapshot save snapshot.db</span></span><br><span class="line">Snapshot saved at snapshot.db</span><br></pre></td></tr></table></figure>

<h3 id="分发快照文件"><a href="#分发快照文件" class="headerlink" title="分发快照文件"></a>分发快照文件</h3><p>第二步, 需要分发快照文件到新集群的机器上. 结合在我目前的环境中, 我需要把该快照文件发送到</p>
<ul>
<li>192.168.149.61</li>
<li>192.168.149.62</li>
<li>192.168.149.63</li>
<li>192.168.149.64</li>
</ul>
<p>在实际环境中, 可能另外四台, 或者原集群全部主机都无法使用, 此时需要将之前备份的快照文件, 从备份服务器下载到组建新集群的各个主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> scp snapshot.db root@192.168.149.61:/var/lib/etcd/</span></span><br><span class="line">snapshot.db                                                                                                                         100%   20MB  42.1MB/s   00:00</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp snapshot.db root@192.168.149.62:/var/lib/etcd/</span></span><br><span class="line">snapshot.db                                                                                                                         100%   20MB  30.3MB/s   00:00</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp snapshot.db root@192.168.149.63:/var/lib/etcd/</span></span><br><span class="line">snapshot.db                                                                                                                         100%   20MB  36.9MB/s   00:00</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp snapshot.db root@192.168.149.64:/var/lib/etcd/</span></span><br><span class="line">snapshot.db</span><br></pre></td></tr></table></figure>

<h3 id="恢复快照"><a href="#恢复快照" class="headerlink" title="恢复快照"></a>恢复快照</h3><p>在 <code>192.168.149.60</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/etcd</span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --data-dir="/var/lib/etcd/new.etcd" \</span><br><span class="line">  --name="lv-etcd-research-beta-0" \</span><br><span class="line">  --initial-advertise-peer-urls="http://192.168.149.60:22380" \</span><br><span class="line">  --initial-cluster="lv-etcd-research-beta-0=http://192.168.149.60:22380,lv-etcd-research-beta-1=http://192.168.149.63:22380,lv-etcd-research-beta-2=http://192.168.149.61:22380,lv-etcd-research-beta-3=http://192.168.149.62:22380,lv-etcd-research-beta-4=http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster-token="lv-etcd-research-beta-temp"</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-06-14 14:47:34.172213 I | etcdserver&#x2F;membership: added member 6914761fd26729d7 [http:&#x2F;&#x2F;192.168.149.62:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:47:34.172370 I | etcdserver&#x2F;membership: added member b8ca704ce48fc6c2 [http:&#x2F;&#x2F;192.168.149.63:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:47:34.172419 I | etcdserver&#x2F;membership: added member bff8d73529095f70 [http:&#x2F;&#x2F;192.168.149.64:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:47:34.172464 I | etcdserver&#x2F;membership: added member eb548d413adb4560 [http:&#x2F;&#x2F;192.168.149.61:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:47:34.172506 I | etcdserver&#x2F;membership: added member fee07bdb23e26b2f [http:&#x2F;&#x2F;192.168.149.60:22380] to cluster c1cdf0b2061f8dcc</span><br></pre></td></tr></table></figure>

<hr>
<p>在 <code>192.168.149.63</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/etcd</span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --data-dir="/var/lib/etcd/new.etcd" \</span><br><span class="line">  --name="lv-etcd-research-beta-1" \</span><br><span class="line">  --initial-advertise-peer-urls="http://192.168.149.63:22380" \</span><br><span class="line">  --initial-cluster="lv-etcd-research-beta-0=http://192.168.149.60:22380,lv-etcd-research-beta-1=http://192.168.149.63:22380,lv-etcd-research-beta-2=http://192.168.149.61:22380,lv-etcd-research-beta-3=http://192.168.149.62:22380,lv-etcd-research-beta-4=http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster-token="lv-etcd-research-beta-temp"</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-06-14 14:49:23.896672 I | etcdserver&#x2F;membership: added member 6914761fd26729d7 [http:&#x2F;&#x2F;192.168.149.62:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:49:23.897112 I | etcdserver&#x2F;membership: added member b8ca704ce48fc6c2 [http:&#x2F;&#x2F;192.168.149.63:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:49:23.897210 I | etcdserver&#x2F;membership: added member bff8d73529095f70 [http:&#x2F;&#x2F;192.168.149.64:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:49:23.897264 I | etcdserver&#x2F;membership: added member eb548d413adb4560 [http:&#x2F;&#x2F;192.168.149.61:22380] to cluster c1cdf0b2061f8dcc</span><br><span class="line">2019-06-14 14:49:23.897403 I | etcdserver&#x2F;membership: added member fee07bdb23e26b2f [http:&#x2F;&#x2F;192.168.149.60:22380] to cluster c1cdf0b2061f8dcc</span><br></pre></td></tr></table></figure>

<hr>
<p>在 <code>192.168.149.61</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/etcd</span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --data-dir="/var/lib/etcd/new.etcd" \</span><br><span class="line">  --name="lv-etcd-research-beta-2" \</span><br><span class="line">  --initial-advertise-peer-urls="http://192.168.149.61:22380" \</span><br><span class="line">  --initial-cluster="lv-etcd-research-beta-0=http://192.168.149.60:22380,lv-etcd-research-beta-1=http://192.168.149.63:22380,lv-etcd-research-beta-2=http://192.168.149.61:22380,lv-etcd-research-beta-3=http://192.168.149.62:22380,lv-etcd-research-beta-4=http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster-token="lv-etcd-research-beta-temp"</span><br></pre></td></tr></table></figure>

<p>执行结果同上</p>
<hr>
<p>在 <code>192.168.149.62</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/etcd</span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --data-dir="/var/lib/etcd/new.etcd" \</span><br><span class="line">  --name="lv-etcd-research-beta-3" \</span><br><span class="line">  --initial-advertise-peer-urls="http://192.168.149.62:22380" \</span><br><span class="line">  --initial-cluster="lv-etcd-research-beta-0=http://192.168.149.60:22380,lv-etcd-research-beta-1=http://192.168.149.63:22380,lv-etcd-research-beta-2=http://192.168.149.61:22380,lv-etcd-research-beta-3=http://192.168.149.62:22380,lv-etcd-research-beta-4=http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster-token="lv-etcd-research-beta-temp"</span><br></pre></td></tr></table></figure>

<p>执行结果同上</p>
<hr>
<p>在 <code>192.168.149.64</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /var/lib/etcd</span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore snapshot.db \</span><br><span class="line">  --data-dir="/var/lib/etcd/new.etcd" \</span><br><span class="line">  --name="lv-etcd-research-beta-4" \</span><br><span class="line">  --initial-advertise-peer-urls="http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster="lv-etcd-research-beta-0=http://192.168.149.60:22380,lv-etcd-research-beta-1=http://192.168.149.63:22380,lv-etcd-research-beta-2=http://192.168.149.61:22380,lv-etcd-research-beta-3=http://192.168.149.62:22380,lv-etcd-research-beta-4=http://192.168.149.64:22380" \</span><br><span class="line">  --initial-cluster-token="lv-etcd-research-beta-temp"</span><br></pre></td></tr></table></figure>

<p>执行结果同上</p>
<p>本步骤操作, 将快照中的数据写入到指定的文件夹下, 并写入新集群的元数据信息. 这里需要注意的是, 快照中的数据是干净的数据, 不包含原节点的节点ID和集群ID等元数据信息. 执行 <code>restore</code> 操作后, 集群信息由命令后面的参数决定, 所以后续所有的节点, 仅需要指定新的数据目录启动即可, 集群信息可不指定, 因为已经写入到db中.</p>
<h3 id="启动新集群"><a href="#启动新集群" class="headerlink" title="启动新集群"></a>启动新集群</h3><p>修改etcd 配置文件, 指定新的数据目录来启动服务. 在我这里的实验环境中, 由于老etcd集群都在正常运行中, 我这里通过指定不同的端口, 在原有的5台机器中启动第二套新集群, 验证恢复操作</p>
<p>在 <code>192.168.149.60</code> 上执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建新的配置文件</span></span><br><span class="line">echo 'ETCD_DATA_DIR="/var/lib/etcd/new.etcd"</span><br><span class="line">ETCD_LISTEN_PEER_URLS="http://0.0.0.0:22380"</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:22379"</span><br><span class="line">ETCD_NAME="lv-etcd-research-beta-0"</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS="http://192.168.149.60:22379"</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN="lv-etcd-research-beta"' &gt; /etc/etcd/etcd_new.conf</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 复制原有的启动文件</span></span><br><span class="line">cp /usr/lib/systemd/system/etcd.service /usr/lib/systemd/system/etcd_new.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改启动文件中指定的配置文件</span></span><br><span class="line">sed -i s/etcd.conf/etcd_new.conf/g /usr/lib/systemd/system/etcd_new.service</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start etcd_new</span><br></pre></td></tr></table></figure>

<p>其他四台以此类推…</p>
<p>检查原集群和新集群成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379 member list -w table</span></span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        | STATUS  |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 | started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.63:2379 |</span><br><span class="line">| 2145c204a51dbbc7 | started | lv-etcd-research-alpha-0 | http://192.168.149.60:2380 | http://192.168.149.60:2379 |</span><br><span class="line">| 4252aec339d438d9 | started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| e26482910894af8d | started | lv-etcd-research-alpha-2 | http://192.168.149.61:2380 | http://192.168.149.61:2379 |</span><br><span class="line">| ea04db3353b9fd4e | started | lv-etcd-research-alpha-4 | http://192.168.149.64:2380 | http://192.168.149.64:2379 |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:22379 member list -w table</span></span><br><span class="line">+------------------+---------+-------------------------+-----------------------------+-----------------------------+</span><br><span class="line">|        ID        | STATUS  |          NAME           |         PEER ADDRS          |        CLIENT ADDRS         |</span><br><span class="line">+------------------+---------+-------------------------+-----------------------------+-----------------------------+</span><br><span class="line">| 6914761fd26729d7 | started | lv-etcd-research-beta-3 | http://192.168.149.62:22380 | http://192.168.149.63:22379 |</span><br><span class="line">| b8ca704ce48fc6c2 | started | lv-etcd-research-beta-1 | http://192.168.149.63:22380 | http://192.168.149.63:22379 |</span><br><span class="line">| bff8d73529095f70 | started | lv-etcd-research-beta-4 | http://192.168.149.64:22380 | http://192.168.149.64:22379 |</span><br><span class="line">| eb548d413adb4560 | started | lv-etcd-research-beta-2 | http://192.168.149.61:22380 | http://192.168.149.61:22379 |</span><br><span class="line">| fee07bdb23e26b2f | started | lv-etcd-research-beta-0 | http://192.168.149.60:22380 | http://192.168.149.60:22379 |</span><br><span class="line">+------------------+---------+-------------------------+-----------------------------+-----------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="注意v2与v3区别"><a href="#注意v2与v3区别" class="headerlink" title="注意v2与v3区别"></a>注意v2与v3区别</h2><p>官方不建议v2和v3混合使用, 也就是说, 如果你既有v2的存储需求又有v3的存储需求, 最好应该是用两个独立的集群将需求隔离开. 在备份恢复这个操作上, 也充分体现了v2 v3不要混用的重要性. 因为以上操作都是针对v3版本的备份和恢复. 即使备份的etcd集群中存在v2的数据, 在使用该方案恢复后, v2的数据将不会出现在新的集群中.</p>
<p>如果你需要针对v2版本做备份和恢复, 可以参考官方文档:</p>
<p><a href="https://etcd.io/docs/v2/admin_guide/#disaster-recovery" target="_blank" rel="noopener">https://etcd.io/docs/v2/admin_guide/#disaster-recovery</a></p>
<p>大致步骤如下:</p>
<ul>
<li>使用 etcdctl backup 命令备份数据到新的目录</li>
<li>使用新的目录, 以 <code>--force-new-cluster</code> 的模式指定新的目录, 启动单节点etcd服务</li>
<li>如果需要恢复的是一个集群, 你需要先执行 <code>ETCDCTL_API=2 etcdctl member update</code> 命令更新<peerURLs></li>
<li>最后按照正常运行时配置添加节点即可</li>
</ul>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>snapshot</tag>
        <tag>restore</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言在goroutine中拿到返回值</title>
    <url>/2020/03/26/go%E8%AF%AD%E8%A8%80%E5%9C%A8goroutine%E4%B8%AD%E6%8B%BF%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC/</url>
    <content><![CDATA[<blockquote>
<p>执行go协程时, 是没有返回值的, 这时候需要用到go语言中特色的channel来获取到返回值. 通过channel拿到返回值有两种处理形式, 一种形式是具有go风格特色的, 即发送给一个<code>for channel</code>或<code>select channel</code>的独立goroutine中, 由该独立的goroutine来处理函数的返回值. 还有一种传统的做法, 就是将所有goroutine的返回值都集中到当前函数, 然后统一返回给调用函数.</p>
</blockquote>
<a id="more"></a>

<h2 id="发送给独立的goroutine处理程序"><a href="#发送给独立的goroutine处理程序" class="headerlink" title="发送给独立的goroutine处理程序"></a>发送给独立的goroutine处理程序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseChannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpGet</span><span class="params">(url <span class="keyword">int</span>, limiter <span class="keyword">chan</span> <span class="keyword">bool</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 函数执行完毕时 计数器-1</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">"http get:"</span>, url)</span><br><span class="line">	responseChannel &lt;- fmt.Sprintf(<span class="string">"Hello Go %d"</span>, url)</span><br><span class="line">	<span class="comment">// 释放一个坑位</span></span><br><span class="line">	&lt;- limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ResponseController</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> rc := <span class="keyword">range</span> responseChannel &#123;</span><br><span class="line">		fmt.Println(<span class="string">"response: "</span>, rc)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动接收response的控制器</span></span><br><span class="line">	<span class="keyword">go</span> ResponseController()</span><br><span class="line"></span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="comment">// 控制并发数为10</span></span><br><span class="line">	limiter := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">99</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 计数器+1</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		limiter &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="keyword">go</span> httpGet(i, limiter, wg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所以协程执行完毕</span></span><br><span class="line">	wg.Wait() <span class="comment">// 当计数器为0时, 不再阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"所有协程已执行完毕"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种具有Go语言特色的处理方式的关键在于, 你需要预先创建一个用于处理返回值的公共管道. 然后定义一个一直在读取该管道的函数, 该函数需要预先以单独的goroutine形式启动. </p>
<p>最后当执行到并发任务时, 每个并发任务得到结果后, 都会将结果通过管道传递到之前预先启动的goroutine中.</p>
<h2 id="在当前函数中聚合返回"><a href="#在当前函数中聚合返回" class="headerlink" title="在当前函数中聚合返回"></a>在当前函数中聚合返回</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpGet</span><span class="params">(url <span class="keyword">int</span>,response <span class="keyword">chan</span> <span class="keyword">string</span>, limiter <span class="keyword">chan</span> <span class="keyword">bool</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 函数执行完毕时 计数器-1</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="comment">// 将拿到的结果, 发送到参数中传递过来的channel中</span></span><br><span class="line">	response &lt;- fmt.Sprintf(<span class="string">"http get: %d"</span>, url)</span><br><span class="line">	<span class="comment">// 释放一个坑位</span></span><br><span class="line">	&lt;- limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有的返回结果, 以 []string 的形式返回</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">collect</span><span class="params">(urls []<span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> result []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="comment">// 控制并发数为10</span></span><br><span class="line">	limiter := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">5</span>)</span><br><span class="line">	<span class="keyword">defer</span> <span class="built_in">close</span>(limiter)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 函数内的局部变量channel, 专门用来接收函数内所有goroutine的结果</span></span><br><span class="line">	responseChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// 为读取结果控制器创建新的WaitGroup, 需要保证控制器内的所有值都已经正确处理完毕, 才能结束</span></span><br><span class="line">	wgResponse := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="comment">// 启动读取结果的控制器</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// wgResponse计数器+1</span></span><br><span class="line">		wgResponse.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 读取结果</span></span><br><span class="line">		<span class="keyword">for</span> response :=  <span class="keyword">range</span> responseChannel &#123;</span><br><span class="line">			<span class="comment">// 处理结果</span></span><br><span class="line">			result = <span class="built_in">append</span>(result, response)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 当 responseChannel被关闭时且channel中所有的值都已经被处理完毕后, 将执行到这一行</span></span><br><span class="line">		wgResponse.Done()</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, url := <span class="keyword">range</span> urls &#123;</span><br><span class="line">		<span class="comment">// 计数器+1</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		limiter &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="comment">// 这里在启动goroutine时, 将用来收集结果的局部变量channel也传递进去</span></span><br><span class="line">		<span class="keyword">go</span> httpGet(url,responseChannel, limiter, wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待所以协程执行完毕</span></span><br><span class="line">	wg.Wait() <span class="comment">// 当计数器为0时, 不再阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"所有协程已执行完毕"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭接收结果channel</span></span><br><span class="line">	<span class="built_in">close</span>(responseChannel)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待wgResponse的计数器归零</span></span><br><span class="line">	wgResponse.Wait()</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 返回聚合后结果</span></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	urls := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line"></span><br><span class="line">	result := collect(urls)</span><br><span class="line">	fmt.Println(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
        <tag>channel</tag>
        <tag>WaitGroup</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>BufferedChannel&amp;sync.WaitGroup实现并发数控制</title>
    <url>/2020/03/26/BufferedChannel-sync-WaitGroup%E5%AE%9E%E7%8E%B0%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>利用带缓存的channel和WaitGroup, 可以实现对goroutine的并发数控制. 使用起来非常简单</p>
</blockquote>
<a id="more"></a>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sync"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpGet</span><span class="params">(url <span class="keyword">string</span>, limiter <span class="keyword">chan</span> <span class="keyword">bool</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 函数执行完毕时 计数器-1</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	fmt.Println(<span class="string">"http get:"</span>, url)</span><br><span class="line">	<span class="comment">// 释放一个坑位</span></span><br><span class="line">	&lt;- limiter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line">	<span class="comment">// 控制并发数为10</span></span><br><span class="line">	limiter := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">99</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 计数器+1</span></span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		limiter &lt;- <span class="literal">true</span></span><br><span class="line">		<span class="keyword">go</span> httpGet(<span class="keyword">string</span>(i), limiter, wg)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所以协程执行完毕</span></span><br><span class="line">	wg.Wait() <span class="comment">// 当计数器为0时, 不再阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"所有协程已执行完毕"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>带缓存channel的特性, 当缓存被填满时, for循环中最新一次迭代将阻塞到 <code>limiter &lt;- true</code> 这一行中, 当有其他goroutine执行完毕, 会主动消费<code>limiter</code>中的一个元素, 这样就腾出了一个新的坑位, 之前停留在 <code>limiter &lt;- true</code> 的代码会继续向下执行, 继续循环迭代</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>goroutine</tag>
        <tag>channel</tag>
        <tag>WaitGroup</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言zap日志自定义输出</title>
    <url>/2020/03/25/go%E8%AF%AD%E8%A8%80zap%E6%97%A5%E5%BF%97%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>前篇文章中介绍了zap日志包的basic用法, 在<code>zap.Config</code>的配置中, 有<code>OutputPaths</code>和<code>ErrorOutputPaths</code>分别可以指定日志输出目标, 一般情况下, 日志会输出到<code>stdout</code> <code>stderr</code> 或 本地文本文件. 本篇文章介绍自定义协议的日志输出目标</p>
</blockquote>
<a id="more"></a>

<h2 id="基础配置示例"><a href="#基础配置示例" class="headerlink" title="基础配置示例"></a>基础配置示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">logLevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> zc = zap.Config&#123;</span><br><span class="line">		Level:             logLevel,</span><br><span class="line">		Development:       <span class="literal">false</span>,</span><br><span class="line">		DisableCaller:     <span class="literal">false</span>,</span><br><span class="line">		DisableStacktrace: <span class="literal">false</span>,</span><br><span class="line">		Sampling:          <span class="literal">nil</span>,</span><br><span class="line">		Encoding:          <span class="string">"json"</span>,</span><br><span class="line">		EncoderConfig: zapcore.EncoderConfig&#123;</span><br><span class="line">			MessageKey:     <span class="string">"message"</span>,</span><br><span class="line">			LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">			TimeKey:        <span class="string">"time"</span>,</span><br><span class="line">			NameKey:        <span class="string">"name"</span>,</span><br><span class="line">			CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">			StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">			LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">			EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">			EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">			EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">			EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">			EncodeName:     zapcore.FullNameEncoder,</span><br><span class="line">		&#125;,</span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stdout"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		InitialFields:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"app"</span>: <span class="string">"apdex"</span>&#125;,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OutputPaths-定义"><a href="#OutputPaths-定义" class="headerlink" title="OutputPaths 定义"></a>OutputPaths 定义</h2><p>源码截取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OutputPaths is a list of URLs or file paths to write logging output to.</span></span><br><span class="line">	<span class="comment">// See Open for details.</span></span><br><span class="line">	OutputPaths []<span class="keyword">string</span> <span class="string">`json:"outputPaths" yaml:"outputPaths"`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Open is a high-level wrapper that takes a variadic number of URLs, opens or</span></span><br><span class="line"><span class="comment">// creates each of the specified resources, and combines them into a locked</span></span><br><span class="line"><span class="comment">// WriteSyncer. It also returns any error encountered and a function to close</span></span><br><span class="line"><span class="comment">// any opened files.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Passing no URLs returns a no-op WriteSyncer. Zap handles URLs without a</span></span><br><span class="line"><span class="comment">// scheme and URLs with the "file" scheme. Third-party code may register</span></span><br><span class="line"><span class="comment">// factories for other schemes using RegisterSink.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// URLs with the "file" scheme must use absolute paths on the local</span></span><br><span class="line"><span class="comment">// filesystem. No user, password, port, fragments, or query parameters are</span></span><br><span class="line"><span class="comment">// allowed, and the hostname must be empty or "localhost".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Since it's common to write logs to the local filesystem, URLs without a</span></span><br><span class="line"><span class="comment">// scheme (e.g., "/var/log/foo.log") are treated as local file paths. Without</span></span><br><span class="line"><span class="comment">// a scheme, the special paths "stdout" and "stderr" are interpreted as</span></span><br><span class="line"><span class="comment">// os.Stdout and os.Stderr. When specified without a scheme, relative file</span></span><br><span class="line"><span class="comment">// paths also work.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(paths ...<span class="keyword">string</span>)</span> <span class="params">(zapcore.WriteSyncer, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">	writers, <span class="built_in">close</span>, err := open(paths)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	writer := CombineWriteSyncers(writers...)</span><br><span class="line">	<span class="keyword">return</span> writer, <span class="built_in">close</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">open</span><span class="params">(paths []<span class="keyword">string</span>)</span> <span class="params">([]zapcore.WriteSyncer, <span class="keyword">func</span>()</span>, <span class="title">error</span>)</span> &#123;</span><br><span class="line">	writers := <span class="built_in">make</span>([]zapcore.WriteSyncer, <span class="number">0</span>, <span class="built_in">len</span>(paths))</span><br><span class="line">	closers := <span class="built_in">make</span>([]io.Closer, <span class="number">0</span>, <span class="built_in">len</span>(paths))</span><br><span class="line">	<span class="built_in">close</span> := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> closers &#123;</span><br><span class="line">			c.Close()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> openErr error</span><br><span class="line">	<span class="keyword">for</span> _, path := <span class="keyword">range</span> paths &#123;</span><br><span class="line">		sink, err := newSink(path)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			openErr = multierr.Append(openErr, fmt.Errorf(<span class="string">"couldn't open sink %q: %v"</span>, path, err))</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		writers = <span class="built_in">append</span>(writers, sink)</span><br><span class="line">		closers = <span class="built_in">append</span>(closers, sink)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> openErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">close</span>()</span><br><span class="line">		<span class="keyword">return</span> writers, <span class="literal">nil</span>, openErr</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> writers, <span class="built_in">close</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现自定义输出协议, 注释中最重要的一句话是: <code>Third-party code may register factories for other schemes using RegisterSink.</code> 也就是说, 你可以使用 <code>RegisterSink</code> 函数来注册新的输出方式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RegisterSink registers a user-supplied factory for all sinks with a</span></span><br><span class="line"><span class="comment">// particular scheme.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All schemes must be ASCII, valid under section 3.1 of RFC 3986</span></span><br><span class="line"><span class="comment">// (https://tools.ietf.org/html/rfc3986#section-3.1), and must not already</span></span><br><span class="line"><span class="comment">// have a factory registered. Zap automatically registers a factory for the</span></span><br><span class="line"><span class="comment">// "file" scheme.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterSink</span><span class="params">(scheme <span class="keyword">string</span>, factory <span class="keyword">func</span>(*url.URL)</span> <span class="params">(Sink, error)</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	_sinkMutex.Lock()</span><br><span class="line">	<span class="keyword">defer</span> _sinkMutex.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> scheme == <span class="string">""</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">"can't register a sink factory for empty string"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	normalized, err := normalizeScheme(scheme)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"%q is not a valid scheme: %v"</span>, scheme, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> _, ok := _sinkFactories[normalized]; ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">"sink factory already registered for scheme %q"</span>, normalized)</span><br><span class="line">	&#125;</span><br><span class="line">	_sinkFactories[normalized] = factory</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数的入参之一为一个自定义的工厂函数, 该工厂函数接收一个<code>*url.URL</code>类型的指针, 返回一个<code>Sink</code>类型的接口和一个错误. 简化来看, 其实我们需要重点处理的就是这个自定义工厂函数.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxx</span> <span class="params">(*url.URL)</span> <span class="params">(Sink, error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该工厂函数需要返回的最重要的值为一个实现了Sink接口的对象, Sink接口的定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sink defines the interface to write to and close logger destinations.</span></span><br><span class="line"><span class="keyword">type</span> Sink <span class="keyword">interface</span> &#123;</span><br><span class="line">	zapcore.WriteSyncer</span><br><span class="line">	io.Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Sink接口可以简单理解为是用来写日志和关闭日志对象的, Sink接口中又包含两个接口, 两个接口的源码定义如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WriteSyncer is an io.Writer that can also flush any buffered data. Note</span></span><br><span class="line"><span class="comment">// that *os.File (and thus, os.Stderr and os.Stdout) implement WriteSyncer.</span></span><br><span class="line"><span class="keyword">type</span> WriteSyncer <span class="keyword">interface</span> &#123;</span><br><span class="line">	io.Writer</span><br><span class="line">	Sync() error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Writer is the interface that wraps the basic Write method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Write writes len(p) bytes from p to the underlying data stream.</span></span><br><span class="line"><span class="comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span></span><br><span class="line"><span class="comment">// and any error encountered that caused the write to stop early.</span></span><br><span class="line"><span class="comment">// Write must return a non-nil error if it returns n &lt; len(p).</span></span><br><span class="line"><span class="comment">// Write must not modify the slice data, even temporarily.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Implementations must not retain p.</span></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Write(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Closer is the interface that wraps the basic Close method.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The behavior of Close after the first call is undefined.</span></span><br><span class="line"><span class="comment">// Specific implementations may document their own behavior.</span></span><br><span class="line"><span class="keyword">type</span> Closer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Close() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>展开所有接口的定义后, 可以清晰的看出, 我们只需要定义三个函数, 就可以实现<code>Sink</code>接口</p>
<ul>
<li>Sync() error  // 如果写日志用到了缓存的话, 你需要定义sync的逻辑, 以便在程序关闭时, 保证缓存中的日志可以正确写入到目标对象中</li>
<li>Write(p []byte) (n int, err error)  // 这个是写日志的函数, 也是三个函数中, 必须要定义逻辑的一个函数, 它定义了日志内容<code>p</code>如何写入到目标对象中</li>
<li>Close() error  // 关闭日志对象, 在程序关闭时, 你可能需要先正确关闭日志对象. 例如你的日志对象是个文件时, 你需要close掉这个文件描述符; 例如你的日志对象是个远程TCP连接时, 你需要close掉这条连接</li>
</ul>
<h2 id="实现自定义日志输出协议"><a href="#实现自定义日志输出协议" class="headerlink" title="实现自定义日志输出协议"></a>实现自定义日志输出协议</h2><p>上面已经明确了自定义日志输出协议需要定义的函数, 那么接下来我们就来定义一个最简单的日志输出协议, 当程序中调用日志打印时, 我将日志以全部红色的字体打印在控制台的标准输出, 需要用到一个特殊的库 <code>github.com/gookit/color</code> 该库可以实现带颜色的控制台输出</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gookit/color"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个结构体</span></span><br><span class="line"><span class="keyword">type</span> Color <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Sync方法以实现Sink接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span> <span class="title">Sync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是控制台打印, 涉及不到缓存同步问题, 所以简单return就可以</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Close方法以实现Sink接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="comment">// 因为只是控制台打印, 也涉及不到关闭对象的问题, return就好</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义Write方法以实现Sink接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Color)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用带颜色的控制台输出日志信息</span></span><br><span class="line">	color.Red.Println(<span class="string">"我是自定义的日志输出协议: "</span>, <span class="keyword">string</span>(p))</span><br><span class="line">	<span class="comment">// 返回写入日志的长度,以及错误</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">colorSink</span><span class="params">(url *url.URL)</span> <span class="params">(sink zap.Sink, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 工厂函数中, 定义了必须接收一个*url.URL参数</span></span><br><span class="line">    <span class="comment">// 但是我们的需求比较简单, 暂时用不到, 所以可以直接忽略这个参数的使用</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例化一个Color对象, 该对象实现了Sink接口</span></span><br><span class="line">	c := Color&#123;&#125;</span><br><span class="line">	<span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将colorSink工厂函数注册到zap中, 自定义协议名为 Color</span></span><br><span class="line">	<span class="keyword">if</span> err := zap.RegisterSink(<span class="string">"Color"</span>, colorSink); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		painc(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logLevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)</span><br><span class="line">	<span class="keyword">var</span> zc = zap.Config&#123;</span><br><span class="line">		Level:             logLevel,</span><br><span class="line">		Development:       <span class="literal">false</span>,</span><br><span class="line">		DisableCaller:     <span class="literal">false</span>,</span><br><span class="line">		DisableStacktrace: <span class="literal">false</span>,</span><br><span class="line">		Sampling:          <span class="literal">nil</span>,</span><br><span class="line">		Encoding:          <span class="string">"json"</span>,</span><br><span class="line">		EncoderConfig: zapcore.EncoderConfig&#123;</span><br><span class="line">			MessageKey:     <span class="string">"message"</span>,</span><br><span class="line">			LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">			TimeKey:        <span class="string">"time"</span>,</span><br><span class="line">			NameKey:        <span class="string">"name"</span>,</span><br><span class="line">			CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">			StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">			LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">			EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">			EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">			EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">			EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">			EncodeName:     zapcore.FullNameEncoder,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 日志标准输出的定义中, 除了标准的控制台输出, 还增加了一个我们自定义的Color协议输出</span></span><br><span class="line">		<span class="comment">// 这里需要注意的是, 我们的自定义协议中, 固定是接收了一个 *url.URL, 虽然我们没有用到</span></span><br><span class="line">		<span class="comment">// 但是在日志实际配置使用时, 我们仍需要显示传递该参数. 按照http协议的风格, 我们可以</span></span><br><span class="line">		<span class="comment">// 将其定义为 "Color://127.0.0.1", 当然 "Color:127.0.0.1" 和 "Color:" </span></span><br><span class="line">		<span class="comment">// 这种形式也是可以的. 但是 "Color" 这种是错误的配置形式</span></span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stdout"</span>, <span class="string">"Color://127.0.0.1"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		InitialFields:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"app"</span>: <span class="string">"apdex"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger, err := zc.Build()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	logger.Info(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		zap.String(<span class="string">"key"</span>, <span class="string">"value"</span>),</span><br><span class="line">		zap.Int(<span class="string">"number"</span>, <span class="number">9</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	sugarLogger := logger.Sugar()</span><br><span class="line"></span><br><span class="line">	sugarLogger.Infow(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		<span class="string">"key"</span>, <span class="string">"value"</span>, <span class="string">"number"</span>, <span class="number">9</span>,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<p><img src="https://20150509.oss-cn-qingdao.aliyuncs.com/2020/03/25/15851163967119.jpg" alt=""></p>
<h2 id="实现自定义日志输出协议-http"><a href="#实现自定义日志输出协议-http" class="headerlink" title="实现自定义日志输出协议-http"></a>实现自定义日志输出协议-http</h2><p>接下来, 再实现一个稍微复杂一些的例子, 通过http协议, 将日志以json格式发送到远端.</p>
<p>首先来实现接收端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"io/ioutil"</span></span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	http.HandleFunc(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"请求方法:"</span>, r.Method)</span><br><span class="line">		fmt.Println(<span class="string">"请求地址:"</span>, r.URL)</span><br><span class="line">		body, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">		fmt.Println(<span class="string">"Body体内容: "</span>, bytes.NewBuffer(body).String())</span><br><span class="line">		fmt.Println(<span class="string">"==========="</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	log.Fatal(http.ListenAndServe(<span class="string">"0.0.0.0:5001"</span>, <span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端/日志接收端代码很简单, 只是启动了一个http服务, 用来接收http请求, 会把接收到的请求的基本信息打印出来. 执行 <code>go run logServer.go</code> 启动日志接收服务端</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"bytes"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line">	<span class="string">"net/http"</span></span><br><span class="line">	<span class="string">"net/url"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义http协议接口体</span></span><br><span class="line"><span class="keyword">type</span> Http <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 包含一个属性: 远端地址</span></span><br><span class="line">	Remote *url.URL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为没有使用到缓存技术, 所以直接return即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Http)</span> <span class="title">Sync</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭http连接, 因为本次示例仅是短连接, 不涉及关闭连接, 所以直接return即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Http)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本质就是发起一次http post的过程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h Http)</span> <span class="title">Write</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 构造 http post 请求</span></span><br><span class="line">	req, err := http.NewRequest(<span class="string">"POST"</span>, h.Remote.String(), bytes.NewBuffer(p))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">	<span class="comment">// 创建http client</span></span><br><span class="line">	client := &amp;http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">// 发起请求</span></span><br><span class="line">	resp, err := client.Do(req)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 记得关闭body</span></span><br><span class="line">	<span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line">	<span class="keyword">if</span> resp.StatusCode != <span class="number">200</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">"request failed"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 返回写入的字节长度</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(p), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现工厂函数, 返回实现了Sink接口的http对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpSink</span><span class="params">(url *url.URL)</span> <span class="params">(sink zap.Sink, err error)</span></span> &#123;</span><br><span class="line">	h := Http&#123;Remote: url&#125;</span><br><span class="line">	<span class="keyword">return</span> h, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 把自定义的http协议日志输出注册到zap</span></span><br><span class="line">	<span class="keyword">if</span> err := zap.RegisterSink(<span class="string">"Http"</span>, httpSink); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logLevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> zc = zap.Config&#123;</span><br><span class="line">		Level:             logLevel,</span><br><span class="line">		Development:       <span class="literal">false</span>,</span><br><span class="line">		DisableCaller:     <span class="literal">false</span>,</span><br><span class="line">		DisableStacktrace: <span class="literal">false</span>,</span><br><span class="line">		Sampling:          <span class="literal">nil</span>,</span><br><span class="line">		Encoding:          <span class="string">"json"</span>,</span><br><span class="line">		EncoderConfig: zapcore.EncoderConfig&#123;</span><br><span class="line">			MessageKey:     <span class="string">"message"</span>,</span><br><span class="line">			LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">			TimeKey:        <span class="string">"time"</span>,</span><br><span class="line">			NameKey:        <span class="string">"name"</span>,</span><br><span class="line">			CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">			StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">			LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">			EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">			EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">			EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">			EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">			EncodeName:     zapcore.FullNameEncoder,</span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 使用自定义的http协议日志输出时, 既然要记得配置成正确的协议格式</span></span><br><span class="line">		<span class="comment">// xxx://ooo</span></span><br><span class="line">		<span class="comment">// 由于我在本地 5001 启动了一个http服务, 所以IP地址需要配置成: 127.0.0.1:5001</span></span><br><span class="line">		<span class="comment">// 我启动的http服务监听了根 /, 所以可以接受任何Request Path, 这里的/log 仅仅是为了</span></span><br><span class="line">		<span class="comment">// 演示才配置上的, 你可以定义任何需要的路径</span></span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stdout"</span>, <span class="string">"http://127.0.0.1:5001/log"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		InitialFields:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"app"</span>: <span class="string">"apdex"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger, err := zc.Build()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	logger.Info(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		zap.String(<span class="string">"key"</span>, <span class="string">"value"</span>),</span><br><span class="line">		zap.Int(<span class="string">"number"</span>, <span class="number">9</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	sugarLogger := logger.Sugar()</span><br><span class="line"></span><br><span class="line">	sugarLogger.Infow(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		<span class="string">"key"</span>, <span class="string">"value"</span>, <span class="string">"number"</span>, <span class="number">9</span>,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<p>远程日志接收服务端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求方法: POST</span><br><span class="line">请求地址: &#x2F;log</span><br><span class="line">Body体内容:  &#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-25T14:48:29.221+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;log2.go:117&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;apdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">请求方法: POST</span><br><span class="line">请求地址: &#x2F;log</span><br><span class="line">Body体内容:  &#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-25T14:48:29.221+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;log2.go:124&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;apdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>

<p>执行写日志的客户端:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-25T14:48:29.221+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;log2.go:117&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;apdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-25T14:48:29.221+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;log2.go:124&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;apdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意: 该http用法仅仅是用来抛砖引玉, 该代码无法在实际生产环境中使用, 因为日志量太大的话, http短连接会消耗相当大的主机资源, 如果确实需要以这种方式传输日志的话, 可以考虑使用全局的http连接池, 并做好Close方法的实现. 也可以开辟一块内存, 专门用来做日志缓存, 定期发起http请求, 发送到远端, 避免频繁的单次调用, 同时也需要做好Sync方法的实现</strong></p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>自定义日志传输协议的最佳实践, 应该是直接将json日志发送到远端的kafka服务器中. 以kafka的吞吐能力, 正常的日志输出想要把kafka使用到瓶颈的一个状态, 并不是很容易😆 </p>
<p>一般情况下的日志处理流程是, 程序将日志打入到本地文件, 然后由filebeat或logstash之类的日志收集客户端进行收集, 收集后发送到kafka, 然后再由logstash消费, 处理格式后发送给elasticsearch.</p>
<p>程序直接对接kafka的话, 依然要注意日志量输出情况, 好在zap本身就可以设置日志输出速率, 因为kafka抗住一个疯狂打印日志的”疯子”很容易, 抗住千千万万个乱打日志的”疯子”, kafka也受不了的~</p>
<p>我这里暂时没有kafka环境, 后续有机会的话会单独实现zap下kafka的日志传输协议</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>zap</tag>
        <tag>log</tag>
        <tag>日志</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言优秀的日志包zap基础自定义配置用法</title>
    <url>/2020/03/23/go%E8%AF%AD%E8%A8%80%E4%BC%98%E7%A7%80%E7%9A%84%E6%97%A5%E5%BF%97%E5%8C%85zap%E5%9F%BA%E7%A1%80%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>zap 的官方案例中, 介绍了三种使用方式, 分别是 <code>AdvancedConfiguration</code> <code>BasicConfiguration</code> 和 <code>Presets</code> 本篇文章介绍 zap 包的 BasicConfiguration 用法</p>
</blockquote>
<a id="more"></a>

<p>上一篇文档中引用官方案例介绍了预置函数的用法, 当预置函数的logger配置不满足我们的需求时, 可以自定义配置logger</p>
<p>自定义配置logger, 有如下选项可以配置</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Level is the minimum enabled logging level. Note that this is a dynamic</span></span><br><span class="line">	<span class="comment">// level, so calling Config.Level.SetLevel will atomically change the log</span></span><br><span class="line">	<span class="comment">// level of all loggers descended from this config.</span></span><br><span class="line">	Level AtomicLevel <span class="string">`json:"level" yaml:"level"`</span></span><br><span class="line">	<span class="comment">// Development puts the logger in development mode, which changes the</span></span><br><span class="line">	<span class="comment">// behavior of DPanicLevel and takes stacktraces more liberally.</span></span><br><span class="line">	Development <span class="keyword">bool</span> <span class="string">`json:"development" yaml:"development"`</span></span><br><span class="line">	<span class="comment">// DisableCaller stops annotating logs with the calling function's file</span></span><br><span class="line">	<span class="comment">// name and line number. By default, all logs are annotated.</span></span><br><span class="line">	DisableCaller <span class="keyword">bool</span> <span class="string">`json:"disableCaller" yaml:"disableCaller"`</span></span><br><span class="line">	<span class="comment">// DisableStacktrace completely disables automatic stacktrace capturing. By</span></span><br><span class="line">	<span class="comment">// default, stacktraces are captured for WarnLevel and above logs in</span></span><br><span class="line">	<span class="comment">// development and ErrorLevel and above in production.</span></span><br><span class="line">	DisableStacktrace <span class="keyword">bool</span> <span class="string">`json:"disableStacktrace" yaml:"disableStacktrace"`</span></span><br><span class="line">	<span class="comment">// Sampling sets a sampling policy. A nil SamplingConfig disables sampling.</span></span><br><span class="line">	Sampling *SamplingConfig <span class="string">`json:"sampling" yaml:"sampling"`</span></span><br><span class="line">	<span class="comment">// Encoding sets the logger's encoding. Valid values are "json" and</span></span><br><span class="line">	<span class="comment">// "console", as well as any third-party encodings registered via</span></span><br><span class="line">	<span class="comment">// RegisterEncoder.</span></span><br><span class="line">	Encoding <span class="keyword">string</span> <span class="string">`json:"encoding" yaml:"encoding"`</span></span><br><span class="line">	<span class="comment">// EncoderConfig sets options for the chosen encoder. See</span></span><br><span class="line">	<span class="comment">// zapcore.EncoderConfig for details.</span></span><br><span class="line">	EncoderConfig zapcore.EncoderConfig <span class="string">`json:"encoderConfig" yaml:"encoderConfig"`</span></span><br><span class="line">	<span class="comment">// OutputPaths is a list of URLs or file paths to write logging output to.</span></span><br><span class="line">	<span class="comment">// See Open for details.</span></span><br><span class="line">	OutputPaths []<span class="keyword">string</span> <span class="string">`json:"outputPaths" yaml:"outputPaths"`</span></span><br><span class="line">	<span class="comment">// ErrorOutputPaths is a list of URLs to write internal logger errors to.</span></span><br><span class="line">	<span class="comment">// The default is standard error.</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// Note that this setting only affects internal errors; for sample code that</span></span><br><span class="line">	<span class="comment">// sends error-level logs to a different location from info- and debug-level</span></span><br><span class="line">	<span class="comment">// logs, see the package-level AdvancedConfiguration example.</span></span><br><span class="line">	ErrorOutputPaths []<span class="keyword">string</span> <span class="string">`json:"errorOutputPaths" yaml:"errorOutputPaths"`</span></span><br><span class="line">	<span class="comment">// InitialFields is a collection of fields to add to the root logger.</span></span><br><span class="line">	InitialFields <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:"initialFields" yaml:"initialFields"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Level-AtomicLevel"><a href="#Level-AtomicLevel" class="headerlink" title="Level AtomicLevel"></a>Level AtomicLevel</h2><p>zap 提供如下日志级别</p>
<ul>
<li>debug</li>
<li>info</li>
<li>warn</li>
<li>error</li>
<li>dpanic 如果开发模式开启 DPanicLevel 日志会产生 panic, 反之如果开发模式没有开启, 则仅会打印一行日志, 不会有 panic 抛出</li>
<li>panic 在日志记录后产生 panic</li>
<li>fatal 在日志记录后调用 os.Exit(1)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成 debug level 对象</span></span><br><span class="line">logLevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)</span><br><span class="line"><span class="comment">// 生成 error level 对象</span></span><br><span class="line">errLevel := zap.NewAtomicLevelAt(zapcore.ErrorLevel)</span><br></pre></td></tr></table></figure>

<h2 id="Development"><a href="#Development" class="headerlink" title="Development"></a>Development</h2><p>开发模式开关, 如果该字段的值为<code>true</code>, 意为开启开发模式. 在开发模式下, DPanicLevel 的错误就打印出完整的堆栈, 并随后抛出一个 panic, 如果你不希望因为日志中的 panic 影响程序继续运行, 那么你必须处理这个 panic.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预置函数 zap.NewDevelopment() 中开发模式默认为开启</span></span><br><span class="line">logger, err := zap.NewDevelopment()</span><br><span class="line">...</span><br><span class="line">logger.DPanic(<span class="string">"diy dpanic"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-17T23:27:30.380+0800    DPANIC  log&#x2F;l2.go:26    diy dpanic</span><br><span class="line">main.main</span><br><span class="line">        &#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;awesomeProject&#x2F;log&#x2F;l2.go:26</span><br><span class="line">runtime.main</span><br><span class="line">        &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go:203</span><br><span class="line">panic: diy dpanic</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">go.uber.org&#x2F;zap&#x2F;zapcore.(*CheckedEntry).Write(0xc0000c62c0, 0x0, 0x0, 0x0)</span><br><span class="line">        &#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;go.uber.org&#x2F;zap&#x2F;zapcore&#x2F;entry.go:230 +0x546</span><br><span class="line">go.uber.org&#x2F;zap.(*SugaredLogger).log(0xc0000fbd78, 0xc0000b2203, 0x0, 0x0, 0xc0000fbd90, 0x1, 0x1, 0x0, 0x0, 0x0)</span><br><span class="line">        &#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;go.uber.org&#x2F;zap&#x2F;sugar.go:234 +0x100</span><br><span class="line">go.uber.org&#x2F;zap.(*SugaredLogger).DPanic(...)</span><br><span class="line">        &#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;go.uber.org&#x2F;zap&#x2F;sugar.go:118</span><br><span class="line">main.main()</span><br><span class="line">        &#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;awesomeProject&#x2F;log&#x2F;l2.go:26 +0x30c</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p>如果 <code>Development</code> 字段的值为 <code>false</code>, 意为关闭开发模式, 此时 <code>DPanicLevel</code> 的错误不会打印完整的堆栈, 也不会抛出 panic, 仅会记录日志</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 预置函数 zap.NewProduction() 中开发模式默认为关闭</span></span><br><span class="line">logger, err := zap.NewProduction()</span><br><span class="line">...</span><br><span class="line">logger.DPanic(<span class="string">"diy dpanic"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;dpanic&quot;,&quot;ts&quot;:1584459058.8611479,&quot;caller&quot;:&quot;log&#x2F;l2.go:26&quot;,&quot;msg&quot;:&quot;diy dpanic&quot;,&quot;stacktrace&quot;:&quot;main.main\n\t&#x2F;Users&#x2F;lvrui&#x2F;go&#x2F;src&#x2F;awesomeProject&#x2F;log&#x2F;l2.go:26\nruntime.main\n\t&#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;proc.go:203&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DisableCaller"><a href="#DisableCaller" class="headerlink" title="DisableCaller"></a>DisableCaller</h2><p>是否禁用调用信息. 该字段值为 <code>true</code> 时, 日志中将不再显示该日志所在的函数调用信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; false 显示调用信息</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-17T23:33:57.881+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;l1.go:44&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;zapdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-17T23:33:57.881+0800&quot;,&quot;caller&quot;:&quot;log&#x2F;l1.go:51&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;zapdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; true 关闭调用信息</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-17T23:34:25.064+0800&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;zapdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;time&quot;:&quot;2020-03-17T23:34:25.064+0800&quot;,&quot;message&quot;:&quot;logger construction succeeded&quot;,&quot;app&quot;:&quot;zapdex&quot;,&quot;key&quot;:&quot;value&quot;,&quot;number&quot;:9&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DisableStacktrace"><a href="#DisableStacktrace" class="headerlink" title="DisableStacktrace"></a>DisableStacktrace</h2><p>是否禁用自动堆栈跟踪捕获.</p>
<ul>
<li>默认情况下, 在 warn level 及以上日志捕获 stacktrace</li>
<li>在生产环境, 一般在 error level 及以上日志捕获 stacktrace</li>
</ul>
<h2 id="Sampling"><a href="#Sampling" class="headerlink" title="Sampling"></a>Sampling</h2><p>流控配置, 也叫采样. 单位是每秒钟, 作用是限制日志在每秒钟内的输出数量, 以防止CPU和IO被过度占用</p>
<p>源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> SamplingConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	Initial    <span class="keyword">int</span> <span class="string">`json:"initial" yaml:"initial"`</span></span><br><span class="line">	Thereafter <span class="keyword">int</span> <span class="string">`json:"thereafter" yaml:"thereafter"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有两个参数可以配置</p>
<ul>
<li>Initial</li>
<li>Thereafter</li>
</ul>
<p>在一秒钟内, 如果某个级别的日志输出量超过了 <code>Initial</code>, 那么在超过之后, 每 <code>Thereafter</code> 条日志才会输出一条, 其余的日志都将被删除</p>
<p>在官方文档中有这么一句话:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Keep in mind that zap&#39;s sampling implementation is optimized for speed over</span><br><span class="line">&#x2F;&#x2F; absolute precision; under load, each tick may be slightly over- or</span><br><span class="line">&#x2F;&#x2F; under-sampled.</span><br></pre></td></tr></table></figure>

<p>由此可见 zap 性能至上的设计理念</p>
<h2 id="Encoding"><a href="#Encoding" class="headerlink" title="Encoding"></a>Encoding</h2><p>指定日志编码器, 目前仅支持两种编码器</p>
<ul>
<li>console</li>
<li>json</li>
</ul>
<p>上篇 zap 预置函数用法中的 <code>NewProduction</code> 用的就是 <code>json</code>, 而 <code>NewDevelopment</code> 用的则是 <code>console</code></p>
<p>在实际生产环境中, 一般推荐使用 <code>json</code> 编码器, 方便日志收集器收集, 免去格式化成结构化日志的CPU性能损耗</p>
<h2 id="EncoderConfig"><a href="#EncoderConfig" class="headerlink" title="EncoderConfig"></a>EncoderConfig</h2><p><code>EncoderConfig</code> 接收一个 <code>zapcore.EncoderConfig</code> 类型的变量, 支持如下配置项:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// An EncoderConfig allows users to configure the concrete encoders supplied by</span></span><br><span class="line"><span class="comment">// zapcore.</span></span><br><span class="line"><span class="keyword">type</span> EncoderConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Set the keys used for each log entry. If any key is empty, that portion</span></span><br><span class="line">	<span class="comment">// of the entry is omitted.</span></span><br><span class="line">	MessageKey    <span class="keyword">string</span> <span class="string">`json:"messageKey" yaml:"messageKey"`</span></span><br><span class="line">	LevelKey      <span class="keyword">string</span> <span class="string">`json:"levelKey" yaml:"levelKey"`</span></span><br><span class="line">	TimeKey       <span class="keyword">string</span> <span class="string">`json:"timeKey" yaml:"timeKey"`</span></span><br><span class="line">	NameKey       <span class="keyword">string</span> <span class="string">`json:"nameKey" yaml:"nameKey"`</span></span><br><span class="line">	CallerKey     <span class="keyword">string</span> <span class="string">`json:"callerKey" yaml:"callerKey"`</span></span><br><span class="line">	StacktraceKey <span class="keyword">string</span> <span class="string">`json:"stacktraceKey" yaml:"stacktraceKey"`</span></span><br><span class="line">	LineEnding    <span class="keyword">string</span> <span class="string">`json:"lineEnding" yaml:"lineEnding"`</span></span><br><span class="line">	<span class="comment">// Configure the primitive representations of common complex types. For</span></span><br><span class="line">	<span class="comment">// example, some users may want all time.Times serialized as floating-point</span></span><br><span class="line">	<span class="comment">// seconds since epoch, while others may prefer ISO8601 strings.</span></span><br><span class="line">	EncodeLevel    LevelEncoder    <span class="string">`json:"levelEncoder" yaml:"levelEncoder"`</span></span><br><span class="line">	EncodeTime     TimeEncoder     <span class="string">`json:"timeEncoder" yaml:"timeEncoder"`</span></span><br><span class="line">	EncodeDuration DurationEncoder <span class="string">`json:"durationEncoder" yaml:"durationEncoder"`</span></span><br><span class="line">	EncodeCaller   CallerEncoder   <span class="string">`json:"callerEncoder" yaml:"callerEncoder"`</span></span><br><span class="line">	<span class="comment">// Unlike the other primitive type encoders, EncodeName is optional. The</span></span><br><span class="line">	<span class="comment">// zero value falls back to FullNameEncoder.</span></span><br><span class="line">	EncodeName NameEncoder <span class="string">`json:"nameEncoder" yaml:"nameEncoder"`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><p><code>MessageKey</code> <code>LevelKey</code> <code>TimeKey</code> <code>NameKey</code> <code>CallerKey</code> <code>StacktraceKey</code> 用来标识日志中对应字段的<code>Key</code>的名字</p>
<h3 id="LineEnding"><a href="#LineEnding" class="headerlink" title="LineEnding"></a>LineEnding</h3><p>设置每行日志的结束符, 默认使用换行符</p>
<h3 id="EncodeLevel"><a href="#EncodeLevel" class="headerlink" title="EncodeLevel"></a>EncodeLevel</h3><p>配置日志级别编码器, 可以配置例如带控制台颜色的输出, 全小写输出或首字母大写输出等</p>
<h3 id="EncodeTime"><a href="#EncodeTime" class="headerlink" title="EncodeTime"></a>EncodeTime</h3><p>配置时间编码器, 配置显示时间的格式</p>
<h3 id="EncodeDuration"><a href="#EncodeDuration" class="headerlink" title="EncodeDuration"></a>EncodeDuration</h3><p>配置序列化时间的类型, 可配置int64类型的毫秒, int64类型的纳秒, float64类型的秒, 和字符串类型的时间</p>
<h3 id="EncodeCaller"><a href="#EncodeCaller" class="headerlink" title="EncodeCaller"></a>EncodeCaller</h3><p>配置调用点编码器, 可配置全路径或短路径的显示形式</p>
<h3 id="EncodeName"><a href="#EncodeName" class="headerlink" title="EncodeName"></a>EncodeName</h3><p>配置logger名称编码器</p>
<h2 id="OutputPaths"><a href="#OutputPaths" class="headerlink" title="OutputPaths"></a>OutputPaths</h2><p>配置日志标准输出, 接收数据类型为 <code>[]string</code> 意味着可以配置多个路径作为日志的输出路径, 一般情况可以仅配置标准输出或输出到文件, 如有需求的话, 也可以两者同时配置.</p>
<p>也可以自定义输出协议, 但是需要使用RegisterSink方法先注册一个该协议对应的工厂方法, 该工厂方法实现了Sink接口</p>
<h2 id="ErrorOutputPaths"><a href="#ErrorOutputPaths" class="headerlink" title="ErrorOutputPaths"></a>ErrorOutputPaths</h2><p>配置标准错误输出, 使用方式同<code>OutputPaths</code></p>
<h2 id="InitialFields"><a href="#InitialFields" class="headerlink" title="InitialFields"></a>InitialFields</h2><p>初始化字段配置, 该配置的字段会以结构化的形式打印在每条日志输出中</p>
<h2 id="配置完整示例"><a href="#配置完整示例" class="headerlink" title="配置完整示例"></a>配置完整示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"go.uber.org/zap/zapcore"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	logLevel := zap.NewAtomicLevelAt(zapcore.DebugLevel)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> zc = zap.Config&#123;</span><br><span class="line">		Level:             logLevel,</span><br><span class="line">		Development:       <span class="literal">false</span>,</span><br><span class="line">		DisableCaller:     <span class="literal">false</span>,</span><br><span class="line">		DisableStacktrace: <span class="literal">false</span>,</span><br><span class="line">		Sampling:          <span class="literal">nil</span>,</span><br><span class="line">		Encoding:          <span class="string">"json"</span>,</span><br><span class="line">		EncoderConfig: zapcore.EncoderConfig&#123;</span><br><span class="line">			MessageKey:     <span class="string">"message"</span>,</span><br><span class="line">			LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">			TimeKey:        <span class="string">"time"</span>,</span><br><span class="line">			NameKey:        <span class="string">"name"</span>,</span><br><span class="line">			CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">			StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">			LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">			EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">			EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">			EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">			EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">			EncodeName:     zapcore.FullNameEncoder,</span><br><span class="line">		&#125;,</span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stdout"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		InitialFields:    <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;<span class="string">"app"</span>: <span class="string">"zapdex"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	logger, err := zc.Build()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	logger.Info(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		zap.String(<span class="string">"key"</span>, <span class="string">"value"</span>),</span><br><span class="line">		zap.Int(<span class="string">"number"</span>, <span class="number">9</span>),</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	sugarLogger := logger.Sugar()</span><br><span class="line"></span><br><span class="line">	sugarLogger.Infow(<span class="string">"logger construction succeeded"</span>,</span><br><span class="line">		<span class="string">"key"</span>, <span class="string">"value"</span>, <span class="string">"number"</span>, <span class="number">9</span>,</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>zap</tag>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言优秀的日志包zap预置函数用法</title>
    <url>/2020/03/21/go%E8%AF%AD%E8%A8%80%E4%BC%98%E7%A7%80%E7%9A%84%E6%97%A5%E5%BF%97%E5%8C%85zap%E9%A2%84%E7%BD%AE%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>zap 和 logrus 是 go 语言中日志包的佼佼者. 两者都推荐使用结构化的日志打印, 从速度上来说, zap 要比 logrus 快很多. zap 的官方案例中, 介绍了三种使用方式, 分别是 <code>AdvancedConfiguration</code> <code>BasicConfiguration</code> 和 <code>Presets</code> 本篇文章介绍 zap 包的 Presets 用法</p>
</blockquote>
<a id="more"></a>

<p>Presets(预置函数) 是 zap 日志包最简单的用法, 不需要过多的自定义配置就可以用起来</p>
<h2 id="NewExample"><a href="#NewExample" class="headerlink" title="NewExample"></a>NewExample</h2><p>预置函数 NewExample 的源码定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewExample</span><span class="params">(options ...Option)</span> *<span class="title">Logger</span></span> &#123;</span><br><span class="line">	encoderCfg := zapcore.EncoderConfig&#123;</span><br><span class="line">		MessageKey:     <span class="string">"msg"</span>,</span><br><span class="line">		LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">		NameKey:        <span class="string">"logger"</span>,</span><br><span class="line">		EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">		EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">		EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">	&#125;</span><br><span class="line">	core := zapcore.NewCore(zapcore.NewJSONEncoder(encoderCfg), os.Stdout, DebugLevel)</span><br><span class="line">	<span class="keyword">return</span> New(core).WithOptions(options...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到, 预置函数为我们配置了以上内容, 包括</p>
<ul>
<li>各个字段的名称</li>
<li>日志级别的显示形式</li>
<li>时间编码类型</li>
<li>序列化时间的方式</li>
<li>输出到标准输出</li>
<li>以json形式打印</li>
<li>日志打印级别为Debug</li>
</ul>
<p><code>NewExample</code> 输出信息比较少, 打印内容比较详细, 一般用于开发时临时调试使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger := zap.NewExample()</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> url = <span class="string">"http://example.com"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sugar 版本的 logger</span></span><br><span class="line">	sugar := logger.Sugar()</span><br><span class="line">	sugar.Infow(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		<span class="string">"url"</span>, url,</span><br><span class="line">		<span class="string">"attempt"</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="string">"backoff"</span>, time.Second,</span><br><span class="line">	)</span><br><span class="line">	sugar.Infof(<span class="string">"Failed to fetch URL: %s"</span>, url)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 极速版 logger</span></span><br><span class="line">	logger.Info(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		zap.String(<span class="string">"url"</span>, url),</span><br><span class="line">		zap.Int(<span class="string">"attempt"</span>, <span class="number">3</span>),</span><br><span class="line">		zap.Duration(<span class="string">"backoff"</span>, time.Second),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Failed to fetch URL.&quot;,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Failed to fetch URL: http:&#x2F;&#x2F;example.com&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;Failed to fetch URL.&quot;,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:&quot;1s&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NewDevelopment"><a href="#NewDevelopment" class="headerlink" title="NewDevelopment"></a>NewDevelopment</h2><p>预置函数 NewDevelopment 的源码定义如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDevelopment</span><span class="params">(options ...Option)</span> <span class="params">(*Logger, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewDevelopmentConfig().Build(options...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDevelopmentConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Config&#123;</span><br><span class="line">		Level:            NewAtomicLevelAt(DebugLevel),</span><br><span class="line">		Development:      <span class="literal">true</span>,</span><br><span class="line">		Encoding:         <span class="string">"console"</span>,</span><br><span class="line">		EncoderConfig:    NewDevelopmentEncoderConfig(),</span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDevelopmentEncoderConfig</span><span class="params">()</span> <span class="title">zapcore</span>.<span class="title">EncoderConfig</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> zapcore.EncoderConfig&#123;</span><br><span class="line">		<span class="comment">// Keys can be anything except the empty string.</span></span><br><span class="line">		TimeKey:        <span class="string">"T"</span>,</span><br><span class="line">		LevelKey:       <span class="string">"L"</span>,</span><br><span class="line">		NameKey:        <span class="string">"N"</span>,</span><br><span class="line">		CallerKey:      <span class="string">"C"</span>,</span><br><span class="line">		MessageKey:     <span class="string">"M"</span>,</span><br><span class="line">		StacktraceKey:  <span class="string">"S"</span>,</span><br><span class="line">		LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">		EncodeLevel:    zapcore.CapitalLevelEncoder,</span><br><span class="line">		EncodeTime:     zapcore.ISO8601TimeEncoder,</span><br><span class="line">		EncodeDuration: zapcore.StringDurationEncoder,</span><br><span class="line">		EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg Config)</span> <span class="title">Build</span><span class="params">(opts ...Option)</span> <span class="params">(*Logger, error)</span></span> &#123;</span><br><span class="line">	enc, err := cfg.buildEncoder()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sink, errSink, err := cfg.openSinks()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cfg.Level == (AtomicLevel&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"missing Level"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log := New(</span><br><span class="line">		zapcore.NewCore(enc, sink, cfg.Level),</span><br><span class="line">		cfg.buildOptions(errSink)...,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(opts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log = log.WithOptions(opts...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> log, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>NewDevelopment</code> 打印内容比较详细(debug level), 输出格式为<code>console</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"go.uber.org/zap"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger, err := zap.NewDevelopment()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> url = <span class="string">"http://example.com"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sugar 版本的 logger</span></span><br><span class="line">	sugar := logger.Sugar()</span><br><span class="line">	sugar.Infow(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		<span class="string">"url"</span>, url,</span><br><span class="line">		<span class="string">"attempt"</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="string">"backoff"</span>, time.Second,</span><br><span class="line">	)</span><br><span class="line">	sugar.Infof(<span class="string">"Failed to fetch URL: %s"</span>, url)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 极速版 logger</span></span><br><span class="line">	logger.Info(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		zap.String(<span class="string">"url"</span>, url),</span><br><span class="line">		zap.Int(<span class="string">"attempt"</span>, <span class="number">3</span>),</span><br><span class="line">		zap.Duration(<span class="string">"backoff"</span>, time.Second),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2020-03-17T22:52:45.665+0800    INFO    log&#x2F;l2.go:19    Failed to fetch URL.    &#123;&quot;url&quot;: &quot;http:&#x2F;&#x2F;example.com&quot;, &quot;attempt&quot;: 3, &quot;backoff&quot;: &quot;1s&quot;&#125;</span><br><span class="line">2020-03-17T22:52:45.666+0800    INFO    log&#x2F;l2.go:24    Failed to fetch URL: http:&#x2F;&#x2F;example.com</span><br><span class="line">2020-03-17T22:52:45.666+0800    INFO    log&#x2F;l2.go:27    Failed to fetch URL.    &#123;&quot;url&quot;: &quot;http:&#x2F;&#x2F;example.com&quot;, &quot;attempt&quot;: 3, &quot;backoff&quot;: &quot;1s&quot;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NewProduction"><a href="#NewProduction" class="headerlink" title="NewProduction"></a>NewProduction</h2><p> 源码如下</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewProduction</span><span class="params">(options ...Option)</span> <span class="params">(*Logger, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewProductionConfig().Build(options...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProductionConfig</span><span class="params">()</span> <span class="title">Config</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Config&#123;</span><br><span class="line">		Level:       NewAtomicLevelAt(InfoLevel),</span><br><span class="line">		Development: <span class="literal">false</span>,</span><br><span class="line">		Sampling: &amp;SamplingConfig&#123;</span><br><span class="line">			Initial:    <span class="number">100</span>,</span><br><span class="line">			Thereafter: <span class="number">100</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		Encoding:         <span class="string">"json"</span>,</span><br><span class="line">		EncoderConfig:    NewProductionEncoderConfig(),</span><br><span class="line">		OutputPaths:      []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">		ErrorOutputPaths: []<span class="keyword">string</span>&#123;<span class="string">"stderr"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProductionEncoderConfig</span><span class="params">()</span> <span class="title">zapcore</span>.<span class="title">EncoderConfig</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> zapcore.EncoderConfig&#123;</span><br><span class="line">		TimeKey:        <span class="string">"ts"</span>,</span><br><span class="line">		LevelKey:       <span class="string">"level"</span>,</span><br><span class="line">		NameKey:        <span class="string">"logger"</span>,</span><br><span class="line">		CallerKey:      <span class="string">"caller"</span>,</span><br><span class="line">		MessageKey:     <span class="string">"msg"</span>,</span><br><span class="line">		StacktraceKey:  <span class="string">"stacktrace"</span>,</span><br><span class="line">		LineEnding:     zapcore.DefaultLineEnding,</span><br><span class="line">		EncodeLevel:    zapcore.LowercaseLevelEncoder,</span><br><span class="line">		EncodeTime:     zapcore.EpochTimeEncoder,</span><br><span class="line">		EncodeDuration: zapcore.SecondsDurationEncoder,</span><br><span class="line">		EncodeCaller:   zapcore.ShortCallerEncoder,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cfg Config)</span> <span class="title">Build</span><span class="params">(opts ...Option)</span> <span class="params">(*Logger, error)</span></span> &#123;</span><br><span class="line">	enc, err := cfg.buildEncoder()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sink, errSink, err := cfg.openSinks()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> cfg.Level == (AtomicLevel&#123;&#125;) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"missing Level"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	log := New(</span><br><span class="line">		zapcore.NewCore(enc, sink, cfg.Level),</span><br><span class="line">		cfg.buildOptions(errSink)...,</span><br><span class="line">	)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(opts) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		log = log.WithOptions(opts...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> log, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>NewProduction</code> 的日志级别提高到了info level, 而且默认使用了结构化更友好的json格式输出日志, 该预置函数, 适用于生产环境, 程序上线后使用</p>
 <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	logger, err := zap.NewProduction()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> logger.Sync()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> url = <span class="string">"http://example.com"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// sugar 版本的 logger</span></span><br><span class="line">	sugar := logger.Sugar()</span><br><span class="line">	sugar.Infow(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		<span class="string">"url"</span>, url,</span><br><span class="line">		<span class="string">"attempt"</span>, <span class="number">3</span>,</span><br><span class="line">		<span class="string">"backoff"</span>, time.Second,</span><br><span class="line">	)</span><br><span class="line">	sugar.Infof(<span class="string">"Failed to fetch URL: %s"</span>, url)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 极速版 logger</span></span><br><span class="line">	logger.Info(<span class="string">"Failed to fetch URL."</span>,</span><br><span class="line">		zap.String(<span class="string">"url"</span>, url),</span><br><span class="line">		zap.Int(<span class="string">"attempt"</span>, <span class="number">3</span>),</span><br><span class="line">		zap.Duration(<span class="string">"backoff"</span>, time.Second),</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 执行结果</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1584457473.942979,&quot;caller&quot;:&quot;log&#x2F;l2.go:19&quot;,&quot;msg&quot;:&quot;Failed to fetch URL.&quot;,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:1&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1584457473.943102,&quot;caller&quot;:&quot;log&#x2F;l2.go:24&quot;,&quot;msg&quot;:&quot;Failed to fetch URL: http:&#x2F;&#x2F;example.com&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;ts&quot;:1584457473.943125,&quot;caller&quot;:&quot;log&#x2F;l2.go:27&quot;,&quot;msg&quot;:&quot;Failed to fetch URL.&quot;,&quot;url&quot;:&quot;http:&#x2F;&#x2F;example.com&quot;,&quot;attempt&quot;:3,&quot;backoff&quot;:1&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>zap</tag>
        <tag>log</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 添加之前已删除过的节点</title>
    <url>/2019/06/01/etcd-%E6%B7%BB%E5%8A%A0%E4%B9%8B%E5%89%8D%E5%B7%B2%E5%88%A0%E9%99%A4%E8%BF%87%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>场景: 当etcd集群中的一个节点, 由于主机故障, 被迫临时下线时, 为了保证etcd集群的健壮性, 会先删除掉该故障节点后, 再补位新的节点顶上去. 当故障机器经历了N天辛苦的修复后, 重新上线了, 此时需要将该台机器重新加回到etcd集群中</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>在前面两篇文章的实验中, 一个原始的etcd集群如下</p>
<ul>
<li>192.168.149.60</li>
<li>192.168.149.61</li>
<li>192.168.149.62</li>
</ul>
<p>将 <code>192.168.149.60</code> 迁移到了 <code>192.168.149.63</code></p>
<p>将 <code>192.168.149.61</code> 替换掉换成了 <code>192.168.149.64</code></p>
<p>所以我这里的实验环境中, 已经有两台曾经服役过的etcd节点, 本篇文章将介绍如何将原节点重新加回到集群中</p>
<h2 id="整体步骤"><a href="#整体步骤" class="headerlink" title="整体步骤"></a>整体步骤</h2><ul>
<li>确认待添加的节点, etcd服务是停止的状态</li>
<li>删除etcd数据目录 member</li>
<li>执行运行时配置, 按正常添加一台新节点执行</li>
<li>更新配置文件, 启动etcd服务</li>
</ul>
<h3 id="Step-1-确认状态"><a href="#Step-1-确认状态" class="headerlink" title="Step 1: 确认状态"></a>Step 1: 确认状态</h3><p>保证待添加节点的etcd服务状态为down</p>
<h3 id="Step-2-删除数据目录"><a href="#Step-2-删除数据目录" class="headerlink" title="Step 2: 删除数据目录"></a>Step 2: 删除数据目录</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 去配置文件中, 找你的数据目录</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> rm -fr <span class="variable">$ETCD_DATA_DIR</span>/member</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-3-添加节点"><a href="#Step-3-添加节点" class="headerlink" title="Step 3: 添加节点"></a>Step 3: 添加节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379 member add lv-etcd-research-alpha-0 --peer-urls=<span class="string">"http://192.168.149.60:2380"</span></span></span><br><span class="line">Member 2145c204a51dbbc7 added to cluster 2c25150e88501a13</span><br><span class="line"></span><br><span class="line">ETCD_NAME="lv-etcd-research-alpha-0"</span><br><span class="line">ETCD_INITIAL_CLUSTER="lv-etcd-research-alpha-1=http://192.168.149.63:2380,lv-etcd-research-alpha-0=http://192.168.149.60:2380,lv-etcd-research-alpha-3=http://192.168.149.62:2380,lv-etcd-research-alpha-4=http://192.168.149.64:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE="existing"</span><br></pre></td></tr></table></figure>

<h3 id="Step-4-更新配置文件-启动服务"><a href="#Step-4-更新配置文件-启动服务" class="headerlink" title="Step 4: 更新配置文件, 启动服务"></a>Step 4: 更新配置文件, 启动服务</h3><p>按照上一步添加集群成员的回显, 修改配置文件(由于该台主机曾经就是etcd集群中的一员, 所以配置文件中仅需要修改回显中的关键参数即可)</p>
<p>修改完配置文件, 启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> systemctl start etcd</span></span><br></pre></td></tr></table></figure>

<p>集群状态:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379 member list</span></span><br><span class="line">1161d5b4260241e3, started, lv-etcd-research-alpha-1, http://192.168.149.63:2380, http://192.168.149.63:2379</span><br><span class="line">2145c204a51dbbc7, started, lv-etcd-research-alpha-0, http://192.168.149.60:2380, http://192.168.149.60:2379</span><br><span class="line">4252aec339d438d9, started, lv-etcd-research-alpha-3, http://192.168.149.62:2380, http://192.168.149.62:2379</span><br><span class="line">ea04db3353b9fd4e, started, lv-etcd-research-alpha-4, http://192.168.149.64:2380, http://192.168.149.64:2379</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意 --endpoints 参数中添加新的节点地址 http://192.168.149.60:2379</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379,http://192.168.149.60:2379,http://192.168.149.63:2379,http://192.168.149.64:2379  endpoint status -w table</span></span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http://192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   21 MB |      true |         8 |     148457 |</span><br><span class="line">| http://192.168.149.60:2379 | 2145c204a51dbbc7 |  3.2.28 |   21 MB |     false |         8 |     148457 |</span><br><span class="line">| http://192.168.149.63:2379 | 1161d5b4260241e3 |  3.2.28 |   21 MB |     false |         8 |     148457 |</span><br><span class="line">| http://192.168.149.64:2379 | ea04db3353b9fd4e |  3.2.28 |   21 MB |     false |         8 |     148457 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br></pre></td></tr></table></figure>

<p>第二个节点也依照此方法炮制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379 member add lv-etcd-research-alpha-2 --peer-urls=<span class="string">"http://192.168.149.61:2380"</span></span></span><br><span class="line">Member e26482910894af8d added to cluster 2c25150e88501a13</span><br><span class="line"></span><br><span class="line">ETCD_NAME="lv-etcd-research-alpha-2"</span><br><span class="line">ETCD_INITIAL_CLUSTER="lv-etcd-research-alpha-1=http://192.168.149.63:2380,lv-etcd-research-alpha-0=http://192.168.149.60:2380,lv-etcd-research-alpha-3=http://192.168.149.62:2380,lv-etcd-research-alpha-2=http://192.168.149.61:2380,lv-etcd-research-alpha-4=http://192.168.149.64:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE="existing"</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379 member list</span></span><br><span class="line">1161d5b4260241e3, started, lv-etcd-research-alpha-1, http://192.168.149.63:2380, http://192.168.149.63:2379</span><br><span class="line">2145c204a51dbbc7, started, lv-etcd-research-alpha-0, http://192.168.149.60:2380, http://192.168.149.60:2379</span><br><span class="line">4252aec339d438d9, started, lv-etcd-research-alpha-3, http://192.168.149.62:2380, http://192.168.149.62:2379</span><br><span class="line">e26482910894af8d, started, lv-etcd-research-alpha-2, http://192.168.149.61:2380, http://192.168.149.61:2379</span><br><span class="line">ea04db3353b9fd4e, started, lv-etcd-research-alpha-4, http://192.168.149.64:2380, http://192.168.149.64:2379</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.62:2379,http://192.168.149.60:2379,http://192.168.149.61:2379,http://192.168.149.63:2379,http://192.168.149.64:2379  endpoint status -w table</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http://192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   21 MB |      true |         8 |     148909 |</span><br><span class="line">| http://192.168.149.60:2379 | 2145c204a51dbbc7 |  3.2.28 |   21 MB |     false |         8 |     148909 |</span><br><span class="line">| http://192.168.149.61:2379 | e26482910894af8d |  3.2.28 |   21 MB |     false |         8 |     148909 |</span><br><span class="line">| http://192.168.149.63:2379 | 1161d5b4260241e3 |  3.2.28 |   21 MB |     false |         8 |     148909 |</span><br><span class="line">| http://192.168.149.64:2379 | ea04db3353b9fd4e |  3.2.28 |   21 MB |     false |         8 |     148909 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>重新添加之前已删除的节点的关键之所在就是删除数据目录, 因为数据目录中还保存这节点ID和集群ID等信息, 带着这些信息是无法通过校验添加到集群的</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 替换扩容节点</title>
    <url>/2019/05/16/etcd-%E6%9B%BF%E6%8D%A2%E6%89%A9%E5%AE%B9%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>etcd 替换节点的本质就是添加一个新的实例, 再删除一个已有实例, 以完成替换. 如果替换的是一台已经无法正常运行的主机, 你需要先删除掉故障节点, 然后再正常添加一个节点.</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.63:2379 | 1161d5b4260241e3 |  3.2.28 |   20 MB |     false |         8 |     141652 |</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   20 MB |      true |         8 |     141652 |</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.61:2379 | e6f45ed7d9402b75 |  3.2.28 |   20 MB |     false |         8 |     141652 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br></pre></td></tr></table></figure>

<p>替换需求节点: <code>192.168.149.61</code> 替换成 <code>192.168.149.64</code></p>
<h2 id="替换总体步骤-先添加-后删除"><a href="#替换总体步骤-先添加-后删除" class="headerlink" title="替换总体步骤(先添加, 后删除)"></a>替换总体步骤(先添加, 后删除)</h2><ul>
<li>执行etcd运行时配置命令, 添加节点, 注意记录回显</li>
<li>在新机器上使用上一步首先的参数, 启动etcd服务</li>
<li>删除需要替换的节点</li>
</ul>
<h3 id="Step-1-执行运行时配置-添加节点"><a href="#Step-1-执行运行时配置-添加节点" class="headerlink" title="Step 1: 执行运行时配置, 添加节点"></a>Step 1: 执行运行时配置, 添加节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.61:2379 member add lv-etcd-research-alpha-4 --peer-urls=<span class="string">"http://192.168.149.64:2380"</span></span></span><br><span class="line">Member ea04db3353b9fd4e added to cluster 2c25150e88501a13</span><br><span class="line"></span><br><span class="line">ETCD_NAME="lv-etcd-research-alpha-4"</span><br><span class="line">ETCD_INITIAL_CLUSTER="lv-etcd-research-alpha-1=http://192.168.149.63:2380,lv-etcd-research-alpha-3=http://192.168.149.62:2380,lv-etcd-research-alpha-2=http://192.168.149.61:2380,lv-etcd-research-alpha-4=http://192.168.149.64:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE="existing"</span><br></pre></td></tr></table></figure>

<p>查看当前集群成员</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 member list -w table</span></span><br><span class="line">+------------------+-----------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        |  STATUS   |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+-----------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 |   started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.63:2379 |</span><br><span class="line">| 4252aec339d438d9 |   started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| e6f45ed7d9402b75 |   started | lv-etcd-research-alpha-2 | http://192.168.149.61:2380 | http://192.168.149.61:2379 |</span><br><span class="line">| ea04db3353b9fd4e | unstarted |                          | http://192.168.149.64:2380 |                            |</span><br><span class="line">+------------------+-----------+--------------------------+----------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<h3 id="Step-2-根据回显参数-启动服务"><a href="#Step-2-根据回显参数-启动服务" class="headerlink" title="Step 2: 根据回显参数, 启动服务"></a>Step 2: 根据回显参数, 启动服务</h3><p>在任意已运行节点执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可以先将一个已存在节点上的配置文件, 发送到新的节点</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp /etc/etcd/etcd.conf root@192.168.149.64:/etc/etcd/</span></span><br></pre></td></tr></table></figure>

<p>在新节点执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 编译配置文件, 将上一步运行时配置的回显结果中的参数, 替换到配置文件中</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> vim /etc/etcd/etcd.conf</span></span><br><span class="line"></span><br><span class="line">ETCD_NAME="lv-etcd-research-alpha-4"</span><br><span class="line">ETCD_INITIAL_CLUSTER="lv-etcd-research-alpha-1=http://192.168.149.63:2380,lv-etcd-research-alpha-3=http://192.168.149.62:2380,lv-etcd-research-alpha-2=http://192.168.149.61:2380,lv-etcd-research-alpha-4=http://192.168.149.64:2380"</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE="existing"</span><br></pre></td></tr></table></figure>

<p>同理, 由于是copy过来的配置文件, 以下参数也需要做响应的修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ETCD_LISTEN_PEER_URLS</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS</span><br></pre></td></tr></table></figure>

<p>由copy原主机IP, 修改到目标主机IP地址, 修改完成后, 启动etcd 服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start etcd</span><br></pre></td></tr></table></figure>

<p>集群状态:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379,http://192.168.149.62:2379,http://192.168.149.61:2379,http://192.168.149.64:2379 endpoint status -w table</span></span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http://192.168.149.63:2379 | 1161d5b4260241e3 |  3.2.28 |   21 MB |     false |         8 |     144745 |</span><br><span class="line">| http://192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   21 MB |      true |         8 |     144745 |</span><br><span class="line">| http://192.168.149.61:2379 | e6f45ed7d9402b75 |  3.2.28 |   21 MB |     false |         8 |     144745 |</span><br><span class="line">| http://192.168.149.64:2379 | ea04db3353b9fd4e |  3.2.28 |   21 MB |     false |         8 |     144745 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 member list -w table</span></span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        | STATUS  |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 | started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.63:2379 |</span><br><span class="line">| 4252aec339d438d9 | started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| e6f45ed7d9402b75 | started | lv-etcd-research-alpha-2 | http://192.168.149.61:2380 | http://192.168.149.61:2379 |</span><br><span class="line">| ea04db3353b9fd4e | started | lv-etcd-research-alpha-4 | http://192.168.149.64:2380 | http://192.168.149.64:2379 |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<p>注意: 执行<code>endpoint status</code>查询时, 记得在<code>--endpoints</code>参数中, 加上新节点的地址<code>http://192.168.149.64:2379</code></p>
<h3 id="Step-3-删除需要替换的节点"><a href="#Step-3-删除需要替换的节点" class="headerlink" title="Step 3: 删除需要替换的节点"></a>Step 3: 删除需要替换的节点</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379 member remove e6f45ed7d9402b75</span></span><br><span class="line">Member e6f45ed7d9402b75 removed from cluster 2c25150e88501a13</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379 member list -w table</span></span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        | STATUS  |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 | started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.63:2379 |</span><br><span class="line">| 4252aec339d438d9 | started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| ea04db3353b9fd4e | started | lv-etcd-research-alpha-4 | http://192.168.149.64:2380 | http://192.168.149.64:2379 |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<p>节点已被删除, 节点被删除后, etcd服务会被关闭, 日志中将出现如下信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">removed member e6f45ed7d9402b75 from cluster 2c25150e88501a13</span><br><span class="line">...</span><br><span class="line">the member has been permanently removed from the cluster</span><br></pre></td></tr></table></figure>

<p>此时, 你需要保证该节点的etcd不会自动启动, 开机启动, 重新启动. (虽然即使启动也不会再次成功加入到集群, 但是为了避免不必要的错误, 还是需要保证挂的彻底一些, 最好将数据目录也一并删除)</p>
<h2 id="替换故障节点"><a href="#替换故障节点" class="headerlink" title="替换故障节点"></a>替换故障节点</h2><p>以上的操作, 前提是集群节点全部正常的情况下, 才能执行member的操作, 当其中一个节点故障时, 你将无法直接新增节点, 你需要先删除故障节点, 然后再执行新增节点的操作</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>替换</tag>
      </tags>
  </entry>
  <entry>
    <title>etcd 节点迁移</title>
    <url>/2019/05/13/etcd-%E8%8A%82%E7%82%B9%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<blockquote>
<p>etcd 的节点变更有两种方式变更, 一种是数据迁移, 一种是通过增加新节点, 同步数据完成后, 删除老节点来实现的. 本篇文章介绍前者, 通过数据目录的迁移, 来实现etcd节点的迁移</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>当前etcd集群信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.60:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 member list</span></span><br><span class="line">1161d5b4260241e3, started, lv-etcd-research-alpha-1, http://192.168.149.60:2380, http://192.168.149.60:2379</span><br><span class="line">4252aec339d438d9, started, lv-etcd-research-alpha-3, http://192.168.149.62:2380, http://192.168.149.62:2379</span><br><span class="line">e6f45ed7d9402b75, started, lv-etcd-research-alpha-2, http://192.168.149.61:2380, http://192.168.149.61:2379</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ETCDCTL_API&#x3D;3 etcdctl --endpoints http:&#x2F;&#x2F;192.168.149.60:2379,http:&#x2F;&#x2F;192.168.149.62:2379,http:&#x2F;&#x2F;192.168.149.61:2379 endpoint status -w table</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.60:2379 | 1161d5b4260241e3 |  3.2.28 |   18 MB |     false |         7 |     124802 |</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   18 MB |     false |         7 |     124802 |</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.61:2379 | e6f45ed7d9402b75 |  3.2.28 |   18 MB |      true |         7 |     124802 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br></pre></td></tr></table></figure>

<p>本次目标是将 <code>192.168.149.60</code> 节点迁移到 <code>192.168.149.63</code> 节点</p>
<h2 id="总体迁移步骤"><a href="#总体迁移步骤" class="headerlink" title="总体迁移步骤"></a>总体迁移步骤</h2><ul>
<li>先在<code>192.168.149.60</code>上停止etcd服务, 如果该进程已经挂掉, 也就省去了停止etcd的步骤了😆 前提是你必须要保证, 它挂的很彻底, 不要迁移了一半又自己活过来…</li>
<li>从老机器上迁移数据到新机器对应目录</li>
<li>在任意节点执行member update操作, 更新peerURLs信息为新机器的 IP:Port</li>
<li>从老机器上将配置文件一并拷贝到新机器, 修改成新机器IP地址后, 保证指向的数据目录正确, 启动即可</li>
</ul>
<h3 id="Step-1-停服务"><a href="#Step-1-停服务" class="headerlink" title="Step 1: 停服务"></a>Step 1: 停服务</h3><p>在需要迁移的节点上, kill掉etcd的进程, 如果条件允许, 不要<code>-9</code>, 优雅关闭优先</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop etcd</span><br></pre></td></tr></table></figure>

<p>此时查询集群状态:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ETCDCTL_API&#x3D;3 etcdctl --endpoints http:&#x2F;&#x2F;192.168.149.60:2379,http:&#x2F;&#x2F;192.168.149.62:2379,http:&#x2F;&#x2F;192.168.149.61:2379 endpoint status -w table</span><br><span class="line">Failed to get the status of endpoint http:&#x2F;&#x2F;192.168.149.60:2379 (context deadline exceeded)</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   18 MB |     false |         7 |     124940 |</span><br><span class="line">| http:&#x2F;&#x2F;192.168.149.61:2379 | e6f45ed7d9402b75 |  3.2.28 |   18 MB |      true |         7 |     124940 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br></pre></td></tr></table></figure>

<p><code>192.168.149.60</code> 节点已经处于失联状态</p>
<h3 id="Step-2-迁移数据目录"><a href="#Step-2-迁移数据目录" class="headerlink" title="Step 2: 迁移数据目录"></a>Step 2: 迁移数据目录</h3><p>在<code>192.168.149.63</code>上执行(预建数据目录)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> mkdir -p /var/lib/etcd/default.etcd</span></span><br></pre></td></tr></table></figure>

<p>在<code>192.168.149.60</code>上执行(打包发送)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -cvzf member.tar.gz member</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> scp member.tar.gz root@192.168.149.63:/var/lib/etcd/default.etcd/</span></span><br></pre></td></tr></table></figure>

<p>在<code>192.168.149.63</code>上执行(解压)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> <span class="built_in">cd</span> /var/lib/etcd/default.etcd/</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> tar -xvzf member.tar.gz</span></span><br></pre></td></tr></table></figure>

<h3 id="Step-3-更新member信息"><a href="#Step-3-更新member信息" class="headerlink" title="Step 3: 更新member信息"></a>Step 3: 更新member信息</h3><p>在任意一个节点执行, 已更新原节点 peerURLs 信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.61:2379 member update 1161d5b4260241e3 --peer-urls=<span class="string">"http://192.168.149.63:2380"</span></span></span><br><span class="line">Member 1161d5b4260241e3 updated in cluster 2c25150e88501a13</span><br></pre></td></tr></table></figure>

<p><code>--endpoints http://192.168.149.61:2379</code> 因为 <code>192.168.149.60</code> 节点已停止服务, 所以这里需要选择一个其他的endpoint节点来对集群进行操作</p>
<p><code>1161d5b4260241e3</code> 是 <code>192.168.149.60</code> 的节点ID, 如果忘记的话, 可以执行 <code>member list</code>查看</p>
<p>回显显示命令已正确执行, 查询状态如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.60:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 member list -w table</span></span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        | STATUS  |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 | started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.60:2379 |</span><br><span class="line">| 4252aec339d438d9 | started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| e6f45ed7d9402b75 | started | lv-etcd-research-alpha-2 | http://192.168.149.61:2380 | http://192.168.149.61:2379 |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<p>可以看到第一行, PEER ADDRS 已经正确更新成为 <code>http://192.168.149.63:2380</code>, 但是后面的 CLIENT ADDRS 依然是原来的 <code>http://192.168.149.60:2379</code>. 这个不用担心, 等新的节点启动后, 这个值就会变成正确的地址</p>
<h3 id="Step-4-在新节点启动服务"><a href="#Step-4-在新节点启动服务" class="headerlink" title="Step 4: 在新节点启动服务"></a>Step 4: 在新节点启动服务</h3><p>在新节点启动服务之前, 记得把配置文件, 从老节点拷贝过去. 拷贝完成后, 一定要参数进行修改.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下两个参数如果指定了: 0.0.0.0 就无需更改, 如果是精确指定每个IP地址, 则需要将IP60更改为63</span></span><br><span class="line">ETCD_LISTEN_PEER_URLS</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下两个参数注意修改IP地址到新机器的IP</span></span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下集群信息中, 记得也将原IP修改为新机器的IP地址</span></span><br><span class="line">ETCD_INITIAL_CLUSTER</span><br></pre></td></tr></table></figure>

<p>以上修改的参数中, <code>ETCD_LISTEN_PEER_URLS</code> <code>ETCD_LISTEN_CLIENT_URLS</code> <code>ETCD_ADVERTISE_CLIENT_URLS</code> 是最重要的参数, 一定要和新机器的IP地址匹配</p>
<p>因为etcd是运行时重新配置, 另外两个 INIT 的参数虽然在服务启动的时候不再起什么作用了, 但是为了后期看到配置文件后不知道迷茫, 也最好都统一修改到新机器的IP地址</p>
<p>同理 <code>ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</code> 参数可以保留, 因为不起作用</p>
<p>启动etcd服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> systemctl start etcd</span></span><br></pre></td></tr></table></figure>

<p>集群状态:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 endpoint status -w table</span></span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">|          ENDPOINT          |        ID        | VERSION | DB SIZE | IS LEADER | RAFT TERM | RAFT INDEX |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line">| http://192.168.149.63:2379 | 1161d5b4260241e3 |  3.2.28 |   18 MB |     false |         7 |     128011 |</span><br><span class="line">| http://192.168.149.62:2379 | 4252aec339d438d9 |  3.2.28 |   18 MB |     false |         7 |     128011 |</span><br><span class="line">| http://192.168.149.61:2379 | e6f45ed7d9402b75 |  3.2.28 |   18 MB |      true |         7 |     128011 |</span><br><span class="line">+----------------------------+------------------+---------+---------+-----------+-----------+------------+</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> ETCDCTL_API=3 etcdctl --endpoints http://192.168.149.63:2379,http://192.168.149.62:2379,http://192.168.149.61:2379 member list -w table</span></span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">|        ID        | STATUS  |           NAME           |         PEER ADDRS         |        CLIENT ADDRS        |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br><span class="line">| 1161d5b4260241e3 | started | lv-etcd-research-alpha-1 | http://192.168.149.63:2380 | http://192.168.149.63:2379 |</span><br><span class="line">| 4252aec339d438d9 | started | lv-etcd-research-alpha-3 | http://192.168.149.62:2380 | http://192.168.149.62:2379 |</span><br><span class="line">| e6f45ed7d9402b75 | started | lv-etcd-research-alpha-2 | http://192.168.149.61:2380 | http://192.168.149.61:2379 |</span><br><span class="line">+------------------+---------+--------------------------+----------------------------+----------------------------+</span><br></pre></td></tr></table></figure>

<p>可以看到”新的集群” <code>RAFT INDEX</code> 已经一致, 表示新节点<code>192.168.149.63</code>已经追上集群数据.</p>
<p><code>PEER ADDRS</code> 和 <code>CLIENT ADDRS</code> 也均为正确的地址</p>
<p>此时, 节点迁移正确完成</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>这种迁移方式基本仅在待迁移的节点还能正常登陆, 还能正常访问数据目录的前提下进行. 如果机器已经挂掉, 无法访问到原有数据, 那么这种方式并不合适. 迁移嘛, 都正常才能迁移, 不正常的迁移叫故障恢复😆</p>
]]></content>
      <categories>
        <category>etcd</category>
      </categories>
      <tags>
        <tag>etcd</tag>
        <tag>迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言struct中的匿名字段与组合</title>
    <url>/2019/04/20/go%E8%AF%AD%E8%A8%80struct%E4%B8%AD%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5%E4%B8%8E%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>很多文档中都反复强调了, go语言中没有继承, 只有组合, 活用组合的特性可以让代码更加优雅. 在go语言中, struct中的匿名字段实现了组合的特性</p>
</blockquote>
<a id="more"></a>

<h2 id="struct匿名字段"><a href="#struct匿名字段" class="headerlink" title="struct匿名字段"></a>struct匿名字段</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> boy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b boy)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The boy is eating an apple"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> girl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g girl)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The girl is eating an orange"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">	b boy</span><br><span class="line">	girl  <span class="comment">// 匿名字段 接口体重只写了数据类型的字段叫匿名字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> boy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b boy)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The boy is eating an apple"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> girl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g girl)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The girl is eating an orange"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">	b boy</span><br><span class="line">	girl  <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> h human</span><br><span class="line">	h.b.eat()  </span><br><span class="line">	h.girl.eat()</span><br><span class="line">	h.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The boy is eating an apple</span><br><span class="line">The girl is eating an orange</span><br><span class="line">The girl is eating an orange</span><br></pre></td></tr></table></figure>

<p><code>h.b.eat()</code> 的运行结果 <code>The boy is eating an apple</code> 是符合我们的预期的. </p>
<p><code>h.girl.eat()</code> 的运行结果 <code>The girl is eating an orange</code> 也符合预期, 只不过因为<code>girl</code>匿名字段, 没有字段名称, 所以这里可以使用数据类型来调用其内部的<code>eat</code>函数</p>
<p><code>h.eat()</code> 这个函数调用比较奇怪, 正常情况下, 应该是定义在<code>human</code>下的<code>eat</code>方法才能被我们直接调用, 但是这里, 在<code>human</code>没有直接定义<code>eat</code>方法的情况下, <code>eat</code>函数依然被执行成功, 而且输出的结果与<code>h.girl.eat()</code>的结果相同</p>
<p>这就是组合, 使用匿名字段实现的组合. 使用组合后, 匿名字段拥有的所有方法都可以直接被调用, 而无需像<code>h.girl.eat()</code>这样写上字段类型来调用</p>
<h2 id="重写-重载"><a href="#重写-重载" class="headerlink" title="重写/重载"></a>重写/重载</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> boy <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b boy)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The boy is eating an apple"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> girl <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g girl)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The girl is eating an orange"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">	b boy</span><br><span class="line">	girl  <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h human)</span> <span class="title">eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"The man is eating some strawberries"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> h human</span><br><span class="line">	h.b.eat()</span><br><span class="line">	h.girl.eat()</span><br><span class="line">	h.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个demo仅比上个例子多了一个<code>human</code>的<code>eat</code>方法</p>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The boy is eating an apple</span><br><span class="line">The girl is eating an orange</span><br><span class="line">The man is eating some strawberries</span><br></pre></td></tr></table></figure>

<p>这次的执行结果中, <code>h.eat()</code> 的执行结果不再是 <code>The girl is eating an orange</code>, 而是 <code>The man is eating some strawberries</code>. 说明<code>human</code>下定义的<code>eat</code>方法重写了组合中同名的<code>eat</code>方法, 当该方法被直接调用时, 优先执行<code>human</code>下的<code>eat</code>方法. 此时如果还需要执行<code>girl</code>下的<code>eat</code>方法, 则需要先引用其数据类型, 再调用<code>eat</code>方法 -&gt; <code>h.girl.eat()</code></p>
<p><img src="https://20150509.oss-cn-qingdao.aliyuncs.com/2020/02/20/15822044593973.jpg" alt=""></p>
<p>编辑器中也会提示你下面的方法重写了上面的方法</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>组合</tag>
        <tag>匿名字段</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言实现加权轮询调度算法</title>
    <url>/2019/04/11/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>上篇文章中介绍了轮询调度算法, 忽略后端元素的差异性, 将请求均匀的”涂抹”到后端节点. 本篇介绍更为复杂的加权轮询调度算法, 可以根据后端节点实际承载能力, 单独调整每个节点的权重</p>
</blockquote>
<a id="more"></a>

<h2 id="演示思路"><a href="#演示思路" class="headerlink" title="演示思路"></a>演示思路</h2><p>在编写代码前, 先来说下实现加权轮询调度算法的思路. 加权轮询, 是在轮询的基础之上, 加上了对权重值的判断, 先看下下面的权重配置实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">-    -    -</span><br><span class="line">          -</span><br><span class="line">          -</span><br></pre></td></tr></table></figure>

<p>上面<code>a, b, c, d</code>四个后端节点, 配置的权重分别为<code>4, 4, 6, 2</code>. 也就是说, 当正好有16个请求打过来之后, 后端实际被调度的次数应该就是<code>4, 4, 6, 2</code></p>
<p>实现加权轮询算法的核心, 依然离不开轮询调度算法, 依然需要前篇文章介绍的轮询调度算法来控制索引下标. 第一步, 我们先找出后端所有元素配置的最大权重, 结果是: 最大权重为6, 那么我们期望第一次的调度结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">-    -    -</span><br><span class="line">          -</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>通过轮询调度算法, 依次判断哪个元素<code>&gt;=</code>最大权重值<code>6</code>, 当内存循环到<code>c</code>元素时, 条件满足, 则第一次调度的结果, 在算法内部循环了3次后, 返回了<code>c</code>.  </p>
<p>当有第二次请求到达时, 期望结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">-    -    -</span><br><span class="line">          ✔️</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>操作流程同上, 依次判断哪个元素的权重<code>&gt;=最大权重值</code> <code>最大权重值</code>此时<code>=8</code>, 内部开始轮询, 根据上次的索引下标继续向下轮询, 上次轮询到<code>c</code>, 本次将从<code>d</code>开始轮询, <code>d</code>的值不满足<code>&gt;=最大权重值</code>的条件, 应该回到<code>a</code>继续轮询判断, 直到符合条件为止. </p>
<p>这里需要注意的是, 再回到<code>a</code>之前, 应该将最大权重值<code>-1</code>, 因为在上一轮的轮询中, 已经将<code>=最大权重值</code>的元素消灭, 所以需要将<code>最大权重值-1</code>, 继续轮询判断, 是否有满足条件的元素, 我们在这里临时命名为<code>当前最大权重值(后面用cw表示)</code>, <code>-1</code>操作后, <code>cw=5</code>.</p>
<p><code>c</code>元素的权重值<code>6</code>符合<code>&gt;=5</code>的条件. 立即返回, 所以第二次的调度结果, 依然是<code>c</code>. </p>
<p>当有第三次请求到达时, 期望结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">✔️   -    -</span><br><span class="line">          ✔️</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>同上, 依次判断哪个元素的权重<code>&gt;=cw</code> <code>cw</code>此时<code>=5</code>, 开始轮询, 上次轮询到<code>c</code>, 本次从下一个元素<code>d</code>开始轮询, <code>d</code>不满足条件, 此时一整轮轮询结束🔚, 再次将<code>cw-1</code>, 此时<code>cw=4</code>. 并从<code>a</code>开始重新轮询, 发现<code>a</code>符合<code>&gt;=4</code>的条件, 立即返回, 所以第三次的调度结果为<code>a</code>.</p>
<p>当有第四次请求到达时, 期望结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">✔️   ✔️   -</span><br><span class="line">          ✔️</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>同上, 此时<code>cw=4</code>, 从<code>b</code>元素开始轮询, <code>b</code>即符合条件, 立即返回, 所以第四次调度结果为<code>b</code></p>
<p>第五次请求, 期望结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -</span><br><span class="line">✔️  ✔️   ✔️</span><br><span class="line">          ✔️</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>此时<code>cw=4</code>, 从上次结束的下一个元素开始轮询, <code>c</code>即符合条件, 立即返回, 所以第五次调度结果为<code>c</code></p>
<p>第六次请求, 期望结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b    c    d</span><br><span class="line">-    -    -    -</span><br><span class="line">-    -    -    -</span><br><span class="line">✔️   -    -</span><br><span class="line">✔️  ✔️   ✔️</span><br><span class="line">          ✔️</span><br><span class="line">          ✔️</span><br></pre></td></tr></table></figure>

<p>此时<code>cw=4</code>, 从上次结束的下一个元素开始轮询, <code>d</code>不符合<code>&gt;=cw</code>条件, 本轮轮询结束, <code>cw-1</code>, 此时<code>cw=3</code>, 从<code>a</code>元素开始轮询, <code>a</code>即符合<code>&gt;=cw</code>条件, 所以第六次调度结果为<code>a</code></p>
<p>以此类推~ 当所有的元素都被调度过一次之后, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a    b   c    d</span><br><span class="line">✔️  ✔️  ✔️   ✔️</span><br><span class="line">✔️  ✔️  ✔️   ✔️</span><br><span class="line">✔️  ✔️  ✔️</span><br><span class="line">✔️  ✔️  ✔️</span><br><span class="line">         ✔️</span><br><span class="line">         ✔️</span><br></pre></td></tr></table></figure>

<p>需要将<code>cw</code>的重置为<code>最大权重值</code>, 以供后续请求重新调度</p>
<p>总结: 我们总结一下上面流程的关键点</p>
<ul>
<li>通过<code>i = (i + 1) mod n</code>轮询每个元素(这是上一篇轮询调度算法的核心)</li>
<li>需要取得所有元素中最大的权重值</li>
<li>需要定义一个cw(current weight)变量, 用来记录最新的”最大权重值”</li>
<li>每次所有的元素被轮询一次后, 都需要将<code>cw-1</code></li>
<li>当<code>cw-1</code>之后的值<code>&lt;=0</code>时, 意味着所有的元素按照权重之比, 都已经被调度过一次了, 此时需要将<code>cw</code>的值重置为<code>最大权重值</code>, 以供后续请求重新调度</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="step-0-前期准备"><a href="#step-0-前期准备" class="headerlink" title="step 0: 前期准备"></a>step 0: 前期准备</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义带权重属性的元素结构体</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元素集合类型</span></span><br><span class="line"><span class="keyword">type</span> Volumes []Volume</span><br><span class="line"><span class="comment">// GetMaxWeight 获取Slice中最大权重值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Volumes)</span> <span class="title">GetMaxWeight</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	maxWeight := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, volume := <span class="keyword">range</span> v &#123;</span><br><span class="line">		<span class="keyword">if</span> maxWeight &lt; volume.Weight &#123;</span><br><span class="line">			maxWeight = volume.Weight</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxWeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度索引</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// current weight 记录当前调度的权重值</span></span><br><span class="line"><span class="keyword">var</span> cw = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="step-1-首先实现轮询调度算法"><a href="#step-1-首先实现轮询调度算法" class="headerlink" title="step 1: 首先实现轮询调度算法"></a>step 1: 首先实现轮询调度算法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">	i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">	<span class="keyword">return</span> v[i].name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="step-2-每次所有的元素被轮询一次后将cw-1"><a href="#step-2-每次所有的元素被轮询一次后将cw-1" class="headerlink" title="step 2: 每次所有的元素被轮询一次后将cw-1"></a>step 2: 每次所有的元素被轮询一次后将cw-1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">	i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">	<span class="comment">// 当 (i + 1) mod n 的余数为0时, 有两种情况</span></span><br><span class="line">	<span class="comment">// 1. 首次被调用执行时</span></span><br><span class="line">	<span class="comment">// 2. 已经轮询完一整轮, 又回到起点时</span></span><br><span class="line">	<span class="keyword">if</span> i  == <span class="number">0</span> &#123;</span><br><span class="line">	   <span class="comment">// 每次轮询完一轮之后将cw-1</span></span><br><span class="line">	   cw = cw - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v[i].name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="step-3-cw-lt-0时将cw重置为最大权重值"><a href="#step-3-cw-lt-0时将cw重置为最大权重值" class="headerlink" title="step 3: cw&lt;=0时将cw重置为最大权重值"></a>step 3: cw&lt;=0时将cw重置为最大权重值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前算好最大权重值, 传进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">(maxWeight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">	i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">	<span class="comment">// 当 (i + 1) mod n 的余数为0时, 有两种情况</span></span><br><span class="line">	<span class="comment">// 1. 首次被调用执行时</span></span><br><span class="line">	<span class="comment">// 2. 已经轮询完一整轮, 又回到起点时</span></span><br><span class="line">	<span class="keyword">if</span> i  == <span class="number">0</span> &#123;</span><br><span class="line">	   <span class="comment">// 每次轮询完一轮之后将cw-1</span></span><br><span class="line">	   cw = cw - <span class="number">1</span></span><br><span class="line">	   <span class="comment">// cw 为负数或0的两种特殊情况</span></span><br><span class="line">	   <span class="comment">// 1. 当首次被调用时, cw的值为0, 所以执行 cw - 1 后, cw 的值为负数</span></span><br><span class="line">	   <span class="comment">// 2. 当所有元素都已经被调度过一次后, cw的值将递减至0</span></span><br><span class="line">	   <span class="comment">// 所以这里需要单独处理一下cw&lt;=0的情况</span></span><br><span class="line">	   <span class="keyword">if</span> cw &lt;= <span class="number">0</span> &#123;</span><br><span class="line">	       cw = maxWeight</span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> v[i].name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="step-4-当索引对应的元素权重值-gt-cw时返回"><a href="#step-4-当索引对应的元素权重值-gt-cw时返回" class="headerlink" title="step 4: 当索引对应的元素权重值&gt;=cw时返回"></a>step 4: 当索引对应的元素权重值&gt;=cw时返回</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 提前算好最大权重值, 传进去</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">(maxWeight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">	i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">	<span class="comment">// 当 (i + 1) mod n 的余数为0时, 有两种情况</span></span><br><span class="line">	<span class="comment">// 1. 首次被调用执行时</span></span><br><span class="line">	<span class="comment">// 2. 已经轮询完一整轮, 又回到起点时</span></span><br><span class="line">	<span class="keyword">if</span> i  == <span class="number">0</span> &#123;</span><br><span class="line">	   <span class="comment">// 每次轮询完一轮之后将cw-1</span></span><br><span class="line">	   cw = cw - <span class="number">1</span></span><br><span class="line">	   <span class="comment">// cw 为负数或0的两种特殊情况</span></span><br><span class="line">	   <span class="comment">// 1. 当首次被调用时, cw的值为0, 所以执行 cw - 1 后, cw 的值为负数</span></span><br><span class="line">	   <span class="comment">// 2. 当所有元素都已经被调度过一次后, cw的值将递减至0</span></span><br><span class="line">	   <span class="comment">// 所以这里需要单独处理一下cw&lt;=0的情况</span></span><br><span class="line">	   <span class="keyword">if</span> cw &lt;= <span class="number">0</span> &#123;</span><br><span class="line">	       cw = maxWeight</span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// return这里需要稍加修改, 只有元素的权重值&gt;=cw时才可以返回</span></span><br><span class="line">	<span class="keyword">if</span> v[i].Weight &gt;= cw &#123;</span><br><span class="line">	   <span class="keyword">return</span> v[i].name</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内部轮询"><a href="#内部轮询" class="headerlink" title="内部轮询"></a>内部轮询</h3><p>上面的return中, 定义了只有当元素的权重值&gt;=cw时才可以返回, 那么该条件如果不符合时, 需要在函数内继续轮询元素, 直至有元素的权重值符合条件为止</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">(maxWeight <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">		<span class="comment">// 当 (i + 1) mod n 的余数为0时, 有两种情况</span></span><br><span class="line">		<span class="comment">// 1. 首次被调用执行时</span></span><br><span class="line">		<span class="comment">// 2. 已经轮询完一整轮, 又回到起点时</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 每次轮询完一轮之后将cw-1</span></span><br><span class="line">			cw = cw - <span class="number">1</span></span><br><span class="line">			<span class="comment">// cw 为负数或0的两种特殊情况</span></span><br><span class="line">			<span class="comment">// 1. 当首次被调用时, cw的值为0, 所以执行 cw - 1 后, cw 的值为负数</span></span><br><span class="line">			<span class="comment">// 2. 当所有元素都已经被调度过一次后, cw的值将递减至0</span></span><br><span class="line">			<span class="comment">// 所以这里需要单独处理一下cw&lt;=0的情况</span></span><br><span class="line">			<span class="keyword">if</span> cw &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 将cw重置为最大权重值</span></span><br><span class="line">				cw = maxWeight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// return这里需要稍加修改, 只有元素的权重值&gt;=cw时才可以返回</span></span><br><span class="line">		<span class="keyword">if</span> v[i].Weight &gt;= cw &#123;</span><br><span class="line">			<span class="keyword">return</span> v[i].name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="优化项"><a href="#优化项" class="headerlink" title="优化项"></a>优化项</h3><ul>
<li>性能优化: 上面的代码实现中, 所有的元素每当轮询一轮后, cw都是写死了要<code>-1</code>, 其实这里可以可以稍加优化, 预先计算出所有元素权重值得最大公约数, 每次轮询完一轮后cw可以直接<code>-最大公约数(gcd)</code>, 这样可以减少内部循环的次数, 而且调度效果更为分散. (当然配置的权重最大公约数计算之后如果也是1, 则该优化与直接每次-1的循环次数相同)</li>
</ul>
<p><strong>求最大公约数算法可参考前面的文章</strong></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义带权重属性的元素结构体</span></span><br><span class="line"><span class="keyword">type</span> Volume <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name   <span class="keyword">string</span></span><br><span class="line">	Weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元素集合类型</span></span><br><span class="line"><span class="keyword">type</span> Volumes []Volume</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调度索引</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// current weight 记录当前调度的权重值</span></span><br><span class="line"><span class="keyword">var</span> cw = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Volumes)</span> <span class="title">Select</span><span class="params">(maxWeight, gcd <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 轮询调度算法 i = (i + 1) mod n</span></span><br><span class="line">		i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">		<span class="comment">// 当 (i + 1) mod n 的余数为0时, 有两种情况</span></span><br><span class="line">		<span class="comment">// 1. 首次被调用执行时</span></span><br><span class="line">		<span class="comment">// 2. 已经轮询完一整轮, 又回到起点时</span></span><br><span class="line">		<span class="keyword">if</span> i == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// 最新权重值 = 当前权重值 - 最大公约数</span></span><br><span class="line">			cw = cw - gcd</span><br><span class="line">			<span class="keyword">if</span> cw &lt;= <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// cw &lt;= 0 时, 有两种情况</span></span><br><span class="line">				<span class="comment">// 1. 首次被调用执行时, cw值初始化为0, 只要maxWeight最大权重数值在0以上, cw的最新值一定&lt;0</span></span><br><span class="line">				<span class="comment">// 2. 当所有的元素按照权重都被调度/选择一遍之后, cw的值一定为0</span></span><br><span class="line">				<span class="comment">// 此时需要将最大权重值(重新)赋值到cw</span></span><br><span class="line">				cw = maxWeight</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当索引值 &gt;= 最新权重值时, 返回名称</span></span><br><span class="line">		<span class="keyword">if</span> v[i].Weight &gt;= cw &#123;</span><br><span class="line">			<span class="keyword">return</span> v[i].Name</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetMaxWeight 获取Slice中最大权重值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Volumes)</span> <span class="title">GetMaxWeight</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	maxWeight := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, volume := <span class="keyword">range</span> v &#123;</span><br><span class="line">		<span class="keyword">if</span> maxWeight &lt; volume.Weight &#123;</span><br><span class="line">			maxWeight = volume.Weight</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> maxWeight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gcd</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Gcd(b, a%b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetGcd 获取Slice最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v Volumes)</span> <span class="title">GetGcd</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	g := v[<span class="number">0</span>].Weight</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(v)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		g = Gcd(g, v[i+<span class="number">1</span>].Weight)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	v1 := Volume&#123;</span><br><span class="line">		Name:   <span class="string">"a"</span>,</span><br><span class="line">		Weight: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v2 := Volume&#123;</span><br><span class="line">		Name:   <span class="string">"b"</span>,</span><br><span class="line">		Weight: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v3 := Volume&#123;</span><br><span class="line">		Name:   <span class="string">"c"</span>,</span><br><span class="line">		Weight: <span class="number">6</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v4 := Volume&#123;</span><br><span class="line">		Name:   <span class="string">"d"</span>,</span><br><span class="line">		Weight: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vo := Volumes&#123;</span><br><span class="line">		v1, v2, v3, v4,</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 获取元素集中的最大权重值</span></span><br><span class="line">	maxWeight := vo.GetMaxWeight()</span><br><span class="line">	<span class="comment">// 获取元素集中权重值的最大公约数</span></span><br><span class="line">	gcd := vo.GetGcd()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">18</span>; j++ &#123;</span><br><span class="line">		fmt.Println(j+<span class="number">1</span>, vo.Select(maxWeight, gcd))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 c</span><br><span class="line">2 a</span><br><span class="line">3 b</span><br><span class="line">4 c</span><br><span class="line">5 a</span><br><span class="line">6 b</span><br><span class="line">7 c</span><br><span class="line">8 d</span><br><span class="line">9 c</span><br><span class="line">10 a</span><br><span class="line">11 b</span><br><span class="line">12 c</span><br><span class="line">13 a</span><br><span class="line">14 b</span><br><span class="line">15 c</span><br><span class="line">16 d</span><br><span class="line">17 c</span><br><span class="line">18 a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>gcd</tag>
        <tag>wrr</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言实现轮询调度算法</title>
    <url>/2019/04/10/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>实现轮询调度算法(Round-Robin/rr)的原理是通过取模拿到数组/切片的下标, 从而提取出下一次即将调度的元素. 公式为<code>i = (i + 1) mod n</code><br><code>i</code>为数组下标, <code>n</code>为数组长度<br>轮询调度算法的优点是无状态, 均匀的将请求调度到后端的每个节点, 并不关心后端每个节点的实际差异</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明后端元素的数据结构</span></span><br><span class="line"><span class="keyword">type</span> volume <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	quota <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明数据类型存放元素的Slice</span></span><br><span class="line"><span class="keyword">type</span> volumes []volume</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并赋值索引下标</span></span><br><span class="line"><span class="keyword">var</span> i = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 轮询调度算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v volumes)</span> <span class="title">Select</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	i = (i + <span class="number">1</span>) % <span class="built_in">len</span>(v)</span><br><span class="line">	<span class="keyword">return</span> v[i].name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	v1 := volume&#123;</span><br><span class="line">		name:   <span class="string">"a"</span>,</span><br><span class="line">		quota: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v2 := volume&#123;</span><br><span class="line">		name:   <span class="string">"b"</span>,</span><br><span class="line">		quota: <span class="number">4</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v3 := volume&#123;</span><br><span class="line">		name:   <span class="string">"c"</span>,</span><br><span class="line">		quota: <span class="number">8</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	v4 := volume&#123;</span><br><span class="line">		name:   <span class="string">"d"</span>,</span><br><span class="line">		quota: <span class="number">2</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	vo := volumes&#123;</span><br><span class="line">		v1, v2, v3, v4,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">20</span>; j++ &#123;</span><br><span class="line">		fmt.Println(j+<span class="number">1</span>, vo.Select())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 a</span><br><span class="line">2 b</span><br><span class="line">3 c</span><br><span class="line">4 d</span><br><span class="line">5 a</span><br><span class="line">6 b</span><br><span class="line">7 c</span><br><span class="line">8 d</span><br><span class="line">9 a</span><br><span class="line">10 b</span><br><span class="line">11 c</span><br><span class="line">12 d</span><br><span class="line">13 a</span><br><span class="line">14 b</span><br><span class="line">15 c</span><br><span class="line">16 d</span><br><span class="line">17 a</span><br><span class="line">18 b</span><br><span class="line">19 c</span><br><span class="line">20 d</span><br></pre></td></tr></table></figure>

<p>通过运行结果可以看出, 每次<code>Select</code>请求都被均匀的调度到”后端的节点”. 考虑到后端节点可能存在的差异性, 下篇文章将介绍更为复杂的加权轮询调度算法</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>rr</tag>
        <tag>round-robin</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言实现最大公约数算法</title>
    <url>/2019/03/17/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最大公约数简介"><a href="#最大公约数简介" class="headerlink" title="最大公约数简介"></a>最大公约数简介</h2><p>最大公约数(GCD/Greatest Common Divisor)指几个整数中共有约数中最大的一个</p>
<h2 id="欧几里德算法"><a href="#欧几里德算法" class="headerlink" title="欧几里德算法"></a>欧几里德算法</h2><p>欧几里德算法又称辗转相除法, 该算法用于计算两个整数的最大公约数. 定理如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcd(a,b) &#x3D; gcd(b,a mod b)</span><br></pre></td></tr></table></figure>

<p>意思就是说: <code>a</code>和<code>b</code>的最大公约数 =  <code>b</code>和<code>a➗b的余数</code>的最大公约数</p>
<ul>
<li>当<code>a➗b的余数</code>为0时, 最大公约数为b</li>
<li>当<code>a➗b的余数</code>不为0时, 则将<code>a=b</code>, <code>b=a➗b的余数</code>, 递归运算, 直到余数为<code>0</code></li>
</ul>
<p>具体证明的过程在此不再赘述, 如有兴趣可以自行谷歌一下, 下面直接给出基于go语言的实现代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(gcd(<span class="number">5</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p>解析:</p>
<p><strong>第一次调用:</strong></p>
<p>调用<code>gcd(5, 10)</code>则<code>a=5, b=10</code>, 进入函数后判断<code>if b == 0</code>, 此时<code>b=10</code>, 判断条件为假, 递归调用<code>gcd(b, a % b)</code>, 此时实际值为 <code>gcd(10, 5 % 10)</code>, <code>5与10计算取余</code>商0, 余5, 则实际调用参数为<code>gcd(10, 5)</code> </p>
<p><strong>第二次调用:</strong><br>调用<code>gcd(10, 5)</code>则<code>a=10, b=5</code>, 进入函数后判断<code>if b == 0</code>, 此时<code>b=5</code>, 判断条件为假, 递归调用<code>gcd(b, a % b)</code>, 此时实际值为 <code>gcd(5, 10 % 5)</code>, <code>10与5计算取余</code>商2, 余0, 则实际调用参数为<code>gcd(5, 0)</code> </p>
<p><strong>第三次调用:</strong><br>调用<code>gcd(5, 0)</code>则<code>a=5, b=0</code>, 进入函数后判断<code>if b == 0</code>, 此时<code>b=0</code>, 判断条件为真, 直接返回<code>a</code> 此时<code>a</code>即为两个数的最大公约数</p>
<h2 id="多个数求最大公约数"><a href="#多个数求最大公约数" class="headerlink" title="多个数求最大公约数"></a>多个数求最大公约数</h2><p>实现思路: 先求出头两个数的最大公约数, 再拿计算出的最大公约数依次与后面所有的数求最大公约数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a,b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> gcd(b, a % b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetGcd</span><span class="params">(n []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 先取得Slice中的第一个数, 并假设第一个数为最大公约数</span></span><br><span class="line">	g := n[<span class="number">0</span>]</span><br><span class="line">	<span class="comment">// 依次与Slice中的每个数字求最大公约数</span></span><br><span class="line">	<span class="comment">// 这里i=1, 因为第0个数字已经取出并假设为最大公约数</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;<span class="built_in">len</span>(n)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		oldGcd := g</span><br><span class="line">		<span class="comment">// 使用两个数字比较的最大公约数函数进行计算, 得出当前两个数字的最大公约数</span></span><br><span class="line">		<span class="comment">// 循环开始后, 依次将当前最大公约数与后面的数字一一进行运算, 求最大公约数</span></span><br><span class="line">		g = gcd(g, n[i])</span><br><span class="line">		fmt.Printf(<span class="string">"第%d次运算, 当前最大公约数为%d, 与%d运算得出的新最大公约数为: %d \n"</span>, i, oldGcd, n[i], g)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> g</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	nums := []<span class="keyword">int</span>&#123;<span class="number">4</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">10</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">"运算结果: \n\t数列: %v 的最大公约数为: %d"</span>, nums, GetGcd(nums))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第1次运算, 当前最大公约数为4, 与4运算得出的新最大公约数为: 4 </span><br><span class="line">第2次运算, 当前最大公约数为4, 与6运算得出的新最大公约数为: 2 </span><br><span class="line">第3次运算, 当前最大公约数为2, 与2运算得出的新最大公约数为: 2 </span><br><span class="line">第4次运算, 当前最大公约数为2, 与8运算得出的新最大公约数为: 2 </span><br><span class="line">运算结果: </span><br><span class="line">        数列: [4 4 6 2 8 10] 的最大公约数为: 2</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>算法</category>
        <category>Go</category>
      </categories>
      <tags>
        <tag>gcd</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言巧用intstr来处理数字与字符类型</title>
    <url>/2019/03/06/go%E8%AF%AD%E8%A8%80%E5%B7%A7%E7%94%A8intstr%E6%9D%A5%E5%A4%84%E7%90%86%E6%95%B0%E5%AD%97%E4%B8%8E%E5%AD%97%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<p><code>intstr</code> 这个包是偶然在k8s client-go中发现的, 在编写<code>deployment</code>结构体定义时, <code>apiv1.Container</code>实例下<code>LivenessProbe</code>中用到的<code>Port</code>, 就是<code>intstr.IntOrString</code>. 特地看下来这个函数, 发现这个函数恰巧解决了一直困扰我的一个问题: 在<code>restful</code>接口中, 如果要求json格式<code>body</code>体内传递<code>port</code>端口参数, 那么<code>port</code>这个字段, 我应该在服务端定义成整型好呢, 还是字符串类型好呢, 一直很纠结~ 有了<code>intstr.IntOrString</code>再也不用为这事儿发愁了</p>
</blockquote>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以往我们接收<code>json</code>或<code>yaml</code>字符串要转成结构体时, 数据类型必须一一对应. 比如数据中的端口字段, 如果<code>json</code> 中传递是的整型, 则为以下样式 <code>{&quot;port&quot;: 8080}</code>; 如果传递的是字符串类型, 则为以下形式<code>{&quot;port&quot;: &quot;8080&quot;}</code></p>
<p>服务端接收到这些字符串后, 需要将数据与结构体中的字段一一绑定, 当然数据类型也必须一致. 如果在服务端定义了<code>port</code>字段为<code>int</code>, 但是<code>json</code>字符串传递过来的是<code>{&quot;port&quot;: &quot;8080&quot;}</code>, 则绑定数据时将会报错. 反之也一样, 数据类型必须一致.</p>
<p>我自己开发过得项目中, 很多接口的<code>body</code>体内都出现了端口字段, 有的时候定义为整型, 有的时候定义为字符串类型, api doc里也是有的写得整型, 有的写的字符串, 每次都纠结用什么类型好</p>
<p><code>intstr.IntOrString</code> 数据类型顾名思义, 该类型可以既可以接受整型, 也可以接受字符串类型. 再也不用纠结这种用整型和字符串类型都合适的字段到底用什么数据类型了</p>
<p><code>intstr.IntOrString</code> 不仅可以兼容接收整型或字符串类型, 而且可以通过其内置的函数, 在两个数据类型之间自由转换</p>
<h2 id="json-yaml串转结构体"><a href="#json-yaml串转结构体" class="headerlink" title="json/yaml串转结构体"></a>json/yaml串转结构体</h2><p>以下demo的场景为, 拿到<code>json/yaml</code>串, 转换成结构体的使用场景</p>
<h3 id="端口字段为整型"><a href="#端口字段为整型" class="headerlink" title="端口字段为整型"></a>端口字段为整型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/util/intstr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">	Port intstr.IntOrString <span class="string">`json:"port"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义json字符串, port字段的值设置为整型</span></span><br><span class="line">	jsonStr := <span class="string">`&#123;"name": "nginx", "host": "192.168.1.2", "port": 8080&#125;`</span></span><br><span class="line"></span><br><span class="line">	nginxService := &amp;service&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将json字符串的数据, 绑定到结构体实例中</span></span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), nginxService)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"提取数据类型: %T 实际数据类型(编号): %v 值: %#v \n"</span>, nginxService.Port.IntVal, nginxService.Port.Type, nginxService.Port.IntVal)</span><br><span class="line">	fmt.Printf(<span class="string">"提取数据类型: %T 实际数据类型(编号): %v 值: %#v \n"</span>, nginxService.Port.StrVal, nginxService.Port.Type, nginxService.Port.StrVal)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提取数据类型: int32 实际数据类型(编号): 0 值: 8080 </span><br><span class="line">提取数据类型: string 实际数据类型(编号): 0 值: &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>上面的例子中, json字符串中的端口字段为整型, 绑定到结构体的实例后, 通过<code>nginxService.Port.Type</code> 可以取得json串中实际传递的是哪种数据类型, 在本例中, 调用<code>nginxService.Port.Type</code>的结果是<code>0</code>, 通过查看源码得知, <code>0</code>表示json串中传递的数据是整型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 源码定义</span></span><br><span class="line"><span class="comment">// Type represents the stored type of IntOrString.</span></span><br><span class="line"><span class="keyword">type</span> Type <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Int    Type = <span class="literal">iota</span> <span class="comment">// The IntOrString holds an int.</span></span><br><span class="line">	String             <span class="comment">// The IntOrString holds a string.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在实际使用时, 可以先判断<code>nginxService.Port.Type</code>的结果是0, 还是1</p>
<ul>
<li>如果是0, 则取整型<code>nginxService.Port.IntVal</code></li>
<li>如果是1, 则取字符串类型<code>nginxService.Port.StrVal</code></li>
</ul>
<p>还有一种更直接的用法, 就是根据需要, 显式的类型转换</p>
<p>比如上面的例子中, json传递的端口值为整型, 但是服务端绑定到结构体之后, 当使用该端口时, 需要该端口值得数据类型为字符串类型, 你可以直接这样做:</p>
<p><code>fmt.Printf(&quot;%#v&quot;, nginxService.Port.String())</code></p>
<p>运行结果:</p>
<p><code>&quot;8080&quot;</code></p>
<p>可以看到, 整型的数据, 已经帮你转换成为字符串类型, 后期使用非常灵活, 可以随时提取两种数据类型的值</p>
<h3 id="端口为字符串类型"><a href="#端口为字符串类型" class="headerlink" title="端口为字符串类型"></a>端口为字符串类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/util/intstr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">	Port intstr.IntOrString <span class="string">`json:"port"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义json字符串, port字段的值设置为字符串类型</span></span><br><span class="line">	jsonStr := <span class="string">`&#123;"name": "nginx", "host": "192.168.1.2", "port": "8080""&#125;`</span></span><br><span class="line">	</span><br><span class="line">	nginxService := &amp;service&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将json字符串的数据, 绑定到结构体实例中</span></span><br><span class="line">	json.Unmarshal([]<span class="keyword">byte</span>(jsonStr), nginxService)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"提取数据类型: %T 实际数据类型(编号): %v 值: %#v \n"</span>, nginxService.Port.IntVal, nginxService.Port.Type, nginxService.Port.IntVal)</span><br><span class="line">	fmt.Printf(<span class="string">"提取数据类型: %T 实际数据类型(编号): %v 值: %#v \n"</span>, nginxService.Port.StrVal, nginxService.Port.Type, nginxService.Port.StrVal)</span><br><span class="line">	fmt.Printf(<span class="string">"值: %#v 实际数据类型: %T \t \n"</span>, nginxService.Port.String(), nginxService.Port.String())</span><br><span class="line">	fmt.Printf(<span class="string">"值: %#v 实际数据类型: %T \t \n"</span>, nginxService.Port.String(), nginxService.Port.IntValue())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">提取数据类型: int32 实际数据类型(编号): 1 值: 0 </span><br><span class="line">提取数据类型: string 实际数据类型(编号): 1 值: &quot;8080&quot; </span><br><span class="line">值: &quot;8080&quot; 实际数据类型: string          </span><br><span class="line">值: &quot;8080&quot; 实际数据类型: int</span><br></pre></td></tr></table></figure>

<h2 id="结构体转json-yaml"><a href="#结构体转json-yaml" class="headerlink" title="结构体转json/yaml"></a>结构体转json/yaml</h2><h3 id="数据类型-整型"><a href="#数据类型-整型" class="headerlink" title="数据类型: 整型"></a>数据类型: 整型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/util/intstr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">	Port intstr.IntOrString <span class="string">`json:"port"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	nginxService := service&#123;</span><br><span class="line">		Name: <span class="string">"nginx"</span>,</span><br><span class="line">		Host: <span class="string">"192.168.1.2"</span>,</span><br><span class="line">		Port: intstr.IntOrString&#123;</span><br><span class="line">			Type:   <span class="number">0</span>,    <span class="comment">// 这里设置为0, 意为数据类型为整型</span></span><br><span class="line">			IntVal: <span class="number">2222</span>,</span><br><span class="line">			StrVal: <span class="string">"1111"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jsonBytes, _ := json.Marshal(nginxService)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(jsonBytes))</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面<code>intstr.IntOrString.Type</code>的值设置为<code>0</code>, 运行结果: </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"nginx"</span>,<span class="attr">"host"</span>:<span class="string">"192.168.1.2"</span>,<span class="attr">"port"</span>:<span class="number">2222</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>intstr.IntOrString.Type</code>的值设置为<code>0</code>, 表示该结构体实例内的数据为整型, 故转json时, 按照<code>IntVal</code>中的值来生成字符串</p>
<p>*<em>注意: *</em> 如果没有显式为<code>intstr.IntOrString.Type</code>赋值, 则该值默认为0, 默认会取<code>IntVal</code>中的数据, 也就是说, 可以简写为以下形式</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">nginxService := service&#123;</span><br><span class="line">	Name: <span class="string">"nginx"</span>,</span><br><span class="line">	Host: <span class="string">"192.168.1.2"</span>,</span><br><span class="line">	Port: intstr.IntOrString&#123;IntVal: <span class="number">2222</span>&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型-字符串"><a href="#数据类型-字符串" class="headerlink" title="数据类型: 字符串"></a>数据类型: 字符串</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"encoding/json"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"k8s.io/apimachinery/pkg/util/intstr"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:"name"`</span></span><br><span class="line">	Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">	Port intstr.IntOrString <span class="string">`json:"port"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	</span><br><span class="line">	nginxService := service&#123;</span><br><span class="line">		Name: <span class="string">"nginx"</span>,</span><br><span class="line">		Host: <span class="string">"192.168.1.2"</span>,</span><br><span class="line">		Port: intstr.IntOrString&#123;</span><br><span class="line">			Type:   <span class="number">1</span>,    <span class="comment">// 这里设置为1, 意为数据类型为str</span></span><br><span class="line">			IntVal: <span class="number">2222</span>,</span><br><span class="line">			StrVal: <span class="string">"1111"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	jsonBytes, _ := json.Marshal(nginxService)</span><br><span class="line">	fmt.Println(<span class="keyword">string</span>(jsonBytes))</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面<code>intstr.IntOrString.Type</code>的值设置为<code>1</code>, 运行结果: </p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"nginx"</span>,<span class="attr">"host"</span>:<span class="string">"192.168.1.2"</span>,<span class="attr">"port"</span>:<span class="string">"1111"</span>&#125;</span><br></pre></td></tr></table></figure>

<p><code>intstr.IntOrString.Type</code>的值设置为<code>1</code>, 表示该结构体实例内的数据为字符串类型, 故转json时, 按照<code>StrVal</code>中的值来生成字符串</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>struct</tag>
        <tag>json</tag>
        <tag>intstr</tag>
        <tag>IntOrString</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言结构体多字段多因素排序</title>
    <url>/2019/03/04/go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E5%A4%9A%E5%AD%97%E6%AE%B5%E5%A4%9A%E5%9B%A0%E7%B4%A0%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>上篇结构体排序的文档介绍了如果依据多个字段进行单因素排序, 举例来说, 一个学生实例, 可以单独按照姓名排序, 可以单独按照年龄排序, 可以单独按照体重排序. 本篇文章介绍如果进行多因素排序, 也就是按照姓名排序, 当姓名相同时, 按照年龄排序…</p>
</blockquote>
<p>以官方文档的demo来做演示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据类型</span></span><br><span class="line"><span class="keyword">type</span> Change <span class="keyword">struct</span> &#123;</span><br><span class="line">	user     <span class="keyword">string</span></span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">	lines    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort接口方法之一(Less)</span></span><br><span class="line"><span class="keyword">type</span> lessFunc <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Change)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集类型, 与上一篇排序文章(多字段单独排序)比较, less字段的数据类型不再是 func(p1, p2 *Change) bool</span></span><br><span class="line"><span class="comment">// 而是 []func(p1, p2 *Change) bool 因为在第一个比较的值相等的情况下, 还要比较第二个值, 所以这里需要多个比较函数</span></span><br><span class="line"><span class="keyword">type</span> multiSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	changes []Change</span><br><span class="line">	less    []lessFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort 函数有两个作用</span></span><br><span class="line"><span class="comment">// 第一, 将参数(实际的数据集)赋值给ms对象</span></span><br><span class="line"><span class="comment">// 第二, 调用内置sort函数进行排序操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Sort</span><span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">	ms.changes = changes</span><br><span class="line">	sort.Sort(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderedBy 函数的作用是返回一个multiSorter实例, 并将所有的实际排序函数赋值给实例的less字段,</span></span><br><span class="line"><span class="comment">// 上面已经为multiSorter结构体定义了Sort方法, 所以该函数的返回值可以直接调用Sort方法进行排序</span></span><br><span class="line"><span class="comment">// 该函数中, 为multiSorter结构体中的less字段赋值, Sort方法中又将实际数据集传入, 赋值给multiSorter的changes字段</span></span><br><span class="line"><span class="comment">// 一个函数, 一个方法调用过后, multiSorter实例中两个字段就已经全部被正确赋值, 可以调用系统sort函数进行排序</span></span><br><span class="line"><span class="comment">// 该函数也可看作是一个工厂方法, 用来生成less字段已经被赋值的multiSorter实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedBy</span><span class="params">(less ...lessFunc)</span> *<span class="title">multiSorter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;multiSorter&#123;</span><br><span class="line">		less: less,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ms.changes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ms.changes[i], ms.changes[j] = ms.changes[j], ms.changes[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了后面编写简便, 这里将需要比较的两个元素赋值给两个单独的变量</span></span><br><span class="line">	p, q := &amp;ms.changes[i], &amp;ms.changes[j]</span><br><span class="line">	<span class="comment">// Try all but the last comparison.</span></span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 由于可能有多个需要排序的字段, 也就对应了多个less函数, 当第一个字段的值相等时,</span></span><br><span class="line">	<span class="comment">// 需要依次尝试比对后续其他字段的值得大小, 所以这里需要获取比较函数的长度, 以便遍历比较</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>(ms.less)<span class="number">-1</span>; k++ &#123;</span><br><span class="line">		<span class="comment">// 提取比较函数, 将函数赋值到新的变量中以便调用</span></span><br><span class="line">		less := ms.less[k]</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> less(p, q):</span><br><span class="line">			<span class="comment">// 如果 p &lt; q, 返回值为true, 不存在两个值相等需要比较后续字段的情况, 所以这里直接返回</span></span><br><span class="line">			<span class="comment">// 如果 p &gt; q, 返回值为false, 则调到下一个case中处理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> less(q, p):</span><br><span class="line">			<span class="comment">// 如果 p &gt; q, 返回值为false, 不存在两个值相等需要比较后续字段的情况, 所以这里直接返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果代码走到这里, 说明ms.less[k]函数比较后 p == q; 重新开始下一次循环, 更换到下一个比较函数处理</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果代码走到这里, 说明所有的比较函数执行过后, 所有比较的值都相等</span></span><br><span class="line">	<span class="comment">// 直接返回最后一次的比较结果数据即可</span></span><br><span class="line">	<span class="keyword">return</span> ms.less[k](p, q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changes = []Change&#123;</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"glenda"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"rsc"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"dmr"</span>, <span class="string">"C"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Smalltalk"</span>, <span class="number">80</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照姓名升序排列</span></span><br><span class="line">	user := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.user &lt; c2.user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照语言升序排列</span></span><br><span class="line">	language := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.language &lt; c2.language</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照行数升序排列</span></span><br><span class="line">	increasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.lines &lt; c2.lines</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//预定义排序函数: 按照行数降序排列</span></span><br><span class="line">	decreasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.lines &gt; c2.lines</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照姓名升序排列</span></span><br><span class="line">	OrderedBy(user).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照姓名升序排列, 姓名相同的按行数升序排列</span></span><br><span class="line">	OrderedBy(user, increasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&lt;lines:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按姓名升序排列, 姓名相同的按行数降序排列</span></span><br><span class="line">	OrderedBy(user, decreasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&gt;lines:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按语言升序排列, 语言相同按行数升序排列</span></span><br><span class="line">	OrderedBy(language, increasingLines).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines:\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按语言升序排列, 语言相同按行数升序排列, 行数也相同的, 按姓名升序排列</span></span><br><span class="line">	OrderedBy(language, increasingLines, user).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines,user:"</span>, changes)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By user:                 [&#123;dmr C 100&#125; &#123;glenda Go 200&#125; &#123;gri Go 100&#125; &#123;gri Smalltalk 80&#125; &#123;ken C 150&#125; &#123;ken Go 200&#125; &#123;r Go 100&#125; &#123;r C 150&#125; &#123;rsc Go 200&#125;]</span><br><span class="line">By user,&lt;lines:          [&#123;dmr C 100&#125; &#123;glenda Go 200&#125; &#123;gri Smalltalk 80&#125; &#123;gri Go 100&#125; &#123;ken C 150&#125; &#123;ken Go 200&#125; &#123;r Go 100&#125; &#123;r C 150&#125; &#123;rsc Go 200&#125;]</span><br><span class="line">By user,&gt;lines:          [&#123;dmr C 100&#125; &#123;glenda Go 200&#125; &#123;gri Go 100&#125; &#123;gri Smalltalk 80&#125; &#123;ken Go 200&#125; &#123;ken C 150&#125; &#123;r C 150&#125; &#123;r Go 100&#125; &#123;rsc Go 200&#125;]</span><br><span class="line">By language,&lt;lines:      [&#123;dmr C 100&#125; &#123;ken C 150&#125; &#123;r C 150&#125; &#123;r Go 100&#125; &#123;gri Go 100&#125; &#123;ken Go 200&#125; &#123;glenda Go 200&#125; &#123;rsc Go 200&#125; &#123;gri Smalltalk 80&#125;]</span><br><span class="line">By language,&lt;lines,user: [&#123;dmr C 100&#125; &#123;ken C 150&#125; &#123;r C 150&#125; &#123;gri Go 100&#125; &#123;r Go 100&#125; &#123;glenda Go 200&#125; &#123;ken Go 200&#125; &#123;rsc Go 200&#125; &#123;gri Smalltalk 80&#125;]</span><br></pre></td></tr></table></figure>

<p>与上一篇文章&lt;go语言结构体排序&gt;(简称A)中&lt;结构体多字段单独排序&gt;的代码区别 (本篇简称B):</p>
<p>A:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> By <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b By)</span> <span class="title">Sort</span> <span class="params">(students []student)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 生成数据集</span></span><br><span class="line">	ss := studentSorter&#123;</span><br><span class="line">		students: students,</span><br><span class="line">		by:       b,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对数据集进行排序</span></span><br><span class="line">	sort.Sort(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>B:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> multiSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	changes []Change</span><br><span class="line">	less    []lessFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据集类型中编写Sort排序方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Sort</span><span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">	ms.changes = changes</span><br><span class="line">	<span class="comment">// 对数据集进行排序</span></span><br><span class="line">	sort.Sort(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OrderedBy</span><span class="params">(less ...lessFunc)</span> *<span class="title">multiSorter</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;multiSorter&#123;</span><br><span class="line">		less: less,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A B两篇中各截取了部分代码, 均涉及两项操作</p>
<ul>
<li>生成数据集</li>
<li>排序</li>
</ul>
<p>A篇的操作为: 单独声明一个<code>By</code>数据类型, 为该数据类型编写方法, 方法中的第一步为生成数据集, 第二步为排序操作. 调用时<code>By(name).Sort(students)</code>中的<code>By(name)</code>是类型转换操作, 后续的<code>.Sort()</code>方法是调用<code>By</code>自己的<code>Sort</code>方法得到的排序结果</p>
<p>B篇的操作为: 单独编写一个<code>OrderBy</code>函数, 该<code>OrderBy</code>函数仅用于生成数据集并返回, 需要注意的是, 这里生成的数据集, 仅包含有排序函数, 不包含实际数据. 由于数据集类型本身自带<code>Sort</code>方法, 所以返回的数据可以直接调用<code>Sort</code>方法执行排序操作, 排序之前, 将参数中的数据填充到数据集中, 形成完整的数据集. 调用时<code>OrderedBy(user).Sort(changes)</code>中的<code>OrderedBy(user)</code>与A篇不同, 此处不是类型转换, 而是函数调用, 后续的<code>.Sort()</code>方法是由<code>OrderedBy()</code>函数返回的<code>multiSorter</code>对象, 调用<code>multiSorter</code>中的<code>Sort</code>方法得到的排序结果</p>
<p>A B两篇的排序方法略有差别, 但本质都是一样的, 核心操作都是<code>生成数据集</code>和<code>排序</code>, 只是B篇中, Less方法需要根据多因素排序, 略微复杂一些. 上面的例子是官方的demo, 当然我们也可以完全按照A篇的风格改写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除multiSorter数据类型中的Sort方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明OrderedBy数据类型</span></span><br><span class="line"><span class="keyword">type</span> OrderedBy []lessFunc</span><br><span class="line"><span class="comment">// 与A篇风格保持一致, 在OrderedBy的方法中进行数据集的完整生成和排序操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ob OrderedBy)</span> <span class="title">Sort</span> <span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 生成完整的数据集</span></span><br><span class="line">	ms := &amp;multiSorter&#123;</span><br><span class="line">		changes: changes,</span><br><span class="line">		less: ob,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	sort.Sort(ms)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样修改之后, 调用方式也发生了变更</p>
<p><code>OrderedBy()</code>是一个类型转换的操作, 根据上面的声明, 它只能转换<code>[]lessFunc</code>类型的数据, 所以需要先声明并赋值<code>[]lessFunc{}</code>对象, 然后才能交给<code>OrderedBy()</code>函数进行类型转换. 转换后其自身拥有<code>Sort</code>方法可供调用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   OrderedBy([]lessFunc&#123;user&#125;).Sort(changes)</span><br><span class="line">fmt.Println(<span class="string">"By user:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照姓名升序排列, 姓名相同的按行数升序排列</span></span><br><span class="line">OrderedBy([]lessFunc&#123;user, increasingLines&#125;).Sort(changes)</span><br><span class="line">fmt.Println(<span class="string">"By user,&lt;lines:\t\t"</span>, changes)</span><br></pre></td></tr></table></figure>

<p>以下是A篇风格的完整代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据类型</span></span><br><span class="line"><span class="keyword">type</span> Change <span class="keyword">struct</span> &#123;</span><br><span class="line">	user     <span class="keyword">string</span></span><br><span class="line">	language <span class="keyword">string</span></span><br><span class="line">	lines    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sort接口方法之一(Less)</span></span><br><span class="line"><span class="keyword">type</span> lessFunc <span class="function"><span class="keyword">func</span><span class="params">(p1, p2 *Change)</span> <span class="title">bool</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集类型, 与上一篇排序文章(多字段单独排序)比较, less字段的数据类型不再是 func(p1, p2 *Change) bool</span></span><br><span class="line"><span class="comment">// 而是 []func(p1, p2 *Change) bool 因为在第一个比较的值相等的情况下, 还要比较第二个值, 所以这里需要多个比较函数</span></span><br><span class="line"><span class="keyword">type</span> multiSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	changes []Change</span><br><span class="line">	less    []lessFunc</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> OrderedBy []lessFunc</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ob OrderedBy)</span> <span class="title">Sort</span> <span class="params">(changes []Change)</span></span> &#123;</span><br><span class="line">	ms := &amp;multiSorter&#123;</span><br><span class="line">		changes: changes,</span><br><span class="line">		less: ob,</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Sort(ms)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ms.changes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Swap 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ms.changes[i], ms.changes[j] = ms.changes[j], ms.changes[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Less 为sort接口方法之一</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *multiSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 为了后面编写简便, 这里将需要比较的两个元素赋值给两个单独的变量</span></span><br><span class="line">	p, q := &amp;ms.changes[i], &amp;ms.changes[j]</span><br><span class="line">	<span class="comment">// Try all but the last comparison.</span></span><br><span class="line">	<span class="keyword">var</span> k <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 由于可能有多个需要排序的字段, 也就对应了多个less函数, 当第一个字段的值相等时,</span></span><br><span class="line">	<span class="comment">// 需要依次尝试比对后续其他字段的值得大小, 所以这里需要获取比较函数的长度, 以便遍历比较</span></span><br><span class="line">	<span class="keyword">for</span> k = <span class="number">0</span>; k &lt; <span class="built_in">len</span>(ms.less)<span class="number">-1</span>; k++ &#123;</span><br><span class="line">		<span class="comment">// 提取比较函数, 将函数赋值到新的变量中以便调用</span></span><br><span class="line">		less := ms.less[k]</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> less(p, q):</span><br><span class="line">			<span class="comment">// 如果 p &lt; q, 返回值为true, 不存在两个值相等需要比较后续字段的情况, 所以这里直接返回</span></span><br><span class="line">			<span class="comment">// 如果 p &gt; q, 返回值为false, 则调到下一个case中处理</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		<span class="keyword">case</span> less(q, p):</span><br><span class="line">			<span class="comment">// 如果 p &gt; q, 返回值为false, 不存在两个值相等需要比较后续字段的情况, 所以这里直接返回</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 如果代码走到这里, 说明ms.less[k]函数比较后 p == q; 重新开始下一次循环, 更换到下一个比较函数处理</span></span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 如果代码走到这里, 说明所有的比较函数执行过后, 所有比较的值都相等</span></span><br><span class="line">	<span class="comment">// 直接返回最后一次的比较结果数据即可</span></span><br><span class="line">	<span class="keyword">return</span> ms.less[k](p, q)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> changes = []Change&#123;</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"glenda"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"rsc"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"Go"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"ken"</span>, <span class="string">"Go"</span>, <span class="number">200</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"dmr"</span>, <span class="string">"C"</span>, <span class="number">100</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"r"</span>, <span class="string">"C"</span>, <span class="number">150</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"gri"</span>, <span class="string">"Smalltalk"</span>, <span class="number">80</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照姓名升序排列</span></span><br><span class="line">	user := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.user &lt; c2.user</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照语言升序排列</span></span><br><span class="line">	language := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.language &lt; c2.language</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预定义排序函数: 按照行数升序排列</span></span><br><span class="line">	increasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.lines &lt; c2.lines</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//预定义排序函数: 按照行数降序排列</span></span><br><span class="line">	decreasingLines := <span class="function"><span class="keyword">func</span><span class="params">(c1, c2 *Change)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c1.lines &gt; c2.lines</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照姓名升序排列</span></span><br><span class="line">	OrderedBy([]lessFunc&#123;user&#125;).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按照姓名升序排列, 姓名相同的按行数升序排列</span></span><br><span class="line">	OrderedBy([]lessFunc&#123;user, increasingLines&#125;).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&lt;lines:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按姓名升序排列, 姓名相同的按行数降序排列</span></span><br><span class="line">	OrderedBy([]lessFunc&#123;user, decreasingLines&#125;).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By user,&gt;lines:\t\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按语言升序排列, 语言相同按行数升序排列</span></span><br><span class="line">	OrderedBy([]lessFunc&#123;language, increasingLines&#125;).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines:\t"</span>, changes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 按语言升序排列, 语言相同按行数升序排列, 行数也相同的, 按姓名升序排列</span></span><br><span class="line">	OrderedBy([]lessFunc&#123;language, increasingLines, user&#125;).Sort(changes)</span><br><span class="line">	fmt.Println(<span class="string">"By language,&lt;lines,user:"</span>, changes)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言结构体排序</title>
    <url>/2019/02/22/go%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>有了go语言中的排序接口, 可以很容易的对结构体的任意一个字段进行排序, 具体以哪个字段排序, 定义在该结构体Slice的<code>Less</code>方法中. 一个结构体的Slice仅可以实现一次<code>sort</code>接口, 如果一个结构体中有多个字段需要单独进行排序, 最粗鲁的办法只能是定义多个Slice类型, 为每个类型都编写不同的<code>Less</code>方法</p>
</blockquote>
<p>约定关键字:</p>
<p>多字段单独排序: 一个结构体中, 需要有多个字段作为依据, 单独进行排序, 单个字段排序时不受其他字段排序策略的影响<br>多字段多因素排序: 一个结构体中, 对第一个字段排序时, 如果该字段的数值相等, 按其他字段再次进行排序操作(例如: 按年龄进行排序, 年龄相同的按体重排序)</p>
<h2 id="结构体单字段排序"><a href="#结构体单字段排序" class="headerlink" title="结构体单字段排序"></a>结构体单字段排序</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素类型</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">uint</span></span><br><span class="line">	weight <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集类型</span></span><br><span class="line"><span class="keyword">type</span> students []student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s students)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s students)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s students)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].age &lt; s[j].age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集</span></span><br><span class="line"><span class="keyword">var</span> ss = students&#123;</span><br><span class="line">	&#123;<span class="string">"d"</span>, <span class="number">7</span>, <span class="number">28</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">40</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"b"</span>, <span class="number">8</span>, <span class="number">35</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"a"</span>, <span class="number">5</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sort.Sort(ss)</span><br><span class="line">	fmt.Println(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;c 3 40&#125; &#123;a 5 30&#125; &#123;d 7 28&#125; &#123;b 8 35&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="结构体多字段单独排序"><a href="#结构体多字段单独排序" class="headerlink" title="结构体多字段单独排序"></a>结构体多字段单独排序</h2><p>多字段需要排序的, 最粗鲁的办法是为每一个需要排序的字段单独声明一个数据集类型, 然后在每个数据集类型中实现其对应的<code>Less</code>方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">uint</span></span><br><span class="line">	weight <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsSortByName []student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByName)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByName)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByName)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].name &lt; s[j].name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsSortByAge []student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByAge)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByAge)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByAge)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].age &lt; s[j].age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> studentsSortByWeight []student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByWeight)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByWeight)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentsSortByWeight)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i].weight &lt; s[j].weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据集</span></span><br><span class="line"><span class="keyword">var</span> ss = []student&#123;</span><br><span class="line">	&#123;<span class="string">"d"</span>, <span class="number">7</span>, <span class="number">28</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">40</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"b"</span>, <span class="number">8</span>, <span class="number">35</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"a"</span>, <span class="number">5</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sort.Sort(studentsSortByName(ss))</span><br><span class="line">	fmt.Println(ss)</span><br><span class="line"></span><br><span class="line">	sort.Sort(studentsSortByAge(ss))</span><br><span class="line">	fmt.Println(ss)</span><br><span class="line"></span><br><span class="line">	sort.Sort(studentsSortByWeight(ss))</span><br><span class="line">	fmt.Println(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;a 5 30&#125; &#123;b 8 35&#125; &#123;c 3 40&#125; &#123;d 7 28&#125;]  &#x2F;&#x2F; 按姓名排序</span><br><span class="line">[&#123;c 3 40&#125; &#123;a 5 30&#125; &#123;d 7 28&#125; &#123;b 8 35&#125;]  &#x2F;&#x2F; 按年龄排序</span><br><span class="line">[&#123;d 7 28&#125; &#123;a 5 30&#125; &#123;b 8 35&#125; &#123;c 3 40&#125;]  &#x2F;&#x2F; 按体重排序</span><br></pre></td></tr></table></figure>

<p>这个排序的办法的劣势是需要写很多重复代码, 通过这个例子也可以看出, 按不动字段排序实际只是<code>Less</code>方法的实现不同</p>
<h2 id="结构体多字段单独排序-推荐"><a href="#结构体多字段单独排序-推荐" class="headerlink" title="结构体多字段单独排序(推荐)"></a>结构体多字段单独排序(推荐)</h2><p>这里介绍一个更优雅的方式, 解决上面多字段排序需要编写<code>n * 3</code>方法的问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义元素类型</span></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">uint</span></span><br><span class="line">	weight <span class="keyword">float32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义数据集类型</span></span><br><span class="line"><span class="comment">// 在单字段排序中, 数据集类型仅仅是元素类型的Slice, 但是在此方法中, 元素类型的Slice作为数据集类型的一个字段出现</span></span><br><span class="line"><span class="comment">// 由于需要对多个字段排序, 且每个字段实现的`Less`方法不同, 这里将排序方法(函数)作为数据集类型的一个字段</span></span><br><span class="line"><span class="keyword">type</span> studentSorter <span class="keyword">struct</span> &#123;</span><br><span class="line">	students []student  <span class="comment">// 具体的数据集, 待排序的数据都会存放在这里</span></span><br><span class="line">	by <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span>  // 排序函数, 排序的依据, 具体排序的策略, 会被放置在这里</span></span><br><span class="line">	<span class="comment">// 可以明显的看出, by 函数的入参与返回 与 `Less` 函数的入参与返回是一致的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据集类型之上实现排序接口的Len方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentSorter)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s.students)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据集类型之上实现交换元素的Swap方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentSorter)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s.students[i], s.students[j] = s.students[j], s.students[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在数据集类型之上实现比较元素大小的Less方法</span></span><br><span class="line"><span class="comment">// 由于多个字段需要排序, 这里的返回值, 返回的是一个排序函数</span></span><br><span class="line"><span class="comment">// 上面的数据集结构体中, 已经明确定义了一个 by 字段, 该字段用来保存具体的排序函数</span></span><br><span class="line"><span class="comment">// 所以这里的返回值并没有直接指定数据的大小的比较方法, 而是调用了保存在数据集by字段中的函数去处理</span></span><br><span class="line"><span class="comment">// 可以简单的理解为, 将比较数据大小的操作委托给了 数据集类型.by 的函数, 具体的排序策略也就交给了 by 对应的具体函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s studentSorter)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.by(s.students[i], s.students[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并赋值测试数据集</span></span><br><span class="line"><span class="keyword">var</span> students = []student&#123;</span><br><span class="line">	&#123;<span class="string">"d"</span>, <span class="number">7</span>, <span class="number">28</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">40</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"b"</span>, <span class="number">8</span>, <span class="number">35</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"a"</span>, <span class="number">5</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用工厂方法定义排序数据集, 并进行排序</span></span><br><span class="line"><span class="comment">// 上面的 students 仅仅是实际的待排序数据, 仅仅是数据集对象中的 studentSorter.students 字段的值</span></span><br><span class="line"><span class="comment">// 工厂方法就是用来根据实际的排序策略, 为数据集对象中的by赋值, 生成一个完整的数据集, 从而完成排序操作</span></span><br><span class="line"><span class="keyword">type</span> By <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b By)</span> <span class="title">Sort</span> <span class="params">(students []student)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 生成数据集</span></span><br><span class="line">	ss := studentSorter&#123;</span><br><span class="line">		students: students,</span><br><span class="line">		by:       b,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 对数据集进行排序</span></span><br><span class="line">	sort.Sort(ss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预定义排序策略函数, 这些函数都实现了sort接口中的less方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先定义的排序函数: 按照姓名排序</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.name &lt; j.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先定义的排序函数: 按照年龄排序</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.age &lt; j.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预先定义的排序函数: 按照体重排序</span></span><br><span class="line"><span class="keyword">var</span> weight = <span class="function"><span class="keyword">func</span><span class="params">(i, j student)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> i.weight &lt; j.weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	By(name).Sort(students)</span><br><span class="line">	fmt.Println(<span class="string">"By name:"</span>, students)</span><br><span class="line"></span><br><span class="line">	By(age).Sort(students)</span><br><span class="line">	fmt.Println(<span class="string">"By age:"</span>, students)</span><br><span class="line"></span><br><span class="line">	By(weight).Sort(students)</span><br><span class="line">	fmt.Println(<span class="string">"By weight:"</span>, students)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">By name: [&#123;a 5 30&#125; &#123;b 8 35&#125; &#123;c 3 40&#125; &#123;d 7 28&#125;]</span><br><span class="line">By age: [&#123;c 3 40&#125; &#123;a 5 30&#125; &#123;d 7 28&#125; &#123;b 8 35&#125;]</span><br><span class="line">By weight: [&#123;d 7 28&#125; &#123;a 5 30&#125; &#123;b 8 35&#125; &#123;c 3 40&#125;]</span><br></pre></td></tr></table></figure>

<p>这个多字段单独排序的方法, 省去了需要重复编写<code>Len()``Swap()</code>方法的麻烦, 也是<code>sort</code>包官方推荐的多字段排序案例</p>
<h2 id="结构体多字段单独排序2-推荐"><a href="#结构体多字段单独排序2-推荐" class="headerlink" title="结构体多字段单独排序2(推荐)"></a>结构体多字段单独排序2(推荐)</h2><p>官方文档中还介绍了另一种排序方式, 通过Go语言独特的组合特性来实现sort接口的三个方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"sort"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">	name   <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	weight <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> students []student</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s students)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s students)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByName <span class="keyword">struct</span> &#123;</span><br><span class="line">	students</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByName)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.students[i].name &lt; s.students[j].name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ByWeight <span class="keyword">struct</span> &#123;</span><br><span class="line">	students</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s ByWeight)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s.students[i].weight &lt; s.students[j].weight</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ss = []student&#123;</span><br><span class="line">	&#123;<span class="string">"d"</span>, <span class="number">7</span>, <span class="number">28</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"c"</span>, <span class="number">3</span>, <span class="number">40</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"b"</span>, <span class="number">8</span>, <span class="number">35</span>&#125;,</span><br><span class="line">	&#123;<span class="string">"a"</span>, <span class="number">5</span>, <span class="number">30</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sort.Sort(ByWeight&#123;ss&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"Organs by weight: "</span>, ss)</span><br><span class="line"></span><br><span class="line">	sort.Sort(ByName&#123;ss&#125;)</span><br><span class="line">	fmt.Println(<span class="string">"Organs by name: "</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<hr>
<ul>
<li>参考文档: <a href="https://golang.org/pkg/sort" target="_blank" rel="noopener">https://golang.org/pkg/sort</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>struct</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言sort排序基本用法</title>
    <url>/2019/02/08/go%E8%AF%AD%E8%A8%80sort%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>go语言中预置了<code>[]int</code> <code>[]float64</code> <code>[]String</code>三种数据类型的排序函数, 如果需要对其他数据类型进行排序, 需要自己实现<code>sort interface</code></p>
</blockquote>
<h2 id="内置数据类型排序"><a href="#内置数据类型排序" class="headerlink" title="内置数据类型排序"></a>内置数据类型排序</h2><h3 id="int-类型排序"><a href="#int-类型排序" class="headerlink" title="[]int 类型排序"></a>[]int 类型排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"------------ Int Slice ------------"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 待排序的数据</span></span><br><span class="line">	is := []<span class="keyword">int</span>&#123;<span class="number">19</span>, <span class="number">26</span>, <span class="number">3</span>, <span class="number">78</span>, <span class="number">56</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"排序前的Int Slice"</span>, is)</span><br><span class="line">	fmt.Println(<span class="string">"Int Slice是否已经按升序排序"</span>, sort.IntsAreSorted(is))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用内置的排序函数进行排序</span></span><br><span class="line">	sort.Ints(is)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 排序后</span></span><br><span class="line">	fmt.Println(<span class="string">"排序后的Int Slice"</span>, is)</span><br><span class="line">	fmt.Println(<span class="string">"Int Slice是否已经按升序排序"</span>, sort.IntsAreSorted(is))</span><br><span class="line">	sort.Sort(sort.Reverse(sort.IntSlice(is)))</span><br><span class="line">	fmt.Println(<span class="string">"逆序排列(降序)后的Int Slice"</span>, is)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------ Int Slice ------------</span><br><span class="line">排序前的Int Slice [19 26 3 78 56]</span><br><span class="line">Int Slice是否已经按升序排序 false</span><br><span class="line">排序后的Int Slice [3 19 26 56 78]</span><br><span class="line">Int Slice是否已经按升序排序 true</span><br><span class="line">逆序排列(降序)后的Int Slice [78 56 26 19 3]</span><br></pre></td></tr></table></figure>

<h3 id="float64-类型排序"><a href="#float64-类型排序" class="headerlink" title="[]float64 类型排序"></a>[]float64 类型排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"------------ Float64 Slice ------------"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 待排序数据</span></span><br><span class="line">	f64s := []<span class="keyword">float64</span>&#123;<span class="number">98.5</span>, <span class="number">53.2</span>, <span class="number">78.5</span>, <span class="number">12.78</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"排序前的Float64 Slice"</span>, f64s)</span><br><span class="line">	fmt.Println(<span class="string">"Float64 Slice是否已经按升序排序"</span>, sort.Float64sAreSorted(f64s))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用内置的排序函数进行排序</span></span><br><span class="line">	sort.Float64s(f64s)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 排序后</span></span><br><span class="line">	fmt.Println(<span class="string">"排序后的Float64 Slice"</span>, f64s)</span><br><span class="line">	fmt.Println(<span class="string">"Float64 Slice是否已经按升序排序"</span>, sort.Float64sAreSorted(f64s))</span><br><span class="line">	sort.Sort(sort.Reverse(sort.Float64Slice(f64s)))</span><br><span class="line">	fmt.Println(<span class="string">"逆序排列(降序)后的Float64 Slice"</span>, f64s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------ Float64 Slice ------------</span><br><span class="line">排序前的Float64 Slice [98.5 53.2 78.5 12.78]</span><br><span class="line">Float64 Slice是否已经按升序排序 false</span><br><span class="line">排序后的Float64 Slice [12.78 53.2 78.5 98.5]</span><br><span class="line">Float64 Slice是否已经按升序排序 true</span><br><span class="line">逆序排列(降序)后的Float64 Slice [98.5 78.5 53.2 12.78]</span><br></pre></td></tr></table></figure>

<h3 id="string-类型排序"><a href="#string-类型排序" class="headerlink" title="[]string 类型排序"></a>[]string 类型排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"------------ String Slice ------------"</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 待排序数据</span></span><br><span class="line">	ss := []<span class="keyword">string</span>&#123;<span class="string">"watermelon"</span>, <span class="string">"apple"</span>, <span class="string">"strawberry"</span>, <span class="string">"orange"</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"排序前的String Slice"</span>, ss)</span><br><span class="line">	fmt.Println(<span class="string">"String Slice是否已经按升序排序"</span>, sort.StringsAreSorted(ss))</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用内置的排序函数进行排序</span></span><br><span class="line">	sort.Strings(ss)</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 排序后</span></span><br><span class="line">	fmt.Println(<span class="string">"排序后的String Slice"</span>, ss)</span><br><span class="line">	fmt.Println(<span class="string">"String Slice是否已经按升序排序"</span>, sort.StringsAreSorted(ss))</span><br><span class="line">	sort.Sort(sort.Reverse(sort.StringSlice(ss)))</span><br><span class="line">	fmt.Println(<span class="string">"逆序排列(降序)后的String Slice"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------ String Slice ------------</span><br><span class="line">排序前的String Slice [watermelon apple strawberry orange]</span><br><span class="line">String Slice是否已经按升序排序 false</span><br><span class="line">排序后的String Slice [apple orange strawberry watermelon]</span><br><span class="line">String Slice是否已经按升序排序 true</span><br><span class="line">逆序排列(降序)后的String Slice [watermelon strawberry orange apple]</span><br></pre></td></tr></table></figure>

<h2 id="其他数据类型排序"><a href="#其他数据类型排序" class="headerlink" title="其他数据类型排序"></a>其他数据类型排序</h2><p><code>int8</code> <code>int16</code> <code>int32</code> <code>int64</code> <code>float32</code> 虽然也是常用的数据类型, 但是这些数据类型需要自己实现排序接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A type, typically a collection, that satisfies sort.Interface can be</span></span><br><span class="line"><span class="comment">// sorted by the routines in this package. The methods require that the</span></span><br><span class="line"><span class="comment">// elements of the collection be enumerated by an integer index.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Len is the number of elements in the collection.</span></span><br><span class="line">	Len() <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// Less reports whether the element with</span></span><br><span class="line">	<span class="comment">// index i should sort before the element with index j.</span></span><br><span class="line">	Less(i, j <span class="keyword">int</span>) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// Swap swaps the elements with indexes i and j.</span></span><br><span class="line">	Swap(i, j <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int32-类型排序"><a href="#int32-类型排序" class="headerlink" title="[]int32 类型排序"></a>[]int32 类型排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Int32Slice []<span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int32Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int32Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Int32Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    i32s := Int32Slice&#123;<span class="number">19</span>, <span class="number">26</span>, <span class="number">3</span>, <span class="number">78</span>, <span class="number">56</span>&#125;</span><br><span class="line">	sort.Sort(i32s)</span><br><span class="line">	fmt.Println(i32s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[3 19 26 56 78]</span><br></pre></td></tr></table></figure>

<h3 id="float32-类型排序"><a href="#float32-类型排序" class="headerlink" title="[]float32 类型排序"></a>[]float32 类型排序</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Float32Slice []<span class="keyword">float32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Float32Slice)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Float32Slice)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s Float32Slice)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[i] &lt; s[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f32s := Float32Slice&#123;<span class="number">98.5</span>, <span class="number">53.2</span>, <span class="number">78.5</span>, <span class="number">12.78</span>&#125;</span><br><span class="line">	sort.Sort(f32s)</span><br><span class="line">	fmt.Println(f32s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[12.78 53.2 78.5 98.5]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>gin添加自定义中间件</title>
    <url>/2019/01/27/gin%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="中间件的作用"><a href="#中间件的作用" class="headerlink" title="中间件的作用"></a>中间件的作用</h2><p>在我们熟悉的一个完整的<code>http</code>请求中, 客户端先向服务端发送的<code>http request</code>, 服务端接收到<code>request</code>之后, 根据实际需要, 给客户端返回<code>http response</code></p>
<p>站在服务端的角度来看, 就是接收<code>request</code>, 响应<code>response</code>, 而中间件的作用, 就在<code>request</code>与<code>response</code>之间</p>
<ul>
<li>收到<code>request</code>之后, 在<code>request</code>还未到达处理的<code>handler</code>之前, 可以通过中间件做出一系列的数据处理, 可以看做是前置校验或过滤</li>
<li><code>request</code>到达<code>handler</code>之后, 中间件还可以根据需要对响应体做统一的数据处理</li>
</ul>
<p><strong>gin内置的中间件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func BasicAuth(accounts Accounts) HandlerFunc</span><br><span class="line">func BasicAuthForRealm(accounts Accounts, realm string) HandlerFunc</span><br><span class="line">func Bind(val interface&#123;&#125;) HandlerFunc </span><br><span class="line">func ErrorLogger() HandlerFunc </span><br><span class="line">func ErrorLoggerT(typ ErrorType) HandlerFunc</span><br><span class="line">func Logger() HandlerFunc</span><br><span class="line">func LoggerWithConfig(conf LoggerConfig) HandlerFunc</span><br><span class="line">func LoggerWithFormatter(f LogFormatter) HandlerFunc</span><br><span class="line">func LoggerWithWriter(out io.Writer, notlogged ...string) HandlerFunc</span><br><span class="line">func Recovery() HandlerFunc</span><br><span class="line">func RecoveryWithWriter(out io.Writer) HandlerFunc</span><br><span class="line">func WrapF(f http.HandlerFunc) HandlerFunc </span><br><span class="line">func WrapH(h http.Handler) HandlerFunc</span><br></pre></td></tr></table></figure>

<h2 id="中间件的作用域"><a href="#中间件的作用域" class="headerlink" title="中间件的作用域"></a>中间件的作用域</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.Default()  <span class="comment">//默认带Logger(), Recovery()这两个内置中间件</span></span><br><span class="line">r := gin.New()      <span class="comment">//不带任何中间件</span></span><br></pre></td></tr></table></figure>

<h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.New()  <span class="comment">//不带任何中间件</span></span><br><span class="line">r.Use(gin.Recovery()) <span class="comment">//在全局使用内置中间件</span></span><br></pre></td></tr></table></figure>

<h3 id="组作用域"><a href="#组作用域" class="headerlink" title="组作用域"></a>组作用域</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.New()</span><br><span class="line">vm := r.Group(<span class="string">"vm"</span>, gin.Logger(),gin.Recovery())</span><br><span class="line">&#123;</span><br><span class="line">    vm.GET(<span class="string">"cpu"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">    vm.GET(<span class="string">"ram"</span>, <span class="function"><span class="keyword">func</span><span class="params">(context *gin.Context)</span></span> &#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单个路由作用域"><a href="#单个路由作用域" class="headerlink" title="单个路由作用域"></a>单个路由作用域</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := gin.New()</span><br><span class="line">router.GET(<span class="string">"/healthcheck"</span>,gin.Recovery(),gin.Logger(),<span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    c.JSON(<span class="number">200</span>,<span class="string">"ok"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="自定义中间件"><a href="#自定义中间件" class="headerlink" title="自定义中间件"></a>自定义中间件</h2><ul>
<li>第一种形式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义中间件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware1</span><span class="params">(c *gin.Context)</span></span>&#123;</span><br><span class="line">    <span class="comment">//中间件逻辑 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用中间件</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.Use(middleware1)</span><br></pre></td></tr></table></figure>

<p>注意: <code>r.Use()</code>中的中间件函数没有<code>()</code></p>
<ul>
<li>第二种形式</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">    <span class="comment">//自定义逻辑</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">//中间件逻辑</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用中间件</span></span><br><span class="line">r := gin.Default()</span><br><span class="line">r.Use(middleware2())</span><br></pre></td></tr></table></figure>

<h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p><code>gin.Context</code>中提供了<code>Set``Get</code>函数用来存储和提取数据</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中间件set数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Set(<span class="string">"name"</span>, c.Request.Header.Get(<span class="string">"name"</span>))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//handler中get数据</span></span><br><span class="line">r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"name"</span>: c.Get(<span class="string">"name"</span>),</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"ok"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Set</code>方法存储的值为<code>interface{}</code>类型, <code>Get</code>方法中提供以下常用的数据类型方便提取数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (c *Context) GetBool(key string) (b bool)</span><br><span class="line">func (c *Context) GetDuration(key string) (d time.Duration)</span><br><span class="line">func (c *Context) GetFloat64(key string) (f64 float64)</span><br><span class="line">func (c *Context) GetInt(key string) (i int)</span><br><span class="line">func (c *Context) GetInt64(key string) (i64 int64)</span><br><span class="line">func (c *Context) GetString(key string) (s string)</span><br><span class="line">func (c *Context) GetStringMap(key string) (sm map[string]interface&#123;&#125;)</span><br><span class="line">func (c *Context) GetStringMapString(key string) (sms map[string]string)</span><br><span class="line">func (c *Context) GetStringMapStringSlice(key string) (smss map[string][]string)</span><br><span class="line">func (c *Context) GetStringSlice(key string) (ss []string)</span><br><span class="line">func (c *Context) GetTime(key string) (t time.Time)</span><br></pre></td></tr></table></figure>

<h3 id="拦截request请求"><a href="#拦截request请求" class="headerlink" title="拦截request请求"></a>拦截request请求</h3><ul>
<li>为<code>request</code>请求添加<code>header</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中间件</span></span><br><span class="line"><span class="comment">//在请求到达`handler`之前, 为`request`请求添加`header`</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware1</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	c.Request.Header.Set(<span class="string">"abc"</span>, <span class="string">"123"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//handler</span></span><br><span class="line">r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">//获取请求头</span></span><br><span class="line">		fmt.Println(c.Request.Header.Get(<span class="string">"abc"</span>))</span><br><span class="line">		c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line">			<span class="string">"message"</span>: <span class="string">"ok"</span>,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>为<code>response</code>响应添加<code>header</code></li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">	   <span class="comment">//在接收request请求时就设置好response时要添加的header</span></span><br><span class="line">		c.Header(<span class="string">"xyz"</span>, <span class="string">"789"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="追加handler处理后的动作"><a href="#追加handler处理后的动作" class="headerlink" title="追加handler处理后的动作"></a>追加handler处理后的动作</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.Next()</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"handler ok\n"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line">	</span><br><span class="line">	r.Use(middleware2())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"handler ok\n"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.Run(<span class="string">":8080"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:8080/</span><br><span class="line">handler ok</span><br><span class="line">middleware ok</span><br></pre></td></tr></table></figure>

<h3 id="c-Next"><a href="#c-Next" class="headerlink" title="c.Next()"></a>c.Next()</h3><p><code>c.Next()</code>函数允许我们在中间件中控制调度的逻辑, 每执行到<code>c.Next()</code>一次, 执行权就会别切换到其他中间件或<code>handler</code>函数中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware1</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware1"</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware2"</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware3</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware3"</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware3"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.Use(middleware1(), middleware2(), middleware3())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start handler"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"ok\n"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"end handler"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.Run(<span class="string">":8080"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure>

<p>访问:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:8080  <span class="comment"># 返回结果: ok</span></span><br></pre></td></tr></table></figure>

<p>程序日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start middleware1</span><br><span class="line">start middleware2</span><br><span class="line">start middleware3</span><br><span class="line">start handler</span><br><span class="line">end handler</span><br><span class="line">end middleware3</span><br><span class="line">end middleware2</span><br><span class="line">end middleware1</span><br></pre></td></tr></table></figure>

<p>依据注册中间件的顺序, 每次遇到<code>c.Next()</code>函数就跳转到下一个中间件执行, 直到跳转到最后一个中间件, 再次遇到<code>c.Next()</code>的时候, 就跳到<code>handler</code>主函数中运行, 当<code>handler</code>执行完毕后, 再逐层向上返回, 继续执行<code>c.Next()</code>之后的代码</p>
<h3 id="c-Abord"><a href="#c-Abord" class="headerlink" title="c.Abord()"></a>c.Abord()</h3><p><code>c.Abord()</code>用来终止<code>request</code>, 阻止其到达<code>handler</code> 一般情况下用在鉴权与认证的中间件中</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware1</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware1"</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware1"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跟上面c.Next()的代码相比, 只是middleware2中的Next换成了Abort</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware2</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware2"</span>)</span><br><span class="line">		c.Abort()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware2"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware3</span><span class="params">()</span> <span class="title">gin</span>.<span class="title">HandlerFunc</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start middleware3"</span>)</span><br><span class="line">		c.Next()</span><br><span class="line">		fmt.Println(<span class="string">"end middleware3"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	r := gin.Default()</span><br><span class="line"></span><br><span class="line">	r.Use(middleware1(), middleware2(), middleware3())</span><br><span class="line"></span><br><span class="line">	r.GET(<span class="string">"/"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"start handler"</span>)</span><br><span class="line">		c.String(<span class="number">200</span>, <span class="string">"ok\n"</span>)</span><br><span class="line">		fmt.Println(<span class="string">"end handler"</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := r.Run(<span class="string">":8080"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问后, 程序日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start middleware1</span><br><span class="line">start middleware2</span><br><span class="line">end middleware2</span><br><span class="line">end middleware1</span><br></pre></td></tr></table></figure>

<p>可以看到即使在<code>middleware2</code>中执行了<code>c.Abord()</code>, <code>c.Abord()</code>后面的代码依然被完整的执行, 并且返回到了<code>middleware1</code>跳转的地方, 继续执行了后续代码</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>gin</tag>
        <tag>middleware</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言中的常量与枚举</title>
    <url>/2018/12/26/go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%9E%9A%E4%B8%BE/</url>
    <content><![CDATA[<blockquote>
<p>go语言中使用关键字<code>const</code>来定义常量. 最近在项目开发中, 在ovirt-go sdk中经常会用到其内置常量, 善用go的常量, 不仅可以增加代码的可读性, 还能省去一些”小麻烦”~</p>
</blockquote>
<h2 id="常量的定义"><a href="#常量的定义" class="headerlink" title="常量的定义"></a>常量的定义</h2><p>常量可以单个定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HttpStatusOk = <span class="number">200</span></span><br><span class="line"><span class="keyword">const</span> HttpStatusNotFound = <span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>也可以批量定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	VMStatusDown        = <span class="string">"down"</span></span><br><span class="line">	VMStatusUp          = <span class="string">"up"</span></span><br><span class="line">	VMStatusImageLocked = <span class="string">"image_locked"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="常量的优势"><a href="#常量的优势" class="headerlink" title="常量的优势"></a>常量的优势</h2><p>go在代码编译前, 变量的类型就已经确定, 并不可更改. 但是常量就比较特殊, 常量在代码编译的时候, 类型才会确定下来, 下面来举个例子🌰</p>
<ul>
<li>变量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">int32</span></span><br><span class="line">	</span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(a + b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"># command-line-arguments</span><br><span class="line">./demo.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">16</span>: invalid operation: a + b (mismatched types <span class="keyword">int16</span> and <span class="keyword">int32</span>)</span><br></pre></td></tr></table></figure>

<p>很显然, 代码在编译前, <code>a,b</code> 两个变量的数据类型已经确定, 两个不同的数据类型, 是不予许进行运算操作的.</p>
<ul>
<li>常量</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> aa = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"type: %v\n"</span>, reflect.TypeOf(aa))</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line">	b = <span class="number">2.1</span></span><br><span class="line">	fmt.Println(a + b)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int32</span></span><br><span class="line">	c = <span class="number">3</span></span><br><span class="line">	fmt.Println(a + c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span>: <span class="keyword">int</span></span><br><span class="line"><span class="number">3.1</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>如果其中一个数字是常量的情况, 运行结果就大不相同了, 可以看到, 该程序可以正常执行, 而且拿到了正确的结果. 这是因为, 虽然<code>b</code>变量在编译前确定了数据类型, 但是<code>a</code>常量并没有, <code>a</code>常量是在编译时才根据实际情况确定了数据类型, 常量会根据编译时的运算, 自动执行类型转换</p>
<p>上面的例子中, 声明了<code>a</code>常量, 同时声明了<code>aa</code>变量, 赋值均为<code>1</code>, 通过编译执行, 得到<code>aa</code>的数据类型自动判定为<code>int</code>, 而<code>a</code>常量却可以先和<code>float32</code>类型的<code>b</code>运算, 而后又和<code>int32</code>类型的<code>c</code>进行运算. 说明<code>a</code>常量的数据类型, 是在编译时, 根据实际的运算需要而变化的</p>
<p>所以, 项目中的一些数字可以多多定义为常量, 这样在运算的时候, 也可以减少显式的数据类型转换</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>go 语言中没有专门的枚举关键字, 是通过常量<code>const</code>关键字实现的, 枚举的标志性关键字为<code>iota</code>. </p>
<p><code>iota</code>关键字在<code>const</code>关键字出现的时候, 被重置为<code>0</code>, 且<code>const</code>中每新增一行常量的声明, <code>iota</code>计数器将被<code>+1</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span></span><br><span class="line">	b</span><br><span class="line">	c</span><br><span class="line">	d</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="同行声明的情况"><a href="#同行声明的情况" class="headerlink" title="同行声明的情况"></a>同行声明的情况</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a, b = <span class="literal">iota</span>, <span class="literal">iota</span></span><br><span class="line">	c, d = <span class="literal">iota</span>, <span class="literal">iota</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>注意: <code>iota</code> 仅会在新增的常量声明中才会自增, 声明在同一行的常量, <code>iota</code>的值是相同的</p>
<h3 id="跨行声明的情况"><a href="#跨行声明的情况" class="headerlink" title="跨行声明的情况"></a>跨行声明的情况</h3><ul>
<li>情况1</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span></span><br><span class="line">	b = <span class="number">1024</span></span><br><span class="line">	c</span><br><span class="line">	d</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1024</span><br><span class="line">1024</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<p><code>const</code>批量声明的特点, 如果后面的常量没有显式赋值, 则它们的值等于上一个显式赋值的值</p>
<ul>
<li>情况2</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="literal">iota</span></span><br><span class="line">	b = <span class="number">1024</span></span><br><span class="line">	c = <span class="literal">iota</span></span><br><span class="line">	d</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1024</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>由于<code>iota</code>的特点, 每新增一行<code>const</code>的定义, 计数器就会自增1, 所以即使中间显式赋值了一些常量, 依然不会影响<code>iota</code>的自增</p>
<h3 id="枚举的应用"><a href="#枚举的应用" class="headerlink" title="枚举的应用"></a>枚举的应用</h3><h4 id="自定义自增大小"><a href="#自定义自增大小" class="headerlink" title="自定义自增大小"></a>自定义自增大小</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	_ = <span class="literal">iota</span>      <span class="comment">// 0</span></span><br><span class="line">	a = <span class="literal">iota</span> * <span class="number">2</span>  <span class="comment">// 1 * 2</span></span><br><span class="line">	b             <span class="comment">// 2 * 2</span></span><br><span class="line">	c             <span class="comment">// 3 * 2</span></span><br><span class="line">	d             <span class="comment">// 4 * 2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">	fmt.Println(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h4 id="数据单位运算"><a href="#数据单位运算" class="headerlink" title="数据单位运算"></a>数据单位运算</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">// 1 &lt;&lt; (10 * 0)</span></span><br><span class="line">	kb</span><br><span class="line">	mb</span><br><span class="line">	gb</span><br><span class="line">	tb</span><br><span class="line">	pb</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(kb)</span><br><span class="line">	fmt.Println(mb)</span><br><span class="line">	fmt.Println(gb)</span><br><span class="line">	fmt.Println(tb)</span><br><span class="line">	fmt.Println(pb)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1024</span><br><span class="line">1048576</span><br><span class="line">1073741824</span><br><span class="line">1099511627776</span><br><span class="line">1125899906842624</span><br></pre></td></tr></table></figure>

<ul>
<li>b = 1 &lt;&lt; (10 * iota)</li>
</ul>
<p>第一个常量: iota被初始化为0, 则表达式为<code>1 &lt;&lt; (10 * 0)</code> –&gt; <code>1 &lt;&lt; 0</code>, 1 向左位移0位, 还是<code>1</code></p>
<ul>
<li>kb</li>
</ul>
<p>第二个常量: 没有显式赋值, 该值应该等于上一行显式赋值的”值”, 由于上一行显式赋值的值为一个表达式, 所以将该表达式完整的继承下来. 且该行为新增常量声明, 所以<code>iota</code>变量自增1, 则赋值表达式实际为: <code>1 &lt;&lt; (10 * 1)</code> –&gt; <code>1 &lt;&lt; 10</code>, 1 向左位移 10 位, 二进制表示为<code>10000000000</code>(2的10次方), 转换为10进制为<code>1024</code>, 所以 kb 经过表达式运算后, 值为: <code>1024</code></p>
<ul>
<li>mb</li>
</ul>
<p>第三个常量: 同理, iota 自增 1 后, 赋值表达式实际为: <code>1 &lt;&lt; (10 * 2)</code> —&gt; <code>1 &lt;&lt; 20</code>, 1 向左位移 20 位, 二进制表示为<code>100000000000000000000</code>(2的20次方), 转换为10进制为<code>1048576</code></p>
<ul>
<li>以此类推</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>overlayfs与overlayfs2下编译镜像的区别</title>
    <url>/2018/12/11/overlayfs%E4%B8%8Eoverlayfs2%E4%B8%8B%E7%BC%96%E8%AF%91%E9%95%9C%E5%83%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>近期编译镜像时, 出现了镜像体积骤增的情况, 排查后, 发现本质原因居然是由于升级了存储引擎导致的问题, overlayfs 与 overlayfs2 存储引擎实现多层联合文件系统的原理不同, 最终导致了我们遇到的这个问题</p>
</blockquote>
<h2 id="昨日重现"><a href="#昨日重现" class="headerlink" title="昨日重现"></a>昨日重现</h2><p>镜像引用关系图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">centos:7.5</span><br><span class="line">   ↑</span><br><span class="line">base-os (创建了一系列目录, 安装了部分命令工具)</span><br><span class="line">   ↑</span><br><span class="line">open-jdk (下载并部署 jdk 至 &#x2F;opt&#x2F;soft 下, 335MB)</span><br><span class="line">   ↑</span><br><span class="line">application (应用部署, 且执行了 chown user:user &#x2F;opt)</span><br></pre></td></tr></table></figure>

<p>引发镜像体积增大的原因: 在 open-jdk dockerfile 中, 将 jdk 文件拷贝至 <code>/opt/soft</code> 下, 该文件夹体积为335MB; 在 application dockerfile 中, 执行了一行 shell 命令 <code>chown -R /opt</code></p>
<p>从编译镜像最佳实践来说, <code>chown -R /opt</code> 这样的匹配命令是不应该出现的, 其实体积增大的道理也很简单, 由于更改了整个<code>/opt</code>目录的属性, 导致<code>/opt</code>目录下的所有文件被重新拷贝到 application 镜像层中, 也就造成了 335MB 空间的浪费, 体积至少也无端增大了 335MB. 但问题是, 之前在 overlayfs 存储引擎下编译镜像, 却一直相安无事, 所有镜像版本都迭代了很多次, 没有出现上面预期的335MB 的空间浪费. 造成这样的问题, 是由于 overlayfs 和 overlayfs2 在实现多层联合文件系统的原理不同.</p>
<h2 id="overlayfs-vs-overlayfs2"><a href="#overlayfs-vs-overlayfs2" class="headerlink" title="overlayfs vs overlayfs2"></a>overlayfs vs overlayfs2</h2><blockquote>
<p>overlayfs将单个Linux主机上的两个目录分层并将它们呈现为单个目录. 这些目录称为图层, 统一过程称为联合装载. overlayfs将下部目录称为lowerdir上部目录upperdir. 统一视图通过自己的目录公开merged.<br>虽然overlay驱动程序只能使用一个较低的overlayfs层, 因此需要硬链接来实现多层图像, 但该overlay2驱动程序本身最多支持128个较低的overlayfs层. 此功能为和层相关的Docker命令（如docker build）提供更好的性能docker commit，并且在后备文件系统上占用更少的inode    —-引用自<a href="https://cloud.tencent.com/developer/section/1091813" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1091813</a></p>
</blockquote>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>简单来说, 之前在 application 层执行 <code>chown</code> 一个335MB文件夹之所有没有引发空间浪费问题, 完全是由于使用 overlayfs 的硬链接特性造成的. </p>
<p>之后改为 overlayfs2 存储引擎后, 层与层之间不再使用硬链接形式引用, 所以根据标准情况下镜像层之间的增删改原理推断, application 镜像层至少浪费了 335MB 的空间.(由于 chown 操作导致整个/opt目录文件被拷贝至 application 层)</p>
<p><code>chown</code> 是个很神奇的命令, 它只修改文件的 metadata 属性, 这完美的切中了 overlayfs 与 overlayfs2 最本质的区别.</p>
<h2 id="科普硬链接"><a href="#科普硬链接" class="headerlink" title="科普硬链接"></a>科普硬链接</h2><p>简单来说, 硬链接是有着相同 inode 号仅文件名不同的文件, 因此硬链接存在以下几点特性: </p>
<ul>
<li>文件有相同的 inode 及 data block</li>
<li>只能对已存在的文件进行创建</li>
<li>不能交叉文件系统进行硬链接的创建</li>
<li>不能对目录进行创建，只可对文件创建</li>
<li>删除一个硬链接文件并不影响其他有相同 inode 号的文件</li>
</ul>
<p>由于 overlayfs 的硬链接引用的原理, chown 只更改 metadata 数据, 而 metadata 是作用在 inode 节点上的, 一个硬链接文件的属性被修改, 同步的, 所有指向这个 inode 节点的文件的属性都会变化. 也就是说, overlayfs 通过硬链接将文件挂载到新的镜像层之后, 对里面已存在的文件做 chown 操作, 意味着底层(只读层)的文件属性也会被修改, docker 就会认为这个操作没有引发任何文件的变化, 所以就不会再拷贝那335MB 的文件. 而 overlayfs2 的每层都是独立的, 即使文件属性的变化, 也会导致整个文件被拷贝, 所以在 overlayfs2 下, 会产生335MB 的空间浪费</p>
<hr>
<p>参考文档:</p>
<ul>
<li><a href="https://cloud.tencent.com/developer/section/1091813" target="_blank" rel="noopener">https://cloud.tencent.com/developer/section/1091813</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>image</tag>
        <tag>overlay</tag>
        <tag>overlay2</tag>
        <tag>overlayfs</tag>
        <tag>overlayfs2</tag>
        <tag>build</tag>
        <tag>镜像编译</tag>
        <tag>硬链接</tag>
      </tags>
  </entry>
  <entry>
    <title>记录K8s 1.10.x TLS Bootstrap Bug一枚</title>
    <url>/2018/12/11/%E8%AE%B0%E5%BD%95K8s-1-10-x-TLS-Bootstrap-Bug%E4%B8%80%E6%9E%9A/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OS-Release: CentOS7</span><br><span class="line">kernel: 4.4-LTS</span><br><span class="line">kubernetes version: 1.10.9</span><br><span class="line">kubelet 与 kube-apiserver 通信方式: TLS Bootstrap</span><br></pre></td></tr></table></figure>

<h2 id="问题复现"><a href="#问题复现" class="headerlink" title="问题复现"></a>问题复现</h2><p>集群基于<code>Bear Token</code>方式的 TLS Bootstrap 进行通信, 且使用 kubelet 客户端证书过期轮换的特性</p>
<p>根据 1.10.x 版本的官方文档介绍, 配置使用此特性, 这里具体列出 kubelet 上的相关配置</p>
<ul>
<li>在 kubelet 的启动参数中传入<code>--rotate-certificates</code> 此参数意为声明开启证书轮换机制, 为即将过期的客户端节点颁发新的证书文件</li>
<li>在 kubelet 参数配置模板文件中添加如下配置, 该配置默认开启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">featureGates:</span><br><span class="line">  RotateKubeletClientCertificate: true</span><br></pre></td></tr></table></figure>

<h3 id="创建集群角色绑定"><a href="#创建集群角色绑定" class="headerlink" title="创建集群角色绑定"></a>创建集群角色绑定</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create clusterrolebinding kubelet-bootstrap \</span><br><span class="line"> --clusterrole=system:node-bootstrapper \</span><br><span class="line"> --group=system:bootstrappers</span><br></pre></td></tr></table></figure>

<h3 id="为节点创建-Bootstrap-Token"><a href="#为节点创建-Bootstrap-Token" class="headerlink" title="为节点创建 Bootstrap Token"></a>为节点创建 Bootstrap Token</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TOKEN=`kubeadm token create \</span><br><span class="line">--description kubelet-bootstrap-token \</span><br><span class="line">--groups system:bootstrappers:node6752 \</span><br><span class="line">--kubeconfig ~/.kube/config`</span><br></pre></td></tr></table></figure>

<h3 id="为节点创建-Bootstrap-kubeconfig"><a href="#为节点创建-Bootstrap-kubeconfig" class="headerlink" title="为节点创建 Bootstrap kubeconfig"></a>为节点创建 Bootstrap kubeconfig</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config <span class="built_in">set</span>-cluster kubernetes \</span><br><span class="line">--certificate-authority=/opt/soft/k8s/pki/ca/ca.crt \</span><br><span class="line">--embed-certs=<span class="literal">true</span> \</span><br><span class="line">--server=https://k8smaster:6443 \</span><br><span class="line">--kubeconfig=kubelet-bootstrap-node6752.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config <span class="built_in">set</span>-credentials kubelet-bootstrap \</span><br><span class="line">--token=<span class="variable">$TOKEN</span> \</span><br><span class="line">--kubeconfig=kubelet-bootstrap-node6752.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config <span class="built_in">set</span>-context default \</span><br><span class="line">--cluster=kubernetes \</span><br><span class="line">--user=kubelet-bootstrap \</span><br><span class="line">--kubeconfig=kubelet-bootstrap-node6752.kubeconfig</span><br><span class="line"></span><br><span class="line">kubectl config use-context default --kubeconfig=kubelet-bootstrap-node6752.kubeconfig</span><br></pre></td></tr></table></figure>

<p>将<code>kubelet-bootstrap-node6752.kubeconfig</code> Bootstrap kubeconfig 文件分发给 kubelet 客户端</p>
<h3 id="在kubelet客户端指定配置文件"><a href="#在kubelet客户端指定配置文件" class="headerlink" title="在kubelet客户端指定配置文件"></a>在kubelet客户端指定配置文件</h3><ul>
<li>–bootstrap-kubeconfig=”/path/to/bootstrap/kubeconfig”</li>
<li>–kubeconfig=kubelet.kubeconfig</li>
</ul>
<p>注意: 这里指定的<code>--kubeconfig</code>文件并不存在, 当 kubelet 完成认证, 拿到下发的证书后, 证书会存放到<code>--cert-dir</code>指定的文件夹, 然后根据实际证书来创建 kubeconfig 文件并写入到<code>--kubeconfig</code>指定的路径</p>
<h2 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h2><p>在启动 kubelet 服务后, 在 master 端可以看到 csr 请求, 手动审批</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve node-csr-32YapU7hg6hB_87Hyus7NkD6a7-ew8sX2qP09ikjUh6</span><br></pre></td></tr></table></figure>

<p>审批后, 在 kubelet 客户端指定的证书目录下, 你可以看到如下文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubelet-client.crt (由 kube-controller-manager 颁发的客户端证书)</span><br><span class="line">kubelet-client.key (本地自动创建的客户端秘钥)</span><br><span class="line">kubelet.crt (kubelet本地自签名服务端证书)</span><br><span class="line">kubelet.key (本地自动创建的服务端秘钥)</span><br></pre></td></tr></table></figure>

<p>在 kubelet 指定的 <code>--kubeconfig</code> 文件, 也被写入了对应的内容, 问题就出现在了这里</p>
<p>其中<code>users.user.client-certificate</code>和<code>users.user.client-key</code>的配置中, 分别指定了<code>kubelet-client.crt</code>和<code>kubelet-client.key</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">default-auth</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate:</span> <span class="string">/path/pki/kubelet-client.crt</span></span><br><span class="line">    <span class="attr">client-key:</span> <span class="string">/path/pki/kubelet-client.key</span></span><br></pre></td></tr></table></figure>

<p>但问题是, 当<code>kubelet-client.crt</code>证书过期后, 由 Kubernetes 证书轮换特性续期的新证书, 却是以软连接的方式提供的, 而且, 软连接的名字和<code>kubeconfig</code>中配置的证书名字不一致. 以下是 kube-controller-manager 颁发的新证书形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubelet-client-2018-12-11-11-14-18.pem</span><br><span class="line">kubelet-client-current.pem -&gt; &#x2F;path&#x2F;pki&#x2F;kubelet-client-2018-12-11-11-14-18.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>新的证书只有一个文件, 格式为 pem. 该文件中既包含了证书内容也包含了 key 的内容</li>
<li>新证书的实际文件名为: <code>kubelet-client-DATE.pem</code></li>
<li>新证书的软连接为: <code>kubelet-client-current.pem</code></li>
</ul>
<p>可以看出, 当证书续期之后, 新证书的引用路径(文件名)与最开始自动创建的 kubeconfig 文件中指定的证书文件不一致. 这个问题将导致原有证书过期且 kubelet 重启后, 将无法再与 apiserver 通信, apiserver 端也将标记该节点为<code>NotReady</code></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="解决方案1-手动修改-kubeconfig-文件"><a href="#解决方案1-手动修改-kubeconfig-文件" class="headerlink" title="解决方案1: 手动修改 kubeconfig 文件"></a>解决方案1: 手动修改 kubeconfig 文件</h3><p>执行以下操作:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat kubelet-client.crt kubelet.key &gt; kubelet-origin.pem</span><br><span class="line">ln -s kubelet-origin.pem /path/to/pki/kubelet-client-current.pem</span><br><span class="line">sed -i <span class="string">'s/kubelet-client.crt/kubelet-client-current.pem/g'</span> /path/to/kubelet.kubeconfig</span><br><span class="line">sed -i <span class="string">'s/kubelet-client.key/kubelet-client-current.pem/g'</span> /path/to/kubelet.kubeconfig</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure>

<p>原理就是在证书续期之前就手动构造证书续期之后的结构, 这样在证书续期后, 就可以无缝使用新证书了</p>
<h3 id="解决方案2-升级集群版本"><a href="#解决方案2-升级集群版本" class="headerlink" title="解决方案2: 升级集群版本"></a>解决方案2: 升级集群版本</h3><p>通过查看官方文档, 在<code>1.11.0</code>版本中, 该问题得到了修复, 你也可以通过升级集群版本来解决这个问题</p>
<p>注意, 集群升级后, 原有的证书都还是继续使用的, 所以升级并解决不了原来的问题, 除非你将节点删除后, 重新使用 BearToken 的方式重新申请加入集群</p>
<hr>
<p>参考文档:</p>
<ul>
<li>1.13版本 TLS Bootstrap 官方文档: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping/</a></li>
<li>1.10版本 TLS Bootstrap 官方文档: <a href="https://github.com/kubernetes/website/blob/release-1.10/content/en/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping.md" target="_blank" rel="noopener">https://github.com/kubernetes/website/blob/release-1.10/content/en/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping.md</a></li>
<li>1.11版本Changelog: <a href="https://github.com/kubernetes/kubernetes/blob/8c0542dcf126222481390cd0606e3b7f43830a64/CHANGELOG-1.11.md" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/8c0542dcf126222481390cd0606e3b7f43830a64/CHANGELOG-1.11.md</a></li>
<li>修复该 BUG 的 PR: <a href="https://github.com/kubernetes/kubernetes/pull/62152" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/pull/62152</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubelet</tag>
        <tag>k8s</tag>
        <tag>TLS Bootstrap</tag>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd-journald的SIGPIPE信号BUG</title>
    <url>/2018/11/22/systemd-journald%E7%9A%84SIGPIPE%E4%BF%A1%E5%8F%B7BUG/</url>
    <content><![CDATA[<blockquote>
<p>在重启<code>systemd-journald</code>后, 意外的发现, 本台服务器上的其他由 systemd 托管的部分服务, 却意外被 stop 掉了, 由于大部分服务的 unit 文件中都配置了 Restart 规则为 on-failure. 所以如果是异常的退出, 这些服务应该会重启才对. 很明显, 这些服务是被”正常”关闭的.</p>
</blockquote>
<p>在查看被 stop 的应用状态时, 发现了以下线索</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl status kube-apiserver</span><br><span class="line">......</span><br><span class="line">Active: inactive (dead) since Thu 2018-11-22 13:53:46 CST; 25min ago</span><br><span class="line">Main PID: 90457 (code=killed, signal=PIPE)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>code=killed, signal=PIPE</code> 这些信息告诉我们, 这个进程是被<code>SIGPIPE</code>信号关闭的. 在网上查阅资料时, 发现 github 中大量的项目 issue 下都有相关的问题. 而问题的矛头都指向了<code>systemd-journald</code>这个服务的重启事件!</p>
<p>问题的原因在于: <code>systemd-journald</code>这个服务重启的时候, 会给所有的进程发送<code>SIGPIPE</code>信号, 而在默认的 systemd 定义中, <code>SIGPIPE</code> 信号属于正常退出的范围. 所以即使 unit 文件配置了<code>Restart on-failure</code>也不会被重启</p>
<p>该问题是 systemd 的已知 BUG 之一. 规避该问题的方式有很多种, 其中以下这种方式并没有生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ systemctl show kube-apiserver | grep PIPE</span><br><span class="line">IgnoreSIGPIPE&#x3D;yes</span><br></pre></td></tr></table></figure>
<p>默认情况下, <code>IgnoreSIGPIPE=yes</code>是配置好的, 理论上会忽略掉接收到的<code>SIGPIPE</code>信号, 但实际情况表明, 并没有被忽略</p>
<p>解决方案:</p>
<ul>
<li>在 systemd 的 unit 文件中的 <code>Restart</code> 策略设置为 <code>Always</code>, 这样即使是正常的关闭, 也会重启服务</li>
<li>在 systemd 的 unit 文件中配置 <code>RestartForceExitStatus=SIGPIPE</code> 指定收到这个信号时, 强制重启服务</li>
</ul>
<p>坏消息:</p>
<p><code>RestartForceExitStatus</code> 的配置在 systemd 215中才被加入, 对于使用之前版本的情况来说, 并没有什么帮助, 可能<code>Always</code>是唯一的选择</p>
<hr>
<p>病友:</p>
<ul>
<li><a href="https://github.com/influxdata/influxdb/issues/7040" target="_blank" rel="noopener">https://github.com/influxdata/influxdb/issues/7040</a></li>
<li><a href="https://github.com/syncthing/syncthing/issues/2350" target="_blank" rel="noopener">https://github.com/syncthing/syncthing/issues/2350</a></li>
<li><a href="https://github.com/moby/moby/issues/7087" target="_blank" rel="noopener">https://github.com/moby/moby/issues/7087</a></li>
<li><a href="https://github.com/systemd/systemd/issues/6620" target="_blank" rel="noopener">https://github.com/systemd/systemd/issues/6620</a></li>
</ul>
<p>参考文档:</p>
<ul>
<li>systemd-journald BUG记录: <a href="https://bugs.freedesktop.org/show_bug.cgi?id=84923" target="_blank" rel="noopener">https://bugs.freedesktop.org/show_bug.cgi?id=84923</a></li>
<li>systemd.service 中文手册: <a href="http://www.jinbuguo.com/systemd/systemd.service.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/systemd.service.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>journald</tag>
        <tag>systemd</tag>
        <tag>BUG</tag>
        <tag>SIGPIPE</tag>
        <tag>kube-apiserver</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd-journal: Suppressed N messages</title>
    <url>/2018/11/22/systemd-journal-Suppressed-N-messages/</url>
    <content><![CDATA[<blockquote>
<p>问题现象: docker container logs 查看容器日志却没有任何返回结果. 开始以为是程序没有 stdout 标准输出, 但是后来测试, 将<code>echo &quot;log&quot;</code>作为死循环运行在容器中, 再次执行<code>docker container logs</code>依然没有任何日志输出. 找到一台”干净的”docker 服务器测试却可以正常显示日志</p>
</blockquote>
<p>这台无法查看日志回显的服务器, Docker 的日志引擎配置为<code>journald</code>, 查看 journald 服务日志发现大量类似日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemd-journal: Suppressed 9567 messages from &#x2F;system.slice&#x2F;</span><br><span class="line">systemd-journal: Suppressed 6735 messages from &#x2F;system.slice&#x2F;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>根据字面意思理解就是日志被丢弃了, 看来是由于 journald 服务的问题导致的日志问题</p>
<p>在 journald 中, 有如下两个参数跟此问题相关:</p>
<ul>
<li>RateLimitInterval</li>
<li>RateLimitBurst</li>
</ul>
<p><code>RateLimitInterval</code>是指定时间间隔, 意思就是说, 在<code>RateLimitInterval</code>这段时间内的日志总量(总条数)控制在<code>RateLimitBurst</code>以内. 这两个参数搭配使用可以用来控制日志速率, 避免由于大量日志输出导致的一系列性能问题.</p>
<p>该问题的根源在于该主机目前日志输出的速率超出了 journald 默认的配置, 你可以自定定义该速率, 也可以将<code>RateLimitInterval</code>设置为<code>0</code>, 以禁用速率控制</p>
<p>接下来重启 journald 以生效配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart systemd-journald</span><br></pre></td></tr></table></figure>

<p><strong>注意: 重启 journald 服务可能会引发一个 systemd 的 bug, 详情请参考下篇文章&lt;systemd-journald的SIGPIPE信号BUG&gt;</strong></p>
<p>参考文档:</p>
<ul>
<li><a href="https://www.freedesktop.org/software/systemd/man/journald.conf.html" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/journald.conf.html</a></li>
<li><a href="https://bani.com.br/2015/06/systemd-journal-what-does-systemd-journal-suppressed-n-messages-from-system-slice-mean/" target="_blank" rel="noopener">https://bani.com.br/2015/06/systemd-journal-what-does-systemd-journal-suppressed-n-messages-from-system-slice-mean/</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>container</tag>
        <tag>log</tag>
        <tag>Docker</tag>
        <tag>journald</tag>
      </tags>
  </entry>
  <entry>
    <title>heapster部署及配置使用https访问kubelet10250端口</title>
    <url>/2018/11/14/heapster%E9%83%A8%E7%BD%B2%E5%8F%8A%E9%85%8D%E7%BD%AE%E4%BD%BF%E7%94%A8https%E8%AE%BF%E9%97%AEkubelet10250%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<p>默认情况下, heapster 使用 http 协议访问每个 kubelet 节点的10255这个非安全端口, 在kubelet 关闭此端口的情况下, 仅允许通过 https 通信时, heapster 找 kubelet拿数据成了大问题</p>
<p>基础环境:</p>
<p>auth mode: RBAC<br>kubelet port: only https(10250)<br>kubelet ca: SelfSign</p>
<h2 id="创建-ServiceAccount"><a href="#创建-ServiceAccount" class="headerlink" title="创建 ServiceAccount"></a>创建 ServiceAccount</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<h2 id="创建-ClusterRoleBinding"><a href="#创建-ClusterRoleBinding" class="headerlink" title="创建 ClusterRoleBinding"></a>创建 ClusterRoleBinding</h2><p>官方文档中的配置如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:heapster</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>官方文档中的配置在 heapster 使用 http 协议访问 kubelet 10255 端口的时候时没有任何问题的, 但是用这份配置访问 kubelet 的 10250 端口, 你在 heapster 的 console log 日志中, 可以看到 403 Forbidden 的报错, 因为绑定的角色权限没有达到要求, 所以你需要下面这份绑定文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">system:kubelet-api-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br></pre></td></tr></table></figure>

<p>其实只是绑定的角色从 <code>system:heapster</code> 换成了 <code>system:kubelet-api-admin</code></p>
<h2 id="创建-heapster-服务"><a href="#创建-heapster-服务" class="headerlink" title="创建 heapster 服务"></a>创建 heapster 服务</h2><p>以下是官方示例:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">task:</span> <span class="string">monitoring</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">heapster</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">heapster</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">heapster</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">k8s.gcr.io/heapster-amd64:v1.5.4</span></span><br><span class="line">        <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">        <span class="attr">command:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">/heapster</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--source=kubernetes:https://kubernetes.default</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">--sink=influxdb:http://monitoring-influxdb.kube-system.svc:8086</span></span><br></pre></td></tr></table></figure>

<p>我们需要对如下参数做修改:</p>
<ul>
<li>–source=kubernetes:https://这里写你master的域名:6443 </li>
<li>–sink=influxdb:http://这里写你influxdb的地址或域名:8086</li>
</ul>
<p><code>--sink</code> 配置中有如下参数可以选择</p>
<ul>
<li>inClusterConfig - Use kube config in service accounts associated with Heapster’s namespace. (default: true)</li>
<li>kubeletPort - kubelet port to use (default: 10255)</li>
<li>kubeletHttps - whether to use https to connect to kubelets (default: false)</li>
<li>insecure - whether to trust Kubernetes certificates (default: false)</li>
<li>auth - client auth file to use. Set auth if the service accounts are not usable.</li>
<li>useServiceAccount - whether to use the service account token if one is mounted at /var/run/secrets/kubernetes.io/serviceaccount/token (default: false)</li>
</ul>
<p>需要设置访问 kubelet 的安全端口, 需要如下参数</p>
<ul>
<li>kubeletPort 10250  访问10250端口</li>
<li>kubeletHttps true  以https协议访问</li>
<li>insecure true      信任kubernetes证书</li>
<li>useServiceAccount true 使用挂载进来的SA账户进行访问</li>
</ul>
<p>最终的配置结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--source&#x3D;kubernetes:https:&#x2F;&#x2F;k8s-master:6443?useServiceAccount&#x3D;true&amp;kubeletHttps&#x3D;true&amp;kubeletPort&#x3D;10250&amp;insecure&#x3D;true</span><br></pre></td></tr></table></figure>

<p>这里着重说明一下<code>insecure</code>配置, 一般情况下, kubelet 节点在没有静态配置<strong>服务端证书</strong>的情况下, kubelet 节点会自动生成一个自签名的服务端证书到指定或默认的目录下. 这个证书是独立于kubernetes集群的证书, 不是kubernetes集群根证书所签发的. 所以理论上, 在 kubernetse 的双向认证中, 当 apiserver 向 kubelet主动发起 https 请求后, 服务端首先会将自己的服务端证书发送给客户端(apiserver), 一般情况下, apiserver 是需要校验服务端证书是否可信的. 但是在 apiserver 与 kubelet 通信中比较特殊, 默认情况下, apiserver 是不会校验 kubelet 的服务端证书的, 因为 kubelet 一般是独立于k8集群的自签名证书, 如果真的校验, 结果肯定是服务端证书不可信, 所以索性默认就不校验了, 而是直接将 apiserver 持有的 kubelet 客户端证书发送给 kubelet, 供 kubelet 校验, 此时, kubelet 依据配置中指定的ca证书对 apiserver 发来的客户端证书进行校验.</p>
<p>话题再回到<code>insecure</code>配置. 如果你设置这个参数为<code>true</code>, 还要使用 https 协议去访问 kubelet, 那么 heapster 日志中将会报证书验证失败的错误. heapster 会取到每个 kubelet 的IP地址, 然后进行访问, 但问题是, kubelet 在自签名证书时, 默认依据的是自己的主机名, 所以 heapster 以 https 访问 kubelet, 一是证书不是自己持有的根证书签发的,不可信; 二是服务端的地址限定是基于DNS的主机名, 并没有设置IP, 所以也不会校验通过</p>
<hr>
<p>参考文档:</p>
<ul>
<li>官方文档之source配置 <a href="https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md" target="_blank" rel="noopener">https://github.com/kubernetes/heapster/blob/master/docs/source-configuration.md</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubelet</tag>
        <tag>heapster</tag>
      </tags>
  </entry>
  <entry>
    <title>为k8s-master节点添加污点taints</title>
    <url>/2018/11/14/%E4%B8%BAk8s-master%E8%8A%82%E7%82%B9%E6%B7%BB%E5%8A%A0%E6%B1%A1%E7%82%B9taints/</url>
    <content><![CDATA[<p>手动部署的k8s集群, 需要为master节点手动设置taints</p>
<h2 id="设置taint"><a href="#设置taint" class="headerlink" title="设置taint"></a>设置taint</h2><p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl taint node [node] key&#x3D;value[effect]   </span><br><span class="line">     其中[effect] 可取值: [ NoSchedule | PreferNoSchedule | NoExecute ]</span><br><span class="line">      NoSchedule: 一定不能被调度</span><br><span class="line">      PreferNoSchedule: 尽量不要调度</span><br><span class="line">      NoExecute: 不仅不会调度, 还会驱逐Node上已有的Pod</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl taint node node1 key1&#x3D;value1:NoSchedule</span><br><span class="line">kubectl taint node node1 key1&#x3D;value1:NoExecute</span><br><span class="line">kubectl taint node node1 key2&#x3D;value2:NoSchedule</span><br></pre></td></tr></table></figure>

<h2 id="查看taint："><a href="#查看taint：" class="headerlink" title="查看taint："></a>查看taint：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl describe node node1</span><br></pre></td></tr></table></figure>

<h2 id="删除taint"><a href="#删除taint" class="headerlink" title="删除taint:"></a>删除taint:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl taint node node1 key1:NoSchedule-  <span class="comment"># 这里的key可以不用指定value</span></span><br><span class="line">kubectl taint node node1 key1:NoExecute-</span><br><span class="line"><span class="comment"># kubectl taint node node1 key1-  删除指定key所有的effect</span></span><br><span class="line">kubectl taint node node1 key2:NoSchedule-</span><br></pre></td></tr></table></figure>

<h2 id="master节点设置taint"><a href="#master节点设置taint" class="headerlink" title="master节点设置taint"></a>master节点设置taint</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kubectl taint nodes master1 node-role.kubernetes.io&#x2F;master&#x3D;:NoSchedule</span><br></pre></td></tr></table></figure>

<p>注意⚠️ : 为master设置的这个taint中, <code>node-role.kubernetes.io/master</code>为<code>key</code>, <code>value</code>为空, <code>effect</code>为<code>NoSchedule</code></p>
<p>如果输入命令时, 你丢掉了<code>=</code>符号, 写成了<code>node-role.kubernetes.io/master:NoSchedule</code>, 会报<code>error: at least one taint update is required</code>错误</p>
<h2 id="容忍tolerations主节点的taints"><a href="#容忍tolerations主节点的taints" class="headerlink" title="容忍tolerations主节点的taints"></a>容忍tolerations主节点的taints</h2><p>以上面为 master1 设置的 taints 为例, 你需要为你的 yaml 文件中添加如下配置, 才能容忍 master 节点的污点</p>
<p>在 pod 的 spec 中设置 tolerations 字段</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tolerations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">key:</span> <span class="string">"node-role.kubernetes.io/master"</span></span><br><span class="line">  <span class="attr">operator:</span> <span class="string">"Equal"</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="string">"NoSchedule"</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>taints</tag>
        <tag>tolerations</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s设置node节点Role属性</title>
    <url>/2018/11/01/k8s%E8%AE%BE%E7%BD%AEnode%E8%8A%82%E7%82%B9Role%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@k8s-master:~# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES     AGE       VERSION</span><br><span class="line">k8s-master   Ready      master    50d       v1.11.2</span><br><span class="line">k8s-node1    NotReady   &lt;none&gt;    50d       v1.11.2</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;    50d       v1.11.2</span><br></pre></td></tr></table></figure>

<p>在 kubeadm 引导的 k8s 集群中, 查看 nodes 信息时, ROLES 一列标记了 master 节点的身份, 其他节点默认没有标记. 在手动安装的 k8s 集群中, 你看到情况可能是如下这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@k8s-master:~# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES     AGE       VERSION</span><br><span class="line">k8s-master   Ready      &lt;none&gt;    50d       v1.11.2</span><br><span class="line">k8s-node1    NotReady   &lt;none&gt;    50d       v1.11.2</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;    50d       v1.11.2</span><br></pre></td></tr></table></figure>

<p>没错, 连 master 节点的标记都没有, 我们可以手动给任意 node 设置 ROLES</p>
<p>原理就是给 node 打标签, 只不过是特殊的标签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@k8s-master:~# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES     AGE       VERSION</span><br><span class="line">k8s-master   Ready      master    50d       v1.11.2</span><br><span class="line">k8s-node1    NotReady   &lt;none&gt;    50d       v1.11.2</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;    50d       v1.11.2</span><br><span class="line">root@k8s-master:~# kubectl label node k8s-node1 node-role.kubernetes.io&#x2F;worker&#x3D;worker</span><br><span class="line">node&#x2F;k8s-node1 labeled</span><br><span class="line">root@k8s-master:~# kubectl get nodes</span><br><span class="line">NAME         STATUS     ROLES     AGE       VERSION</span><br><span class="line">k8s-master   Ready      master    50d       v1.11.2</span><br><span class="line">k8s-node1    NotReady   worker    50d       v1.11.2</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;    50d       v1.11.2</span><br><span class="line">root@k8s-master:~#</span><br></pre></td></tr></table></figure>

<p>参考文档:</p>
<p><a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/setup-tools/kubeadm/implementation-details/</a></p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>role</tag>
        <tag>node</tag>
        <tag>label</tag>
      </tags>
  </entry>
  <entry>
    <title>yum安装软件包失败的排错过程</title>
    <url>/2018/11/01/yum%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%8E%92%E9%94%99%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>安装 docker-ce 时, 依赖安装 libcgroup 失败</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Total download size: 65 k</span><br><span class="line">Installed size: 130 k</span><br><span class="line">Is this ok [y/d/N]: y</span><br><span class="line">Downloading packages:</span><br><span class="line">libcgroup-0.41-15.el7.x86_64.rpm                                                                                                           |  65 kB  00:00:00</span><br><span class="line">Member: libcgroup.x86_64 0:0.41-15.el7 - u</span><br><span class="line">Adding Package libcgroup-0.41-15.el7.x86_64 <span class="keyword">in</span> mode u</span><br><span class="line">Running transaction check</span><br><span class="line">Transaction check time: 0.108</span><br><span class="line">Running transaction <span class="built_in">test</span></span><br><span class="line">Transaction <span class="built_in">test</span> succeeded</span><br><span class="line">Transaction <span class="built_in">test</span> time: 0.069</span><br><span class="line">Running transaction</span><br><span class="line">groupadd: cannot open /etc/group</span><br><span class="line">error: %pre(libcgroup-0.41-15.el7.x86_64) scriptlet failed, <span class="built_in">exit</span> status 10</span><br><span class="line">Error <span class="keyword">in</span> PREIN scriptlet <span class="keyword">in</span> rpm package libcgroup-0.41-15.el7.x86_64</span><br><span class="line">Warning: scriptlet or other non-fatal errors occurred during transaction.</span><br><span class="line">  Verifying  : libcgroup-0.41-15.el7.x86_64                                                                                                                   1/1</span><br><span class="line">What is this? libcgroup-0.41-15.el7.x86_64</span><br><span class="line">VerifyTransaction time: 0.003</span><br><span class="line">Transaction time: 0.810</span><br><span class="line"></span><br><span class="line">Failed:</span><br><span class="line">  libcgroup.x86_64 0:0.41-15.el7</span><br></pre></td></tr></table></figure>

<p>看到报错信息<code>groupadd: cannot open /etc/group</code>, 安装程序操作了这个文件, 但是报这个文件不可访问的错误</p>
<p>实际检查中, 该文件已经存在</p>
<p>将安装包单独下载下来, 手动安装查看详细操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install --downloadonly libcgroup</span><br><span class="line">Loaded plugins: fastestmirror, langpacks, priorities</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * elrepo: mirrors.neusoft.edu.cn</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package libcgroup.x86_64 0:0.41-15.el7 will be installed</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">==================================================================================================================================================================</span><br><span class="line"> Package                                 Arch                                 Version                                    Repository                          Size</span><br><span class="line">==================================================================================================================================================================</span><br><span class="line">Installing:</span><br><span class="line"> libcgroup                               x86_64                               0.41-15.el7                                base                                65 k</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">==================================================================================================================================================================</span><br><span class="line">Install  1 Package</span><br><span class="line"></span><br><span class="line">Total download size: 65 k</span><br><span class="line">Installed size: 130 k</span><br><span class="line">Background downloading packages, <span class="keyword">then</span> exiting:</span><br><span class="line">libcgroup-0.41-15.el7.x86_64.rpm                                                                                                           |  65 kB  00:00:00</span><br><span class="line">exiting because <span class="string">"Download Only"</span> specified</span><br></pre></td></tr></table></figure>

<p>找到文件位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">"libcgroup-0.41-15.el7.x86_64.rpm"</span> -<span class="built_in">type</span> f</span><br><span class="line">/var/cache/yum/x86_64/7/base/packages/libcgroup-0.41-15.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>手动安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivvvh /var/cache/yum/x86_64/7/base/packages/libcgroup-0.41-15.el7.x86_64.rpm</span><br><span class="line">D: ============== /var/cache/yum/x86_64/7/base/packages/libcgroup-0.41-15.el7.x86_64.rpm</span><br><span class="line">D: loading keyring from pubkeys <span class="keyword">in</span> /var/lib/rpm/pubkeys/*.key</span><br><span class="line">D: couldn<span class="string">'t find any keys in /var/lib/rpm/pubkeys/*.key</span></span><br><span class="line"><span class="string">D: loading keyring from rpmdb</span></span><br><span class="line"><span class="string">D: opening  db environment /var/lib/rpm cdb:0x401</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Packages 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D: locked   db index       /var/lib/rpm/Packages</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Name 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D:  read h#     671 Header SHA1 digest: OK (6c239af7e9e88852422394529fbf054ef1cd4921)</span></span><br><span class="line"><span class="string">D: added key gpg-pubkey-baadae52-49beffa4 to keyring</span></span><br><span class="line"><span class="string">D: Using legacy gpg-pubkey(s) from rpmdb</span></span><br><span class="line"><span class="string">D: Expected size:        66752 = lead(96)+sigs(1284)+pad(4)+data(65368)</span></span><br><span class="line"><span class="string">D:   Actual size:        66752</span></span><br><span class="line"><span class="string">warning: /var/cache/yum/x86_64/7/base/packages/libcgroup-0.41-15.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D: 	added binary package [0]</span></span><br><span class="line"><span class="string">D: found 0 source and 1 binary packages</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Conflictname 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D: ========== +++ libcgroup-0.41-15.el7 x86_64/linux 0x2</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Basenames 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D:  read h#     606 Header SHA1 digest: OK (83b77b161083033277b34d5b3705b5e3a2a52ab3)</span></span><br><span class="line"><span class="string">D:  Requires: /bin/sh                                       YES (db files)</span></span><br><span class="line"><span class="string">D:  Requires: /bin/sh                                       YES (cached)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: /sbin/ldconfig                                YES (db files)</span></span><br><span class="line"><span class="string">D:  Requires: /sbin/ldconfig                                YES (cached)</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Providename 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: ld-linux-x86-64.so.2()(64bit)                 YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: ld-linux-x86-64.so.2(GLIBC_2.3)(64bit)        YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6()(64bit)                            YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.11)(64bit)                  YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.14)(64bit)                  YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.2.5)(64bit)                 YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.3)(64bit)                   YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.3.4)(64bit)                 YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.4)(64bit)                   YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libc.so.6(GLIBC_2.8)(64bit)                   YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libpthread.so.0()(64bit)                      YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: libpthread.so.0(GLIBC_2.2.5)(64bit)           YES (db provides)</span></span><br><span class="line"><span class="string">D:  Requires: rpmlib(CompressedFileNames) &lt;= 3.0.4-1        YES (rpmlib provides)</span></span><br><span class="line"><span class="string">D:  Requires: rpmlib(FileDigests) &lt;= 4.6.0-1                YES (rpmlib provides)</span></span><br><span class="line"><span class="string">D:  Requires: rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1       YES (rpmlib provides)</span></span><br><span class="line"><span class="string">D:  read h#      36 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: rtld(GNU_HASH)                                YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#     344 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: shadow-utils                                  YES (db provides)</span></span><br><span class="line"><span class="string">D:  read h#     365 Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:  Requires: systemd                                       YES (db provides)</span></span><br><span class="line"><span class="string">D:  Requires: systemd                                       YES (cached)</span></span><br><span class="line"><span class="string">D:  Requires: systemd                                       YES (cached)</span></span><br><span class="line"><span class="string">D:  Requires: rpmlib(PayloadIsXz) &lt;= 5.2-1                  YES (rpmlib provides)</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Obsoletename 0x400 mode=0x0</span></span><br><span class="line"><span class="string">D: ========== recording tsort relations</span></span><br><span class="line"><span class="string">D: ========== tsorting packages (order, #predecessors, #succesors, depth)</span></span><br><span class="line"><span class="string">D:     0    0    0    1   +libcgroup-0.41-15.el7.x86_64</span></span><br><span class="line"><span class="string">D: installing binary packages</span></span><br><span class="line"><span class="string">D: Selinux disabled.</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Obsoletename</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Conflictname</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Providename</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Basenames</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Name</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Packages</span></span><br><span class="line"><span class="string">D: closed   db environment /var/lib/rpm</span></span><br><span class="line"><span class="string">D: opening  db environment /var/lib/rpm cdb:0x401</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Packages (none) mode=0x42</span></span><br><span class="line"><span class="string">D: sanity checking 1 elements</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Name (none) mode=0x42</span></span><br><span class="line"><span class="string">D: running pre-transaction scripts</span></span><br><span class="line"><span class="string">D: computing 5 file fingerprints</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Basenames (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Group (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Requirename (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Providename (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Conflictname (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Obsoletename (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Triggername (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Dirnames (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Installtid (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Sigmd5 (none) mode=0x42</span></span><br><span class="line"><span class="string">D: opening  db index       /var/lib/rpm/Sha1header (none) mode=0x42</span></span><br><span class="line"><span class="string">Preparing...                          D: computing file dispositions</span></span><br><span class="line"><span class="string">D: 0x00000803     4096     72372888    146033401 /</span></span><br><span class="line"><span class="string">################################# [100%]</span></span><br><span class="line"><span class="string">D: ========== +++ libcgroup-0.41-15.el7 x86_64-linux 0x2</span></span><br><span class="line"><span class="string">D: Expected size:        66752 = lead(96)+sigs(1284)+pad(4)+data(65368)</span></span><br><span class="line"><span class="string">D:   Actual size:        66752</span></span><br><span class="line"><span class="string">D: libcgroup-0.41-15.el7.x86_64: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEY</span></span><br><span class="line"><span class="string">D:   install: libcgroup-0.41-15.el7 has 5 files</span></span><br><span class="line"><span class="string">D: %pre(libcgroup-0.41-15.el7.x86_64): scriptlet start</span></span><br><span class="line"><span class="string">D: %pre(libcgroup-0.41-15.el7.x86_64): execv(/bin/sh) pid 43192</span></span><br><span class="line"><span class="string">+ getent group cgred</span></span><br><span class="line"><span class="string">+ groupadd -r cgred</span></span><br><span class="line"><span class="string">groupadd: cannot open /etc/group</span></span><br><span class="line"><span class="string">D: %pre(libcgroup-0.41-15.el7.x86_64): waitpid(43192) rc 43192 status a00</span></span><br><span class="line"><span class="string">error: %pre(libcgroup-0.41-15.el7.x86_64) scriptlet failed, exit status 10</span></span><br><span class="line"><span class="string">error: libcgroup-0.41-15.el7.x86_64: install failed</span></span><br><span class="line"><span class="string">D: running post-transaction scripts</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Sha1header</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Sigmd5</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Installtid</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Dirnames</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Triggername</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Obsoletename</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Conflictname</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Providename</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Requirename</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Group</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Basenames</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Name</span></span><br><span class="line"><span class="string">D: closed   db index       /var/lib/rpm/Packages</span></span><br><span class="line"><span class="string">D: closed   db environment /var/lib/rpm</span></span><br></pre></td></tr></table></figure>

<p>可以看到, 在安装的过程中, 是执行了<code>groupadd -r cgred</code>导致的报错</p>
<p>手动执行 <code>groupadd -r cgred</code>, 依然报错 <code>groupadd: cannot open /etc/group</code></p>
<p>查看文件属性</p>
<p>lsattr /etc/group<br>—-i———– /etc/group</p>
<p>原来是有特殊权限, 修改他</p>
<p>chattr -i /etc/group</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>yum</tag>
        <tag>getent</tag>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s证书的KeyUsage问题</title>
    <url>/2018/11/01/k8s%E8%AF%81%E4%B9%A6%E7%9A%84KeyUsage%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>官方文档中, 对 k8s 的证书制作提供了三种方式, 主流使用有两种</p>
<ul>
<li>openssl</li>
<li>cfssl</li>
</ul>
<p>具体证书制作步骤在此就不详细说明, 重点注意参考官方文档, 使用 openssl 方式制作证书时需要注意的事项</p>
<p>官方文档中, 使用 OpenSSL 制作证书, 在 KeyUsage 的设置上, 指定了如下功能:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keyUsage&#x3D;keyEncipherment,dataEncipherment</span><br></pre></td></tr></table></figure>

<p>在制作完 crt 证书后, 使用 <code>openssl x509 -in /path/to/xxx.crt -text -noout</code> 命令查看证书信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X509v3 Key Usage:</span><br><span class="line">    Key Encipherment, Data Encipherment</span><br></pre></td></tr></table></figure>

<p>没毛病, 就是之前指定的两个功能, 一个不多一个不少, 但问题也出现在这里. </p>
<p>在实际使用中, 使用仅带有<code>keyUsage=keyEncipherment,dataEncipherment</code>这两个功能的证书引导集群, 并没有出现什么问题, 但是在使用 Java 客户端访问 apiserver 时, 却报以下错误:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.kubernetes.client.ApiException: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: KeyUsage does not allow digital signatures</span><br></pre></td></tr></table></figure>

<p>报错信息很明确, 证书没有提供<code>digital signatures</code>的功能. 查询另一篇证书说明文档(<a href="https://kubernetes.io/docs/setup/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/certificates/</a>) 里面说的很清楚</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind	Key usage</span><br><span class="line">server	digital signature, key encipherment, server auth</span><br><span class="line">client	digital signature, key encipherment, client auth</span><br></pre></td></tr></table></figure>

<p>不管是服务端证书还是客户端证书, 都至少需要提供<code>digital signature, key encipherment</code>这两个功能, 但是制作证书的官方文档中, openssl 方式创建的证书, 却没有显式指定 <code>digital signatures</code> 功能. 在后期的制作中, openssl 也没有默认给我们加入此功能, 结果导致 java 客户端无法完成 ssl 认证.</p>
<p>但是官方文档中, 使用 cfssl 工具也没有显示指定加入 <code>digital signatures</code> 功能, 但是制作证书时, 默认为我们加入了该功能. 就冲这点, 也强烈建议使用 cfssl 工具制作证书😆</p>
<p>解决方法: </p>
<ul>
<li>使用 openssl 签发证书的话, 将 <code>keyUsage=keyEncipherment,dataEncipherment</code> 修改为–&gt; <code>keyUsage=digitalSignature,keyEncipherment,dataEncipherment</code> 即可</li>
<li>使用 cfssl 签发证书, 默认就会加入<code>digitalSignature</code>功能</li>
</ul>
<p>解决方案:<br>   方案一: 重新制作所有证书, 加入<code>digital signatures</code>功能, 并为集群更换证书<br>   方案二: 重新制作 apiserver 服务端证书和 java 客户端使用的客户端证书, 加入<code>digital signatures</code>功能, 替换所有 apiserver 和 java 使用的证书, 即可完成最小代价的替换</p>
<p>附录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeyUsage ::&#x3D; BIT STRING &#123;</span><br><span class="line">          digitalSignature        (0),</span><br><span class="line">          nonRepudiation          (1), -- recent editions of X.509 have</span><br><span class="line">                               -- renamed this bit to contentCommitment</span><br><span class="line">          keyEncipherment         (2),</span><br><span class="line">          dataEncipherment        (3),</span><br><span class="line">          keyAgreement            (4),</span><br><span class="line">          keyCertSign             (5),</span><br><span class="line">          cRLSign                 (6),</span><br><span class="line">          encipherOnly            (7),</span><br><span class="line">          decipherOnly            (8) &#125;</span><br><span class="line"></span><br><span class="line">  Bits in the KeyUsage type are used as follows:</span><br><span class="line"></span><br><span class="line">     The digitalSignature bit is asserted when the subject public key</span><br><span class="line">     is used for verifying digital signatures, other than signatures on</span><br><span class="line">     certificates (bit 5) and CRLs (bit 6), such as those used in an</span><br><span class="line">     entity authentication service, a data origin authentication</span><br><span class="line">     service, and&#x2F;or an integrity service.</span><br></pre></td></tr></table></figure>

<p>参考文档:</p>
<p>k8s证书制作文档</p>
<ul>
<li>中文文档: <a href="https://k8smeetup.github.io/docs/concepts/cluster-administration/certificates/#openssl" target="_blank" rel="noopener">https://k8smeetup.github.io/docs/concepts/cluster-administration/certificates/#openssl</a></li>
<li>英文文档: <a href="https://kubernetes.io/docs/concepts/cluster-administration/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/cluster-administration/certificates/</a></li>
</ul>
<p>k8s证书使用说明文档</p>
<ul>
<li><a href="https://kubernetes.io/docs/setup/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/certificates/</a></li>
</ul>
<p>KeyUsage 文档:</p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.3" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc5280#section-4.2.1.3</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>ca</tag>
        <tag>kubernetes</tag>
        <tag>KeyUsage</tag>
        <tag>k8s</tag>
        <tag>digital</tag>
      </tags>
  </entry>
  <entry>
    <title>DHCP模式下的k8s排错</title>
    <url>/2018/11/01/DHCP%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84k8s%E6%8E%92%E9%94%99/</url>
    <content><![CDATA[<p>环境: </p>
<ul>
<li>Kubernetes</li>
<li>Bridge+DHCP</li>
</ul>
<p>kubelet 日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oct 10 16:52:58 k8node3 kubelet[38221]: E1010 16:52:58.848278   38221 kuberuntime_sandbox.go:54] CreatePodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:52:58 k8node3 kubelet[38221]: E1010 16:52:58.848293   38221 kuberuntime_manager.go:646] createPodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:52:58 k8node3 kubelet[38221]: E1010 16:52:58.848349   38221 pod_workers.go:186] Error syncing pod 88d40907-cc60-11e8-9598-ecebb88a11d4 (&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot;), skipping: failed to &quot;CreatePodSandbox&quot; for &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; with CreatePodSandboxError: &quot;CreatePodSandbox for pod \&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)\&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod \&quot;log-pilot-msvj7_default\&quot; network: error calling DHCP.Allocate: no more tries&quot;</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.433003   38221 cni.go:259] Error adding network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.433036   38221 cni.go:227] Error while adding to cni network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.505258   38221 remote_runtime.go:92] RunPodSandbox from runtime service failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.505313   38221 kuberuntime_sandbox.go:54] CreatePodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.505327   38221 kuberuntime_manager.go:646] createPodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:53:43 k8node3 kubelet[38221]: E1010 16:53:43.505388   38221 pod_workers.go:186] Error syncing pod 88d40907-cc60-11e8-9598-ecebb88a11d4 (&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot;), skipping: failed to &quot;CreatePodSandbox&quot; for &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; with CreatePodSandboxError: &quot;CreatePodSandbox for pod \&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)\&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod \&quot;log-pilot-msvj7_default\&quot; network: error calling DHCP.Allocate: no more tries&quot;</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.112837   38221 cni.go:259] Error adding network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.112865   38221 cni.go:227] Error while adding to cni network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.190742   38221 remote_runtime.go:92] RunPodSandbox from runtime service failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.190800   38221 kuberuntime_sandbox.go:54] CreatePodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.190815   38221 kuberuntime_manager.go:646] createPodSandbox for pod &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:54:29 k8node3 kubelet[38221]: E1010 16:54:29.190899   38221 pod_workers.go:186] Error syncing pod 88d40907-cc60-11e8-9598-ecebb88a11d4 (&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot;), skipping: failed to &quot;CreatePodSandbox&quot; for &quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)&quot; with CreatePodSandboxError: &quot;CreatePodSandbox for pod \&quot;log-pilot-msvj7_default(88d40907-cc60-11e8-9598-ecebb88a11d4)\&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod \&quot;log-pilot-msvj7_default\&quot; network: error calling DHCP.Allocate: no more tries&quot;</span><br><span class="line">Oct 10 16:55:13 k8node3 kubelet[38221]: E1010 16:55:13.604965   38221 cni.go:259] Error adding network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:55:13 k8node3 kubelet[38221]: E1010 16:55:13.605013   38221 cni.go:227] Error while adding to cni network: error calling DHCP.Allocate: no more tries</span><br><span class="line">Oct 10 16:55:13 k8node3 kubelet[38221]: E1010 16:55:13.692412   38221 remote_runtime.go:92] RunPodSandbox from runtime service failed: rpc error: code &#x3D; Unknown desc &#x3D; NetworkPlugin cni failed to set up pod &quot;log-pilot-msvj7_default&quot; network: error calling DHCP.Allocate: no more tries</span><br></pre></td></tr></table></figure>

<p>cni 插件日志如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018&#x2F;10&#x2F;10 16:55:15 d61d6dd5cbda1c51769489334a566a1c4ca6f258efee60375aaf2e71bc116c32&#x2F;zzcloudnet: acquiring lease</span><br><span class="line">2018&#x2F;10&#x2F;10 16:55:20 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:55:29 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:55:43 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:00 bb55ff4ecac38220cbe88d0e34c7bc4296c6faf181fb24499694f9c76881e02c&#x2F;zzcloudnet: acquiring lease</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:05 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:15 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:28 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:45 07c373e24b35ec12d66f991b32a206217288ba018648071cea4f87fc9e055658&#x2F;zzcloudnet: acquiring lease</span><br><span class="line">2018&#x2F;10&#x2F;10 16:56:50 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:57:00 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:57:12 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:57:30 c3d52c2c4ea0db096b079da202ba0733b91e9c68d3b2db7ba6dc4d67c71e6546&#x2F;zzcloudnet: acquiring lease</span><br><span class="line">2018&#x2F;10&#x2F;10 16:57:35 resource temporarily unavailable</span><br><span class="line">2018&#x2F;10&#x2F;10 16:57:44 resource temporarily unavailable</span><br></pre></td></tr></table></figure>

<p>DHCP 服务端抓包 <code>tcpdump -n -i cni0</code> 发现, 服务端接收到了客户端的 <code>DISCOVER</code>, 并且服务端给了 <code>OFFER</code>, 但却迟迟收不到客户端发来的 <code>REQUEST</code>, 由此可以定位到问题, 要么包在服务端发不出去, 要么是客户端收不着, 着重检查两者之间的防火墙设置以及网络连通性.</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>DHCP</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes中内存资源限制引发的报错</title>
    <url>/2018/11/01/Kubernetes%E4%B8%AD%E5%86%85%E5%AD%98%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%BC%95%E5%8F%91%E7%9A%84%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>一个 Pod 被创建后, 一直卡在<code>ContainerCreating</code>的状态, 执行<code>describe</code>命令查看该 Pod 详细信息后发现如下 Event</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Events:</span><br><span class="line">  Type     Reason                  Age               From                            Message</span><br><span class="line">  ----     ------                  ----              ----                            -------</span><br><span class="line">  Normal   Scheduled               2m                default-scheduler               Successfully assigned 61f983b5-19ca-4b33-8647-6b279ae93812 to k8node3</span><br><span class="line">  Normal   SuccessfulMountVolume   2m                kubelet, k8node3  MountVolume.SetUp succeeded for volume &quot;default-token-7r9jt&quot;</span><br><span class="line">  Warning  FailedCreatePodSandBox  2m (x12 over 2m)  kubelet, k8node3  Failed create pod sandbox: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">  Normal   SandboxChanged          2m (x12 over 2m)  kubelet, k8node3  Pod sandbox changed, it will be killed and re-created.</span><br></pre></td></tr></table></figure>

<p>以上 Event 信息中, 能解读到的信息极其有限</p>
<ul>
<li>Failed create pod sandbox: Google 提供的 pause 容器启动失败</li>
<li>oci runtime error: 运行时接口出的问题, 我的环境中运行时环境为 docker</li>
<li>connection reset by peer: 连接被重置</li>
<li>Pod sandbox changed, it will be killed and re-created: pause 容器引导的 Pod 环境被改变, 重新创建 Pod 中的 pause 引导</li>
</ul>
<p>看完上面的报错信息并不能准确定位到问题的根源, 只能大致了解到是因为创建SandBox失败导致的, 接下来查看 kubelet 的日志</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oct 31 16:33:57 k8node3 kubelet[1865]: E1031 16:33:57.551282    1865 remote_runtime.go:92] RunPodSandbox from runtime service failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:57 k8node3 kubelet[1865]: E1031 16:33:57.551415    1865 kuberuntime_sandbox.go:54] CreatePodSandbox for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:57 k8node3 kubelet[1865]: E1031 16:33:57.551459    1865 kuberuntime_manager.go:646] createPodSandbox for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:57 k8node3 kubelet[1865]: E1031 16:33:57.551581    1865 pod_workers.go:186] Error syncing pod 77b2b948-dce4-11e8-afec-b82a72cf3061 (&quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot;), skipping: failed to &quot;CreatePodSandbox&quot; for &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; with CreatePodSandboxError: &quot;CreatePodSandbox for pod \&quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)\&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod \&quot;61f983b5-19ca-4b33-8647-6b279ae93812\&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused \&quot;process_linux.go:286: decoding sync type from init pipe caused \\\&quot;read parent: connection reset by peer\\\&quot;\&quot;&quot;</span><br><span class="line">Oct 31 16:33:58 k8node3 kubelet[1865]: E1031 16:33:58.718255    1865 remote_runtime.go:92] RunPodSandbox from runtime service failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:58 k8node3 kubelet[1865]: E1031 16:33:58.718406    1865 kuberuntime_sandbox.go:54] CreatePodSandbox for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:58 k8node3 kubelet[1865]: E1031 16:33:58.718443    1865 kuberuntime_manager.go:646] createPodSandbox for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused &quot;process_linux.go:286: decoding sync type from init pipe caused \&quot;read parent: connection reset by peer\&quot;&quot;</span><br><span class="line">Oct 31 16:33:58 k8node3 kubelet[1865]: E1031 16:33:58.718597    1865 pod_workers.go:186] Error syncing pod 77b2b948-dce4-11e8-afec-b82a72cf3061 (&quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot;), skipping: failed to &quot;CreatePodSandbox&quot; for &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot; with CreatePodSandboxError: &quot;CreatePodSandbox for pod \&quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)\&quot; failed: rpc error: code &#x3D; Unknown desc &#x3D; failed to start sandbox container for pod \&quot;61f983b5-19ca-4b33-8647-6b279ae93812\&quot;: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused \&quot;process_linux.go:286: decoding sync type from init pipe caused \\\&quot;read parent: connection reset by peer\\\&quot;\&quot;&quot;</span><br><span class="line">Oct 31 16:36:02 k8node3 kubelet[1865]: E1031 16:36:02.114171    1865 kubelet.go:1644] Unable to mount volumes for pod &quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot;: timeout expired waiting for volumes to attach or mount for pod &quot;default&quot;&#x2F;&quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;. list of unmounted volumes&#x3D;[default-token-7r9jt]. list of unattached volumes&#x3D;[default-token-7r9jt]; skipping pod</span><br><span class="line">Oct 31 16:36:02 k8node3 kubelet[1865]: E1031 16:36:02.114262    1865 pod_workers.go:186] Error syncing pod 77b2b948-dce4-11e8-afec-b82a72cf3061 (&quot;61f983b5-19ca-4b33-8647-6b279ae93812_default(77b2b948-dce4-11e8-afec-b82a72cf3061)&quot;), skipping: timeout expired waiting for volumes to attach or mount for pod &quot;default&quot;&#x2F;&quot;61f983b5-19ca-4b33-8647-6b279ae93812&quot;. list of unmounted volumes&#x3D;[default-token-7r9jt]. list of unattached volumes&#x3D;[default-token-7r9jt]</span><br></pre></td></tr></table></figure>

<p>kubelet 的日志中, 与 describe 出来的信息差不多, tail 的时候更直观的感觉到频繁的Sandbox创建的过程, 既然是 OCI 运行时报错, 只能去 docker 的日志中找找看了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Oct 31 16:33:58 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:33:58.671146675+08:00&quot; level&#x3D;error msg&#x3D;&quot;containerd: start container&quot; error&#x3D;&quot;oci runtime error: container_linux.go:247: starting container process caused \&quot;process_linux.go:286: decoding sync type from init pipe caused \\\&quot;read parent: connection reset by peer\\\&quot;\&quot;\n&quot; id&#x3D;029d9e843eedb822370c285b5abf1f37556461083d3bda2c7af38b3b00695b0f</span><br><span class="line">Oct 31 16:33:58 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:33:58.671871096+08:00&quot; level&#x3D;error msg&#x3D;&quot;Create container failed with error: oci runtime error: container_linux.go:247: starting container process caused \&quot;process_linux.go:286: decoding sync type from init pipe caused \\\&quot;read parent: connection reset by peer\\\&quot;\&quot;\n&quot;</span><br><span class="line">Oct 31 16:33:58 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:33:58.717553371+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;029d9e843eedb822370c285b5abf1f37556461083d3bda2c7af38b3b00695b0f&#x2F;start returned error: oci runtime error: container_linux.go:247: starting container process caused \&quot;process_linux.go:286: decoding sync type from init pipe caused \\\&quot;read parent: connection reset by peer\\\&quot;\&quot;\n&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.759631102+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;207f0ffb4b5ecc5f8261af40cd7a2c4c2800a2c30b027c4fb95648f8c1b00274&#x2F;stop returned error: Container 207f0ffb4b5ecc5f8261af40cd7a2c4c2800a2c30b027c4fb95648f8c1b00274 is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.768603351+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;03bf9bfcf4e3f66655b0124d6779ff649b2b00219b83645ca18b4bb08d1cc573&#x2F;stop returned error: Container 03bf9bfcf4e3f66655b0124d6779ff649b2b00219b83645ca18b4bb08d1cc573 is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.777073508+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;7b37f5aee7afe01f209bcdc6b3568b522fb0bbda5cb4b322e10b05ec603f5728&#x2F;stop returned error: Container 7b37f5aee7afe01f209bcdc6b3568b522fb0bbda5cb4b322e10b05ec603f5728 is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.785774443+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;1a01419973e4701b231556d74c619c30e0966889948e810b46567f08475ec431&#x2F;stop returned error: Container 1a01419973e4701b231556d74c619c30e0966889948e810b46567f08475ec431 is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.794198279+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;c3c4049e7b1942395b3cc3a45cf0cc69b34bab6271cb940a70c7d9aed3ba6176&#x2F;stop returned error: Container c3c4049e7b1942395b3cc3a45cf0cc69b34bab6271cb940a70c7d9aed3ba6176 is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.802698120+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;8d2c8a4cd5b43b071a9976251932955937d5b1f0f34dca1482cde4195df4747d&#x2F;stop returned error: Container 8d2c8a4cd5b43b071a9976251932955937d5b1f0f34dca1482cde4195df4747d is already stopped&quot;</span><br><span class="line">Oct 31 16:34:22 k8node3 dockerd[1715]: time&#x3D;&quot;2018-10-31T16:34:22.811103238+08:00&quot; level&#x3D;error msg&#x3D;&quot;Handler for POST &#x2F;v1.27&#x2F;containers&#x2F;7fdb697e251cec249c0a17f1fdcc6d76fbec13a60929eb0217c744c181702c1f&#x2F;stop returned error: Container 7fdb697e251cec249c0a17f1fdcc6d76fbec13a60929eb0217c744c181702c1f is already stopped&quot;</span><br></pre></td></tr></table></figure>

<p>Docker 的日志中, 除了已经看了很多遍的<code>connection reset by peer</code>之外, 还有一些新的发现</p>
<ul>
<li>xxx is already stopped: 看日志, 感觉是向容器接口发送了 POST 请求以 stop 容器, 但是该容器已经被 stop 掉了</li>
</ul>
<p>Docker 的日志和 kubelet 的日志的共同点就是, kubelet 频繁 recreate Sandbox</p>
<p>执行 <code>docker container ls -a</code> 命令发现存在大量 create 状态的 pause 容器</p>
<p>查看 <code>demesg -T</code> 信息, 发现了大量 oom-killer 的字眼的日志, 初步判断是由于内存溢出, 导致系统主动 kill 进程.</p>
<p>发生这样的情况的概率并不高, 一般情况下有两种类型的 oom kill</p>
<ul>
<li>由于 pod 内进程超出了 pod 指定 Limit 限制的值, 将导致 oom kill, 此时 pod 退出的 Reason 会显示 OOMKilled</li>
<li>另一种情况是 pod 内的进程给自己设置了可用内存, 比如 jvm 内存限制设置为2G, pod Limit 设置为6G, 此时由于程序的原因导致内存使用超过2G 时, 也会引发 oom kill</li>
</ul>
<p>这两种内存溢出的 kill 区别是第一种原因直接显示在 pod 的 Event 里; 第二种你在 Event 里找不到, 在宿主机的 dmesg 里面可以找到 invoked oom-killer 的日志</p>
<p>这次的情况看起来像属于第二种情况, 于是赶紧再次 describe pod, 查看 Limit 限制</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Containers:</span><br><span class="line">  61f983b5-19ca-4b33-8647-6b279ae93812:</span><br><span class="line">    Container ID:</span><br><span class="line">    Image:          reg.lvrui.io&#x2F;public&#x2F;testpublish:latest</span><br><span class="line">    Image ID:</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Waiting</span><br><span class="line">      Reason:       ContainerCreating</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Limits:</span><br><span class="line">      cpu:     1</span><br><span class="line">      memory:  2k</span><br><span class="line">    Requests:</span><br><span class="line">      cpu:     1</span><br><span class="line">      memory:  2k</span><br><span class="line">    Environment:</span><br><span class="line">      key:  value</span><br><span class="line">    Mounts:</span><br><span class="line">      &#x2F;var&#x2F;run&#x2F;secrets&#x2F;kubernetes.io&#x2F;serviceaccount from default-token-7r9jt (ro)</span><br></pre></td></tr></table></figure>

<p>终于找到了原因, 就是因为对内存的 Limit 导致的. 这里显示内存 Limit 为2k, 实际上是因为在创建资源时, 写的是 2000(不加单位时, 默认单位为 bytes), k8s 自动转成了以小写 k 的单位表示方式,  所以就变成了2k</p>
<p>理论上来说,  按照之前的经验, 此种情况(实际使用内存超过 Limit 内存的情况)应该属于第一种, 会在 Event 里显示的由于 OOMkilled 原因导致 Terminated 状态. 但实际情况却是在 Event 里找不到 oom kill 的日志, 且 pod 状态处于 ContainerCreating 状态.</p>
<ul>
<li>由于 OOMkilled 处于 Terminated 的状态是因为 pod 已经正常被引导创建后, 导致的内存溢出</li>
<li>由于系统 invoked oom-killer 导致的处于 ContainerCreating 状态的 pod 是因为 pod 还没正常被创建, pod 中的 pause 容器都没有被正常引导就已经被 cgroup 的内存限制而招来杀身之祸</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>kubelet</tag>
        <tag>Limit</tag>
        <tag>oom</tag>
        <tag>OOMKilled</tag>
        <tag>kill</tag>
        <tag>ContainerCreating</tag>
      </tags>
  </entry>
  <entry>
    <title>为容器镜像定制安装Linux工具</title>
    <url>/2018/10/19/%E4%B8%BA%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6%E5%AE%89%E8%A3%85Linux%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<blockquote>
<p>在调试的场景下, 容器在使用中通常需要进入容器并执行一些工具命令, 比如 wget, htop, lsof, rz, sz 等. 本篇文章就讨论如何为镜像定制安装这些工具</p>
</blockquote>
<h2 id="传统的工具安装方式"><a href="#传统的工具安装方式" class="headerlink" title="传统的工具安装方式"></a>传统的工具安装方式</h2><p>传统的运维中, 安装 Linux 工具直接使用各自发行版的包管理器就可以了, 方便, 快捷, 省心</p>
<ul>
<li>RedHat 系列: <code>yum install lsof</code></li>
<li>Debian 系列: <code>apt update &amp;&amp; apt install lsof</code></li>
</ul>
<p>当使用物理机或虚拟机时, 使用上面的安装方法没有任何问题, 但是到了容器镜像领域, 按照上面的安装方式就不行了. 试过的童鞋会发现, 一个 centos 的基础镜像大约 <strong>200MB</strong> 左右, 用以上<code>yum</code>的方式安装完<code>lsof</code>工具之后, 镜像的体积增大到了 <strong>300MB</strong> 仅仅一个小工具的安装, 就会让容器镜像的体积快速膨胀, 虽然成功的完成了安装, 单这显然不是我们希望看到的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos                                        latest              75835a67d134        9 days ago          200MB</span><br></pre></td></tr></table></figure>

<h2 id="镜像中的工具安装方式"><a href="#镜像中的工具安装方式" class="headerlink" title="镜像中的工具安装方式"></a>镜像中的工具安装方式</h2><p>在镜像中安装基础工具, 就不能像在传统虚拟机里那样粗犷操作了, 镜像的体积是个非常敏感的数字, 牵动着打包者的神经, 以下乃安装工具之正道</p>
<ul>
<li>RedHat 系列: <code>yum install lsof &amp;&amp; yum clean all</code></li>
<li>Debian 系列: <code>apt update &amp;&amp; apt install lsof &amp;&amp; apt clean &amp;&amp; apt autoclean &amp;&amp; rm -fr /var/lib/apt/lists/*</code></li>
</ul>
<p>经过善后处理的安装方式, 仍以 centos 安装 lsof 工具为例, 安装完成后, 体积为 <strong>223MB</strong> 相比之前 <strong>300MB</strong> 的体积, 可以说已经得到了很大的优化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mycentos                                      0.1                 80bb7d931f74        1 minutes ago       223MB</span><br></pre></td></tr></table></figure>

<p>Debian 系列比较特殊, <code>apt clean</code> 操作是为了删除掉 <code>/var/cache/apt/archives/</code> 下的软件包, 后面还指定删除了 <code>/var/lib/apt/lists/*</code> 此路径下的所有文件, 是为了删除 <code>apt update</code> 操作后更新到此目录的远程服务器提供的软件列表信息</p>
<h2 id="为容器定制安装工具包"><a href="#为容器定制安装工具包" class="headerlink" title="为容器定制安装工具包"></a>为容器定制安装工具包</h2><p>经过上面的实践, 在 centos 镜像中安装 lsof 工具的体积成本, 已经成功从 300MB 降到了 223 MB, 是否还有更极致的安装方法呢? 当然有的, 就是直接拷贝二进制文件到镜像中</p>
<h3 id="找到命令文件位置及依赖"><a href="#找到命令文件位置及依赖" class="headerlink" title="找到命令文件位置及依赖"></a>找到命令文件位置及依赖</h3><h4 id="找命令位置"><a href="#找命令位置" class="headerlink" title="找命令位置"></a>找命令位置</h4><p>启动临时容器, 传统安装 lsof</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it centos:latest /bin/bash</span><br></pre></td></tr></table></figure>

<p>进入到容器后, 正常安装工具包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install lsof</span><br></pre></td></tr></table></figure>

<p>查看该工具包安装的所有文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@7b532cd952dc /]<span class="comment"># rpm -qa | grep lsof</span></span><br><span class="line">lsof-4.87-5.el7.x86_64</span><br><span class="line">[root@7b532cd952dc /]<span class="comment"># rpm -ql lsof-4.87-5.el7.x86_64</span></span><br><span class="line">/usr/sbin/lsof</span><br><span class="line">/usr/share/doc/lsof-4.87</span><br><span class="line">/usr/share/doc/lsof-4.87/00.README.FIRST</span><br><span class="line">/usr/share/doc/lsof-4.87/00.README.FIRST_4.87</span><br><span class="line">/usr/share/doc/lsof-4.87/00CREDITS</span><br><span class="line">/usr/share/doc/lsof-4.87/00DCACHE</span><br><span class="line">/usr/share/doc/lsof-4.87/00DIALECTS</span><br><span class="line">/usr/share/doc/lsof-4.87/00DIST</span><br><span class="line">/usr/share/doc/lsof-4.87/00FAQ</span><br><span class="line">/usr/share/doc/lsof-4.87/00LSOF-L</span><br><span class="line">/usr/share/doc/lsof-4.87/00MANIFEST</span><br><span class="line">/usr/share/doc/lsof-4.87/00PORTING</span><br><span class="line">/usr/share/doc/lsof-4.87/00QUICKSTART</span><br><span class="line">/usr/share/doc/lsof-4.87/00README</span><br><span class="line">/usr/share/doc/lsof-4.87/00TEST</span><br><span class="line">/usr/share/doc/lsof-4.87/00XCONFIG</span><br><span class="line">/usr/share/doc/lsof-4.87/README.lsof_4.87</span><br><span class="line">/usr/share/man/man8/lsof.8.gz</span><br></pre></td></tr></table></figure>
<p>以上文件中, 除了第一个主程序外, 其他的都是文档文件, 由于 centos 基础镜像中并不包含 man 命令, 所以, 默认这些文件都没有实际存在在磁盘中, 我们要拷贝的目标只有第一个主程序</p>
<p>安装完成后, 找到软件包的安装位置(由于没有 which 命令, 我们可以使用 find 命令)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@7b532cd952dc /]<span class="comment"># find / -name "lsof"</span></span><br><span class="line">/usr/sbin/lsof</span><br></pre></td></tr></table></figure>

<h4 id="找依赖"><a href="#找依赖" class="headerlink" title="找依赖"></a>找依赖</h4><p>使用 <code>ldd</code> 命令, 找到 lsof 命令依赖的库文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@7b532cd952dc /]<span class="comment"># ldd /usr/sbin/lsof</span></span><br><span class="line">	linux-vdso.so.1 =&gt;  (0x00007ffca8dd6000)</span><br><span class="line">	libselinux.so.1 =&gt; /lib64/libselinux.so.1 (0x00007f09b6b7e000)</span><br><span class="line">	libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f09b67b1000)</span><br><span class="line">	libpcre.so.1 =&gt; /lib64/libpcre.so.1 (0x00007f09b654f000)</span><br><span class="line">	libdl.so.2 =&gt; /lib64/libdl.so.2 (0x00007f09b634b000)</span><br><span class="line">	/lib64/ld-linux-x86-64.so.2 (0x00007f09b6da5000)</span><br><span class="line">	libpthread.so.0 =&gt; /lib64/libpthread.so.0 (0x00007f09b612f000)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一列：程序需要依赖什么库</li>
<li>第二列: 系统提供的与程序需要的库所对应的库</li>
<li>第三列：库加载的开始地址</li>
</ul>
<p>通过上面的信息，我们可以得到以下几个信息：</p>
<ul>
<li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配</li>
<li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置</li>
</ul>
<p>在本文的场景中, 我们需要关心的就是第一列和第二列, 我们需要记下第一列的所有库文件, 然后到初始的 centos 镜像中去挨个儿查找</p>
<p>哪些库文件需要查找呢, 着重找那些 <code>第一列 =&gt; 第二列</code> 的库文件在新镜像中是否存在, 因为出现了<code>=&gt;</code>标志, 就意味着当前容器提供了这个文件给程序使用</p>
<p>拿上面的例子来说, 着重查找以下文件:</p>
<ul>
<li>libselinux.so.1 =&gt; /lib64/libselinux.so.1</li>
<li>libc.so.6 =&gt; /lib64/libc.so.6</li>
<li>libpcre.so.1 =&gt; /lib64/libpcre.so.1</li>
<li>libdl.so.2 =&gt; /lib64/libdl.so.2</li>
<li>/lib64/ld-linux-x86-64.so.2</li>
<li>libpthread.so.0 =&gt; /lib64/libpthread.so.0</li>
</ul>
<p>如果你嫌多的话, 还可以执行以下命令, 查找该程序没有使用到的直接依赖文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@7b532cd952dc /]<span class="comment"># ldd -u /usr/sbin/lsof</span></span><br><span class="line">Unused direct dependencies:</span><br><span class="line">	/lib64/libselinux.so.1</span><br></pre></td></tr></table></figure>

<p>也就是说, 在上面的列表中, 可以去掉检查 <code>/lib64/libselinux.so.1</code> 该库文件</p>
<h4 id="检查依赖"><a href="#检查依赖" class="headerlink" title="检查依赖"></a>检查依赖</h4><p><strong>启动一个新的原始镜像进行上面检查列表的查找</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it centos:latest /bin/bash                                                                          </span><br><span class="line">[root@099f82deeb3d /]<span class="comment">#</span></span><br><span class="line">[root@099f82deeb3d /]<span class="comment"># find / -name "libc.so.6"</span></span><br><span class="line">/usr/lib64/libc.so.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># ...... 按照上面的列表文件, 挨个儿查找</span></span><br></pre></td></tr></table></figure>

<p><strong>确保原始镜像中的对应列表文件都已经存在, 如果有部分库文件不存在, 需要在后面的操作中, 和 lsof 主程序文件一同拷贝新的镜像中</strong></p>
<h4 id="拷贝程序及依赖库"><a href="#拷贝程序及依赖库" class="headerlink" title="拷贝程序及依赖库"></a>拷贝程序及依赖库</h4><p>我们将第一启动的容器, 使用 yum 安装了 lsof 命令的容器称之为 A 容器; 将第二次启动的原始容器, 检查了依赖文件的容器称之为 B 容器</p>
<p>将 A 容器的主程序文件以及在 B 容器中缺失的库文件一同拷贝出来(操作对象: A 容器)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到 A 容器的 containerID: 7b532cd952dc</span></span><br><span class="line"><span class="comment"># 我们假设在 B 容器中检查文件列表时, 同时缺失了 `libc.so.6` 库文件 (注意: 是假设!!!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将主文件和缺失的库文件从容器中拷贝到本地目录</span></span><br><span class="line">docker container cp 7b532cd952dc:/usr/sbin/lsof ./                                                                        </span><br><span class="line">docker container cp 7b532cd952dc:/usr/lib64/libc.so.6 ./</span><br></pre></td></tr></table></figure>

<p>然后制作新的镜像, 以支持使用 lsof 命令</p>
<p>新的 dockerfile 内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:latest</span><br><span class="line"></span><br><span class="line">COPY lsof /usr/sbin/</span><br><span class="line">COPY libc.so.6 /usr/lib64/</span><br></pre></td></tr></table></figure>

<p><strong>注意: 由于上面👆我是假设的缺失了libc.so.6文件, 所以在 dockerfile 里加入了这个文件的拷贝, 实际上这个文件在 centos 基础镜像是存在的, 而且是以软连接的形式存在的, 当我们真的<code>COPY libc.so.6 /usr/lib64/</code>这么操作时, 反而会报错. 一定注意: 此处只是演示缺失库文件的处理情况, 库文件已经存在的话, 最好不要动原配!!!</strong></p>
<p>然后我们执行编译新镜像的命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t mycentos:0.2 ./</span><br></pre></td></tr></table></figure>

<p>进入到新的容器验证 lsof 是否可以正常使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container run -it mycentos:0.2 /bin/bash                                                                           </span><br><span class="line">[root@032d75e40f56 /]<span class="comment"># lsof</span></span><br><span class="line">COMMAND PID USER   FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">bash      1 root  cwd    DIR  0,133     4096   47026 /</span><br><span class="line">bash      1 root  rtd    DIR  0,133     4096   47026 /</span><br><span class="line">bash      1 root  txt    REG    8,1   964544  917638 /usr/bin/bash</span><br><span class="line">bash      1 root  mem    REG    8,1    62184  919647 /usr/lib64/libnss_files-2.17.so</span><br><span class="line">bash      1 root  mem    REG    8,1  2173512  919510 /usr/lib64/libc-2.17.so</span><br><span class="line">bash      1 root  mem    REG    8,1    19776  919537 /usr/lib64/libdl-2.17.so</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>支持, 关于为容器镜像定制的Linux工具命令的工作就已经全部完成了, 我们再看下定制版的镜像体积大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls                                                                                                           </span><br><span class="line">REPOSITORY                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">mycentos                                      0.2                 805d98b565c8        7 minutes ago       201MB</span><br></pre></td></tr></table></figure>

<p>精简到了只有 <strong>201MB</strong> 与原始的镜像相比, 只增加了 <strong>1MB</strong></p>
<hr>
<p>参考文档:</p>
<ul>
<li>查看程序依赖库: <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/ldd.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>apt</tag>
        <tag>image</tag>
        <tag>yum</tag>
        <tag>ldd</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下查看开机启动项</title>
    <url>/2018/10/11/CentOS7%E4%B8%8B%E6%9F%A5%E7%9C%8B%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8%E9%A1%B9/</url>
    <content><![CDATA[<h1 id="查看开机启动项"><a href="#查看开机启动项" class="headerlink" title="查看开机启动项"></a>查看开机启动项</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl list-unit-files</span><br></pre></td></tr></table></figure>

<h1 id="查看某一服务是否开启启动"><a href="#查看某一服务是否开启启动" class="headerlink" title="查看某一服务是否开启启动"></a>查看某一服务是否开启启动</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl is-enabled kubelet.service</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>systemctl</tag>
      </tags>
  </entry>
  <entry>
    <title>kubelet删除Pod报device or resource busy</title>
    <url>/2018/10/11/Kubelet%E5%88%A0%E9%99%A4Pod%E6%8A%A5device-or-resource-busy/</url>
    <content><![CDATA[<p>删除 deployment 资源后, 某些 pod 资源的状态一直显示 Terminating, 进入到该 pod 所在的宿主机, 查看 kubelet 日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">journalctl -u kubelet -f</span><br></pre></td></tr></table></figure>

<p>会发现有删除某些目录/文件 <code>device or resource busy</code> 的错误出现, 说明有其他的进程在挂载容器内使用的目录</p>
<p>使用如下脚本, 检查目录挂载情况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node ~]<span class="comment"># cat leak.sh </span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">declare</span> -A map</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `find /proc/*/mounts -<span class="built_in">exec</span> grep <span class="variable">$1</span> &#123;&#125; + 2&gt;/dev/null | awk <span class="string">'&#123;print $1"#"$2&#125;'</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    pid=`<span class="built_in">echo</span> <span class="variable">$i</span> | awk -F <span class="string">"[/]"</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line">    point=`<span class="built_in">echo</span> <span class="variable">$i</span> | awk -F <span class="string">"[#]"</span> <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line">    mnt=`ls -l /proc/<span class="variable">$pid</span>/ns/mnt |awk <span class="string">'&#123;print $11&#125;'</span>`</span><br><span class="line">    map[<span class="string">"<span class="variable">$mnt</span>"</span>]=<span class="string">"exist"</span></span><br><span class="line">    cmd=`cat /proc/<span class="variable">$pid</span>/cmdline`</span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">"<span class="variable">$pid</span>\t<span class="variable">$mnt</span>\t<span class="variable">$cmd</span>\t<span class="variable">$point</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `ps aux|grep docker-containerd-shim |grep -v <span class="string">"grep"</span> |awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    mnt=`ls -l /proc/<span class="variable">$i</span>/ns/mnt  2&gt;/dev/null | awk <span class="string">'&#123;print $11&#125;'</span>`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;map[$mnt]&#125;</span>"</span> == <span class="string">"exist"</span> ]];<span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$mnt</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>执行脚本, 后跟<code>device or resource busy</code>的目录绝对路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh leak.sh &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;81791176-a505-11e7-accf-5254fe5a9007&#x2F;volumes&#x2F;kubernetes.io~secret&#x2F;default-token-pzyxh</span><br></pre></td></tr></table></figure>

<p>执行后, 可以看到该目录被哪些进程所挂载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8392    mnt:[4026532536]    &#x2F;bin&#x2F;bash&#x2F;start.sh--logtostderr -v&#x3D;2    &#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;81791176-a505-11e7-accf-5254fe5a9007&#x2F;volumes&#x2F;kubernetes.io~secret&#x2F;default-token-pzyxh</span><br></pre></td></tr></table></figure>

<p>一级一级往上追踪父进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@k8s-node ~]<span class="comment"># ps -ef | grep 8392</span></span><br><span class="line">root      8392  8345  0 9月30 ?       00:00:00 /bin/bash /start.sh --logtostderr -v=2</span><br><span class="line">root      8420  8392  0 9月30 ?       00:17:19 /usr/bin/python /usr/bin/supervisord -c supervisord.conf</span><br><span class="line">root     13757  7126  0 13:35 pts/2    00:00:00 grep --color=auto 8392</span><br><span class="line">[root@k8s-node ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>我遇到的情况是另一个专门用于收集日志的容器, 挂载了这个容器中的数据目录, 导致删除该容器时, 报<code>device or resource busy</code>的错误</p>
<p>这种情况下, 你可以是用<code>kubectl exec</code>或<code>docker exec</code>进入到容器中, 将该目录 umount 掉, 过一会儿, 该 pod 即可被 Kubernetes 正确删除</p>
<hr>
<p>参考文档:</p>
<ul>
<li><a href="https://www.jianshu.com/p/4fc11a0a31da" target="_blank" rel="noopener">https://www.jianshu.com/p/4fc11a0a31da</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubelet</tag>
        <tag>Pod</tag>
        <tag>Terminating</tag>
      </tags>
  </entry>
  <entry>
    <title>ca证书验证</title>
    <url>/2018/10/09/ca%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81/</url>
    <content><![CDATA[<h1 id="验证证书是否是某-ca-机构颁发"><a href="#验证证书是否是某-ca-机构颁发" class="headerlink" title="验证证书是否是某 ca 机构颁发"></a>验证证书是否是某 ca 机构颁发</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@k8s-master:/var/lib/kubelet/pki<span class="comment"># openssl verify -CAfile /etc/kubernetes/pki/ca.crt kubelet-client-current.pem</span></span><br><span class="line">kubelet-client-current.pem: OK</span><br></pre></td></tr></table></figure>

<p><code>kubelet-client-current.pem</code> 证书是 <code>/etc/kubernetes/pki/ca.crt</code> 该 ca 机构颁发</p>
<h1 id="查看证书详情"><a href="#查看证书详情" class="headerlink" title="查看证书详情"></a>查看证书详情</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@k8s-master:~/ssl/admin<span class="comment"># openssl x509 -in /etc/kubernetes/pki/front-proxy-client.crt -text -noout</span></span><br><span class="line">Certificate:</span><br><span class="line">    Data:</span><br><span class="line">        Version: 3 (0x2)</span><br><span class="line">        Serial Number: 8005382448281716991 (0x6f18d4ec20fa88ff)</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">        Issuer: CN=kubernetes</span><br><span class="line">        Validity</span><br><span class="line">            Not Before: Sep 11 15:15:40 2018 GMT</span><br><span class="line">            Not After : Sep 11 15:15:40 2019 GMT</span><br><span class="line">        Subject: CN=front-proxy-client</span><br><span class="line">        Subject Public Key Info:</span><br><span class="line">            Public Key Algorithm: rsaEncryption</span><br><span class="line">                Public-Key: (2048 bit)</span><br><span class="line">                Modulus:</span><br><span class="line">                    00:c5:b4:21:b9:ad:4e:19:25:e2:12:78:5b:e3:75:</span><br><span class="line">                    3f:41:70:8d:05:f6:30:7f:72:8d:e7:cb:8b:82:de:</span><br><span class="line">                    be:be:fb:5b:57:fd:4f:7d:12:b7:e3:a8:d3:05:02:</span><br><span class="line">                    59:83:95:dd:14:19:c9:13:cf:96:80:1e:f0:70:39:</span><br><span class="line">                    30:4c:b6:a4:5b:47:83:14:04:fd:b7:b9:6d:4b:3d:</span><br><span class="line">                    a0:f1:e3:39:68:5d:b4:7d:af:3e:99:aa:43:30:d9:</span><br><span class="line">                    e9:45:87:47:c2:4f:61:81:0b:d3:f7:83:bb:98:5c:</span><br><span class="line">                    8e:e5:97:16:8e:23:a3:03:28:19:58:ee:3a:6b:de:</span><br><span class="line">                    ad:bf:54:42:90:80:4f:8f:28:76:bc:49:8d:35:d1:</span><br><span class="line">                    2e:e5:37:8a:aa:d2:be:ec:be:12:d6:b8:88:0b:85:</span><br><span class="line">                    88:1b:7d:1e:23:37:25:2d:c0:ea:d6:4e:6b:5f:81:</span><br><span class="line">                    93:26:6e:be:69:a1:67:e5:75:9a:85:db:a4:56:30:</span><br><span class="line">                    54:13:21:c5:41:46:9a:fd:c9:41:11:13:b9:b8:77:</span><br><span class="line">                    ba:74:26:85:5c:e2:78:b6:61:3b:5f:3c:bc:1a:00:</span><br><span class="line">                    3a:e7:e7:2d:a7:3a:04:17:46:86:66:c3:6c:25:3a:</span><br><span class="line">                    f5:b5:fa:d6:28:cc:7c:6e:08:47:2f:0e:08:f2:8a:</span><br><span class="line">                    46:33:e1:00:d7:9a:ce:e8:fe:80:e9:80:c4:58:53:</span><br><span class="line">                    c4:f1</span><br><span class="line">                Exponent: 65537 (0x10001)</span><br><span class="line">        X509v3 extensions:</span><br><span class="line">            X509v3 Key Usage: critical</span><br><span class="line">                Digital Signature, Key Encipherment</span><br><span class="line">            X509v3 Extended Key Usage:</span><br><span class="line">                TLS Web Client Authentication</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">         41:0b:22:92:b5:33:4a:57:76:2f:69:51:12:d1:64:46:4d:f9:</span><br><span class="line">         72:1d:bb:32:2a:f4:c1:e4:58:ae:a3:53:be:8b:b3:da:6b:10:</span><br><span class="line">         ee:4a:15:4d:ad:71:27:6b:d5:dc:ff:12:56:a8:b7:8e:fd:b3:</span><br><span class="line">         ae:90:07:26:6b:e3:16:11:c7:56:79:db:04:f8:09:ca:c5:19:</span><br><span class="line">         c9:0c:54:8e:84:d0:09:e2:34:ed:9b:9c:b4:e8:6a:ae:6a:d1:</span><br><span class="line">         b2:b6:51:22:1c:c0:67:da:9d:1b:06:da:b7:cf:42:2a:98:38:</span><br><span class="line">         d0:48:93:4d:ef:71:73:60:6c:09:19:1d:d9:4e:f1:2d:d2:d4:</span><br><span class="line">         a5:e9:2c:a9:5a:b1:39:54:27:07:09:81:29:54:f8:37:20:db:</span><br><span class="line">         70:8e:7d:16:23:4f:5b:21:a3:02:df:a6:a9:87:f6:a0:10:4a:</span><br><span class="line">         43:73:97:4d:14:b7:4b:06:00:1c:c6:a8:45:d8:97:df:0e:1e:</span><br><span class="line">         70:87:98:ee:08:1f:31:e7:cf:6d:9d:06:05:47:8f:6a:e6:10:</span><br><span class="line">         c8:d7:0a:d3:7a:36:42:a5:05:ef:ba:bb:26:58:aa:ac:<span class="built_in">fc</span>:8d:</span><br><span class="line">         e4:11:45:12:ef:49:b9:fb:7a:f1:74:c7:41:d5:2f:1b:c2:15:</span><br><span class="line">         7d:87:e1:28:7d:05:e5:59:dc:1d:16:0f:e5:ac:a0:07:e4:f0:</span><br><span class="line">         cf:21:42:a4</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>ca</tag>
        <tag>证书</tag>
        <tag>openssl</tag>
        <tag>crt</tag>
        <tag>key</tag>
        <tag>pem</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubelet的认证和授权</title>
    <url>/2018/10/08/Kubelet-%E7%9A%84%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<p>kubelet 与 kube-apiserver 之间的通信是双向的, kubelet 既需要访问 kube-apiserver 获取分配到自己节点上的 pod 信息, kube-apiserver 也需要主动访问 kubelet 拉取日志, 状态, 监控数据等信息, 所以对两个组件来说, 认证是双向的, kube-apiserver 需要持有 kubelet 的客户端证书, 以完成 kubelet 对自己身份的校验; kubelet 也需要持有 kube-apiserver 的客户端证书, 完成 kube-apiserver 对自己身份的认证.</p>
<h1 id="Kubelet-的认证"><a href="#Kubelet-的认证" class="headerlink" title="Kubelet 的认证"></a>Kubelet 的认证</h1><p>默认情况下, 对 kubelet 的 https 请求, 如果没有被配置的其他身份验证拒绝的话, 则被视为匿名请求, 并为这个请求赋予<code>system:anonymous</code>用户名和<code>system:unauthenticated</code>用户组</p>
<h2 id="禁用匿名访问"><a href="#禁用匿名访问" class="headerlink" title="禁用匿名访问"></a>禁用匿名访问</h2><p>如需要禁用匿名访问, 可以在启动 kubelet Daemon 时加入<code>--anonymous-auth=false</code>配置, 当有匿名访问时, 将回复<code>401 Unauthorized</code>响应未认证的请求</p>
<h2 id="开启-X509-认证"><a href="#开启-X509-认证" class="headerlink" title="开启 X509 认证"></a>开启 X509 认证</h2><ul>
<li>kubelet 启动时添加<code>--client-ca-file</code>参数, 并指定签发客户端证书的 ca 根证书所在路径</li>
<li>kube-apiserver 启动时添加<code>--kubelet-client-certificate</code>和<code>--kubelet-client-key</code>参数, 并分别为其指定由 kubelet ca 根证书签发的客户端证书和秘钥</li>
</ul>
<h1 id="Kubelet-的授权"><a href="#Kubelet-的授权" class="headerlink" title="Kubelet 的授权"></a>Kubelet 的授权</h1><p>任何被成功认证的请求(包括匿名请求)都将被授权. 默认的授权模式为<code>AlwaysAllow</code>, 即允许所有类型的请求</p>
<h2 id="细分对-kubelet-API-访问权限的原因"><a href="#细分对-kubelet-API-访问权限的原因" class="headerlink" title="细分对 kubelet API 访问权限的原因"></a>细分对 kubelet API 访问权限的原因</h2><ul>
<li>匿名访问启用时, 应限制其调用 kubelet API 的能力</li>
<li>客户端证书身份认证启用时, 只允许配置 CA 签名的客户端证书使用 kubelet API</li>
</ul>
<h2 id="细分权限"><a href="#细分权限" class="headerlink" title="细分权限"></a>细分权限</h2><ul>
<li>确保<code>authorization.k8s.io/v1beta1</code>该 API Group 在 kube-apiserver 中是被启动的状态</li>
<li>在 kubelet Daemon 启动参数中, 确保配置了<code>--authorization-mode=Webhook</code>和<code>--kubeconfig</code>两个参数</li>
</ul>
<p>kubelet 在接收到每个请求后, 会向指定的 kube-apiserver 发起 <code>SubjectAccessReview</code> API 的请求, 来确定该请求是否被允许</p>
<hr>
<p><strong>参考文档</strong></p>
<ul>
<li>官方文档  <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-authentication-authorization/</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>kubelet</tag>
        <tag>Authentication</tag>
        <tag>Authorization</tag>
      </tags>
  </entry>
  <entry>
    <title>详解kubeadm生成的证书</title>
    <url>/2018/09/28/%E8%AF%A6%E8%A7%A3kubeadm%E7%94%9F%E6%88%90%E7%9A%84%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<blockquote>
<p>如果你使用过kubeadm部署过Kubernetes的环境, master主机节点上就一定会在相应的目录创建了一大批证书文件, 本篇文章就来说说kubeadm到底为我们生成了哪些证书</p>
</blockquote>
<p>在Kubernetes的部署中, 创建证书, 配置证书是一道绕不过去坎儿, 好在有kubeadm这样的自动化工具, 帮我们去生成, 配置这些证书. 对于只是想体验Kubernetes或只是想测试的亲来说, 这已经够了, 但是作为Kubernetes的集群维护者来说, kubeadm更像是一个黑盒, 本篇文章就来说说黑盒中关于证书的事儿~</p>
<p>使用kubeadm创建完Kubernetes集群后, 默认会在<code>/etc/kubernetes/pki</code>目录下存放集群中需要用到的证书文件, 整体结构如下图所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root@k8s-master:&#x2F;etc&#x2F;kubernetes&#x2F;pki# tree</span><br><span class="line">.</span><br><span class="line">|-- apiserver.crt</span><br><span class="line">|-- apiserver-etcd-client.crt</span><br><span class="line">|-- apiserver-etcd-client.key</span><br><span class="line">|-- apiserver.key</span><br><span class="line">|-- apiserver-kubelet-client.crt</span><br><span class="line">|-- apiserver-kubelet-client.key</span><br><span class="line">|-- ca.crt</span><br><span class="line">|-- ca.key</span><br><span class="line">|-- etcd</span><br><span class="line">|   |-- ca.crt</span><br><span class="line">|   |-- ca.key</span><br><span class="line">|   |-- healthcheck-client.crt</span><br><span class="line">|   |-- healthcheck-client.key</span><br><span class="line">|   |-- peer.crt</span><br><span class="line">|   |-- peer.key</span><br><span class="line">|   |-- server.crt</span><br><span class="line">|   &#96;-- server.key</span><br><span class="line">|-- front-proxy-ca.crt</span><br><span class="line">|-- front-proxy-ca.key</span><br><span class="line">|-- front-proxy-client.crt</span><br><span class="line">|-- front-proxy-client.key</span><br><span class="line">|-- sa.key</span><br><span class="line">&#96;-- sa.pub</span><br><span class="line"></span><br><span class="line">1 directory, 22 files</span><br></pre></td></tr></table></figure>

<p>以上22个文件就是kubeadm为我们创建的所有证书相关的文件, 下面我们来一一解析</p>
<h2 id="证书分组"><a href="#证书分组" class="headerlink" title="证书分组"></a>证书分组</h2><p>Kubernetes把证书放在了两个文件夹中</p>
<ul>
<li>/etc/kubernetes/pki</li>
<li>/etc/kubernetes/pki/etcd</li>
</ul>
<p>我们再将这22个文件按照更细的粒度去分组</p>
<h2 id="Kubernetes-集群根证书"><a href="#Kubernetes-集群根证书" class="headerlink" title="Kubernetes 集群根证书"></a>Kubernetes 集群根证书</h2><p>Kubernetes 集群根证书CA(Kubernetes集群组件的证书签发机构)</p>
<ul>
<li><code>/etc/kubernetes/pki/ca.crt</code></li>
<li><code>/etc/kubernetes/pki/ca.key</code></li>
</ul>
<p>以上这组证书为签发其他Kubernetes组件证书使用的根证书, 可以认为是Kubernetes集群中证书签发机构之一</p>
<p>由此根证书签发的证书有:</p>
<ol>
<li><p>kube-apiserver 组件持有的服务端证书</p>
<ul>
<li><code>/etc/kubernetes/pki/apiserver.crt</code></li>
<li><code>/etc/kubernetes/pki/apiserver.key</code></li>
</ul>
</li>
<li><p>kubelet 组件持有的客户端证书, 用作 kube-apiserver 主动向 kubelet 发起请求时的客户端认证</p>
<ul>
<li><code>/etc/kubernetes/pki/apiserver-kubelet-client.crt</code></li>
<li><code>/etc/kubernetes/pki/apiserver-kubelet-client.key</code></li>
</ul>
</li>
</ol>
<blockquote>
<p>注意: Kubernetes集群组件之间的交互是双向的, kubelet 既需要主动访问 kube-apiserver, kube-apiserver 也需要主动向 kubelet 发起请求, 所以双方都需要有自己的根证书以及使用该根证书签发的服务端证书和客户端证书. 在 kube-apiserver 中, 一般明确指定用于 https 访问的服务端证书和带有<code>CN 用户名</code>信息的客户端证书. 而在 kubelet 的启动配置中, 一般只指定了 ca 根证书, 而没有明确指定用于 https 访问的服务端证书, 这是因为, 在生成服务端证书时, 一般会指定服务端地址或主机名, kube-apiserver 相对变化不是很频繁, 所以在创建集群之初就可以预先分配好用作 kube-apiserver 的 IP 或主机名/域名, 但是由于部署在 node 节点上的 kubelet 会因为集群规模的变化而频繁变化, 而无法预知 node 的所有 IP 信息, 所以 kubelet 上一般不会明确指定服务端证书, 而是只指定 ca 根证书, 让 kubelet 根据本地主机信息自动生成服务端证书并保存到配置的<code>cert-dir</code>文件夹中.</p>
</blockquote>
<p>好了, 至此, Kubernetes集群根证书所签发的证书都在上面了, 算上根证书一共涉及到6个文件, 22-6=16, 我们还剩下16个文件</p>
<h2 id="汇聚层证书"><a href="#汇聚层证书" class="headerlink" title="汇聚层证书"></a>汇聚层证书</h2><p>kube-apiserver 的另一种访问方式就是使用 <code>kubectl proxy</code> 来代理访问, 而该证书就是用来支持SSL代理访问的. 在该种访问模式下, 我们是以http的方式发起请求到代理服务的, 此时, 代理服务会将该请求发送给 kube-apiserver, 在此之前, 代理会将发送给 kube-apiserver 的请求头里加入证书信息, 以下两个配置</p>
<p>API Aggregation允许在不修改Kubernetes核心代码的同时扩展Kubernetes API.  开启 API Aggregation 需要在 kube-apiserver 中添加如下配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--requestheader-client-ca-file&#x3D;&lt;path to aggregator CA cert&gt;</span><br><span class="line">--requestheader-allowed-names&#x3D;front-proxy-client</span><br><span class="line">--requestheader-extra-headers-prefix&#x3D;X-Remote-Extra-</span><br><span class="line">--requestheader-group-headers&#x3D;X-Remote-Group</span><br><span class="line">--requestheader-username-headers&#x3D;X-Remote-User</span><br><span class="line">--proxy-client-cert-file&#x3D;&lt;path to aggregator proxy cert&gt;</span><br><span class="line">--proxy-client-key-file&#x3D;&lt;path to aggregator proxy key&gt;</span><br></pre></td></tr></table></figure>

<p><strong>官方警告: 除非你了解保护 CA 使用的风险和机制, 否则不要在不通上下文中重用已经使用过的 CA</strong></p>
<p>如果 kube-proxy 没有和 API server 运行在同一台主机上，那么需要确保启用了如下 apiserver 标记：</p>
<p><code>--enable-aggregator-routing=true</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端 ---发起请求---&gt; 代理 ---Add Header:发起请求---&gt; kube-apiserver</span><br><span class="line">                   (客户端证书)                        (服务端证书)</span><br></pre></td></tr></table></figure>

<p>kube-apiserver 代理根证书(客户端证书)</p>
<p>用在<code>requestheader-client-ca-file</code>配置选项中, kube-apiserver 使用该证书来验证客户端证书是否为自己所签发</p>
<ul>
<li><code>/etc/kubernetes/pki/front-proxy-ca.crt</code></li>
<li><code>/etc/kubernetes/pki/front-proxy-ca.key</code></li>
</ul>
<p>由此根证书签发的证书只有一组:</p>
<p>代理层(如汇聚层aggregator)使用此套代理证书来向 kube-apiserver 请求认证</p>
<ol>
<li>代理端使用的客户端证书, 用作代用户与 kube-apiserver 认证<ul>
<li><code>/etc/kubernetes/pki/front-proxy-client.crt</code></li>
<li><code>/etc/kubernetes/pki/front-proxy-client.key</code></li>
</ul>
</li>
</ol>
<p>参考文档:</p>
<ul>
<li>kube-apiserver 配置参数: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/" target="_blank" rel="noopener">https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/</a></li>
<li>使用汇聚层扩展 Kubernetes API: <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/apiserver-aggregation/</a></li>
<li>配置汇聚层: <a href="https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/access-kubernetes-api/configure-aggregation-layer/</a></li>
</ul>
<p>至此, 刨除代理专用的证书外, 还剩下 16-4=12 个文件</p>
<h2 id="etcd-集群根证书"><a href="#etcd-集群根证书" class="headerlink" title="etcd 集群根证书"></a>etcd 集群根证书</h2><p>etcd集群所用到的证书都保存在<code>/etc/kubernetes/pki/etcd</code>这路径下, 很明显, 这一套证书是用来专门给etcd集群服务使用的, 设计以下证书文件</p>
<p>etcd 集群根证书CA(etcd 所用到的所有证书的签发机构)</p>
<ul>
<li><code>/etc/kubernetes/pki/etcd/ca.crt</code></li>
<li><code>/etc/kubernetes/pki/etcd/ca.key</code></li>
</ul>
<p>由此根证书签发机构签发的证书有:</p>
<ol>
<li><p>etcd server 持有的服务端证书</p>
<ul>
<li><code>/etc/kubernetes/pki/etcd/server.crt</code></li>
<li><code>/etc/kubernetes/pki/etcd/server.key</code></li>
</ul>
</li>
<li><p>peer 集群中节点互相通信使用的客户端证书</p>
<ul>
<li><p><code>/etc/kubernetes/pki/etcd/peer.crt</code></p>
</li>
<li><p><code>/etc/kubernetes/pki/etcd/peer.key</code></p>
<p>注: Peer：对同一个etcd集群中另外一个Member的称呼</p>
</li>
</ul>
</li>
<li><p>pod 中定义 Liveness 探针使用的客户端证书</p>
<p>kubeadm 部署的 Kubernetes 集群是以 pod 的方式运行 etcd 服务的, 在该 pod 的定义中, 配置了 Liveness 探活探针</p>
<ul>
<li><p><code>/etc/kubernetes/pki/etcd/healthcheck-client.crt</code></p>
</li>
<li><p><code>/etc/kubernetes/pki/etcd/healthcheck-client.key</code></p>
<p>当你 describe etcd 的 pod 时, 会看到如下一行配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Liveness:       exec [&#x2F;bin&#x2F;sh -ec ETCDCTL_API&#x3D;3 etcdctl --endpoints&#x3D;https:&#x2F;&#x2F;[127.0.0.1]:2379 --cacert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;ca.crt --cert&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.crt --key&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;pki&#x2F;etcd&#x2F;healthcheck-client.key get foo] delay&#x3D;15s timeout&#x3D;15s period&#x3D;10s #success&#x3D;1 #failure&#x3D;8</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置在 kube-apiserver 中用来与 etcd server 做双向认证的客户端证书</p>
<ul>
<li><code>/etc/kubernetes/pki/apiserver-etcd-client.crt</code></li>
<li><code>/etc/kubernetes/pki/apiserver-etcd-client.key</code></li>
</ul>
</li>
</ol>
<p>至此, 介绍了涉及到 etcd 服务的10个证书文件, 12-10=2, 仅剩两个没有介绍到的文件啦, 胜利✌️在望, 坚持一下~</p>
<h2 id="Serveice-Account秘钥"><a href="#Serveice-Account秘钥" class="headerlink" title="Serveice Account秘钥"></a>Serveice Account秘钥</h2><p>最后介绍的这组”证书”其实不是证书, 而是一组秘钥. 看着后缀名是不是有点眼熟呢, 没错, 这组秘钥对儿其实跟我们在Linux上创建, 用于免密登录的密钥对儿原理是一样的~</p>
<blockquote>
<p>这组的密钥对儿仅提供给 kube-controller-manager 使用. kube-controller-manager 通过 sa.key 对 token 进行签名, master 节点通过公钥 sa.pub 进行签名的验证</p>
</blockquote>
<ul>
<li><code>/etc/kubernetes/pki/sa.key</code></li>
<li><code>/etc/kubernetes/pki/sa.pub</code></li>
</ul>
<p>至此, kubeadm 工具帮我们创建的所有证书文件都已经介绍完了, 整个 Kubernetes&amp;etcd 集群中所涉及到的绝大部分证书都差不多在这里了. 有的行家可能会看出来, 至少还少了一组证书呀, 就是 kube-proxy 持有的证书怎么没有自动生成呀. 因为 kubeadm 创建的集群, kube-proxy 是以 pod 形式运行的, 在 pod 中, 直接使用 service account 与 kube-apiserver 进行认证, 此时就不需要再单独为 kube-proxy 创建证书了. 如果你的 kube-proxy 是以守护进程的方式直接运行在宿主机的, 那么你就需要为它创建一套证书了. 创建的方式也很简单, 直接使用上面第一条提到的 <code>Kubernetes 集群根证书</code> 进行签发就可以了(注意CN和O的设置)</p>
<p>下一篇文章中, 将实际操作创建所有证书的流程(含kube-proxy证书), 并逐一解释参数的使用</p>
<hr>
<p>参考文档:</p>
<ul>
<li>PKI 认证: <a href="https://kubernetes.io/docs/setup/certificates/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/certificates/</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
        <tag>证书</tag>
        <tag>crt</tag>
        <tag>key</tag>
        <tag>pem</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP基本概念</title>
    <url>/2018/09/18/HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>#HTTP发展历史</p>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><ul>
<li>只有一个GET方法</li>
<li>没有header等描述数据信息</li>
<li>服务器发送完毕, 就关闭TCP连接</li>
</ul>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><ul>
<li>增加了很多方法, 例如POST, PUT, DELETE等</li>
<li>增加了status code和header</li>
<li>增加了多字符集的支持, 多部分发送, 权限, 缓存等</li>
</ul>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><ul>
<li>持久连接/长连接</li>
<li>Pipeline 客户端可以在同一个连接中发送多个请求, 服务端按顺序返回(串行)</li>
<li>增加host头, 有了host之后可以实现一台web服务可以接收/处理多个域名的请求</li>
<li>增加了其他更多的方法</li>
</ul>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><ul>
<li>2.0所有的数据以二进制进行传输(帧), 在1.1大部分是以字符串的形式传输</li>
<li>得益于基于帧的传输, 可以实现在同一个连接里面发送多个请求不再需要按顺序来返回(并行)</li>
<li>头信息压缩, 1.1的header头以字符串的形式进行传输, 占用了大量带宽</li>
<li>推送, 1.1之前只支持客户端主动向服务端发起请求, 服务端被动向客户端响应请求; 2.0之后服务可以主动向客户端发送数据(例子🌰: 客户端在发起请求访问服务端页面时, 先请求html页面, 当客户端收到服务端发来的html数据之后, 客户端浏览器进行解析并渲染, 在其中, 发现了引用到了其他文件, 如css, js文件, 均以url链接形式引用, 此时浏览器会按顺序再次对新的资源发起请求; 2.0中, 此场景下, 客户端在请求了html页面后, 服务端可以实现主动将css, js数据推送到客户端, 从而解决了1.1串行请求资源的性能低下问题. 并且服务端主动推送资源到客户端, 也可以解决客户端因各种原因, 请求不到指定资源的情况)</li>
</ul>
<p>2.0 以提高效率为主要目标对1.1进行了大量改进</p>
<h1 id="经典五层模型"><a href="#经典五层模型" class="headerlink" title="经典五层模型"></a>经典五层模型</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">应用层  —&gt; HTTP&#x2F;FTP</span><br><span class="line">    🔽</span><br><span class="line">传输层  —&gt; TCP&#x2F;UDP</span><br><span class="line">    🔽</span><br><span class="line">网络层: 数据在节点之间传输创建逻辑链路</span><br><span class="line">    🔽</span><br><span class="line">数据链路层: 在通信的实体间建立数据链路连接(0101)</span><br><span class="line">    🔽</span><br><span class="line">物理层: 定义物理设备如何传输数据</span><br></pre></td></tr></table></figure>

<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>向用户提供可靠的端到端的服务, 传输层向高层屏蔽了下层数据通信的细节</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>为应用软件提供服务, 构建在传输层协议之上, 屏蔽网络通信细节</p>
<h1 id="HTTP-TCP-的三次握手"><a href="#HTTP-TCP-的三次握手" class="headerlink" title="HTTP(TCP)的三次握手"></a>HTTP(TCP)的三次握手</h1><p>三次握手是TCP连接中的概念,  HTTP不存在连接的概念, HTTP只有请求和响应的概念</p>
<p>每个HTTP的请求与响应都是需要基于一个TCP的连接的</p>
<p>User http requests ———— <code>TCP connection</code> ———— Server http response</p>
<p>在HTTP 1.0 版本中, 客户端发起一个HTTP请求, 此时, 会创建一条TCP连接通道, 在服务端处理完毕, 响应给客户端之后, 这条TCP连接就会被断掉</p>
<p>在HTTP 1.1版本中, 通过声明特殊的属性, 可以实现一个TCP连接上, 可以发送多个HTTP请求(长连接/Keepalive)</p>
<p>在HTTP 2.0 版本中, 可以实现, 同一个客户端请求同一个服务端, 只需要一个TCP连接即可, 因为2.0版本支持并行发送请求, 和并行接收请求, 不需要再额外创建更多的TCP连接</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">client                                                 server</span><br><span class="line">    ———————SYN&#x3D;1, Seq&#x3D;x—————— &gt;</span><br><span class="line">    &lt;——SYN&#x3D;1, ACK&#x3D;x+1, Seq&#x3D;Y——</span><br><span class="line">    ———————ACK&#x3D;Y+1, Seq&#x3D;Z————&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TCP/HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Go面向对象之结构体和方法</title>
    <url>/2018/08/14/Go%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>go语言只支持封装, 不支持继承和多态. Java是典型的支持面向对象的语言之一, 他本身支持面向对象的三大特征, 封装继承和多态; 到了Python中, Python显式的支持封装和继承, Python多态的特性大家争论不休, 虽然Python没有显式的多态语法, 但是由于Python这种动态语言的设计, 他本身就是多态的; 到了Go这里, 却只支持封装了, 与其说Go语言是一种面向对象的语言, 倒不如说他是一种面向接口的语言</p>
</blockquote>
<p>go语言没有class, 只有struct, Go语言中也没有构造函数的说法</p>
<h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h1><p>在结构体中, 可以为不同的key定义不同的数据类型, 结构体是由一系列具有相同类型或不同类型的数据构成的数据集合</p>
<p>结构体更类似于在传统的分层开发领域中的module层(实体层), 一般情况下, 实体层中的每个成员属性都对应了数据库中数据表的一个字段, 实力层存在的意义在于以对象的形式进行传值. 拿三层开发来说, 一般分为表示层/接口层, 业务逻辑层, 数据访问层. 每层与每层之间的数据流转正是通过引入的实体层, 实例化实体层的对象来实现的. 结构体之于Go, 类似于实体层中的类之于Java</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	ee := employee&#123;id:<span class="number">234</span>, name:<span class="string">"sam"</span>, age:<span class="number">45</span>, department:<span class="string">"daas"</span>, city:<span class="string">"BeiJing"</span>&#125;</span><br><span class="line">	fmt.Println(e)</span><br><span class="line">	fmt.Println(ee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;123 larry 28 paas TangShan&#125;</span><br><span class="line">&#123;234 sam 45 daas BeiJing&#125;</span><br></pre></td></tr></table></figure>

<h1 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> e1 employee  <span class="comment">// 声明e1变量为employee类型</span></span><br><span class="line">	<span class="keyword">var</span> e2 employee  <span class="comment">// 声明e2变量为employee类型</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为e1对象赋值</span></span><br><span class="line">	e1.id = <span class="number">123</span></span><br><span class="line">	e1.name = <span class="string">"larry"</span></span><br><span class="line">	e1.age = <span class="number">28</span></span><br><span class="line">	e1.department = <span class="string">"paas"</span></span><br><span class="line">	e1.city = <span class="string">"TangShan"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为e2对象赋值</span></span><br><span class="line">	e2.id = <span class="number">234</span></span><br><span class="line">	e2.name = <span class="string">"sam"</span></span><br><span class="line">	e2.age = <span class="number">45</span></span><br><span class="line">	e2.department = <span class="string">"daas"</span></span><br><span class="line">	e2.city = <span class="string">"BeiJing"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问结构体对象的成员</span></span><br><span class="line">	fmt.Println(e1.name, e1.age)</span><br><span class="line">	fmt.Println(e2.name, e2.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">larry 28</span><br><span class="line">sam 45</span><br></pre></td></tr></table></figure>

<h1 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printEmpInfo</span><span class="params">(emp employee)</span></span> &#123;</span><br><span class="line">	fmt.Println(emp.name, emp.city)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	ee := employee&#123;id:<span class="number">234</span>, name:<span class="string">"sam"</span>, age:<span class="number">45</span>, department:<span class="string">"daas"</span>, city:<span class="string">"BeiJing"</span>&#125;</span><br><span class="line"></span><br><span class="line">	printEmpInfo(e)</span><br><span class="line">	printEmpInfo(ee)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体用作函数参数的时候, 最像三层开发中的实体层用法</p>
<h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> e1 *employee</span><br><span class="line"></span><br><span class="line">	e1 = &amp;e</span><br><span class="line"></span><br><span class="line">	fmt.Println(e1.age, e.age)</span><br><span class="line"></span><br><span class="line">	e1.age = <span class="number">29</span></span><br><span class="line">	</span><br><span class="line">	fmt.Println(e1.age, e.age)  <span class="comment">// 由于e1对象拿到的是e对象的指针, 所以对任意一个变量赋值都会被更改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">28 28</span><br><span class="line">29 29</span><br></pre></td></tr></table></figure>

<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在Python中, 方法和函数的区别可以简单理解为在类中的函数就叫方法. 在Go语言中, 什么是方法呢, 可以简单认为, 为结构体定义的函数就叫方法</p>
<p>与其他语言不同的是, 为结构体定义的方法, 从形式上看不是写在结构体里面的, 而是写在结构体外面的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体方法</span></span><br><span class="line"><span class="comment">// (emp employee) 在函数名的前面定义了接收者, 类似于其他语言的this, 或是Python的self</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emp employee)</span> <span class="title">printEmpInfo</span><span class="params">(arg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"我是形式参数 %s\n"</span>, arg)</span><br><span class="line">	fmt.Println(emp.name)</span><br><span class="line">	fmt.Println(emp.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	e.printEmpInfo(<span class="string">"PolarSnow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是形式参数 PolarSnow</span><br><span class="line">larry</span><br><span class="line">28</span><br></pre></td></tr></table></figure>

<p>上面的demo中, <code>e.printEmpInfo(&quot;PolarSnow&quot;)</code> e对象调用了printEmpInfo方法, 并显式传递了PolarSnow参数, 其实在背后, 在存在一个隐式传参, 就是e把自己传递给了方法定义中的<code>(emp employee)</code>, 类似于Java中的this, 和Python中的self</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printEmpInfo</span><span class="params">(emp employee, arg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"我是形式参数 %s\n"</span>, arg)</span><br><span class="line">	fmt.Println(emp.name)</span><br><span class="line">	fmt.Println(emp.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	printEmpInfo(e, <span class="string">"PolarSnow"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么写效果是一样的, 只是调用的时候是直接调用函数, 把结构体对象当做形式参数传递, 而不是调用结构体自己的方法, 将自己隐式传递到方法中</p>
<h1 id="结构体方法中隐式传参的问题"><a href="#结构体方法中隐式传参的问题" class="headerlink" title="结构体方法中隐式传参的问题"></a>结构体方法中隐式传参的问题</h1><p><strong>注意: 默认情况下, Go语言所有参数都是传值, <code>func (emp employee) printEmpInfo(arg string)</code> 也不例外, 同样是值传递</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emp employee)</span> <span class="title">setEmpAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	emp.age = age</span><br><span class="line">	fmt.Println(<span class="string">"我是结构体方法里的值"</span>, emp.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	e.setEmpAge(<span class="number">29</span>)</span><br><span class="line">	fmt.Println(<span class="string">"我是结构体方法外面的值"</span>, e.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是结构体方法里的值 29</span><br><span class="line">我是结构体方法外面的值 28</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体方法</span></span><br><span class="line"><span class="comment">// 只要将接收结构体对象的数据类型前加*(取指针) 则方法内对结构体对象成员的修改就会同步到方法外部</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emp *employee)</span> <span class="title">setEmpAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	emp.age = age</span><br><span class="line">	fmt.Println(<span class="string">"我是结构体方法里的值"</span>, emp.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e := employee&#123;id:<span class="number">123</span>, name:<span class="string">"larry"</span>, age:<span class="number">28</span>, department:<span class="string">"paas"</span>, city:<span class="string">"TangShan"</span>&#125;</span><br><span class="line">	<span class="comment">// 调用方不需要任何更改, Go会自动去识别是应该传值还是传址</span></span><br><span class="line">	e.setEmpAge(<span class="number">29</span>)</span><br><span class="line">	fmt.Println(<span class="string">"我是结构体方法外面的值"</span>, e.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是结构体方法里的值 29</span><br><span class="line">我是结构体方法外面的值 29</span><br></pre></td></tr></table></figure>

<p><strong>注意: 只有指针才可以改变结构体中的内容</strong></p>
<p>nil指针也是可以调用方法的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> employee <span class="keyword">struct</span> &#123;</span><br><span class="line">	id <span class="keyword">int</span></span><br><span class="line">	name <span class="keyword">string</span></span><br><span class="line">	age <span class="keyword">int</span></span><br><span class="line">	department <span class="keyword">string</span></span><br><span class="line">	city <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(emp *employee)</span> <span class="title">setEmpAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> emp == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"employee 对象为 nil 指针"</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> e *employee</span><br><span class="line">	e.setEmpAge(<span class="number">29</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employee 对象为 nil 指针</span><br></pre></td></tr></table></figure>

<h1 id="值接收者-vs-指针接收者"><a href="#值接收者-vs-指针接收者" class="headerlink" title="值接收者 vs 指针接收者"></a>值接收者 vs 指针接收者</h1><ul>
<li>要改变内容必须使用指针接收者</li>
<li>结构过大也需要考虑使用指针接受者</li>
<li>一致性: 如果有指针接收者, 最好都是指针接收者</li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>struct</tag>
        <tag>方法</tag>
        <tag>结构体</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之字符和字符串的处理</title>
    <url>/2018/08/13/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在Go语言中, 当我们尝试遍历一个字符串的时候</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"我是带😈emoji的字符串!"</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> s &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d %c\n"</span>, i, ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是带😈emoji的字符串!</span><br><span class="line">0 我</span><br><span class="line">3 是</span><br><span class="line">6 带</span><br><span class="line">9 😈</span><br><span class="line">13 e</span><br><span class="line">14 m</span><br><span class="line">15 o</span><br><span class="line">16 j</span><br><span class="line">17 i</span><br><span class="line">18 的</span><br><span class="line">21 字</span><br><span class="line">24 符</span><br><span class="line">27 串</span><br><span class="line">30 !</span><br></pre></td></tr></table></figure>

<p>每个<code>i</code>对应的都是一个字节, 结果中出现的<code>0 3 6 9</code>是对应了获取底层字节的索引码, 第二个字符的字节码之所以会从第3位开始取, 是因为第一个中文字符其实占用了三个字节, 所以下一个字需要从索引为3的字节开始读取</p>
<p>Go语言中, 有一种数据类型叫<code>rune</code>, 他是由一个<code>int32</code>类型构成的新的数据类型, 专门用来处理Go语言中的字符问题</p>
<p>下面的demo中, 我们使用强制类型转换来将字符串, 强制转换为rune类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">"我是带😈emoji的字符串!"</span></span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, ch := <span class="keyword">range</span> []<span class="keyword">rune</span>(s) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"%d %c\n"</span>, i, ch)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是带😈emoji的字符串!</span><br><span class="line">0 我</span><br><span class="line">1 是</span><br><span class="line">2 带</span><br><span class="line">3 😈</span><br><span class="line">4 e</span><br><span class="line">5 m</span><br><span class="line">6 o</span><br><span class="line">7 j</span><br><span class="line">8 i</span><br><span class="line">9 的</span><br><span class="line">10 字</span><br><span class="line">11 符</span><br><span class="line">12 串</span><br><span class="line">13 !</span><br></pre></td></tr></table></figure>

<p>小结:</p>
<ul>
<li>rune相当于Go语言中的char</li>
<li>使用range遍历position, rune</li>
<li>使用utf8.RuneCountInString来获得字符的长度</li>
<li>使用len(s)来获得字节的长度, len([]rune(s))来获得字符的长度</li>
<li>使用[]byte获得字节</li>
</ul>
<h1 id="使用strings包操作字符串"><a href="#使用strings包操作字符串" class="headerlink" title="使用strings包操作字符串"></a>使用strings包操作字符串</h1><p>一下列出常用的函数, 更多使用方法和demo请参考官方文档: <a href="https://golang.org/pkg/strings/" target="_blank" rel="noopener">https://golang.org/pkg/strings/</a></p>
<h2 id="Compare"><a href="#Compare" class="headerlink" title="Compare"></a>Compare</h2><p><code>func Compare(a, b string) int</code></p>
<p>Compare函数用来比较两个字符串, 返回值为int类型, 如果两个字符串相等, 返回<code>0</code>; 如果<code>a&gt;b</code>返回<code>1</code>; <code>a&lt;b</code>返回<code>-1</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Compare(<span class="string">"a"</span>, <span class="string">"b"</span>))</span><br><span class="line">	fmt.Println(strings.Compare(<span class="string">"a"</span>, <span class="string">"a"</span>))</span><br><span class="line">	fmt.Println(strings.Compare(<span class="string">"b"</span>, <span class="string">"a"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="Contains"><a href="#Contains" class="headerlink" title="Contains"></a>Contains</h2><p><code>func Contains(s, substr string) bool</code></p>
<p>Contains函数用来判断第二个参数的字符串是否是第一个参数字符串的子串, 返回值为bool类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Contains(<span class="string">"seafood"</span>, <span class="string">"foo"</span>))</span><br><span class="line">	fmt.Println(strings.Contains(<span class="string">"seafood"</span>, <span class="string">"bar"</span>))</span><br><span class="line">	fmt.Println(strings.Contains(<span class="string">"seafood"</span>, <span class="string">""</span>))</span><br><span class="line">	fmt.Println(strings.Contains(<span class="string">""</span>, <span class="string">""</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br></pre></td></tr></table></figure>

<h2 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h2><p><code>func Count(s, substr string) int</code></p>
<p>Count函数用来计算子串在s字符串中出现的次数</p>
<h2 id="Fields"><a href="#Fields" class="headerlink" title="Fields"></a>Fields</h2><p><code>func Fields(s string) []string</code></p>
<p>Fields函数以空格为分隔符, 将字符串分割成slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"Fields are: %q"</span>, strings.Fields(<span class="string">"  foo bar  baz   "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fields are: [&quot;foo&quot; &quot;bar&quot; &quot;baz&quot;]</span><br></pre></td></tr></table></figure>

<h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p><code>func Index(s, substr string) int</code></p>
<p>Index函数返回第一个substr在s中出现的位置, 如果没有找到, 将返回<code>-1</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Index(<span class="string">"chicken"</span>, <span class="string">"ken"</span>))</span><br><span class="line">	fmt.Println(strings.Index(<span class="string">"chicken"</span>, <span class="string">"dmr"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<h2 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h2><p><code>func Join(a []string, sep string) string</code></p>
<p>Join函数用来将slice以指定的字符拼接成字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">string</span>&#123;<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>&#125;</span><br><span class="line">	fmt.Println(strings.Join(s, <span class="string">", "</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo, bar, baz</span><br></pre></td></tr></table></figure>

<h2 id="LastIndex"><a href="#LastIndex" class="headerlink" title="LastIndex"></a>LastIndex</h2><p><code>func LastIndex(s, substr string) int</code></p>
<p>LastIndex函数用来查找在s中最后一次出现子串的位置</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(strings.Index(<span class="string">"go gopher"</span>, <span class="string">"go"</span>))</span><br><span class="line">	fmt.Println(strings.LastIndex(<span class="string">"go gopher"</span>, <span class="string">"go"</span>))</span><br><span class="line">	fmt.Println(strings.LastIndex(<span class="string">"go gopher"</span>, <span class="string">"rodent"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">3</span><br><span class="line">-1</span><br></pre></td></tr></table></figure>

<h2 id="Repeat"><a href="#Repeat" class="headerlink" title="Repeat"></a>Repeat</h2><p><code>func Repeat(s string, count int) string</code></p>
<p>Repeat函数返回以指定次数重复的字符(串)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">"ba"</span> + strings.Repeat(<span class="string">"na"</span>, <span class="number">2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">banana</span><br></pre></td></tr></table></figure>

<h2 id="Replace"><a href="#Replace" class="headerlink" title="Replace"></a>Replace</h2><p><code>func Replace(s, old, new string, n int) string</code></p>
<p>替换</p>
<h2 id="Split"><a href="#Split" class="headerlink" title="Split"></a>Split</h2><p><code>func Split(s, sep string) []string</code></p>
<p>将字符串以指定字符切割成slice</p>
<h2 id="Title"><a href="#Title" class="headerlink" title="Title"></a>Title</h2><p><code>func Title(s string) string</code></p>
<p>每个单词的首字符大写</p>
<h2 id="ToLower"><a href="#ToLower" class="headerlink" title="ToLower"></a>ToLower</h2><p><code>func ToLower(s string) string</code></p>
<p>转小写</p>
<h2 id="ToUpper"><a href="#ToUpper" class="headerlink" title="ToUpper"></a>ToUpper</h2><p><code>func ToUpper(s string) string</code></p>
<p>转大写</p>
<h2 id="Trim-TrimLeft-TrimRight"><a href="#Trim-TrimLeft-TrimRight" class="headerlink" title="Trim/TrimLeft/TrimRight"></a>Trim/TrimLeft/TrimRight</h2><p><code>func Trim(s string, cutset string) string</code></p>
<p>去掉两边空格/去掉左边空格/去掉右边空格</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>rune</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之Map</title>
    <url>/2018/08/13/Go%E5%9F%BA%E7%A1%80%E4%B9%8BMap/</url>
    <content><![CDATA[<h2 id="map中的key"><a href="#map中的key" class="headerlink" title="map中的key"></a>map中的key</h2><p>Go语言中对map中的key的数据类型有如下要求:</p>
<ul>
<li>map使用哈希表, key必须可以比较相等</li>
<li>除了slice, map, function的内建类型都可以作为key</li>
<li>struct类型如果不包含第二条中排除的数据类型, 也可以做为key</li>
</ul>
<h2 id="map的声明与赋值"><a href="#map的声明与赋值" class="headerlink" title="map的声明与赋值"></a>map的声明与赋值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[name:larry company:PolarSnow Inc. website:https:&#x2F;&#x2F;lvrui.io]</span><br></pre></td></tr></table></figure>

<h3 id="嵌套Map"><a href="#嵌套Map" class="headerlink" title="嵌套Map"></a>嵌套Map</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"member"</span>: &#123;</span><br><span class="line">			<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">			<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">			<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(m[<span class="string">"member"</span>][<span class="string">"name"</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">larry</span><br></pre></td></tr></table></figure>

<h3 id="其他声明map的方式"><a href="#其他声明map的方式" class="headerlink" title="其他声明map的方式"></a>其他声明map的方式</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)  <span class="comment">// m == empty map</span></span><br><span class="line">	<span class="keyword">var</span> mm <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>  <span class="comment">// mm == nil</span></span><br><span class="line">	fmt.Println(m, mm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[] map[]</span><br></pre></td></tr></table></figure>

<h2 id="map的遍历"><a href="#map的遍历" class="headerlink" title="map的遍历"></a>map的遍历</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">company PolarSnow Inc.</span><br><span class="line">website https:&#x2F;&#x2F;lvrui.io</span><br><span class="line">name larry</span><br></pre></td></tr></table></figure>

<p>注意: map是无序的</p>
<h2 id="读取map中的值"><a href="#读取map中的值" class="headerlink" title="读取map中的值"></a>读取map中的值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m[<span class="string">"website"</span>])</span><br><span class="line"></span><br><span class="line">	fmt.Println(m[<span class="string">"site"</span>])  <span class="comment">// map中无此key, 但是不会报错, 拿到的是string的zero value</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 通常判断map取值有没有成功的方式</span></span><br><span class="line">	<span class="keyword">if</span> address, ok := m[<span class="string">"website"</span>]; ok &#123;</span><br><span class="line">		fmt.Println(address)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Key does not exist"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;lvrui.io</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;lvrui.io</span><br></pre></td></tr></table></figure>

<h2 id="增加-修改元素"><a href="#增加-修改元素" class="headerlink" title="增加/修改元素"></a>增加/修改元素</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"country"</span>] = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	m[<span class="string">"name"</span>] = <span class="string">"Polar Snow"</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[company:PolarSnow Inc. website:https:&#x2F;&#x2F;lvrui.io name:larry]</span><br><span class="line">map[name:larry company:PolarSnow Inc. website:https:&#x2F;&#x2F;lvrui.io country:China]</span><br><span class="line">map[name:Polar Snow company:PolarSnow Inc. website:https:&#x2F;&#x2F;lvrui.io country:China]</span><br></pre></td></tr></table></figure>

<p>Go对map添加/修改元素的操作形式, 与Python相同</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">delete</span>(m, <span class="string">"company"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(m)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[name:larry company:PolarSnow Inc. website:https:&#x2F;&#x2F;lvrui.io]</span><br><span class="line">map[name:larry website:https:&#x2F;&#x2F;lvrui.io]</span><br></pre></td></tr></table></figure>

<h2 id="获取map元素的个数"><a href="#获取map元素的个数" class="headerlink" title="获取map元素的个数"></a>获取map元素的个数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(m))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>


<h2 id="map的应用"><a href="#map的应用" class="headerlink" title="map的应用"></a>map的应用</h2><h3 id="取出所有key和所有value"><a href="#取出所有key和所有value" class="headerlink" title="取出所有key和所有value"></a>取出所有key和所有value</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> &#123;</span><br><span class="line">		<span class="string">"name"</span>: <span class="string">"larry"</span>,</span><br><span class="line">		<span class="string">"company"</span>: <span class="string">"PolarSnow Inc."</span>,</span><br><span class="line">		<span class="string">"website"</span>: <span class="string">"https://lvrui.io"</span>,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> key []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">var</span> value []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		key = <span class="built_in">append</span>(key, k)</span><br><span class="line">		value = <span class="built_in">append</span>(value, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(key)</span><br><span class="line">	fmt.Println(value)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[name company website]</span><br><span class="line">[larry PolarSnow Inc. https:&#x2F;&#x2F;lvrui.io]</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之range遍历</title>
    <url>/2018/08/13/Go%E5%9F%BA%E7%A1%80%E4%B9%8Brange%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>Go语言的<code>range</code>关键字用于在<code>for</code>语句中遍历数组Array, Slice, Map和Channel中的元素.</p>
</blockquote>
<h1 id="遍历Array"><a href="#遍历Array" class="headerlink" title="遍历Array"></a>遍历Array</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个array</span></span><br><span class="line">	arr := [<span class="number">4</span>]<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line">	<span class="comment">// 遍历array</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br></pre></td></tr></table></figure>

<h1 id="遍历Slice"><a href="#遍历Slice" class="headerlink" title="遍历Slice"></a>遍历Slice</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个slice</span></span><br><span class="line">	arr := []<span class="keyword">string</span> &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>&#125;</span><br><span class="line">	<span class="comment">// 遍历array</span></span><br><span class="line">	<span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">		fmt.Println(i, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 a</span><br><span class="line">1 b</span><br><span class="line">2 c</span><br><span class="line">3 d</span><br></pre></td></tr></table></figure>

<h1 id="遍历Map"><a href="#遍历Map" class="headerlink" title="遍历Map"></a>遍历Map</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个map</span></span><br><span class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">"k1"</span>: <span class="string">"polarsnow"</span>, <span class="string">"k2"</span>: <span class="string">"larry"</span>, <span class="string">"k3"</span>: <span class="string">"lyu"</span>&#125;</span><br><span class="line">	<span class="comment">// 遍历array</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">k1 polarsnow</span><br><span class="line">k2 larry</span><br><span class="line">k3 lyu</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>range</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump unknown table &#39;column_statistics&#39; in information_schema</title>
    <url>/2018/08/08/mysqldump-unknown-table-column-statistics-in-information-schema/</url>
    <content><![CDATA[<p>如果使用MySQL 8.0+版本提供的命令行工具mysqldump来导出低于8.0版本的MySQL数据库到SQL文件，会出现<code>Unknown table &#39;column_statistics&#39; in information_schema</code>的错误，因为早期版本的MySQL数据库的information_schema数据库中没有名为COLUMN_STATISTICS的数据表。  </p>
<p>解决方法: 使用8.0以前版本MySQL附带的mysqldump工具，最好使用待备份的MySQL服务器版本对应版本号的mysqldump工具.</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>mysqldump</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语言实现工厂方法设计模式</title>
    <url>/2018/08/08/Python%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>根据软件设计原则中<code>开放封闭原则</code>的指导思想, 一个类写好后，尽量不要修改里面的内容, 而是通过添加新的继承应对变化, 简单工厂不符合这个设计原则, 所以本篇文章将使用伪代码介绍工厂方法设计模式的使用</p>
</blockquote>
<p>背景: 现公司监控系统报警需要对接企业微信公众号, 由于未认证企业微信推送消息的限制, 默认每天推送条数上限为<code>6000</code>条, 考虑到报警系统多, 规则没有收敛, 接收的人员多, 每天6000条可能不够用, 所以需要创建多个未认证的企业微信账号用于发送报警信息. 我们将以此需求为背景, 演示工厂方法的设计模式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChat</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_image</span><span class="params">(self, imageid)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountA</span><span class="params">(WeChat)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号A推送信息: "</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_image</span><span class="params">(self, imageid)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号A推送图片: "</span>, imageid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountB</span><span class="params">(WeChat)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号B推送信息: "</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_image</span><span class="params">(self, imageid)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号B推送图片: "</span>, imageid)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeChatFactory</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_wechat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountAFactory</span><span class="params">(WeChatFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_wechat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> AccountA()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountBFactory</span><span class="params">(WeChatFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_wechat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> AccountB()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	<span class="comment"># 实例化账号A</span></span><br><span class="line">    wechat_factory_a = AccountAFactory()</span><br><span class="line">	<span class="comment"># 创建账号A的微信对象</span></span><br><span class="line">    wechat1 = wechat_factory_a.create_wechat()</span><br><span class="line">    wechat2 = wechat_factory_a.create_wechat()</span><br><span class="line">    wechat3 = wechat_factory_a.create_wechat()</span><br><span class="line">	<span class="comment"># 使用账号A对象发送信息</span></span><br><span class="line">    wechat1.send_message(content=<span class="string">"haha"</span>)</span><br><span class="line">    wechat2.send_message(content=<span class="string">"hehe"</span>)</span><br><span class="line">    wechat3.send_message(content=<span class="string">"xixi"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 实例化账号B</span></span><br><span class="line">    wechat_factory_b = AccountBFactory()</span><br><span class="line">	<span class="comment"># 创建账号B的微信对象</span></span><br><span class="line">    wechat4 = wechat_factory_b.create_wechat()</span><br><span class="line">    wechat5 = wechat_factory_b.create_wechat()</span><br><span class="line">	<span class="comment"># 使用账号B对象发送信息</span></span><br><span class="line">    wechat4.send_message(content=<span class="string">"heihei"</span>)</span><br><span class="line">    wechat5.send_message(content=<span class="string">"pupu"</span>)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用企业微信账号A推送信息:  haha</span><br><span class="line">使用企业微信账号A推送信息:  hehe</span><br><span class="line">使用企业微信账号A推送信息:  xixi</span><br><span class="line">使用企业微信账号B推送信息:  heihei</span><br><span class="line">使用企业微信账号B推送信息:  pupu</span><br></pre></td></tr></table></figure>

<p>如果此时, 两个微信账号都不够用了, 需要增加第三个账号时, 所有的类都不需要修改, 只需创建新的类即可, 符合开放封闭原则</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountC</span><span class="params">(WeChat)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span><span class="params">(self, content)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号C推送信息: "</span>, content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_image</span><span class="params">(self, imageid)</span>:</span></span><br><span class="line">        print(<span class="string">"使用企业微信账号C推送图片: "</span>, imageid)</span><br><span class="line">      </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountCFactory</span><span class="params">(WeChatFactory)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_wechat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> AccountC()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用sorted对字典的key或value排序</title>
    <url>/2018/08/08/Python%E4%BD%BF%E7%94%A8sorted%E5%AF%B9%E5%AD%97%E5%85%B8%E7%9A%84key%E6%88%96value%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h2 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h2><p>sorted(iterable,key,reverse)</p>
<ul>
<li>iterable 待排序的可迭代对象</li>
<li>key 对应的是个函数, 该函数用来决定选取用哪些值来进行排序</li>
<li>reverse 反转排序</li>
</ul>
<h2 id="对key排序"><a href="#对key排序" class="headerlink" title="对key排序"></a>对key排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d: dict = &#123;<span class="string">"p"</span>: <span class="number">59</span>, <span class="string">"o"</span>: <span class="number">9</span>, <span class="string">"s"</span>: <span class="number">5</span>, <span class="string">"a"</span>: <span class="number">20</span>, <span class="string">"z"</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">li: list = sorted(d.keys())</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;a&#39;, &#39;o&#39;, &#39;p&#39;, &#39;s&#39;, &#39;z&#39;]</span><br></pre></td></tr></table></figure>



<h2 id="对value排序"><a href="#对value排序" class="headerlink" title="对value排序"></a>对value排序</h2><p>在对value之前, 先来回炉一下Python的lambda表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="keyword">lambda</span> x: x+<span class="number">1</span></span><br><span class="line">print(f(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">print(ff(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>以上两种方式是等价的, lambda表达式写法更简洁, 一般当做匿名表达式/匿名函数使用</p>
<p><code>lambda x:y</code> </p>
<ul>
<li>x 为入参</li>
<li>y 为计算表达式, 运算后返回</li>
</ul>
<p>接下来进入到对字典的value排序正题, 这里就需要使用到lambda表达式</p>
<h3 id="直接对值排序"><a href="#直接对值排序" class="headerlink" title="直接对值排序"></a>直接对值排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d: dict = &#123;<span class="string">"p"</span>: <span class="number">59</span>, <span class="string">"o"</span>: <span class="number">9</span>, <span class="string">"s"</span>: <span class="number">5</span>, <span class="string">"a"</span>: <span class="number">20</span>, <span class="string">"z"</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">li: list = sorted(d.values())</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[5, 9, 18, 20, 59]</span><br></pre></td></tr></table></figure>

<h3 id="在包含Key的情况下对值排序"><a href="#在包含Key的情况下对值排序" class="headerlink" title="在包含Key的情况下对值排序"></a>在包含Key的情况下对值排序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d: dict = &#123;<span class="string">"p"</span>: <span class="number">59</span>, <span class="string">"o"</span>: <span class="number">9</span>, <span class="string">"s"</span>: <span class="number">5</span>, <span class="string">"a"</span>: <span class="number">20</span>, <span class="string">"z"</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line">li: list = sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[(&#39;s&#39;, 5), (&#39;o&#39;, 9), (&#39;z&#39;, 18), (&#39;a&#39;, 20), (&#39;p&#39;, 59)]</span><br></pre></td></tr></table></figure>



<p><code>d.items()</code> 返回以元组形式构成的列表 <code>dict_items([(&#39;p&#39;, 59), (&#39;o&#39;, 9), (&#39;s&#39;, 5), (&#39;a&#39;, 20), (&#39;z&#39;, 18)])</code>  (列表为可迭代对象)</p>
<p><code>lambda x: x[1]</code> lambda表达式中, x为入参, 每次x的值为一个<code>d.items()</code>中的元素(一个元组), 第一个入参为<code>(&#39;p&#39;, 59)</code> 冒号后面的x[1]是运算表达式, 意思是取元组中的第二个元素返回(索引为1), 返回的元素即为排序的依据. 所以如果需要对key进行排序, 也可以在表达式里写 <code>x[0]</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>lambda</tag>
        <tag>sorted</tag>
        <tag>dict</tag>
      </tags>
  </entry>
  <entry>
    <title>aiohttp+uvloop+gunicorn</title>
    <url>/2018/08/08/aiohttp-uvloop-gunicorn/</url>
    <content><![CDATA[<h1 id="aiohttp-uvloop"><a href="#aiohttp-uvloop" class="headerlink" title="aiohttp+uvloop"></a>aiohttp+uvloop</h1><p><strong>main.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> web</span><br><span class="line"><span class="keyword">from</span> utils.logger_helper <span class="keyword">import</span> LogFactory</span><br><span class="line"></span><br><span class="line">logger = LogFactory.get_logger()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    logger.info(<span class="string">"Server Starting at &#123;0&#125;;&#123;1&#125;"</span>.format(cfg.host, cfg.port))</span><br><span class="line">    app = web.Application()</span><br><span class="line">    setup_routes(app)</span><br><span class="line">    app.on_shutdown.append(shutdown)</span><br><span class="line">    web.run_app(app, host=cfg.host, port=cfg.port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 使用 uvloop 替换掉 asyncio 默认的事件循环</span></span><br><span class="line">    asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 启动 Server</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        main()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br></pre></td></tr></table></figure>



<h1 id="aiohttp-uvloop-gunicorn"><a href="#aiohttp-uvloop-gunicorn" class="headerlink" title="aiohttp+uvloop+gunicorn"></a>aiohttp+uvloop+gunicorn</h1><p><strong>main.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># For Gunicorn</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">web_app</span><span class="params">()</span>:</span></span><br><span class="line">    logger.info(<span class="string">"Server Starting at &#123;0&#125;;&#123;1&#125;"</span>.format(cfg.host, cfg.port))</span><br><span class="line">    app = web.Application()</span><br><span class="line">    setup_routes(app)</span><br><span class="line">    app.on_shutdown.append(shutdown)</span><br><span class="line">    <span class="keyword">return</span> app</span><br></pre></td></tr></table></figure>

<p><code>gunicorn ... --worker-class aiohttp.worker.GunicornUVLoopWebWorker</code></p>
<p>在启动gunicorn的时候, 指定uvloop的worker-class即可</p>
<h1 id="How-to-use-uvloop-in-an-asyncio-application"><a href="#How-to-use-uvloop-in-an-asyncio-application" class="headerlink" title="How to use uvloop in an asyncio application"></a>How to use uvloop in an asyncio application</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br></pre></td></tr></table></figure>

<h1 id="How-to-use-uvloop-with-Tornado"><a href="#How-to-use-uvloop-with-Tornado" class="headerlink" title="How to use uvloop with Tornado"></a>How to use uvloop with Tornado</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tornado.platform.asyncio <span class="keyword">import</span> AsyncIOMainLoop</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line"></span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line">AsyncIOMainLoop().install()</span><br><span class="line">asyncio.get_event_loop().run_forever()</span><br></pre></td></tr></table></figure>

<p>参考文档:</p>
<ul>
<li><a href="https://github.com/MagicStack/uvloop/wiki" target="_blank" rel="noopener">https://github.com/MagicStack/uvloop/wiki</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>aiohttp</tag>
        <tag>uvloop</tag>
        <tag>gunicorn</tag>
        <tag>tornado</tag>
      </tags>
  </entry>
  <entry>
    <title>Python SMTPException: No suitable authentication method found</title>
    <url>/2018/08/08/Python-SMTPException-No-suitable-authentication-method-found/</url>
    <content><![CDATA[<p>最近在发送邮件日报时, 使用<code>smtplib</code>库抛了一个异常<code>raise SMTPException(&quot;No suitable authentication method found.&quot;)</code></p>
<p>原因是配置了<code>https</code>的邮件服务器, 在初始化SMTP和login之间调用<code>starttls()</code>方法即可解决问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line">server = smtplib.SMTP(self.server, self.port)</span><br><span class="line">server.set_debuglevel(<span class="number">1</span>)</span><br><span class="line">server.starttls()</span><br><span class="line">server.login(self.send_user, self.password)</span><br><span class="line">server.sendmail(self.send_user, [to], msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>smtplib</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的抽象方法@abstractmethod</title>
    <url>/2018/08/08/Python%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95-abstractmethod/</url>
    <content><![CDATA[<blockquote>
<p>抽象方法是父类的一个方法, 父类没有实现这个方法, 父类是不可以实例化的. 子类继承父类, 子类必须实现父类定义的抽象方法, 子类才可以被实例化. Python中的abc提供了@abstractmethod装饰器实现抽象方法的定义</p>
</blockquote>
<h2 id="抽象类的实现"><a href="#抽象类的实现" class="headerlink" title="抽象类的实现"></a>抽象类的实现</h2><p>Python 3.4+</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        你需要在子类中实现该方法, 子类才允许被实例化</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubFoo</span><span class="params">(Foo)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"子类实现父类的抽象方法"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    sf = SubFoo()</span><br><span class="line">    sf.fun()</span><br></pre></td></tr></table></figure>

<p>Python 3.0 - 3.3 版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>Python 2 版本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooBar</span><span class="params">()</span>:</span></span><br><span class="line">    __metaclass__ = ABCMeta</span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="浅谈抽象类"><a href="#浅谈抽象类" class="headerlink" title="浅谈抽象类"></a>浅谈抽象类</h2><p>类, 是从一堆对象中抽象出来的, 比如<code>猫类</code>,<code>狗类</code>,<code>人类</code></p>
<p>抽象类, 是从一堆类中抽象出来的,  比如上面的三个类可以抽取出<code>动物类</code></p>
<p>抽象类的特点是不能给实例化, 只能被子类继承, 由子类实现了父类的抽象方法后, 子类才能被实例化</p>
<h2 id="Python中的接口-抽象类-抽象函数"><a href="#Python中的接口-抽象类-抽象函数" class="headerlink" title="Python中的接口, 抽象类, 抽象函数"></a>Python中的接口, 抽象类, 抽象函数</h2><p>Python中的接口是个弱概念, 从Java中的概念延伸而来, Python中通过抽象类和抽象方法来实现一个接口, 例如Python3中, class 类继承的 <code>abc.ABC</code> 即为抽象类, <code>@abstractmethod</code> 装饰器使其装饰的函数成为抽象函数</p>
<p>一般情况下, Python多在单继承的情况下使用抽象类</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>abstractmethod</tag>
        <tag>抽象类</tag>
        <tag>抽象方法</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之切片Slice操作</title>
    <url>/2018/08/08/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87Slice%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="向Slice中添加元素"><a href="#向Slice中添加元素" class="headerlink" title="向Slice中添加元素"></a>向Slice中添加元素</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line">	s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	ss := <span class="built_in">append</span>(s, <span class="string">"xx"</span>)</span><br><span class="line">	sss := <span class="built_in">append</span>(ss, <span class="string">"yy"</span>)</span><br><span class="line">	ssss := <span class="built_in">append</span>(sss, <span class="string">"zz"</span>)</span><br><span class="line">	fmt.Println(<span class="string">"s"</span>, s)</span><br><span class="line">	fmt.Println(<span class="string">"ss"</span>, ss)</span><br><span class="line">	fmt.Println(<span class="string">"sss"</span>, sss)</span><br><span class="line">	fmt.Println(<span class="string">"ssss"</span>, ssss)</span><br><span class="line">	fmt.Println(<span class="string">"arr"</span>, arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s [c d e f]</span><br><span class="line">ss [c d e f xx]</span><br><span class="line">sss [c d e f xx yy]</span><br><span class="line">ssss [c d e f xx yy zz]</span><br><span class="line">arr [a b c d e f xx yy]</span><br></pre></td></tr></table></figure>

<p>从执行结果中可以看出, 向Slice中append元素后, 会覆盖掉底层Array的值, 会覆盖掉索引为<code>ptr+len(Slice)</code>的值. 当Slice append后, 超出了cap的长度, 底层Array中已经没有多余的值可以给他覆盖后, 这时, 新的Slice其实已经不再是老的Array的view了, Go语言会在内部创建一个新的Array, 把老数据拷贝过去, 且新的Array的长度会设置的更长一些. 上面的Demo中, ssss已经不再是原始Array的view</p>
<ul>
<li><p>当添加元素时, 如果超越了cap, 系统会重新分配更大的底层数组, 原来的Array如果没有被任何对象使用, 将被垃圾回收机制回收</p>
</li>
<li><p>由于Go语言是值传递, 在append后, 必须接收其返回值. 原因是在append操作后, Slice的len肯定会变化, 如果超过了Array长度, cap的值也会变化, 所以需要我们使用新的Slice对象去接收新的返回值</p>
</li>
</ul>
<h2 id="创建Slice"><a href="#创建Slice" class="headerlink" title="创建Slice"></a>创建Slice</h2><p>上一篇文章的介绍中, 全篇都使用了Array去创建Slice, 我们可以直接创建Slice</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceInfo</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d cap=%d\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> s []<span class="keyword">int</span>  <span class="comment">// 声明创建一个int类型的Slice</span></span><br><span class="line">	<span class="comment">// 如果变量没有被赋值, Go语言会为每个变量定义Zero Value</span></span><br><span class="line">	<span class="comment">// Slice的Zero Value 为 nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;=<span class="number">59</span>; i++ &#123;</span><br><span class="line">		printSliceInfo(s)</span><br><span class="line">		s = <span class="built_in">append</span>(s, i)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;0 cap&#x3D;0</span><br><span class="line">len&#x3D;1 cap&#x3D;1</span><br><span class="line">len&#x3D;2 cap&#x3D;2</span><br><span class="line">len&#x3D;3 cap&#x3D;4</span><br><span class="line">len&#x3D;4 cap&#x3D;4</span><br><span class="line">len&#x3D;5 cap&#x3D;8</span><br><span class="line">len&#x3D;6 cap&#x3D;8</span><br><span class="line">len&#x3D;7 cap&#x3D;8</span><br><span class="line">len&#x3D;8 cap&#x3D;8</span><br><span class="line">len&#x3D;9 cap&#x3D;16</span><br><span class="line">len&#x3D;10 cap&#x3D;16</span><br><span class="line">len&#x3D;11 cap&#x3D;16</span><br><span class="line">len&#x3D;12 cap&#x3D;16</span><br><span class="line">len&#x3D;13 cap&#x3D;16</span><br><span class="line">len&#x3D;14 cap&#x3D;16</span><br><span class="line">len&#x3D;15 cap&#x3D;16</span><br><span class="line">len&#x3D;16 cap&#x3D;16</span><br><span class="line">len&#x3D;17 cap&#x3D;32</span><br><span class="line">len&#x3D;18 cap&#x3D;32</span><br><span class="line">len&#x3D;19 cap&#x3D;32</span><br><span class="line">len&#x3D;20 cap&#x3D;32</span><br><span class="line">len&#x3D;21 cap&#x3D;32</span><br><span class="line">len&#x3D;22 cap&#x3D;32</span><br><span class="line">len&#x3D;23 cap&#x3D;32</span><br><span class="line">len&#x3D;24 cap&#x3D;32</span><br><span class="line">len&#x3D;25 cap&#x3D;32</span><br><span class="line">len&#x3D;26 cap&#x3D;32</span><br><span class="line">len&#x3D;27 cap&#x3D;32</span><br><span class="line">len&#x3D;28 cap&#x3D;32</span><br><span class="line">len&#x3D;29 cap&#x3D;32</span><br><span class="line">len&#x3D;30 cap&#x3D;32</span><br><span class="line">len&#x3D;31 cap&#x3D;32</span><br><span class="line">len&#x3D;32 cap&#x3D;32</span><br><span class="line">len&#x3D;33 cap&#x3D;64</span><br><span class="line">len&#x3D;34 cap&#x3D;64</span><br><span class="line">len&#x3D;35 cap&#x3D;64</span><br><span class="line">len&#x3D;36 cap&#x3D;64</span><br><span class="line">len&#x3D;37 cap&#x3D;64</span><br><span class="line">len&#x3D;38 cap&#x3D;64</span><br><span class="line">len&#x3D;39 cap&#x3D;64</span><br><span class="line">len&#x3D;40 cap&#x3D;64</span><br><span class="line">len&#x3D;41 cap&#x3D;64</span><br><span class="line">len&#x3D;42 cap&#x3D;64</span><br><span class="line">len&#x3D;43 cap&#x3D;64</span><br><span class="line">len&#x3D;44 cap&#x3D;64</span><br><span class="line">len&#x3D;45 cap&#x3D;64</span><br><span class="line">len&#x3D;46 cap&#x3D;64</span><br><span class="line">len&#x3D;47 cap&#x3D;64</span><br><span class="line">len&#x3D;48 cap&#x3D;64</span><br><span class="line">len&#x3D;49 cap&#x3D;64</span><br><span class="line">len&#x3D;50 cap&#x3D;64</span><br><span class="line">len&#x3D;51 cap&#x3D;64</span><br><span class="line">len&#x3D;52 cap&#x3D;64</span><br><span class="line">len&#x3D;53 cap&#x3D;64</span><br><span class="line">len&#x3D;54 cap&#x3D;64</span><br><span class="line">len&#x3D;55 cap&#x3D;64</span><br><span class="line">len&#x3D;56 cap&#x3D;64</span><br><span class="line">len&#x3D;57 cap&#x3D;64</span><br><span class="line">len&#x3D;58 cap&#x3D;64</span><br><span class="line">len&#x3D;59 cap&#x3D;64</span><br><span class="line">[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59]</span><br></pre></td></tr></table></figure>

<p>从上面的执行结果可以看出, Go语言会根据使用情况自动去扩展Slice的len以及cap</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceInfo</span><span class="params">(s []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d cap=%d\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;  <span class="comment">// 首先创建了个Array, 然后对其view</span></span><br><span class="line">	printSliceInfo(s)</span><br><span class="line"></span><br><span class="line">	ss := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">16</span>, <span class="number">32</span>)  <span class="comment">// 创建一个len为16, cap为32的string类型Slice</span></span><br><span class="line">	printSliceInfo(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;3 cap&#x3D;3</span><br><span class="line">  len&#x3D;16 cap&#x3D;32</span><br></pre></td></tr></table></figure>

<h2 id="拷贝Slice"><a href="#拷贝Slice" class="headerlink" title="拷贝Slice"></a>拷贝Slice</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSliceInfo</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">"len=%d cap=%d\n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">2015</span>, <span class="number">5</span>, <span class="number">9</span>&#125;  <span class="comment">// 首先创建了个Array, 然后对其view</span></span><br><span class="line">	printSliceInfo(s)</span><br><span class="line">	fmt.Println(<span class="string">"s"</span>, s)</span><br><span class="line"></span><br><span class="line">	ss := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">4</span>, <span class="number">8</span>)  <span class="comment">// 创建一个len为16, cap为32的string类型Slice</span></span><br><span class="line">	printSliceInfo(ss)</span><br><span class="line">	fmt.Println(<span class="string">"ss"</span>, ss)</span><br><span class="line"></span><br><span class="line">	<span class="built_in">copy</span>(ss, s)  <span class="comment">// 将s切片的数据拷贝到ss切片中</span></span><br><span class="line">	fmt.Println(<span class="string">"ss"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len&#x3D;3 cap&#x3D;3</span><br><span class="line">s [2015 5 9]</span><br><span class="line">len&#x3D;4 cap&#x3D;8</span><br><span class="line">ss [0 0 0 0]</span><br><span class="line">ss [2015 5 9 0]</span><br></pre></td></tr></table></figure>

<h2 id="删除Slice中的元素"><a href="#删除Slice中的元素" class="headerlink" title="删除Slice中的元素"></a>删除Slice中的元素</h2><p>对于Slice的删除功能, Go语言没有提供直接的操作语句, 但是可以通过Reslice来实现</p>
<p>需求: 删除Slice中的第3个元素 [12, 34, 56, 78, 90, 89, 72]</p>
<p>思路: 使用Reslice, s[:3] + s[4:] 取得的就是删除原切片第三个元素的数据, 但Go语言也没有提供Slice相加的功能, 只能通过append函数来实现, append(s[:3], s[4:]), 问题又来了, append的源码中要求第二参数必须是可变参数, 也就是一个值一个值的写在后面 <code>func append(slice []Type, elems ...Type) []Type</code></p>
<p>Go语言中提供了相关的语法, 来解决s[4:]变成可变参数的问题</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">72</span>&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	ss := <span class="built_in">append</span>(s[:<span class="number">3</span>], s[<span class="number">4</span>:]...)</span><br><span class="line">	fmt.Println(ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[12 34 56 78 90 89 72]</span><br><span class="line">[12 34 56 90 89 72]</span><br></pre></td></tr></table></figure>

<h3 id="删除头尾"><a href="#删除头尾" class="headerlink" title="删除头尾"></a>删除头尾</h3><p>删头</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">72</span>&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Poping from front"</span>)</span><br><span class="line">	front := s[<span class="number">0</span>]</span><br><span class="line">	ss := s[<span class="number">1</span>:]</span><br><span class="line">	fmt.Println(<span class="string">"取出的头部元素为"</span>, front)</span><br><span class="line">	fmt.Println(<span class="string">"取出头部元素后的Slice为"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[12 34 56 78 90 89 72]</span><br><span class="line">Poping from front</span><br><span class="line">取出的头部元素为 12</span><br><span class="line">取出头部元素后的Slice为 [34 56 78 90 89 72]</span><br></pre></td></tr></table></figure>

<p>删尾</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="keyword">int</span>&#123;<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">90</span>, <span class="number">89</span>, <span class="number">72</span>&#125;</span><br><span class="line">	fmt.Println(s)</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"Poping from front"</span>)</span><br><span class="line">	tail := s[<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">	ss := s[:<span class="built_in">len</span>(s)<span class="number">-1</span>]</span><br><span class="line">	fmt.Println(<span class="string">"取出的尾部元素为"</span>, tail)</span><br><span class="line">	fmt.Println(<span class="string">"取出尾部元素后的Slice为"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[12 34 56 78 90 89 72]</span><br><span class="line">Poping from front</span><br><span class="line">取出的尾部元素为 72</span><br><span class="line">取出尾部元素后的Slice为 [12 34 56 78 90 89]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Slice</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之切片Slice的概念</title>
    <url>/2018/08/07/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87Slice%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="Slice的基本使用"><a href="#Slice的基本使用" class="headerlink" title="Slice的基本使用"></a>Slice的基本使用</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"arr[2:6]"</span>, arr[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:6]"</span>, arr[:<span class="number">6</span>])</span><br><span class="line">	fmt.Println(<span class="string">"arr[2:]"</span>, arr[<span class="number">2</span>:])</span><br><span class="line">	fmt.Println(<span class="string">"arr[:]"</span>, arr[:])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arr[2:6] [c d e f]</span><br><span class="line">arr[:6] [a b c d e f]</span><br><span class="line">arr[2:] [c d e f g h]</span><br><span class="line">arr[:] [a b c d e f g h]</span><br></pre></td></tr></table></figure>

<p><strong>注意: 左开右闭区间; Slice是对数组的View(视图)</strong></p>
<h2 id="Slice是引用类型"><a href="#Slice是引用类型" class="headerlink" title="Slice是引用类型"></a>Slice是引用类型</h2><p>由于Slice是对底层数组的视图, 当Slice中的元素被修改后, 同样的, 底层数组中的元素也将被修改</p>
<p>看以下demo</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line"></span><br><span class="line">	s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	fmt.Println(<span class="string">"原始s变量的值"</span>, s)</span><br><span class="line">	fmt.Println(<span class="string">"原始数组的值"</span>, arr)</span><br><span class="line">	s[<span class="number">0</span>] = <span class="string">"xx"</span>  <span class="comment">// 改变视图中的第一个元素</span></span><br><span class="line">	fmt.Println(<span class="string">"修改后变量的值"</span>, s)</span><br><span class="line">	fmt.Println(<span class="string">"修改后数组的值"</span>, arr)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">原始s变量的值 [c d e f]</span><br><span class="line">原始数组的值 [a b c d e f g h]</span><br><span class="line">修改后变量的值 [xx d e f]</span><br><span class="line">修改后数组的值 [a b xx d e f g h]</span><br></pre></td></tr></table></figure>

<h2 id="Slice-amp-Array"><a href="#Slice-amp-Array" class="headerlink" title="Slice &amp; Array"></a>Slice &amp; Array</h2><p>切片和数组的写法很相似, 这里把他们放到一起区分以下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(arr [5]<span class="keyword">int</span>)</span> // 接收一个长度为5的<span class="title">int</span>类型的数组<span class="params">(值传递)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span>  // 接收一个长度5的<span class="title">int</span>类型的数组的指针<span class="params">(引用传递)</span></span></span><br><span class="line"><span class="comment">// &amp;arr 用&amp;传递参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(sli []<span class="keyword">int</span>)</span>  // 接收一个<span class="title">Slice</span>切片<span class="params">(引用传递)</span></span></span><br><span class="line"><span class="comment">// arr[:] 用[:]切片语法传递参数</span></span><br></pre></td></tr></table></figure>

<h2 id="Reslice"><a href="#Reslice" class="headerlink" title="Reslice"></a>Reslice</h2><p>Slice可以在Slice的基础上再次Slice, 创建Slice的视图</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line"></span><br><span class="line">	s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	fmt.Println(<span class="string">"数组arr的值"</span>, arr)</span><br><span class="line">	fmt.Println(<span class="string">"s切片的值"</span>, s)</span><br><span class="line"></span><br><span class="line">	s2 := s[:<span class="number">3</span>]</span><br><span class="line">	s3 := s[<span class="number">2</span>:]</span><br><span class="line">	fmt.Println(<span class="string">"s2, 基于s切片的view"</span>, s2)</span><br><span class="line">	fmt.Println(<span class="string">"s3, 基于s切片的view"</span>, s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组arr的值 [a b c d e f g h]</span><br><span class="line">s切片的值 [c d e f]</span><br><span class="line">s2, 基于s切片的view [c d e]</span><br><span class="line">s3, 基于s切片的view [e f]</span><br></pre></td></tr></table></figure>

<p><strong>上面的Demo中, 即使有多个Slice, 但其本质, 还是view了同一个Array</strong></p>
<h2 id="Slice的扩展"><a href="#Slice的扩展" class="headerlink" title="Slice的扩展"></a>Slice的扩展</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line"></span><br><span class="line">	s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	fmt.Println(<span class="string">"数组arr的值"</span>, arr)</span><br><span class="line">	fmt.Println(<span class="string">"s切片是对arr的view, 值为"</span>, s)</span><br><span class="line"></span><br><span class="line">	ss := s[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(<span class="string">"ss切片是对s切片的view, 值为"</span>, ss)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组arr的值 [a b c d e f g h]</span><br><span class="line">s切片是对arr的view, 值为 [c d e f]</span><br><span class="line">ss切片是对s切片的view, 值为 [f g]</span><br></pre></td></tr></table></figure>

<p>上面的Demo中, 出现了一个很有意思的问题, 就是ss切片, 根据上面介绍的理论, ss切片是对s切片的view, 也就是Reslice, 但是s切片中只有4个值, 元素索引为<code>0-3</code>, 而ss对其进行reslice后, 却要看<code>3-5</code>的索引, 如果是普通Array的话, 肯定会报索引越界的异常, 但是上面Demo我们看出, 代码并没有抛出任何异常, 不仅还取到了值, 还取到了s切片中不存在的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;  &lt;&#x3D;&#x3D; Array</span><br><span class="line"> 0    1    2    3    4    5    6    7   &lt;&#x3D;&#x3D; Array Index</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">          &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;            &lt;&#x3D;&#x3D; Slice arr[2:6]</span><br><span class="line">           0    1    2    3    4    5   &lt;&#x3D;&#x3D; Sline Index</span><br><span class="line">           </span><br><span class="line">                         &quot;f&quot;, &quot;g&quot;       &lt;&#x3D;&#x3D; Reslice sli[3:5]</span><br><span class="line">                          0    1    2   &lt;&#x3D;&#x3D; Reslice Index</span><br></pre></td></tr></table></figure>

<p><strong>Go语言Slice的扩展特性: 在Slice后, Array后面的元素依然可以被Slice感知, 但是Slice后面这些元素不能直接被取出, 直接取值会报索引越界的错误. 但是当Slice被Reslice时, Slice后面隐藏的值是可以在Reslice中重见天日的</strong></p>
<h2 id="Slice的实现"><a href="#Slice的实现" class="headerlink" title="Slice的实现"></a>Slice的实现</h2><p>假设: <code>- - - -</code>为Slice对Array的视图</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array:  &#96;+ + + + - - - - ~ ~ ~ ~&#96;</span><br><span class="line">                 ↑     |       |</span><br><span class="line">                ptr    |       |</span><br><span class="line">                 |-len-|       |</span><br><span class="line">                 |-----cap-----|</span><br></pre></td></tr></table></figure>


<p>Slice内部有三个元素: </p>
<ul>
<li>ptr: 指向了Slice开头的元素. 依据上图, 也就是指向了第一个<code>-</code></li>
<li>len: 保存了Slice的长度, 使用 sli[x] 这种方式取值, 只能取到sli[len-1]. 依据上图, len保存了<code>-</code>的长度, 4</li>
<li>cap: cap保存了从ptr开始到Array数组结束的长度. 依据上图, 也就是说cap保存了从第一个<code>-</code>开始, 到最后一个<code>~</code>为止的长度, 8</li>
</ul>
<p>所以Go知道, Slice在扩展的时候, 只要不超过cap的长度, 就是可以取到的</p>
<p><strong>注意: Slice可以向后扩展, 但是不能向前扩展, 图示中<code>+</code>部分的值在Slice中永远不会被取出来, 除非重新使用Slice对Array进行view操作`</strong></p>
<p><strong>sli[x]取值不可以超越len(sli); 向后扩展, 不可以超越底层Array cap(sli)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	arr := [...]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>, <span class="string">"h"</span>&#125;</span><br><span class="line">	fmt.Println(<span class="string">"Array数组的cap长度为: "</span>, <span class="built_in">cap</span>(arr))  <span class="comment">// 结果为: 8</span></span><br><span class="line"></span><br><span class="line">	s := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">	fmt.Println(<span class="string">"数组arr的值"</span>, arr)</span><br><span class="line">	fmt.Println(<span class="string">"s切片是对arr的view, 值为"</span>, s)</span><br><span class="line">	fmt.Println(<span class="string">"s切片的len长度和cap长度分别为: "</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">	ss := s[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">	fmt.Println(<span class="string">"ss切片是对s切片的view, 值为"</span>, ss)</span><br><span class="line">	fmt.Println(<span class="string">"ss切片的len长度和cap长度分别为: "</span>, <span class="built_in">len</span>(ss), <span class="built_in">cap</span>(ss))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array数组的cap长度为:  8</span><br><span class="line">数组arr的值 [a b c d e f g h]</span><br><span class="line">s切片是对arr的view, 值为 [c d e f]</span><br><span class="line">s切片的len长度和cap长度分别为:  4 6</span><br><span class="line">ss切片是对s切片的view, 值为 [f g]</span><br><span class="line">ss切片的len长度和cap长度分别为:  2 3</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>Slice</tag>
        <tag>切片</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之一个参数引发的血案</title>
    <url>/2018/08/02/Python%E4%B9%8B%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88/</url>
    <content><![CDATA[<h2 id="参数为可变对象引发的问题"><a href="#参数为可变对象引发的问题" class="headerlink" title="参数为可变对象引发的问题"></a>参数为可变对象引发的问题</h2><p>先来看一个结果符合绝大多数人预期的例子🌰</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, staffs: list=[])</span>:</span></span><br><span class="line">        self.name: str = name</span><br><span class="line">        self.staffs: list = staffs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, staff_name: str)</span>:</span></span><br><span class="line">        self.staffs.append(staff_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    co = Company(<span class="string">"xx"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>])</span><br><span class="line">    co.add(<span class="string">"C"</span>)</span><br><span class="line">    print(co.staffs)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span><br></pre></td></tr></table></figure>

<p>这个结果想必大家都能猜得到, 接下来看下面的例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, staffs: list=[])</span>:</span></span><br><span class="line">        self.name: str = name</span><br><span class="line">        self.staffs: list = staffs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, staff_name: str)</span>:</span></span><br><span class="line">        self.staffs.append(staff_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    co1 = Company(<span class="string">"yy"</span>)</span><br><span class="line">    co1.add(<span class="string">"D"</span>)</span><br><span class="line">    print(<span class="string">"co1's staffs: &#123;0&#125;"</span>.format(co1.staffs))</span><br><span class="line"></span><br><span class="line">    co2 = Company(<span class="string">"oo"</span>)</span><br><span class="line">    co2.add(<span class="string">"E"</span>)</span><br><span class="line">    print(<span class="string">"co1's staffs: &#123;0&#125;"</span>.format(co1.staffs))</span><br><span class="line">    print(<span class="string">"co2's staffs: &#123;0&#125;"</span>.format(co2.staffs))</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">co1&#39;s staffs: [&#39;D&#39;]</span><br><span class="line">co1&#39;s staffs: [&#39;D&#39;, &#39;E&#39;]</span><br><span class="line">co2&#39;s staffs: [&#39;D&#39;, &#39;E&#39;]</span><br></pre></td></tr></table></figure>

<p>第一行的结果, 应该是符合大家的预期的, 但是第二行第三行的结果可以看出, 虽然是两个完全不同的对象, 但是互相受到了影响! 对<code>co2</code>添加员工的操作影响了<code>co1</code>中的成员, 而最开始<code>co1</code>中添加成员的操作也默认影响到了<code>co2</code>的员工列表</p>
<p>这是为什么呢?</p>
<p>如果你用的<code>PyCharm IDE</code>在你定义函数/方法参数的时候, 如果定义的默认参数为列表, 那么IDE会提示你: <code>Default argument value is mutable</code>, 不推荐在函数的参数中直接接收列表类型的数据(不推荐使用可变对象).</p>
<p>那么抛开建议, 为什么会出现上面两个对象之间的值互相影响的情况呢?</p>
<p>是因为<code>co1</code>和<code>co2</code>两个对象在创建的时候, 都没有明确指定<code>staffs</code>列表, 而是都使用了默认的空列表, 在这种情况下他们实际就共用了一个对象, 而恰巧该对象又是可变对象, 所以创建对象后, 任意一个对象对该可变对象的操作都会影响到另一个对象, 在Python代码中, 可以使用<code>is</code>语句来验证两个对象的两个字段是否都引用了同一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(co1.staffs <span class="keyword">is</span> co2.staffs)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>

<p>验证结果也明确显示了, 两个对象的两个字段, 其实是引用了同一个对象, 同一块内存, 我们也可以通过特定函数查看类中构造方法默认值的使用情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name: str, staffs: list=[])</span>:</span></span><br><span class="line">        self.name: str = name</span><br><span class="line">        self.staffs: list = staffs</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, staff_name: str)</span>:</span></span><br><span class="line">        self.staffs.append(staff_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    print(Company.__init__.__defaults__)  <span class="comment"># ([],)</span></span><br><span class="line">    co1 = Company(<span class="string">"yy"</span>)</span><br><span class="line">    co1.add(<span class="string">"D"</span>)</span><br><span class="line">    print(<span class="string">"co1's staffs: &#123;0&#125;"</span>.format(co1.staffs))  <span class="comment"># co1's staffs: ['D']</span></span><br><span class="line">    print(Company.__init__.__defaults__)  <span class="comment"># (['D'],)</span></span><br><span class="line">    co2 = Company(<span class="string">"oo"</span>)</span><br><span class="line">    co2.add(<span class="string">"E"</span>)</span><br><span class="line">    print(<span class="string">"co1's staffs: &#123;0&#125;"</span>.format(co1.staffs))  <span class="comment"># co1's staffs: ['D', 'E']</span></span><br><span class="line">    print(<span class="string">"co2's staffs: &#123;0&#125;"</span>.format(co2.staffs))  <span class="comment"># co2's staffs: ['D', 'E']</span></span><br><span class="line">    print(Company.__init__.__defaults__)  <span class="comment"># (['D', 'E'],)</span></span><br><span class="line">    print(co1.staffs <span class="keyword">is</span> co2.staffs)  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>当函数的参数没有指定值的时候, 就会指向<code>Company.__init__.__defaults__</code>这里的默认值</p>
<h2 id="如果解决这类问题"><a href="#如果解决这类问题" class="headerlink" title="如果解决这类问题"></a>如果解决这类问题</h2><ul>
<li>第一: 最直接的解决之道就是不要使用列表和字典这种可变对象作为参数传递</li>
<li>第二: 可以使用元组传递</li>
<li>第三: 参数的默认值不要使用列表或字典, 让调用者每次都显式传递参数</li>
<li>第四: 使用 def func(<em>args, *</em>kwargs) 的方式传递</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中垃圾回收和del语句</title>
    <url>/2018/08/01/Python%E4%B8%AD%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%92%8Cdel%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>Python中的垃圾回收算法是采用<code>引用计数</code>, 当一个对象的引用计数为0时, Python的垃圾回收机制就会将对象回收</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"larry"</span></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p><code>larry</code>这个字符串对象, 在第一行被贴了<code>a</code>标签后, 引用计数为1, 之后在第二行, 由贴上了<code>b</code>标签, 此时, 该字符串对象的引用计数为2</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"larry"</span></span><br><span class="line">b = a</span><br><span class="line"><span class="keyword">del</span> a</span><br></pre></td></tr></table></figure>

<p>注意: 在Python语言中, <code>del</code>语句操作某个对象的时候, 并不是直接将该对象在内存中删除, 而是将该对象的引用计数<code>-1</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"larry"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4572141808</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    id(a)</span><br><span class="line">NameError: name <span class="string">'a'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>从以上示例中可以看出, <code>larry</code>这个字符串对象在第一行被贴上了<code>a</code>标签, 此时字符串对象的引用计数为1, 接着第二行又被贴上了<code>b</code>标签, 此时该字符串对象的引用计数为2, 在第三行中, del语言删除了a变量(标签), 在后续的print中可以看出, 内存中实际的字符串对象并没有被删除, del语言只是删除了一个变量对该字符串对象的引用, 所以对于<code>larry</code>这个字符串对象来说, 效果只是引用计数<code>-1</code></p>
<h2 id="魔法函数之-del"><a href="#魔法函数之-del" class="headerlink" title="魔法函数之__del__"></a>魔法函数之<code>__del__</code></h2><p>类中的<code>__del__</code>魔法函数, 支持我们自定义清理对象的逻辑, 当Python解释器使用del语言删除类的对象的时候, 会自动调用类中的<code>__del__</code>函数, 我们可以对其进行重载</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Ref</span>:</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line"><span class="meta">... </span>        self.name = name</span><br><span class="line">...</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>        print(<span class="string">"删除对象"</span>)</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">del</span> self.name</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = Ref(name=<span class="string">"larry"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r.name)</span><br><span class="line">larry</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> r</span><br><span class="line">删除对象</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r.name)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(r.name)</span><br><span class="line">NameError: name <span class="string">'r'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>我们可以通过重载<code>__del__</code>魔法函数, 自己灵活控制在<code>del 对象</code>的时候执行哪些善后操作</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>del</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的==和is的区别</title>
    <url>/2018/08/01/Python%E4%B8%AD%E7%9A%84-%E5%92%8Cis%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Python中is"><a href="#Python中is" class="headerlink" title="Python中is"></a>Python中is</h2><p>Python中的is用来判断两个对象是否是同一个对象, 简单来说, 就是你通过使用Python中的<code>id()</code>函数去获取两个对象的内存地址, 如果地址相同, 即为同一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4363614224</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4363614224</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"abc"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4408735760</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4408735760</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>在Python的内部有一种intern机制, 在创建小段字符串和一定范围内的整型对象的时候, 会去建立一个全局唯一的对象, 当有其他”标签”(变量)引用到这个对象的时候, 不会重新生成一个新的对象, 而是会复用这个对象, 所以上面的例子🌰中, 虽然单独为两个变量赋值了短字符串, 但是他们实际指向的还是同一个对象, 同一块内存</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4420807080</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4420807488</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>可以看到, Python中的intern机制只适用于小整数或短字符串, 同样为基础数据类型的浮点型, 也是不支持的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4428278664</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4428154376</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4432739208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4432739208</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="Python中的"><a href="#Python中的" class="headerlink" title="Python中的=="></a>Python中的==</h2><p>Python中的<code>==</code>用来判断两个变量的值是否相等, 而不会纠结于两个变量的对象是否为同一个对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1.1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中, 使用is判断的话, 两个对象是两个单独的对象, 但是使用<code>==</code>判断的话, 只是判断他们的值是否相等, 显而易见, 虽然存放在不同的内存地址上, 但是他们的值是相等的</p>
<h3 id="魔法函数-eq"><a href="#魔法函数-eq" class="headerlink" title="魔法函数__eq__"></a>魔法函数<code>__eq__</code></h3><p><code>==</code>的判断实际上是由类中的<code>__eq__</code>这个魔法函数来实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, obj)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> self.name == obj.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(name=<span class="string">"larry"</span>)</span><br><span class="line">aa = A(name=<span class="string">"larry"</span>)</span><br><span class="line"></span><br><span class="line">print(a == aa)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">True</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>is</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的变量的本质</title>
    <url>/2018/07/31/Python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
    <content><![CDATA[<blockquote>
<p>Python和Java中变量的本质不一样. Java在定义变量的时候, 就已经确定了该变量的数据类型且不可改变. Python的变量实质上是一个指针, 指针本身的大小是固定的, 它可以指向一个int, 也可以指向str或其他任何数据类型. 在Python中查找数据, 只需要找到指针即可找到对应的数据. 可以简单把Python变量理解为一个标签, 这个标签的大小是固定的, 标签可以贴在任何对象上</p>
</blockquote>
<h1 id="创建变量的过程"><a href="#创建变量的过程" class="headerlink" title="创建变量的过程"></a>创建变量的过程</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">a = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>首先, 在内存中声明一个int对象, 用来放数据</li>
<li>然后给对象贴上标签</li>
</ul>
<p>注意: 对于Python来说, 是<code>a</code>标签贴在了对象上, 而不是将对象分配给<code>a</code>. 在Java来说, 才是将对象分配到了<code>a</code>的”盒子”里. “标签”是动态语言的核心</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(d)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<p>可以看到, a标签贴在了一个列表对象上, 然后将b也贴在了这个列表上, 所以后面对b标签的操作, 实际也是在操作a标签下的数据, 因为a, b两个标签此时对应的是同一对象</p>
<p>此时可能有人会有疑问, 上面是引用数据类型, 如果我操作的是基本数据类型呢? 请看如下实验</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">"abc"</span></span><br><span class="line">b = a</span><br><span class="line">b.replace(<span class="string">"c"</span>, <span class="string">"x"</span>)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;abc&#39;</span><br><span class="line">&#39;abc&#39;</span><br></pre></td></tr></table></figure>

<p>在第三行中, 我对字符串进行了替换操作, 为什么没有影响到最终的结果呢? 因为在<code>字符串</code>.replace()的操作后, 会返回一个新的字符串对象, 该字符串对象才是符合预期修改的字符串, 该操作新生成了对象返回, 没有影响到原始对象的数据. 而且我们可以通过id()函数来观察</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">id(a)</span><br><span class="line">id(b)</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4554176528</span><br><span class="line">4554176528</span><br></pre></td></tr></table></figure>

<p>从执行结果可以看出, 即使对象是基础数据类型, a, b两个标签依然是贴在同一个对象上, 没有生成新的对象</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之指针</title>
    <url>/2018/07/27/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="Go-语言的指针"><a href="#Go-语言的指针" class="headerlink" title="Go 语言的指针"></a>Go 语言的指针</h1><h2 id="Go-语言中获取内存地址"><a href="#Go-语言中获取内存地址" class="headerlink" title="Go 语言中获取内存地址"></a>Go 语言中获取内存地址</h2><p>Go语言使用<code>&amp;</code>符号来取地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> lv <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   fmt.Println(&amp;lv)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0xc420080030</span><br></pre></td></tr></table></figure>

<h2 id="Go语言中的指针"><a href="#Go语言中的指针" class="headerlink" title="Go语言中的指针"></a>Go语言中的指针</h2><p>一个指针变量指向了一个值的内存地址, 指针也是一种数据类型, 在使用之前, 你需要先声明指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age *<span class="keyword">int</span>  <span class="comment">// 指向整型的指针</span></span><br><span class="line"><span class="keyword">var</span> name *<span class="keyword">string</span>  <span class="comment">// 指向字符串的指针</span></span><br></pre></td></tr></table></figure>

<p>*<em>变量: *</em> 变量是一种占位符, 用于引用计算机内存的地址, 可以理解为内存地址的标签</p>
<p>*<em>指针: *</em> 指向其他变量内存地址的值</p>
<p>*<em>&amp;: *</em> 取变量的内存地址</p>
<p><em>*\</em>: ** 取指针指向的内存地址的值</p>
<p>比喻: 现屋里有一个2*2的箱子, 左下角箱子的编号是<code>1-1</code>标签贴了苹果, 右下角箱子的编号是<code>1-2</code>标签贴了玉米, 左上角箱子的编号是<code>2-1</code>标签贴了桃子, 右上角箱子的编号是<code>2-2</code>标签贴了土豆, 房间里还立着一个大指示牌. 🔜 如下图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-----------------</span><br><span class="line">|桃子🍑 | 土豆🥔 |</span><br><span class="line">|2-1   | 2-2    |</span><br><span class="line">----------------|</span><br><span class="line">|苹果🍎 | 玉米🌽 |</span><br><span class="line">|1-1   |1-2     |</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">🔜  指示牌</span><br></pre></td></tr></table></figure>

<ul>
<li>变量: 变量就是箱子上的标签, 桃子就是一个变量名, 而箱子里的桃子🍑则是值</li>
<li>值: 实际保存内容的地方, 也就是实际放在盒子里的东西</li>
<li>指针: 指针就理解为摆在房间里的指示牌, 指示牌可以指向任意一个箱子的地址, 也就是可以指向<code>1-1</code> <code>1-2</code> <code>2-1</code> 或 <code>2-2</code></li>
<li>&amp;: 获取变量的地址, 用在变量名前面, 理解为获取标签的地址, 比如&amp;玉米, 意思就是获取玉米所在箱子的地址, 也就是<code>1-2</code></li>
<li>*: 获取指针指向内存地址的值, 假如该指针指向了玉米的地址, 则使用<code>*</code>获取该指针的值即为箱子里所有的玉米🌽</li>
</ul>
<p>*<em>注意: *</em> 指针是有数据类型的, 比如你声明了一个水果类型的指针, 那么这个指针(这个指示牌)就只能指向<code>1-1</code> 或 <code>2-1</code> 这两个地址, 因为只有这两个地址的值类型为水果; 同理, 如果你声明了一个蔬菜类型的指针, 也只能指向 <code>1-2</code> 和 <code>2-2</code> 这两块内存地址, 下面介绍指针的使用时, 仍将使用到该比喻</p>
<h2 id="指针的使用"><a href="#指针的使用" class="headerlink" title="指针的使用"></a>指针的使用</h2><ul>
<li>定义指针变量</li>
<li>为指针赋值</li>
<li>访问指针变量中指向地址的值</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个水果变量, 假设int类型为水果类型</span></span><br><span class="line">	<span class="comment">// 假设59为苹果🍎, 59即为盒子实际存放的东西</span></span><br><span class="line">	<span class="keyword">var</span> fruit <span class="keyword">int</span> = <span class="number">59</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个int类型(水果类型)的指针变量</span></span><br><span class="line">	<span class="keyword">var</span> indicator *<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将fruit变量的地址赋值给指针</span></span><br><span class="line">	<span class="comment">// (将苹果盒子的地址1-1赋值给指示牌, 指示牌上写了/指向了1-1)</span></span><br><span class="line">	indicator = &amp;fruit</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 访问指针指向的值</span></span><br><span class="line">	<span class="comment">// 打开指示牌指向的盒子, 打开1-1盒子发现了真正存放的苹果🍎</span></span><br><span class="line">	fmt.Println(*indicator)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">59</span><br></pre></td></tr></table></figure>

<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><p>当一个指针被声明后, 却没有被赋予任何变量的内存地址, 此时, 该指针的值为<code>nil</code>, nil指针也被称作空指针</p>
<p>nil在概念上和其它语言的null、None、nil、NULL一样，都指代零值或空值, 一个指针变量通常缩写为 ptr</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ptr *<span class="keyword">int</span></span><br><span class="line">	fmt.Println(ptr)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ptr == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"ptr为空指针"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"ptr为非空指针"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;nil&gt;</span><br><span class="line">ptr为空指针</span><br></pre></td></tr></table></figure>

<h2 id="Go指针引用之向函数传递指针参数"><a href="#Go指针引用之向函数传递指针参数" class="headerlink" title="Go指针引用之向函数传递指针参数"></a>Go指针引用之向函数传递指针参数</h2><p><strong>值传递? 引用传递?</strong></p>
<p>在Python中, 除了像int, str这样基本数据类型是值传递外, 其余绝大部分都是引用传递.<br>而在Go语言中, 只有值传递一种方式, Go语言中是通过传递指针来实现引用传递的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap1</span><span class="params">(a, b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	b, a = a, b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *int 指向整型的指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap2</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// b指向的值赋值给a, a指向的值赋值给b</span></span><br><span class="line">	<span class="comment">// *b, *a = *a, *b</span></span><br><span class="line">	<span class="comment">// *a 取出 a 指针指向的值赋值给 c 变量(中间变量)</span></span><br><span class="line">	c := *a</span><br><span class="line">	<span class="comment">// *b 取出 b 指针的指向的值赋值给 a指针的值</span></span><br><span class="line">	<span class="comment">// 注意, 不能把值直接赋值给指针</span></span><br><span class="line">	<span class="comment">// 指针只是保存值的地址</span></span><br><span class="line">	<span class="comment">// 所以这里将 b 指针指向的值赋值给 a 指针指向的值, 即用 b 值覆盖 a 值</span></span><br><span class="line">	*a = *b</span><br><span class="line">	<span class="comment">// 最后用 c 变量的值, 覆盖 b 值</span></span><br><span class="line">	*b = c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap3</span><span class="params">(a, b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	*a, *b = *b, *a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap4</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用值传递的方式, 利用返回值来实现值的交换</span></span><br><span class="line">	<span class="keyword">return</span> b, a</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a, b := <span class="number">5</span>, <span class="number">9</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值传递, 交换只在函数内生效, 不能改变外面的值</span></span><br><span class="line">	swap1(a, b)</span><br><span class="line">	fmt.Println(a, b)  <span class="comment">// 结果为: 5 9</span></span><br><span class="line">	<span class="comment">// 从结果中可以看出, a, b两个变量进入到函数是值拷贝, 在函数内的操作并没有改变函数外a, b实际的值</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 交换地址(引用传递)</span></span><br><span class="line">	swap2(&amp;a, &amp;b)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次交换地址(引用传递)</span></span><br><span class="line">	swap3(&amp;a, &amp;b)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 值传递, 利用返回值交换值</span></span><br><span class="line">	<span class="comment">// 注意返回值的顺序, 返回值里交换了, 接收返回值的顺序就不要变</span></span><br><span class="line">	<span class="comment">// 如果return是 a,b 那么接收的时候就要变成 b, a 去接收</span></span><br><span class="line">	a, b = swap4(a, b)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>以上交换的场景中, swap4为最佳方案, 简单有效! 指针在实际使用中也要充分考虑使用场景, 是否非用指针不可</strong></p>
<h2 id="Go指针引用之指向指针的指针"><a href="#Go指针引用之指向指针的指针" class="headerlink" title="Go指针引用之指向指针的指针"></a>Go指针引用之指向指针的指针</h2><p>待续…</p>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之函数的用法</title>
    <url>/2018/07/26/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>本文Demo介绍Go语言函数的使用, 包含多返回值, 闭包, 带参闭包, 函数作为变量的值, 函数的参数为函数, 函数参数为可变参数列表的这几种情况</p>
</blockquote>
<p><strong>在Go语言的函数的参数中, 没有Python中类似的默认参数, 可变参数等概念, 只有一个可变参数列表的功能</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的用法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Go语言支持多返回值, 大多数情况下, 返回两个值, 一个值是结果, 一个值是error</span></span><br><span class="line"><span class="comment">// 如果函数执行正确, error值返回为nil</span></span><br><span class="line"><span class="comment">// 这样在if判断的时候, 就可以判断函数的第二个返回值是否非nil</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo5</span><span class="params">(arg1, arg2 <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> arg2 == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">float64</span>(<span class="number">0</span>), fmt.Errorf(<span class="string">"被除数不能为0"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arg1/arg2, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的用法之闭包</span></span><br><span class="line"><span class="comment">// 闭包的表现形式为函数里返回另外一个匿名函数, 该匿名函数为一个内联的语句或表达式</span></span><br><span class="line"><span class="comment">// func 函数名() 匿名函数() 匿名函数返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo6</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 在命名函数内声明变量</span></span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="comment">// 在匿名函数中可以直接访问或操作命名函数中定义的变量</span></span><br><span class="line">		i++</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参闭包</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo7</span><span class="params">(arg1, arg2 <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(arg3, arg4 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(arg3, arg4 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">		i++</span><br><span class="line">		sum := arg1 + arg2 + arg3 + arg4 + i</span><br><span class="line">		<span class="keyword">return</span> sum, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数还有一种用法: 作为变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo8</span><span class="params">(arg1, arg2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 声明一个普通变量, 该变量的值为一个函数</span></span><br><span class="line">	result := <span class="function"><span class="keyword">func</span><span class="params">(arg3, arg4 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> arg1 * arg2</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 该变量被赋值为一个函数后, 该变量即可被当做其函数调用</span></span><br><span class="line">	r := result(arg1, arg2)</span><br><span class="line">	fmt.Println(r)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的参数为函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo9</span><span class="params">(arg1, arg2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg1 + arg2, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo10</span><span class="params">(op <span class="keyword">func</span>(arg1, arg2 <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span>, <span class="title">arg3</span>, <span class="title">arg4</span> <span class="title">int</span>) <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	result, err := op(arg3, arg4)</span><br><span class="line">	<span class="keyword">return</span> result, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的参数为可变参数列表(参数传多少个值都可以)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo11</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">	s := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">		s += numbers[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> result, err := FuncDemo5(<span class="number">13</span>,<span class="number">6</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> result, err := FuncDemo5(<span class="number">13</span>,<span class="number">0</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Error"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(result)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	nextValue := FuncDemo6()</span><br><span class="line">	fmt.Println(nextValue())</span><br><span class="line">	fmt.Println(nextValue())</span><br><span class="line">	fmt.Println(nextValue())</span><br><span class="line"></span><br><span class="line">	nextValue2 := FuncDemo6()</span><br><span class="line">	fmt.Println(nextValue2())</span><br><span class="line">	fmt.Println(nextValue2())</span><br><span class="line"></span><br><span class="line">	demo7 :=  FuncDemo7(<span class="number">5</span>,<span class="number">9</span>)</span><br><span class="line">	fmt.Println(demo7(<span class="number">6</span>,<span class="number">13</span>)) <span class="comment">// i==1  5+9+6+13+1</span></span><br><span class="line">	fmt.Println(demo7(<span class="number">6</span>,<span class="number">13</span>)) <span class="comment">// i==2  5+9+6+13+2</span></span><br><span class="line">	fmt.Println(demo7(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">// i==3  5+9+10+10+3</span></span><br><span class="line"></span><br><span class="line">	FuncDemo8(<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(FuncDemo10(FuncDemo9, <span class="number">5</span>,<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">	fmt.Println(FuncDemo11(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2.1666666666666665</span><br><span class="line">Error</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">34 &lt;nil&gt;</span><br><span class="line">35 &lt;nil&gt;</span><br><span class="line">37 &lt;nil&gt;</span><br><span class="line">30</span><br><span class="line">14 &lt;nil&gt;</span><br><span class="line">15 &lt;nil&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>func</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之函数</title>
    <url>/2018/07/25/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// func 函数名(参数1 参数类型, 参数2 参数类型....) 返回值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncName</span><span class="params">(arg1 <span class="keyword">int</span>, arg2 <span class="keyword">int</span>, arg3 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> arg3 &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"+"</span>: <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"-"</span>: <span class="keyword">return</span> arg1 - arg2</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数列表中, 相同类型的参数可以统一声明</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo2</span><span class="params">(arg1, arg2 <span class="keyword">int</span>, arg3 <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">switch</span> arg3 &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"+"</span>: <span class="keyword">return</span> arg1 + arg2</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"-"</span>: <span class="keyword">return</span> arg1 - arg2</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo3</span><span class="params">(arg1, arg2 <span class="keyword">int</span>, arg3 <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> arg1, arg2, arg3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名返回值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FuncDemo4</span><span class="params">(arg1, arg2 <span class="keyword">int</span>, arg3 <span class="keyword">string</span>)</span> <span class="params">(a, b <span class="keyword">int</span>, c <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	a = arg1</span><br><span class="line">	b = arg2</span><br><span class="line">	c = arg3</span><br><span class="line">	<span class="comment">// 由于上面已经为返回值变量赋值, return时后面可以省略不写</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数参数</span></span><br><span class="line"><span class="comment">// 值传递: 指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数</span></span><br><span class="line"><span class="comment">// 引用传递: 指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	result := FuncName(<span class="number">5</span>, <span class="number">9</span>, <span class="string">"+"</span>)</span><br><span class="line">	result2 := FuncDemo2(<span class="number">9</span>, <span class="number">5</span>, <span class="string">"-"</span>)</span><br><span class="line">	fmt.Println(result, result2)</span><br><span class="line"></span><br><span class="line">	a, b, c := FuncDemo3(<span class="number">5</span>,<span class="number">9</span>,<span class="string">"*"</span>)</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line"></span><br><span class="line">	d, e, f := FuncDemo4(<span class="number">5</span>,<span class="number">6</span>, <span class="string">"/"</span>)</span><br><span class="line">	fmt.Println(d, e, f)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14 4</span><br><span class="line">5 9 *</span><br><span class="line">5 6 &#x2F;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>func</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之循环</title>
    <url>/2018/07/25/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForDemo1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 初始值; 循环条件表达式; 赋值</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">1</span>; i&lt;=<span class="number">5</span> ; i++ &#123;</span><br><span class="line">		fmt.Println(<span class="string">"--&gt;"</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForDemo2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 也可以只写一个循环条件表达式, 类似于Python中的while 条件表达式循环</span></span><br><span class="line">	<span class="keyword">for</span> i &lt;= <span class="number">5</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"---&gt;"</span>, i)</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ForDemo3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 死循环, 类似于Python中的while True</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"这是个死循环"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ForDemo1()</span><br><span class="line">	ForDemo2()</span><br><span class="line">	ForDemo3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&gt; 1</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 3</span><br><span class="line">--&gt; 4</span><br><span class="line">--&gt; 5</span><br><span class="line">---&gt; 0</span><br><span class="line">---&gt; 1</span><br><span class="line">---&gt; 2</span><br><span class="line">---&gt; 3</span><br><span class="line">---&gt; 4</span><br><span class="line">---&gt; 5</span><br><span class="line">这是个死循环</span><br><span class="line">这是个死循环</span><br><span class="line">这是个死循环</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>for</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之条件判断</title>
    <url>/2018/07/25/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"runtime"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IfDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	OSName := runtime.GOOS</span><br><span class="line">	<span class="comment">// 现在if条件外面赋值, 再进行判断</span></span><br><span class="line">	<span class="keyword">if</span> OSName == <span class="string">"windows"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"It's Windows"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> OSName == <span class="string">"linux"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"It's Linux🐧"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> OSName == <span class="string">"darwin"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"It's MacOS🍎"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"Other OS"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 也可以在if条件语句中先赋值再判断</span></span><br><span class="line">	<span class="comment">// if条件里的变量作用域只在if代码块中</span></span><br><span class="line">	<span class="keyword">if</span> OSArch := runtime.GOARCH; OSArch == <span class="string">"amd64"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"64位操作系统❗️"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> OSArch == <span class="string">"amd32"</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"32位操作系统❗️️"</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"什么鬼❓"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SwitchDemo</span><span class="params">()</span></span> &#123;</span><br><span class="line">	OSName := runtime.GOOS</span><br><span class="line">	<span class="comment">// switch语句, switch后可以跟任何类型的变量, case后跟该变量相同类型的值</span></span><br><span class="line">	<span class="keyword">switch</span> OSName &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"windows"</span>: fmt.Println(<span class="string">"It's Windows"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"linux"</span>: fmt.Println(<span class="string">"It's Linux🐧"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"darwin"</span>: fmt.Println(<span class="string">"It's MacOS🍎"</span>)</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"unix"</span>, <span class="string">"ios"</span>, <span class="string">"android"</span>: fmt.Println(<span class="string">"🙃"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"什么鬼❓"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	OSArch := runtime.GOARCH</span><br><span class="line">	<span class="comment">// switch语句, switch后面可以不跟任何类型的变量, 由case后定义表达式</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> OSArch == <span class="string">"amd64"</span>: fmt.Println(<span class="string">"64位操作系统❗️"</span>)</span><br><span class="line">	<span class="keyword">case</span> OSArch == <span class="string">"amd32"</span>: fmt.Println(<span class="string">"32位操作系统❗️"</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">"什么鬼❓"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	IfDemo()</span><br><span class="line">	SwitchDemo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">It&#39;s MacOS🍎</span><br><span class="line">64位操作系统❗️</span><br><span class="line">It&#39;s MacOS🍎</span><br><span class="line">64位操作系统❗</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>if</tag>
        <tag>switch</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之枚举类型</title>
    <url>/2018/07/24/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//枚举</span></span><br><span class="line"><span class="comment">//GO语言没有枚举的关键字</span></span><br><span class="line"><span class="comment">//而是通过定义一组常量来实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		cpp = <span class="number">0</span></span><br><span class="line">		java = <span class="number">1</span></span><br><span class="line">		python = <span class="number">2</span></span><br><span class="line">		golang = <span class="number">3</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		iPhone = <span class="number">2</span> * <span class="literal">iota</span> <span class="comment">//iota表示自增值</span></span><br><span class="line">		_</span><br><span class="line">		iPad</span><br><span class="line">		iMac</span><br><span class="line">		iPod</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">		kb</span><br><span class="line">		mb</span><br><span class="line">		gb</span><br><span class="line">		tb</span><br><span class="line">		pb</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Println(cpp, java, python, golang)</span><br><span class="line">	fmt.Println(iPhone, iPad, iMac, iPod)</span><br><span class="line">	fmt.Println(b, kb, mb, gb, tb, pb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	enums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 1 2 3</span><br><span class="line">0 4 6 8</span><br><span class="line">1 1024 1048576 1073741824 1099511627776 1125899906842624</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之常量的定义</title>
    <url>/2018/07/24/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%B8%B8%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Go语言的常量名一般不会使用全部大写或首字符大写</span></span><br><span class="line"><span class="comment">//在Go语言中, 首字母大写一般表示Public</span></span><br><span class="line"><span class="comment">//常量的数值可以作为各种类型使用</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//包内常量</span></span><br><span class="line"><span class="keyword">const</span> car = <span class="string">"logo"</span></span><br><span class="line"><span class="comment">//批量声明常量时必须为常量赋值, 不能像变量一样只声明不赋值</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	page = <span class="number">59</span></span><br><span class="line">	book = <span class="string">"0 to 1"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consts</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//可以不声明类型</span></span><br><span class="line">	<span class="keyword">const</span> filename = <span class="string">"x.txt"</span></span><br><span class="line">	<span class="comment">//可以显示的声明类型, 显示声明后, 该常量的类型就已经确定</span></span><br><span class="line">	<span class="keyword">const</span> os <span class="keyword">string</span> = <span class="string">"mac os"</span></span><br><span class="line">	<span class="comment">//不声明类型, 虽然已经赋值, 但值的类型不确定, 只是文本</span></span><br><span class="line">	<span class="keyword">const</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//由于常量a, b没有声明类型, 在使用a,b 时会自动转换为合适的数据类型</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(a*a + b*b))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之基本数据类型</title>
    <url>/2018/07/24/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"math"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//内建变量类型</span></span><br><span class="line"><span class="comment">//bool string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//u 无符号整数, 不带u为有符号整数</span></span><br><span class="line"><span class="comment">//(u)int (u)int8 (u)int16 (u)int32 (u)int64 uintptr</span></span><br><span class="line"><span class="comment">//int 为不规定长度的整形, 其长度由操作系统的位数决定</span></span><br><span class="line"><span class="comment">//ptr为指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//byte rune(字符型)长度32位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//float32 float64 complex64 complex128(复数)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Go语言中, 所有的类型转换都是显示的强制类型转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangle</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">	<span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">	<span class="comment">//func Sqrt(x float64) float64 接收float64类型的参数, 返回float64类型的值</span></span><br><span class="line">	<span class="comment">//在其他语言中, int类型可以被隐式的转换为float进行计算, 但是在Go, 必须显示强制类型转换</span></span><br><span class="line">	<span class="comment">//c 为int类型, 而函数返回值为float64类型, 所以也需要强制类型转换为int</span></span><br><span class="line">	c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">	fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	triangle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Go基础之变量的定义</title>
    <url>/2018/07/24/Go%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在func外面定义的变量, 必须使用var关键字声明, 不用使用 := 的简写方式</span></span><br><span class="line"><span class="comment">//变量作用域为包内</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明变量</span></span><br><span class="line"><span class="comment">//声明的包变量只能在函数内被赋值, 包内不允许被赋值</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	d <span class="keyword">int</span></span><br><span class="line">	e <span class="keyword">int</span></span><br><span class="line">	f <span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明并赋值</span></span><br><span class="line"><span class="comment">//可以在变量后声明数据类型</span></span><br><span class="line"><span class="keyword">var</span> name1 <span class="keyword">int</span> = <span class="number">9</span></span><br><span class="line"><span class="comment">//也可以让Go自动去判断数据类型</span></span><br><span class="line"><span class="keyword">var</span> name2 = <span class="string">"ps"</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	age <span class="keyword">int</span> = <span class="number">28</span></span><br><span class="line">	address = <span class="string">"China"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> g, h, i = <span class="number">78</span>, <span class="string">"uu"</span>, <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数内变量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//声明</span></span><br><span class="line">	<span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		k <span class="keyword">int</span></span><br><span class="line">		l <span class="keyword">string</span></span><br><span class="line">	)</span><br><span class="line">	<span class="comment">//x y z 全部为bool类型</span></span><br><span class="line">	<span class="keyword">var</span> x, y, z <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//赋值</span></span><br><span class="line">	j = <span class="number">2</span></span><br><span class="line">	k = <span class="number">78</span></span><br><span class="line">	l = <span class="string">"BJ"</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//声明并赋值</span></span><br><span class="line">	<span class="comment">//Go编译器自动决定变量类型</span></span><br><span class="line">	<span class="keyword">var</span> m, n = <span class="number">56</span>, <span class="string">"SOHO"</span></span><br><span class="line">	<span class="comment">//r s t 全部为string类型</span></span><br><span class="line">	<span class="keyword">var</span> r, s, t <span class="keyword">string</span> = <span class="string">"hehe"</span>, <span class="string">"heihei"</span>, <span class="string">"haha"</span></span><br><span class="line">	<span class="comment">//包内的变量声明并赋值可以使用简写方式</span></span><br><span class="line">	o, p, q := <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">87</span></span><br><span class="line"></span><br><span class="line">	fmt.Println(j, k, l, x, y, z, m, n, r, s, t, o, q, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(a, b, c, d, e, f, g, h, i, name1, name2, age, address)</span><br><span class="line">	test()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeError: not all arguments converted during string formatting python</title>
    <url>/2018/03/16/TypeError-not-all-arguments-converted-during-string-formatting-python/</url>
    <content><![CDATA[<p>该报错发生在字符串拼接时的操作, 以下字符串拼接的方式, 只要不混用, 该问题就可以解决</p>
<h1 id="第一种-占位符"><a href="#第一种-占位符" class="headerlink" title="第一种 % 占位符"></a>第一种 % 占位符</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">2</span>]: s  = <span class="string">"abc %s"</span> % <span class="number">123</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: s</span><br><span class="line">Out[<span class="number">3</span>]: <span class="string">'abc 123'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: s = <span class="string">'abc %s %s'</span> % (<span class="number">123</span>, <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: s</span><br><span class="line">Out[<span class="number">5</span>]: <span class="string">'abc 123 456'</span></span><br></pre></td></tr></table></figure>

<h1 id="第二种-大括号"><a href="#第二种-大括号" class="headerlink" title="第二种 {} 大括号"></a>第二种 {} 大括号</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">6</span>]: s = <span class="string">'abc &#123;0&#125;'</span>.format(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: s</span><br><span class="line">Out[<span class="number">7</span>]: <span class="string">'abc 123'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: s = <span class="string">'abc &#123;0&#125; &#123;1&#125;'</span>.format(<span class="number">123</span>, <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: s</span><br><span class="line">Out[<span class="number">9</span>]: <span class="string">'abc 123 456'</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>format</tag>
      </tags>
  </entry>
  <entry>
    <title>python中的mysql连接池</title>
    <url>/2018/03/16/python%E4%B8%AD%E7%9A%84mysql%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB</span><br><span class="line"></span><br><span class="line">MYSQL_HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">USER = <span class="string">'zabbix'</span></span><br><span class="line">PASSWORD = <span class="string">'p@55w0rd'</span></span><br><span class="line">DB = <span class="string">'zabbix'</span></span><br><span class="line">PORT = <span class="number">3306</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据库连接池</span></span><br><span class="line">mp = PooledDB(</span><br><span class="line">    pymysql, mincached=<span class="number">5</span>, maxconnections=<span class="number">10</span>, blocking=<span class="literal">True</span>,</span><br><span class="line">    host=MYSQL_HOST, user=USER, passwd=PASSWORD, db=DB, port=PORT, charset=<span class="string">"utf8"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">conn = mp.connection()</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"select hostid from hosts where name='xxx';"</span></span><br><span class="line">mysql.cur.execute(sql)</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<h1 id="PooledDB的参数"><a href="#PooledDB的参数" class="headerlink" title="PooledDB的参数"></a>PooledDB的参数</h1><ul>
<li>mincached: 最少的空闲连接数, 如果空闲连接数小于这个数, pool会创建一个新的连接</li>
<li>maxcached: 最大的空闲连接数, 如果空闲连接数大于这个数, pool会关闭空闲连接</li>
<li>maxconnections: 最大的连接数</li>
<li>blocking: 当连接数达到最大的连接数时, 在请求连接的时候, 如果这个值是True, 请求连接的程序会一直等待, 直到当前连接数小于最大连接数, 如果这个值是False, 会报错</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pymysql</tag>
        <tag>pool</tag>
      </tags>
  </entry>
  <entry>
    <title>python下http.client与urllib访问https报证书认证失败</title>
    <url>/2018/03/16/python%E4%B8%8Bhttp-client%E4%B8%8Eurllib%E8%AE%BF%E9%97%AEhttps%E6%8A%A5%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<p>在python3代码中, 使用http.client或urllib.request进行https访问的时候, 出现以下报错</p>
<p><code>ssl.SSLError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:777)</code></p>
<p>解决方法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import ssl</span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context &#x3D; ssl._create_unverified_context</span><br></pre></td></tr></table></figure>

<p>再次访问, 即可正常访问https站点</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ssl</tag>
        <tag>http.client</tag>
        <tag>urllib.request</tag>
      </tags>
  </entry>
  <entry>
    <title>python连接mysql报错:&#39;latin-1&#39; codec can&#39;t encode characters</title>
    <url>/2018/03/16/python%E8%BF%9E%E6%8E%A5mysql%E6%8A%A5%E9%94%99-latin-1-codec-can-t-encode-characters/</url>
    <content><![CDATA[<blockquote>
<p>python连接mysql数据库进行查询时, 遇到以下报错: <code>UnicodeEncodeError: &#39;latin-1&#39; codec can&#39;t encode characters in position 40-41: ordinal not in range(256)</code> 很明显提示了是字符编码的问题</p>
</blockquote>
<p>发生以上问题, 是因为我在sql语句中出现了中文, 在拿到db游标对象之后, 去执行sql的时候的报错</p>
<h1 id="排查数据库字符编码"><a href="#排查数据库字符编码" class="headerlink" title="排查数据库字符编码"></a>排查数据库字符编码</h1><p>登录MySQL数据库, 执行以下SQL语句执行查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">| Variable_name            | Value              |</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">| character_set_client     | utf8mb4            |</span><br><span class="line">| character_set_connection | utf8mb4            |</span><br><span class="line">| character_set_database   | utf8mb4            |</span><br><span class="line">| character_set_filesystem | binary             |</span><br><span class="line">| character_set_results    | utf8mb4            |</span><br><span class="line">| character_set_server     | utf8mb4            |</span><br><span class="line">| character_set_system     | utf8               |</span><br><span class="line">| collation_connection     | utf8mb4_unicode_ci |</span><br><span class="line">| collation_database       | utf8mb4_unicode_ci |</span><br><span class="line">| collation_server         | utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>经过查询, 发现mysql数据库本身已是 <code>utf8</code> 的字符编码</p>
<p>分析可能的原因:</p>
<p>mysql一般有三段配置, 分别是: <code>[mysql]</code> <code>[clinet]</code> <code>[mysqld]</code></p>
<ul>
<li>[mysql] 对其他远程连接的mysql客户端的配置, 例如在其他服务器执行<code>mysql -h -u -p</code>或使用代码进行连接</li>
<li>[client] 对本地的mysql客户端的配置, 例如在本地执行<code>mysql -u -p</code></li>
<li>[mysqld] 对mysql服务进行配置</li>
</ul>
<p>有可能mysql配置文件中的[mysql]下没有配置 <code>default-character-set = utf8mb4</code>, 导致远程客户端连接到服务器端后, 没有获得服务端声明的字符编码, 而使用客户端默认带的字符编码进行连接, 如果是这种情况, 可以在mysql服务端更改配置文件并重启mysql服务, 如果你不想重启数据库, 可以显示地在mysql客户端声明使用的字符编码</p>
<h1 id="解决pymysql字符编码问题"><a href="#解决pymysql字符编码问题" class="headerlink" title="解决pymysql字符编码问题"></a>解决pymysql字符编码问题</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">db = pymysql.connect(<span class="string">"localhost"</span>,<span class="string">"root"</span>,<span class="string">"123"</span>,<span class="string">"mysql"</span>, charset=<span class="string">"utf8"</span>)</span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line">sql = <span class="string">"select Host, User from user where User='中文';"</span></span><br><span class="line">cursor.execute(sql)</span><br></pre></td></tr></table></figure>

<p>解决方法很简单, 只需要在创建数据库连接对象的时候, 显示地声明字符编码就可以了 <code>charset=&quot;utf8&quot;</code></p>
<p>注意: 如果你的MySQL服务器的字符编码使用的是<code>utf-8</code> 的话, 你需要声明你的连接对象的字符编码也是 <code>utf-8</code></p>
<p>如果你的MySQL服务器的字符编码使用的是<code>utf8mb4</code> 的话, 相对应的, 你应该声明自己客户端的字符编码是 <code>utf8mb4</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pymysql</tag>
      </tags>
  </entry>
  <entry>
    <title>heartbeat-elastic报错:system_api_version [6] is not supported by system_id [beats]</title>
    <url>/2018/02/11/heartbeat-elastic%E6%8A%A5%E9%94%99-system-api-version-6-is-not-supported-by-system-id-beats/</url>
    <content><![CDATA[<blockquote>
<p>配置heartbeat-elastic服务时日志报错如下<code>2018-02-11T07:36:29.217-0500    ERROR   pipeline/output.go:92   Failed to publish events: 400 Bad Request: {&quot;error&quot;:{&quot;root_cause&quot;:[{&quot;type&quot;:&quot;illegal_argument_exception&quot;,&quot;reason&quot;:&quot;system_api_version [6] is not supported by system_id [beats]&quot;}],&quot;type&quot;:&quot;illegal_argument_exception&quot;,&quot;reason&quot;:&quot;system_api_version [6] is not supported by system_id [beats]&quot;},&quot;status&quot;:400}</code></p>
</blockquote>
<p>解决方法:</p>
<p>手动设置<code>/etc/heartbeat/heartbeat.yml</code> 配置文件中的 <code>name</code>变量 <code>name: 10.10.62.16</code> </p>
<p>重启<code>heartbeat-elastic</code>服务即可</p>
<p><code>systemctl restart heartbeat-elastic.service</code></p>
]]></content>
      <categories>
        <category>ELK Stack</category>
      </categories>
      <tags>
        <tag>elasticsearch</tag>
        <tag>heartbeat-elastic</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现redis的自增操作</title>
    <url>/2018/01/29/Python%E5%AE%9E%E7%8E%B0redis%E7%9A%84%E8%87%AA%E5%A2%9E%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>在传统的数据库中, 如果实现一个计数器的操作, 需要先去数据库中读取该值, 再程序中加1, 再讲最新的值存入数据库. 用户操作的流程步骤多不说, 还容易出现数据安全性的问题, 比如多进程/多线程的并发情况, 有可能出现A进程读取的计数器为5, 在本地执行+1, 操作的时候, 此时B进程也去执行计数器+1操作, B读取的数值也是5, 然后A将+1之后的数字6存入数据库, 之后B处理完后也将+1之后的6存入数据库, 这样就导致了在并发的情况下, 计数器的数据不准的情况.</p>
</blockquote>
<p>Redis的很多操作本身都是原子性的, 例如上面案例中, 计数器+1的问题, 会有三个步骤</p>
<ul>
<li>读取数值</li>
<li>自增操作</li>
<li>写入数值</li>
</ul>
<p>在传统数据库中, 为了保证数据的安全性, 这三个步骤通常是要加锁的, 也就是在步骤已经很多的情况下, 还需要考虑锁的问题. 但是Redis就不同了, Redis原子性的意思就是说, 可以保证上面的三个步骤是一个操作, 在这个操作完成之后才允许我们对其进行其他操作, 这就原生的保证了数据安全性</p>
<h1 id="redis中的自增"><a href="#redis中的自增" class="headerlink" title="redis中的自增"></a>redis中的自增</h1><p>在redis中, 如果一个key的value是数值类型, 我们就可以对这个值进行incr操作, 如果数值是整形int, 使用incr进行自增操作, 如果数值是浮点型float, 则需要使用incrbyfloat进行操作, 还有一种情况, 就是对int使用了incrbyfloat操作, 则这个数值就会变成float类型, 也就无法再对其执行incr操作了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: pool=redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>,port=<span class="number">6379</span>,db=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: r = redis.StrictRedis(connection_pool=pool)</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: r.keys()</span><br><span class="line">Out[<span class="number">4</span>]: []</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: r.incr(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: r.incr(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: r.incr(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: r.incr(<span class="string">'counter'</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: r.keys()</span><br><span class="line">Out[<span class="number">9</span>]: [<span class="string">b'counter'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: r.get(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">10</span>]: <span class="string">b'5'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: r.incrbyfloat(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">6.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: r.incrbyfloat(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">12</span>]: <span class="number">7.0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: r.incrbyfloat(<span class="string">'counter'</span>, <span class="number">0.1</span>)</span><br><span class="line">Out[<span class="number">13</span>]: <span class="number">7.1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: r.incrbyfloat(<span class="string">'counter'</span>, <span class="number">0.1</span>)</span><br><span class="line">Out[<span class="number">14</span>]: <span class="number">7.2</span></span><br></pre></td></tr></table></figure>

<h1 id="redis中的自减"><a href="#redis中的自减" class="headerlink" title="redis中的自减"></a>redis中的自减</h1><p>redis中使用decr函数进行自减操作, 但是自减中, 没有提供类似incrbyfloat的操作, 如果在自减中想实现浮点数的效果, 可以通过在incrbyfloat函数中使用负数的方式实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">19</span>]: r.keys()</span><br><span class="line">Out[<span class="number">19</span>]: []</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: r.incr(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: r.decr(<span class="string">'counter'</span>)</span><br><span class="line">Out[<span class="number">21</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: r.incrbyfloat(<span class="string">'counter'</span>, <span class="number">-1.1</span>)</span><br><span class="line">Out[<span class="number">22</span>]: <span class="number">-1.1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: r.incrbyfloat(<span class="string">'counter'</span>, <span class="number">-1.1</span>)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">-2.2</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx切割日志文件</title>
    <url>/2018/01/26/inx%E5%88%87%E5%89%B2%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>不知道这么基础的功能, 为什么Nginx官方没有提供配置~</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#设置日志文件存放目录</span></span><br><span class="line">logs_path=<span class="string">"/data/logs/nginx/"</span></span><br><span class="line"><span class="comment">#设置pid文件</span></span><br><span class="line">pid_path=<span class="string">"/usr/local/openresty/nginx/logs/nginx.pid"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重命名日志文件</span></span><br><span class="line">mv <span class="variable">$&#123;logs_path&#125;</span>access.log <span class="variable">$&#123;logs_path&#125;</span>access_$(date -d <span class="string">"yesterday"</span> +<span class="string">"%Y%m%d"</span>).<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#向nginx主进程发信号重新打开日志</span></span><br><span class="line"><span class="built_in">kill</span> -USR1 `cat <span class="variable">$&#123;pid_path&#125;</span>`</span><br></pre></td></tr></table></figure>

<p>以上文件名为年月日形式, 写成脚本保存, 然后加入到计划任务里每天执行就可以了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; crontab -l</span><br><span class="line">0 0  *  *  * &#x2F;bin&#x2F;bash &#x2F;data&#x2F;scripts&#x2F;nginx_log_cut.sh &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>json.dumps中的ensure_ascii参数</title>
    <url>/2018/01/25/json-dumps%E4%B8%AD%E7%9A%84ensure-ascii%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>json dump 中文时遇到的问题如下</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"Chinese"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> json.dumps(s)</span><br><span class="line"><span class="string">"Chinese"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"中文"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> json.dumps(s)</span><br><span class="line"><span class="string">"\u4e2d\u6587"</span></span><br></pre></td></tr></table></figure>

<p>可以看到, json在dump中文的时候, 输出的是”中文”对应的ascii码, 这是因为json.dumps 序列化时对中文默认使用的ascii编码</p>
<p>如果需要输出真正的中文字符, 需要在dump的时候加入<code>ensure_ascii=False</code>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"中文"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> json.dumps(s, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="string">"中文"</span></span><br></pre></td></tr></table></figure>

<p>实际使用中, 在与微信企业企业号的主动发送消息接口交互时, 需要使用utf8字符编码encode</p>
<p>所以在这个场景下, 写法可能会是下面这种情况</p>
<p><code>json.dumps(s, ensure_ascii=False).encode(&#39;utf-8&#39;)</code></p>
<p>Python3: 注意以下操作只在Python3环境下是正确的, Python2的环境下.encode会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  ~ python3</span><br><span class="line">Python <span class="number">3.6</span><span class="number">.3</span> (v3<span class="number">.6</span><span class="number">.3</span>:<span class="number">2</span>c5fed86e0, Oct  <span class="number">3</span> <span class="number">2017</span>, <span class="number">00</span>:<span class="number">32</span>:<span class="number">08</span>)</span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"中文"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(s, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="string">'"中文"'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(s, ensure_ascii=<span class="literal">False</span>).encode(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="string">b'"\xe4\xb8\xad\xe6\x96\x87"'</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Input strings must be a multiple of 16 in length</title>
    <url>/2018/01/25/nput-strings-must-be-a-multiple-of-16-in-length/</url>
    <content><![CDATA[<p>在实现微信企业号自建应用与自由服务器信息交互的时候, 报了 <code>Input strings must be a multiple of 16 in length</code> 这个错误, 回复全部英文内容给微信的时候是正常的.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sRespData = <span class="string">"""&lt;xml&gt;</span></span><br><span class="line"><span class="string">                &lt;ToUserName&gt;&lt;![CDATA["""</span>+user_id+<span class="string">"""]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">                &lt;FromUserName&gt;&lt;![CDATA["""</span>+corp_id+<span class="string">"""]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">                &lt;CreateTime&gt;"""</span>+create_time+<span class="string">"""&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">                &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">                &lt;Content&gt;&lt;![CDATA["""</span>+content+<span class="string">"""]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="string">                &lt;/xml&gt;"""</span></span><br></pre></td></tr></table></figure>

<p>如以上即将回复给微信的xml信息, content变量就是实际的消息内容, 当content内容出现中文字符时, 就会报以上错误.</p>
<p>解决方法:</p>
<p><code>content = content.encode(&#39;utf-8&#39;)</code></p>
<p>将content的内容以utf8字符编码进行encode即可</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
        <tag>企业微信</tag>
      </tags>
  </entry>
  <entry>
    <title>import httplib ImportError: No module named httplib</title>
    <url>/2018/01/25/import-httplib-ImportError-No-module-named-httplib/</url>
    <content><![CDATA[<p>在Python2的代码中<code>import httplib</code>是没有问题的, 到了Python3, 这个模块的导入名称变成了<code>http.client</code>, 所以在如果你使用的是Python3, 需要导入这个模块, <code>import http.client</code>就可以了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2的中文字符编码报错</title>
    <url>/2018/01/25/Python2%E7%9A%84%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>在Python2中, 在首行声明了字符编码为<code>utf8</code>, 但是依然报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe6 in position 0: ordinal not in range(128)</span><br></pre></td></tr></table></figure>

<p>解决方法如下:</p>
<p>在报错的python文件中加入以下几行代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title>apt-get install报错</title>
    <url>/2018/01/25/apt-get-install%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>在一台Ubuntu安装软件的时候发现, 安装任何软件都会报一个类似<code>Errors were encountered while processing</code> <code>Sub-process /usr/bin/dpkg returned an error code</code>的错误, 尝试解决方式如下</p>
</blockquote>
<p>清空/var/lib/dpkg/info目录下面的内容即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>apt</tag>
      </tags>
  </entry>
  <entry>
    <title>grep: warning: GREP_OPTIONS is deprecated</title>
    <url>/2018/01/25/grep-warning-GREP-OPTIONS-is-deprecated/</url>
    <content><![CDATA[<blockquote>
<p>原因是在你的配置文件中(我的是CentOS7, /etc/profile)出现了以下配置导致的: <code>export GREP_OPTIONS=--color=auto</code></p>
</blockquote>
<p>解决方法也很简单, 首先在<code>/etc/profile</code>中注释该行</p>
<p><code># export GREP_OPTIONS=--color=auto</code></p>
<p>然后在terminal界面执行<code>unset GREP_OPTIONS</code></p>
<p>再次执行grep操作, 就不会有恼人的Warning出现啦~</p>
<p>附录: 有可能影响到grep的这一行export配置并不在你的<code>/etc/profile</code>文件下,你可以尝试去<code>~/.bashrc</code> <code>~/.bashprofile</code> <code>~/.zshrc</code>等文件中查找</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>Zabbix agent is unreachable for 5 minutes</title>
    <url>/2018/01/25/Zabbix-agent-is-unreachable-for-5-minutes/</url>
    <content><![CDATA[<blockquote>
<p>最近入到了 <code>Zabbix agent on HOSTNAME is unreachable for 5 minutes</code> 的问题, 但实际server到agent的网络通信是没有任何问题的, 这种情况下, 我们需要登录到agent这台主机, 查看<code>zabbix_agent</code>的日志来排查错误</p>
</blockquote>
<h1 id="查看zabbix-agent的启动进程"><a href="#查看zabbix-agent的启动进程" class="headerlink" title="查看zabbix_agent的启动进程"></a>查看zabbix_agent的启动进程</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ps aux | grep <span class="string">"zabbix"</span></span><br></pre></td></tr></table></figure>

<p>如果是编译安装的agent, 手动指定配置文件启动的进程, 在这里你可以看到你引用的配置文件的地址</p>
<h1 id="查看配置文件"><a href="#查看配置文件" class="headerlink" title="查看配置文件"></a>查看配置文件</h1><p>在配置文件中你需要查看的是记录日志的位置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LogFile=/var/<span class="built_in">log</span>/zabbix/zabbix_agentd.log</span><br></pre></td></tr></table></figure>

<h1 id="查看日志报错"><a href="#查看日志报错" class="headerlink" title="查看日志报错"></a>查看日志报错</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; tail -f /var/<span class="built_in">log</span>/zabbix/zabbix_agentd.log</span><br></pre></td></tr></table></figure>

<p>在我这里的实际情况中, 出现了以下报错信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">25863:20180116:103949.621 failed to accept an incoming connection: connection from &quot;192.168.10.85&quot; rejected, allowed hosts: &quot;zabbix_server.lvrui.io&quot;</span><br></pre></td></tr></table></figure>

<p>在这里我们可以看到几个关键字眼</p>
<ul>
<li>reject: 说明客户端拒绝了服务端的请求</li>
<li>allowed hosts: 允许访问客户端的服务端地址</li>
</ul>
<p>通过以上关键字可以判断出, 客户端认到的server的实际IP地址是<code>192.168.10.85</code>, 但是客户端配置的server地址却是<code>zabbix_server.lvrui.io</code>, 客户端不能反解析出这个IP地址对应的域名, 所以拒绝了server的请求</p>
<p>最简单的解决方法就是将zabbix_agent配置文件中的<code>Server</code> <code>ServerActive</code>的配置都改成 <code>192.168.10.85</code> 即可</p>
<p>第二个办法, 你要是非要用域名的话, 你可以将监控模式改为主动模式, 主动去服务端推送数据</p>
<p>第三个办法, 是你需要在你的网络环境中, 配置对应zabbix_server的反向解析</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>2017年终总结:五子连珠</title>
    <url>/2017/12/29/2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E4%BA%94%E5%AD%90%E8%BF%9E%E7%8F%A0/</url>
    <content><![CDATA[<p>​        很多年前的一个”习惯”, 到了年末的时候, 喜欢感慨一番, 回顾这一年的风风雨雨, 展望一下美好的明年~ 正如开题所说, 这是很多年前的一个习惯了, 我已经很多年, 都不记得有多少年没有写过”年终总结”了, 今天, 现在, 是2017年的最后一个工作日(2017年12月29号)的凌晨0点过5分, 我写下这篇2017的年终总结, 希望这是个美好的开端, 将久违的习惯, 再找回来.</p>
<p>​        2017年的年终总结为什么是<code>五子连珠</code>呢? 下过五子棋的筒子们肯定知道, 五子连珠是五子棋的赢法, 今年的总结浓缩为<code>五子连珠</code>再合适不过了. 不仅仅意味着今年对自己来说是个”胜利”之年, 而且真的有<code>五子</code>喜事, 且听我一一道来~</p>
<p>​        <code>一子:票子</code> 很久以前, 在社交平台我写过一个个人自评: “没钱没房没股份”的三无人员…. 有钱! 是个很模糊的定义, 对于食不果腹的人来说, 温饱就是有钱. 而我今天说的”票子”, 是我工作以来的第一份兼职收入! 今年年初的时候, 隋哥找到我, 给我提供了一份兼职工作, 是我之前敢想而不敢干的一个职业:<code>讲师</code>. 讲什么呢? 讲当下最流行的进程虚拟化技术<code>Docker</code> Docker 这项技术当时在公司确实有落地, 生产环境就在跑, 而且期间也趟了不少雷, 对于这项技术在生产环境的落地, 其实我还是有故事讲的. 但是我面对的对象不是 Docker 技术的使用者, 等待 Docker 技术落地的技术人员, 而是刚刚接触 Linux 运维领域的初学者. 对于初学者来说, 接受一个进程虚拟化技术其实并不容易. 因为在 Linux 培训中, 都是以物理机的角度去思考问题的, 而到了进程虚拟化阶段, 很多思想和理念和物理机的用法是背道而驰的, 所以这个讲师的兼职对我来说是一个很大的挑战.</p>
<p>​        接到任务后, 确定大纲肯定是首当其冲, 期间和宫老师反复讨论大纲知识点的顺序. 为什么顺序需要讨论呢, 这么说吧, 我当时已经看过不下五本 Docker 相关的书籍, 每本书介绍 Docker 技术的顺序都不一样, 而对于初学者来说, 选对顺序非常重要! 最后结合自己学习 Docker 的过程, 宫老师给的建议和参考官方文档, 确定了一个让自己满意的大纲. 确定大纲之后就进入到紧张的备课阶段, 这时我才发现, 要把一个东西讲明白是多么不容易, 不仅仅要了解它的所有特性, 还得把这些特性结合实际情况解释清楚, 在生产环境中, 可能遇到问题后, 才会去找解决方案, 用到什么功能, 发掘什么功能, 但是讲课不一样, 不管实际情况的使用频率怎样, 你都得一一知晓他们的使用方法和使用场景, 备课的过程花了好几个晚上, 反复研究, 反复试验, 生怕讲课的时候断档. </p>
<p>​        当我第一次走进讲台的时候, 是很紧张的, 但是上课之后, 从 Docker 的起源, 发展讲起, 慢慢的放松下来, 但是现在看来, 当时紧张导致语速快, 体验还是非常不好的. 按照大纲, 给学生们培训了4天的课程, 最后让我很意外, 原以为三天就可以讲完的内容, 结果到了第四天下课, 拖堂了两个小时才讲完. 中间思路发散的过多了, 不过也都是干货~ 就这样, 我带过了我人生中的第一批学生, 当老师很辛苦,  除了备课, 每天不停的说话几个小时, 真的脸都肿了~ </p>
<p>​        当讲师, 把自己会的东西讲给别人听, 是个非常非常难得的机会, 一般人想找这种机会都找不着, 在隋老大的引荐下, 也算是突破了自己, 大胆的走上台前, 展示自己, 非常非常难得的机会. 当然这也让我收获了工作以来, 兼职的第一桶金</p>
<p>​        <code>二子:房子</code> 房子是所有中国的心病, 成也房子, 败也房子. 对于普通老百姓来说, 刚需住房, 能有一套自己房子, 也算是毕生的一个重大任务. 在2017年5月底, 在父母的倾力帮助下, 我收获了人生中的第一套房产. 中国有句古话, 叫安居乐业, 只有安居才能乐业, 眼瞅即将成家, 这套来之不易的房产正是未来乐业之根本. </p>
<p>​        精装修的房子, 还好在装修这块不用操心, 挑挑家具, 把屋子填满即可. 在看过多家全屋定制之后, 选定了其中两家来定制家具. 其中有一家因为沙发的问题, 来回耽误了好久, 闹得很不愉快. 甚至邀请北京的同事来家里做客的时候, 坐的都是送错的沙发.</p>
<p>​        2017年收获了自己的房产, 也正是因为收获了房产, 才有资格去日本度蜜月, 想想真是悲哀, 如果名下没有房产, 日本的签证需要每人冻结10万的存款, 工作这些年, 别说10万存款, 1万存款都没有攒下~ </p>
<p>​        <code>三子:车子</code> 我之前对车没有什么感觉, 之前都是比较喜欢坐车, 可能很多同龄人都想买车开车的时候, 我还在想坐哪条公交线路会比较快呢, 骑自行车是不是更好呢, 对车一直都没有感觉, 也没有喜欢到非要买的欲望. 直到今年, 买车的想法愈加强烈, 今年在年初的时候就游走于各个汽车展销会, 收了不少广告传单. 当时一直在纠结买 B 级车还是 A 级车, 随着时间的推移, 交房买家具之后, 紧接着就要操办婚礼, 最终还是将目标定在了 A 级车. 在家里的支持下, 很快就提了车. 到现在已经开了5000多公里, 马上就可以首保了. 现在想想, 甭管是多少钱的房, 也甭管是多便宜的车, 也算是有房有车一族了, 在自己不如意的时候, 想想有房有车, 还是能宽心一些的~ </p>
<p>​        <code>四子:妻子</code> 2017年9月16号是我大婚的日子, 有情人终成眷属, 861天, 爱情得到了升华. 人生的第一件大事, 娶妻大事算是落下帷幕, 成功脱单, 晋升到已婚贵族, 有了自己的小家. 还清楚的记得婚礼的前一天, 忙的真是不可开交, 中午饭都到了1点多才和自己的小伙伴去吃. 晚上的时候, 邀请的北京的朋友陆续抵达唐山, 先是去火车站接我的证婚人, 也是我的授业恩师, 隋老大. 响门儿晚宴后送隋老大夫妇入住酒店, 正好在酒店等待其他还没有到的北京筒子们~ 等人都到齐后, 短暂的寒暄, 已是晚上11点多, 顾不上和远道而来的筒子们一起吃个夜宵就赶紧赶回新房了. 到新房后, 床上都布置好了, 怕早上起来无法复原, 就在沙发上凑合了一夜, 当时我还在想, 万一这一晚睡不好, 第二天犯了颈椎病可咋办~ </p>
<p>​        非常幸运的是, 早上并没有任何不适, 虽然只迷迷糊糊睡了4个小时. 在主持人的全程引导下, 顺利的把媳妇儿娶到了家. 为了婚礼这天的6个小时, 太多太多的亲朋好友给予了大力帮助. 当初还计划着, 谁都不要帮忙, 都找外包干, 都上桌吃饭~ 真到了这天才知道, 家人朋友才是你最大的靠山, 请哪个外包团队干也没有家人朋友放心踏实, 再次衷心的感谢!</p>
<p>​        媳妇娶到家的那天晚上, 我称了一下体重, 一周之前的这个时候, 体重是131斤, 今天再称, 降到了125斤, 婚礼前这一个礼拜竟然瘦了6斤! 即使是到我现在写这篇总结, 也依然没有恢复到之前的体重, 不管怎么样, 媳妇终于娶到家啦<del>~</del></p>
<p>​        <code>五子:孩子</code> 这算是2017年最大的惊喜吧! 10月22日, 我和媳妇去日本度蜜月, 刚到日本不久, 媳妇就不舒服, 恶心. 直到行程的四天, 开始频繁的呕吐. 因为媳妇儿之前肠胃就不好, 日本还都是生冷的食物, 当时以为是肠胃炎犯了, 还吃了从国内带的肠胃药. 但是丝毫没有管用, 反而越来越严重. 后来以为是水土不服. 直到到了国内, 又待了一天, 还不见好, 这才往怀孕的方面考虑, 最终, 在回国的第二天确定了这条喜讯. 到现在, 已经快15周啦. 想想真是后怕, 在怀孕初期, 坐飞机, 吃药, 劳累过度都是大忌, 但是宝宝依然挺了过来, 给宝宝的坚强点赞, 但却是苦了孩子妈了, 从日本回来妊娠呕吐反应极其严重, 期间还因为这住了院, 到现在也没有完全好, 唉, 真是忧心啊, 宝宝啊, 希望你明年的降生顺顺利利, 健健康康~</p>
<p>​        2017年对我来说绝对是个不平凡的一年, 在这一年里发生了太多太多的事情, 第一次出国, 第一次玩密室逃脱, 第一次正式的投资, 第一次同时拿到5家公司的 offer, 第一次拿到了本科毕业证书…… </p>
<p>​        还记得2016年的新年计划, 计划2017年要用百度地图的足迹功能, 把北京的三环, 四环足迹补齐, 看来今年是做不到了, 今年太多太多重要的事情发生了, 2017年注定是我人生的里程碑之一! 而且是极其重要的里程碑之一!</p>
<p>​        怀着感恩的心情, 送别2017年, 也因为2017年的私事太多, 反而在工作中, 没有过于突出的贡献, 那么我希望在即将到来的2018年, 在工作上有更突出的表现, 希望在2018年能晋升一个职级, 踏踏实实的等待宝宝的降生, 为马上到来的三口之家做好充足的准备, 真正是为了家在奋斗了! </p>
<p>​        </p>
<p>​        最后, 学书里前言的落款风格落一下今年的最后一个款儿~</p>
<p>​        </p>
<p>2017年12月29日 星期五 于北京</p>
<p>吕瑞</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>tornado实现与企业微信消息的交互</title>
    <url>/2017/12/26/tornado%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BC%81%E4%B8%9A%E5%BE%AE%E4%BF%A1%E6%B6%88%E6%81%AF%E7%9A%84%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="tornado实现与企业微信消息的交互"><a href="#tornado实现与企业微信消息的交互" class="headerlink" title="tornado实现与企业微信消息的交互"></a>tornado实现与企业微信消息的交互</h1><blockquote>
<p>现在企业微信开放了普通用户注册，大大方便了我们实现一些“脑洞大开”的想法。DevOps喊了好多年了，近期出现了两个DevOps的分支，一个是ChatOps，一个是AIOps。ChatOps是最近几年火起来的，其中比较出名是slack+hubot的双剑合璧。在slack频道中，发送的一些信息，根据hubot的配置规则，是可以将聊天信息转化为具体命令去服务器上执行的。基于此，国内使用率比较高的企业IM软件就是企业微信了。在企业中，我们可以创建自己的应用模块，在该模块中实现与用户的消息进行交互，本篇文章就来实现这一目标（本篇文章只介绍在已创建自建应用的情况下，与用户消息交互，不含注册企业微信号和创建企业号自建应用的教程，这个自己去百度.com一下就可以了，点一点，没什么难度）</p>
</blockquote>
<p><strong>注意：本篇文章不考虑tornado框架的完善性，只作为一个restful开发框架来做基本的演示</strong></p>
<h1 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a>前期准备：</h1><ul>
<li>一个企业微信账号（认不认证都可以）</li>
<li>在企业微信账号管理后台中创建一个自建应用（企业应用–&gt;自建应用）</li>
<li>拿到企业账号的CorpID（我的企业–&gt;企业信息）</li>
<li>在企业微信平台获取一个Token（进入自建应用中–&gt;接收消息–&gt;启动API接收–&gt;随机获取Token）</li>
<li>在企业微信平台获取一个EncodingAESKey（进入自建应用中–&gt;接收消息–&gt;启动API接收–&gt;随机获取EncodingAESKey）</li>
<li>一个有公网IP的服务器（可以在阿里云等厂商购买）</li>
<li>一个Python2.7的环境</li>
</ul>
<h1 id="下载企业微信提供的加解密模块"><a href="#下载企业微信提供的加解密模块" class="headerlink" title="下载企业微信提供的加解密模块"></a>下载企业微信提供的加解密模块</h1><p>企业微信提供了Python版本的加解密模块，我们可以直接从企业微信官方网站上下载使用</p>
<ul>
<li>地址：<a href="https://work.weixin.qq.com/api/doc#10128" target="_blank" rel="noopener">https://work.weixin.qq.com/api/doc#10128</a></li>
<li>下载链接：<a href="http://open.work.weixin.qq.com/wwopen/downloadfile/python.zip" target="_blank" rel="noopener">http://open.work.weixin.qq.com/wwopen/downloadfile/python.zip</a></li>
</ul>
<p>下载完成后，你将得到以下文件：</p>
<ul>
<li>ierror.py 错误状态码</li>
<li>Sample.py 示例代码</li>
<li>WXBizMsgCrypt.py 加解密核心模块</li>
<li>Readme.txt</li>
</ul>
<p>为了使用<code>WXBizMsgCrypt.py</code>这个模块，需要先在Python环境中安装<code>pycrypto</code>模块，执行一下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; pip install pycrypto</span><br></pre></td></tr></table></figure>

<h1 id="搭建tornado运行框架"><a href="#搭建tornado运行框架" class="headerlink" title="搭建tornado运行框架"></a>搭建tornado运行框架</h1><p>在与微信提供的模块的同级目录中，创建tornado服务应用<code>app.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">from</span> WXBizMsgCrypt <span class="keyword">import</span> WXBizMsgCrypt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span>  <span class="comment"># 建立连接，认证使用</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span>  <span class="comment"># 信息收发，交互使用</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        application.listen(<span class="number">8888</span>)</span><br><span class="line">        tornado.ioloop.IOLoop.instance().start()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"exit"</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>此处的tornado框架只为演示，框架其他功能未完善</strong></p>
<h1 id="与企业微信认证接口并建立连接"><a href="#与企业微信认证接口并建立连接" class="headerlink" title="与企业微信认证接口并建立连接"></a>与企业微信认证接口并建立连接</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 声明并赋值企业微信中的信息</span></span><br><span class="line">    sToken = <span class="string">"iXIPhJ35"</span></span><br><span class="line">    sEncodingAESKey = <span class="string">"LRB2JiYSMUsszYrcbTd9fWTLwlYEhrEjb7Z9coWRBoJ"</span></span><br><span class="line">    sCorpID = <span class="string">"yy4f13b9b0a629296d"</span></span><br><span class="line">    wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)  <span class="comment"># 使用企业微信提供的模块创建加密解密对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取URL中的参数</span></span><br><span class="line">    sVerifyMsgSig=self.get_argument(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp=self.get_argument(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce=self.get_argument(<span class="string">'nonce'</span>)</span><br><span class="line">    sVerifyEchoStr=self.get_argument(<span class="string">'echostr'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用解密加密对象进行URL认证</span></span><br><span class="line">    ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">    <span class="keyword">if</span> ret != <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ERR: VerifyURL ret:"</span> + ret</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将解密后的字符串发回给企业微信端</span></span><br><span class="line">    self.write(sEchoStr)</span><br></pre></td></tr></table></figure>

<p>认证建立连接的大概流程就是<code>企业微信用自己的加密算法加密一个字符串通过get请求的方式发送给你</code> –&gt; <code>你的接口拿到这次get请求后，依据URL中的参数，反解出企业微信发来的加密字符串</code> –&gt; <code>解密后，将该字符串返回给企业微信端</code> –&gt; <code>企业微信收到明文的字符串后会对比自己的初始发送的字符串</code> –&gt; <code>对比成功即验证成功，建立连接</code></p>
<h1 id="与企业微信进行信息交互"><a href="#与企业微信进行信息交互" class="headerlink" title="与企业微信进行信息交互"></a>与企业微信进行信息交互</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 声明并赋值企业微信中的信息，这点与上面get请求的认证是一样的</span></span><br><span class="line">    sToken = <span class="string">"iXIPhJ35"</span></span><br><span class="line">    sEncodingAESKey = <span class="string">"LRB2JiYSMUsszYrcbTd9fWTLwlYEhrEjb7Z9coWRBoJ"</span></span><br><span class="line">    sCorpID = <span class="string">"yy4f13b9b0a629296d"</span></span><br><span class="line">    wxcpt = WXBizMsgCrypt(sToken, sEncodingAESKey, sCorpID)  <span class="comment"># 使用企业微信提供的模块创建加密解密对象</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取URL中的参数（注意上面的get函数中的密文是通过get请求直接加在url中传递的，而交互模式中，密文是单独post过来的）</span></span><br><span class="line">    sVerifyMsgSig = self.get_argument(<span class="string">'msg_signature'</span>)</span><br><span class="line">    sVerifyTimeStamp = self.get_argument(<span class="string">'timestamp'</span>)</span><br><span class="line">    sVerifyNonce = self.get_argument(<span class="string">'nonce'</span>)</span><br><span class="line">    sReqData = self.request.body</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将以上信息进行解密</span></span><br><span class="line">    ret, sMsg = wxcpt.DecryptMsg(sReqData, sVerifyMsgSig, sVerifyTimeStamp, sVerifyNonce)</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>):</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ERR: VerifyURL ret:"</span></span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据接收到的xml消息，实例化成xml对象</span></span><br><span class="line">    xml_tree = ET.fromstring(sMsg)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否是发送消息的行为</span></span><br><span class="line">    <span class="keyword">if</span> xml.etree.ElementTree.iselement(xml_tree.find(<span class="string">"Content"</span>)):</span><br><span class="line">        content = xml_tree.find(<span class="string">"Content"</span>).text  <span class="comment"># 获取用户发送的消息</span></span><br><span class="line">    <span class="comment"># 判断是否是点击菜单栏的行为</span></span><br><span class="line">    <span class="keyword">elif</span> xml.etree.ElementTree.iselement(xml_tree.find(<span class="string">"EventKey"</span>)):</span><br><span class="line">        content = xml_tree.find(<span class="string">"EventKey"</span>).text  <span class="comment"># 获取用户点击菜单的id</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content = <span class="string">"other type"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将我们收到的信息再发回给企业微信，需要从request的xml获取以下信息</span></span><br><span class="line">    user_id = xml_tree.find(<span class="string">"FromUserName"</span>).text  <span class="comment"># 用户id</span></span><br><span class="line">    corp_id = xml_tree.find(<span class="string">"ToUserName"</span>).text  <span class="comment"># 企业id</span></span><br><span class="line">    create_time = xml_tree.find(<span class="string">"CreateTime"</span>).text  <span class="comment"># 时间戳（用request的时间戳即可）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下为需要回复给企业微信用户的消息的具体内容</span></span><br><span class="line">    content = <span class="string">"1.1.1.1\n2.2.2.2\n3.3.3.3"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 由于不是很熟悉xml的操作，也不明白为啥微信不用json，非要任性的用xml</span></span><br><span class="line">    <span class="comment"># 在这里只能用字符串拼出一个xml文件出来了 -_- 不要喷</span></span><br><span class="line">    <span class="comment"># 以下xml即为发送回企业微信的完整消息体，该消息体不能直接明文发送，需要加密后发送</span></span><br><span class="line">    sRespData = <span class="string">"""&lt;xml&gt;</span></span><br><span class="line"><span class="string">            &lt;ToUserName&gt;&lt;![CDATA["""</span>+user_id+<span class="string">"""]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">            &lt;FromUserName&gt;&lt;![CDATA["""</span>+corp_id+<span class="string">"""]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">            &lt;CreateTime&gt;"""</span>+create_time+<span class="string">"""&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">            &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">            &lt;Content&gt;&lt;![CDATA["""</span>+content+<span class="string">"""]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="string">            &lt;/xml&gt;"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将上面的明文消息体使用企业微信的加密模块进行加密操作</span></span><br><span class="line">    ret,sEncryptMsg = wxcpt.EncryptMsg(sRespData, sVerifyNonce, sVerifyTimeStamp)</span><br><span class="line">    <span class="keyword">if</span> ret!=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"ERR: EncryptMsg ret: "</span> + str(ret)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 最后将密文回复给企业微信，即完成企业微信用户与企业自己服务器之间的信息交互</span></span><br><span class="line">    self.write(sEncryptMsg)</span><br></pre></td></tr></table></figure>

<p>信息交互的大概流程是<code>企业微信用自己的加密算法加密用户发送的消息字符串，通过post请求的方式发送给你</code> –&gt; <code>你的接口拿到post请求后，依据URL中的参数，和post过来的密文，反解出企业微信发来的加密消息</code> –&gt; <code>解密后，将回复给用户的消息重新包进xml消息中</code> –&gt; <code>将完整的xml进行加密</code> –&gt; <code>将密文回复给企业微信端</code></p>
<h1 id="没有下一步了-就是这么简单"><a href="#没有下一步了-就是这么简单" class="headerlink" title="没有下一步了 就是这么简单"></a>没有下一步了 就是这么简单</h1><p>以下是完整的代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tornado.web</span><br><span class="line"><span class="keyword">import</span> tornado.ioloop</span><br><span class="line"><span class="keyword">from</span> WXBizMsgCrypt <span class="keyword">import</span> WXBizMsgCrypt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        sToken = <span class="string">"iXIPhJ35"</span></span><br><span class="line">        sEncodingAESKey = <span class="string">"LRB2JiYSMUsszYrcbTd9fWTLwlYEhrEjb7Z9coWRBoJ"</span></span><br><span class="line">        sCorpID = <span class="string">"yy4f13b9b0a629296d"</span></span><br><span class="line">        wxcpt=WXBizMsgCrypt(sToken,sEncodingAESKey,sCorpID)</span><br><span class="line"></span><br><span class="line">        sVerifyMsgSig=self.get_argument(<span class="string">'msg_signature'</span>)</span><br><span class="line">        sVerifyTimeStamp=self.get_argument(<span class="string">'timestamp'</span>)</span><br><span class="line">        sVerifyNonce=self.get_argument(<span class="string">'nonce'</span>)</span><br><span class="line">        sVerifyEchoStr=self.get_argument(<span class="string">'echostr'</span>)</span><br><span class="line"></span><br><span class="line">        ret,sEchoStr=wxcpt.VerifyURL(sVerifyMsgSig, sVerifyTimeStamp,sVerifyNonce,sVerifyEchoStr)</span><br><span class="line">        <span class="keyword">if</span> ret != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ERR: VerifyURL ret:"</span> + ret</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.write(sEchoStr)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self)</span>:</span></span><br><span class="line">        sToken = <span class="string">"iXIPhJ35"</span></span><br><span class="line">        sEncodingAESKey = <span class="string">"LRB2JiYSMUsszYrcbTd9fWTLwlYEhrEjb7Z9coWRBoJ"</span></span><br><span class="line">        sCorpID = <span class="string">"yy4f13b9b0a629296d"</span></span><br><span class="line">        wxcpt = WXBizMsgCrypt(sToken, sEncodingAESKey, sCorpID)</span><br><span class="line"></span><br><span class="line">        sVerifyMsgSig = self.get_argument(<span class="string">'msg_signature'</span>)</span><br><span class="line">        sVerifyTimeStamp = self.get_argument(<span class="string">'timestamp'</span>)</span><br><span class="line">        sVerifyNonce = self.get_argument(<span class="string">'nonce'</span>)</span><br><span class="line">        sReqData = self.request.body</span><br><span class="line"></span><br><span class="line">        ret, sMsg = wxcpt.DecryptMsg(sReqData, sVerifyMsgSig, sVerifyTimeStamp, sVerifyNonce)</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ERR: VerifyURL ret:"</span></span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        xml_tree = ET.fromstring(sMsg)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> xml.etree.ElementTree.iselement(xml_tree.find(<span class="string">"Content"</span>)):</span><br><span class="line">            content = xml_tree.find(<span class="string">"Content"</span>).text</span><br><span class="line">        <span class="keyword">elif</span> xml.etree.ElementTree.iselement(xml_tree.find(<span class="string">"EventKey"</span>)):</span><br><span class="line">            content = xml_tree.find(<span class="string">"EventKey"</span>).text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = <span class="string">"other type"</span></span><br><span class="line"></span><br><span class="line">        user_id = xml_tree.find(<span class="string">"FromUserName"</span>).text</span><br><span class="line">        corp_id = xml_tree.find(<span class="string">"ToUserName"</span>).text</span><br><span class="line">        create_time = xml_tree.find(<span class="string">"CreateTime"</span>).text</span><br><span class="line"></span><br><span class="line">        content = <span class="string">"1.1.1.1\n2.2.2.2\n3.3.3.3"</span></span><br><span class="line"></span><br><span class="line">        sRespData = <span class="string">"""&lt;xml&gt;</span></span><br><span class="line"><span class="string">                &lt;ToUserName&gt;&lt;![CDATA["""</span>+user_id+<span class="string">"""]]&gt;&lt;/ToUserName&gt;</span></span><br><span class="line"><span class="string">                &lt;FromUserName&gt;&lt;![CDATA["""</span>+corp_id+<span class="string">"""]]&gt;&lt;/FromUserName&gt;</span></span><br><span class="line"><span class="string">                &lt;CreateTime&gt;"""</span>+create_time+<span class="string">"""&lt;/CreateTime&gt;</span></span><br><span class="line"><span class="string">                &lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;</span></span><br><span class="line"><span class="string">                &lt;Content&gt;&lt;![CDATA["""</span>+content+<span class="string">"""]]&gt;&lt;/Content&gt;</span></span><br><span class="line"><span class="string">                &lt;/xml&gt;"""</span></span><br><span class="line"></span><br><span class="line">        ret,sEncryptMsg = wxcpt.EncryptMsg(sRespData, sVerifyNonce, sVerifyTimeStamp)</span><br><span class="line">        <span class="keyword">if</span> ret!=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ERR: EncryptMsg ret: "</span> + str(ret)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        self.write(sEncryptMsg)</span><br><span class="line"></span><br><span class="line">application = tornado.web.Application([</span><br><span class="line">    (<span class="string">r"/"</span>, MainHandler),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        application.listen(<span class="number">8888</span>)</span><br><span class="line">        tornado.ioloop.IOLoop.instance().start()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">"exit"</span>)</span><br><span class="line">        exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>以上代码只是示例代码，细心的童鞋可能会发现get和post中有部分重复代码，而且该tornado框架本身也没有提供log/异步非阻塞等特性的支持，只是为了演示企业微信与自由服务器信息交互的流程与使用方法，无论你是使用Falcon还是Flask框架，逻辑都差不多，注意各个框架的回文函数即可，比如tornado是self.write(), Flask是直接return</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>tornado</tag>
        <tag>WeChat</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>Python3编译安装后pip3命令报ssl错误</title>
    <url>/2017/12/26/Python3%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E5%90%8Epip3%E5%91%BD%E4%BB%A4%E6%8A%A5ssl%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h1 id="Python3编译安装后pip3命令报ssl错误"><a href="#Python3编译安装后pip3命令报ssl错误" class="headerlink" title="Python3编译安装后pip3命令报ssl错误"></a>Python3编译安装后pip3命令报ssl错误</h1><p>首先确保ssl相关的库文件已经安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<p>在编译的时候加上<code>--with-ssl</code>参数即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> Python-3.6.2</span><br><span class="line">./configure --with-ssl</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pip</tag>
        <tag>ssl</tag>
      </tags>
  </entry>
  <entry>
    <title>对Element对象的自省</title>
    <url>/2017/12/26/%E5%AF%B9Element%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%87%AA%E7%9C%81/</url>
    <content><![CDATA[<h1 id="对Element对象的自省"><a href="#对Element对象的自省" class="headerlink" title="对Element对象的自省"></a>对Element对象的自省</h1><p>Python中的自省有两个核心模块实现</p>
<ul>
<li>isinstance(obj, cls)</li>
<li>issubclass(sub, super)</li>
</ul>
<p>当判断一个基础数据类型的时候，我们可以这么做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">print(isinstance(i, int))</span><br></pre></td></tr></table></figure>

<p>当判断一个自有数据类型的时候，我们可以这么做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(isinstance(a, A))</span><br></pre></td></tr></table></figure>

<p>现在我有一个Element对象，如何让他自省呢？</p>
<p>在xml模块中，本身就提供了用于自省的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.etree.cElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line">root = ET.fromstring(<span class="string">"""&lt;xml&gt;&lt;name&gt;polarsnow&lt;/name&gt;&lt;/xml&gt;"""</span>)</span><br><span class="line"><span class="keyword">print</span> type(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> ET.iselement(root)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;type &#39;Element&#39;&gt;</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>自省</tag>
        <tag>Element</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中__import__()的fromlist参数用法</title>
    <url>/2017/10/13/Python%E4%B8%AD-import-%E7%9A%84fromlist%E5%8F%82%E6%95%B0%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Python中的<code>__import__()</code>函数用来动态的加载包文件, 其中<code>__import__()</code>有个<code>fromlist</code>的参数选项, 对于动态加载模块来说, 非常重要</p>
</blockquote>
<p>Python 中的 import 大概有以下几种用法</p>
<ul>
<li>import pkg  调用方法: <code>pkg.mod.func()</code></li>
<li>import pkg.mod 调用方法: <code>pkg.mod.func()</code></li>
<li>import mod 调用方法: <code>mod.func()</code></li>
<li>from pkg import mod 调用方法: <code>mod.func()</code></li>
<li>from pkg.mod import func 调用方法 : <code>func()</code></li>
<li>from mod import func 调用方法: <code>func()</code></li>
</ul>
<p>第一种和第二种情况下, 当使用<code>__import__</code>导入模块时, 得到的对象是完全一样的. 默认情况下, <code>__import__</code> 只能导入最左侧的包文件, 即以下两种写法, 导入的对象都是一样的</p>
<ul>
<li><code>pkg2 = __import__(pkg)</code> 调用方法: <code>pkg2.mod.func()</code></li>
<li><code>pkg3 = __import__(pkg.mod)</code> 调用方法: <code>pkg3.mod.func()</code></li>
</ul>
<p>第三种情况下, 当使用<code>__import__</code>导入模块时, 与<code>import mod</code>的导入效果是一样的</p>
<ul>
<li>mod2 = <code>__import__(mod)</code> 调用方法: <code>mod2.func1(); mod2.func2()</code></li>
</ul>
<p>第四种情况下, 当使用<code>__import__</code>导入模块时的用法</p>
<ul>
<li><code>pkg4 = __import__(pkg, fromlist=[mod1, mod2])</code></li>
</ul>
<p>调用方法:</p>
<ul>
<li><code>pkg4.mod1.func1()</code></li>
<li><code>pkg4.mod2.func2()</code></li>
</ul>
<p>第五种情况下, 不支持使用<code>__import__</code>直接导入包内模块中的函数,  默认情况下, 即使你是如下的写法</p>
<ul>
<li><code>pkg5 = __import__(pkg.mod)</code></li>
</ul>
<p>效果依然是只导入<code>pkg</code>包而已, <code>pkg.mod</code>这个模块并没有被导入</p>
<ul>
<li><code>pkg5 = __import__(pkg.mod, fromlist=[mod])</code></li>
</ul>
<p>如果是加入了 <code>fromlist</code> 关键字的话, 那么该 pkg5 为 mod 模块对象</p>
<p><em>总结来说就是当 <code>__import__(A.B)</code>时, 当 fromlist 为空, 则导入的对象时 A, 如果 fromlist 不为空, 导入的对象就是 B</em></p>
<p>第六种情况下, 当使用<code>__import__</code>导入模块时, 与<code>from mod import func</code>的效果是一样的, 不需要使用fromlist参数支持就可以导入全部函数</p>
<ul>
<li><code>mod3 = __import__(mod)</code> 调用方法: <code>mod3.func()</code></li>
<li><code>pkg5 = __import__(&#39;mod2&#39;, fromlist=[&#39;func2&#39;, &#39;func3&#39;])</code> 这种写法非常啰嗦, 上面的写法已经可以导入全部函数了, 不需要再使用 fromlist 单独指定</li>
</ul>
]]></content>
      <tags>
        <tag>import</tag>
        <tag>fromlist</tag>
      </tags>
  </entry>
  <entry>
    <title>collections中deque的用法</title>
    <url>/2017/07/26/collections%E4%B8%ADdeque%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>collections.deque 是用来创建一个有序的队列, 而且可以限定其队列的大小, 当队列已经装满后, 再填入的元素将实现头部元素被抛弃, 所有元素向前挪动一位, 新元素追加到最后的效果</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">q = collections.deque([], <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">q.append(<span class="number">1</span>)</span><br><span class="line">print(q)</span><br><span class="line"></span><br><span class="line">q.append(<span class="number">2</span>)</span><br><span class="line">print(q)</span><br><span class="line"></span><br><span class="line">q.append(<span class="number">3</span>)</span><br><span class="line">print(q)</span><br><span class="line"></span><br><span class="line">q.append(<span class="number">4</span>)</span><br><span class="line">print(q)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deque([<span class="number">1</span>], maxlen=<span class="number">3</span>)</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>], maxlen=<span class="number">3</span>)</span><br><span class="line">deque([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], maxlen=<span class="number">3</span>)</span><br><span class="line">deque([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], maxlen=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的有序字典</title>
    <url>/2017/07/26/Python%E4%B8%AD%E7%9A%84%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<blockquote>
<p>在 Python 3.5版本(含3.5)之前, 默认的字典是无序的. 在最新的3.6版本中, 字典变成了有序字典, 本篇文章将介绍3.5版本及之前版本中有序字典的使用和3.6版本原生有序字典的使用</p>
</blockquote>
<h1 id="3-5"><a href="#3-5" class="headerlink" title="3.5-"></a>3.5-</h1><p>3.5版本及之前的版本中, 需要借助<code>collections</code>模块中的<code>OrderedDict</code>来实现有序字典的声明和使用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line">od = OrderedDict()</span><br><span class="line">d = &#123;&#125;</span><br><span class="line"></span><br><span class="line">od[<span class="string">'name'</span>] = <span class="string">'lvrui'</span></span><br><span class="line">od[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line">od[<span class="string">'city'</span>] = <span class="string">'HeBei'</span></span><br><span class="line"></span><br><span class="line">d[<span class="string">'name'</span>] = <span class="string">'lvrui'</span></span><br><span class="line">d[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line">d[<span class="string">'city'</span>] = <span class="string">'HeBei'</span></span><br><span class="line"></span><br><span class="line">print(od)</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">OrderedDict([(<span class="string">'name'</span>, <span class="string">'lvrui'</span>), (<span class="string">'age'</span>, <span class="number">26</span>), (<span class="string">'city'</span>, <span class="string">'HeBei'</span>)])</span><br><span class="line">&#123;<span class="string">'city'</span>: <span class="string">'HeBei'</span>, <span class="string">'name'</span>: <span class="string">'lvrui'</span>, <span class="string">'age'</span>: <span class="number">26</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-6"><a href="#3-6" class="headerlink" title="3.6+"></a>3.6+</h1><p>在 Python3.6+ 版本中, 内置字典默认就是有序的😆 爽~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">➜  ~ python3<span class="number">.6</span></span><br><span class="line">Python <span class="number">3.6</span><span class="number">.2</span> (v3<span class="number">.6</span><span class="number">.2</span>:<span class="number">5</span>fd33b5926, Jul <span class="number">16</span> <span class="number">2017</span>, <span class="number">20</span>:<span class="number">11</span>:<span class="number">06</span>) </span><br><span class="line">[GCC <span class="number">4.2</span><span class="number">.1</span> (Apple Inc. build <span class="number">5666</span>) (dot <span class="number">3</span>)] on darwin</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'name'</span>] = <span class="string">'lvrui'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'age'</span>] = <span class="number">26</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="string">'city'</span>] = <span class="string">'HeBei'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'lvrui'</span>, <span class="string">'age'</span>: <span class="number">26</span>, <span class="string">'city'</span>: <span class="string">'HeBei'</span>&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python中为元组的每个元素命名</title>
    <url>/2017/07/26/Python%E4%B8%AD%E4%B8%BA%E5%85%83%E7%BB%84%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%91%BD%E5%90%8D/</url>
    <content><![CDATA[<blockquote>
<p>元组是一种高效的数据类型, 同时我们为了提高提取元组元素的可读性,  做出如下修改来为元组的元素命名</p>
</blockquote>
<p>比如我们用一个元组来描述一个位置信息, 比如 <code>(5,9)</code>来标识横坐标信息和纵坐标信息</p>
<h1 id="第一种方式-通过变量"><a href="#第一种方式-通过变量" class="headerlink" title="第一种方式: 通过变量"></a>第一种方式: 通过变量</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = (<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">x, y = range(<span class="number">2</span>)</span><br><span class="line">print(p[x])</span><br><span class="line">print(p[y])</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h1 id="第二种方式-collections-内置函数"><a href="#第二种方式-collections-内置函数" class="headerlink" title="第二种方式: collections 内置函数"></a>第二种方式: collections 内置函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">P = collections.namedtuple(<span class="string">'P'</span>, [<span class="string">'x'</span>, <span class="string">'y'</span>])</span><br><span class="line">p = P(<span class="number">5</span>, <span class="number">9</span>)</span><br><span class="line">print(p.x)</span><br><span class="line">print(p.y)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>查看<code>p</code>的数据类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(isinstance(p, P))</span><br><span class="line">print(isinstance(p, tuple))</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Python中使用Counter实现简单的计数器</title>
    <url>/2017/07/26/Python%E4%B8%AD%E4%BD%BF%E7%94%A8Counter%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>在 Python 中可以使用 collections 内置模块下的 Counter 来实现简单的统计功能</p>
</blockquote>
<h1 id="统计列表中的元素"><a href="#统计列表中的元素" class="headerlink" title="统计列表中的元素"></a>统计列表中的元素</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">l = [chr(random.randint(<span class="number">97</span>, <span class="number">102</span>)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">result = collections.Counter(l)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'f'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'f'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>]</span><br><span class="line">Counter(&#123;<span class="string">'f'</span>: <span class="number">6</span>, <span class="string">'e'</span>: <span class="number">6</span>, <span class="string">'c'</span>: <span class="number">4</span>, <span class="string">'d'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="统计文件中单词出现的频率"><a href="#统计文件中单词出现的频率" class="headerlink" title="统计文件中单词出现的频率"></a>统计文件中单词出现的频率</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = open(<span class="string">'/etc/apache2/extra/httpd-ssl.conf'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">txt = re.split(<span class="string">'\W+'</span>, f.read())</span><br><span class="line">s = collections.Counter(txt)</span><br><span class="line"></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Counter(&#123;<span class="string">'the'</span>: <span class="number">93</span>, <span class="string">'to'</span>: <span class="number">39</span>, <span class="string">'and'</span>: <span class="number">32</span>, <span class="string">'for'</span>: <span class="number">31</span>, <span class="string">'SSL'</span>: <span class="number">29</span>, <span class="string">'is'</span>: <span class="number">26</span>, <span class="string">'a'</span>: <span class="number">21</span>, <span class="string">'of'</span>: <span class="number">21</span>, <span class="string">'private'</span>: <span class="number">20</span>, <span class="string">'in'</span>: <span class="number">18</span>, <span class="string">'you'</span>: <span class="number">17</span>, <span class="string">'server'</span>: <span class="number">17</span>, <span class="string">'file'</span>: <span class="number">16</span>, <span class="string">'apache2'</span>: <span class="number">16</span>, <span class="string">'be'</span>: <span class="number">16</span>, <span class="string">'1'</span>: <span class="number">16</span>, <span class="string">'etc'</span>: <span class="number">15</span>, <span class="string">'certificate'</span>: <span class="number">15</span>, <span class="string">'this'</span>: <span class="number">14</span>, <span class="string">'as'</span>: <span class="number">13</span>, <span class="string">'This'</span>: <span class="number">13</span>, <span class="string">'0'</span>: <span class="number">13</span>, <span class="string">'or'</span>: <span class="number">13</span>, <span class="string">'use'</span>: <span class="number">12</span>, <span class="string">'client'</span>: <span class="number">10</span>, <span class="string">'that'</span>: <span class="number">10</span>, <span class="string">'when'</span>: <span class="number">10</span>, <span class="string">'can'</span>: <span class="number">10</span>, <span class="string">'are'</span>: <span class="number">9</span>, <span class="string">'mod_ssl'</span>: <span class="number">9</span>, <span class="string">'ciphers'</span>: <span class="number">9</span>, <span class="string">'CA'</span>: <span class="number">8</span>, <span class="string">'on'</span>: <span class="number">8</span>, <span class="string">'one'</span>: <span class="number">8</span>, <span class="string">'2'</span>: <span class="number">8</span>, <span class="string">'an'</span>: <span class="number">7</span>, <span class="string">'crt'</span>: <span class="number">7</span>, <span class="string">'standard'</span>: <span class="number">7</span>, <span class="string">'TLS'</span>: <span class="number">7</span>, <span class="string">'The'</span>: <span class="number">7</span>, <span class="string">'directives'</span>: <span class="number">7</span>, <span class="string">'ssl'</span>: <span class="number">7</span>, <span class="string">'Use'</span>: <span class="number">7</span>, <span class="string">'only'</span>: <span class="number">7</span>, <span class="string">'o'</span>: <span class="number">7</span>, <span class="string">'shutdown'</span>: <span class="number">7</span>, <span class="string">'dev'</span>: <span class="number">7</span>, <span class="string">'all'</span>: <span class="number">6</span>, <span class="string">'more'</span>: <span class="number">6</span>, <span class="string">'close'</span>: <span class="number">6</span>, <span class="string">'used'</span>: <span class="number">6</span>, <span class="string">'not'</span>: <span class="number">6</span>, <span class="string">'which'</span>: <span class="number">6</span>, <span class="string">'notify'</span>: <span class="number">6</span>, <span class="string">'key'</span>: <span class="number">6</span>, <span class="string">'default'</span>: <span class="number">6</span>, <span class="string">'certificates'</span>: <span class="number">6</span>, <span class="string">'alert'</span>: <span class="number">6</span>, <span class="string">'var'</span>: <span class="number">6</span>, <span class="string">'also'</span>: <span class="number">6</span>, <span class="string">'should'</span>: <span class="number">5</span>, <span class="string">'OpenSSL'</span>: <span class="number">5</span>, <span class="string">'SSLv3'</span>: <span class="number">5</span>, <span class="string">'PEM'</span>: <span class="number">5</span>, <span class="string">'encoded'</span>: <span class="number">5</span>, <span class="string">'clients'</span>: <span class="number">5</span>, <span class="string">'random'</span>: <span class="number">5</span>, <span class="string">'OCSP'</span>: <span class="number">5</span>, <span class="string">'containing'</span>: <span class="number">5</span>, <span class="string">'with'</span>: <span class="number">5</span>, <span class="string">'connection'</span>: <span class="number">5</span>, <span class="string">'from'</span>: <span class="number">5</span>, <span class="string">'SSLCertificateFile'</span>: <span class="number">5</span>, <span class="string">'user'</span>: <span class="number">5</span>, <span class="string">'both'</span>: <span class="number">5</span>, <span class="string">'parallel'</span>: <span class="number">4</span>, <span class="string">'variables'</span>: <span class="number">4</span>, <span class="string">'usually'</span>: <span class="number">4</span>, <span class="string">'at'</span>: <span class="number">4</span>, <span class="string">'Note'</span>: <span class="number">4</span>, <span class="string">'HIGH'</span>: <span class="number">4</span>, <span class="string">'configured'</span>: <span class="number">4</span>, </span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>以上方法在读取文件的时候, 采用了读取全部内容到内存的方法, 如果文件体积较大, 会对内存造成较大压力, 可以通过如下这种迭代的用法实现相同的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = open(<span class="string">'/etc/apache2/extra/httpd-ssl.conf'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个空集合对象</span></span><br><span class="line">s = collections.Counter()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代文件中的每一行</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="comment"># 将每行内容进行按单词的切割, 在切割之前去掉每行字符串的首位空格以及换行</span></span><br><span class="line">    res = re.split(<span class="string">'\W+'</span>, line.strip())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 字符串切割后, 拿到 res 列表, 循环迭代它</span></span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> res:</span><br><span class="line">        <span class="comment"># 如果不是空字符的话就在集合中将该键出现的次数+1</span></span><br><span class="line">        <span class="keyword">if</span> word:</span><br><span class="line">            s[word] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>执行结果与上面相同</p>
<h1 id="统计后找出前三个元素"><a href="#统计后找出前三个元素" class="headerlink" title="统计后找出前三个元素"></a>统计后找出前三个元素</h1><p>在 counter 对象中, 还有一个功能可以帮我们取出指定的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">f = open(<span class="string">'/etc/apache2/extra/httpd-ssl.conf'</span>, <span class="string">'r'</span>)</span><br><span class="line"></span><br><span class="line">s = collections.Counter()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    res = re.split(<span class="string">'\W+'</span>, line.strip())</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> res:</span><br><span class="line">        <span class="keyword">if</span> word:</span><br><span class="line">            s[word] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(s.most_common(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[(<span class="string">'the'</span>, <span class="number">93</span>), (<span class="string">'to'</span>, <span class="number">39</span>), (<span class="string">'and'</span>, <span class="number">32</span>)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计数器</tag>
        <tag>counter</tag>
        <tag>collections</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中可迭代对象的排序</title>
    <url>/2017/07/26/Python%E4%B8%AD%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>在 Python 中, 提供给我们了两种排序的方式, 一种是列表对象自己的<code>.sort</code>方法, 一种是Python 内置的<code>sorted</code>函数</p>
</blockquote>
<h1 id="列表排序"><a href="#列表排序" class="headerlink" title="列表排序"></a>列表排序</h1><p>列表排序有两种方式可以实现, 分别是自带的 <code>.sort</code>方法, 还有内置的<code>sorted</code>函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">l = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">16</span>, <span class="number">42</span>, <span class="number">84</span>, <span class="number">78</span>, <span class="number">22</span>, <span class="number">50</span>, <span class="number">86</span>, <span class="number">14</span>, <span class="number">95</span>, <span class="number">75</span>]</span><br></pre></td></tr></table></figure>

<h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title=".sort 方法"></a>.sort 方法</h2><p>列表对象自身的<code>.sort</code>方法执行后, 会改变原列表对象的顺序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l.sort()</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">86</span>, <span class="number">95</span>]</span><br></pre></td></tr></table></figure>

<p>通过上面的结果可以看出, 原列表的成员位置已经发生了变化</p>
<h2 id="sorted-函数"><a href="#sorted-函数" class="headerlink" title="sorted 函数"></a>sorted 函数</h2><p>使用<code>sorted</code>函数排序后会返回新的对象, 不会在原对象中修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l2 = sorted(l)</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">14</span>, <span class="number">16</span>, <span class="number">22</span>, <span class="number">42</span>, <span class="number">50</span>, <span class="number">75</span>, <span class="number">78</span>, <span class="number">84</span>, <span class="number">86</span>, <span class="number">95</span>]</span><br></pre></td></tr></table></figure>

<h1 id="元组排序"><a href="#元组排序" class="headerlink" title="元组排序"></a>元组排序</h1><p>元组中的元素是有序的, 但是本身的元素是不可修改的, 所以元组自身没有<code>.sort</code>方法可以使用. 但是可以通过转化为列表的方式, 间接使用<code>.sort</code></p>
<h2 id="使用类型转换得到元组"><a href="#使用类型转换得到元组" class="headerlink" title="使用类型转换得到元组"></a>使用类型转换得到元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">l = [random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">t = tuple(l)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">t2 = sorted(t)</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="number">47</span>, <span class="number">33</span>, <span class="number">68</span>, <span class="number">5</span>, <span class="number">86</span>, <span class="number">95</span>, <span class="number">51</span>, <span class="number">12</span>, <span class="number">28</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">28</span>, <span class="number">33</span>, <span class="number">47</span>, <span class="number">51</span>, <span class="number">68</span>, <span class="number">86</span>, <span class="number">95</span>]</span><br></pre></td></tr></table></figure>

<h1 id="使用生成器表达式得到元组-迭代对象"><a href="#使用生成器表达式得到元组-迭代对象" class="headerlink" title="使用生成器表达式得到元组(迭代对象)"></a>使用生成器表达式得到元组(迭代对象)</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">t2 = sorted(t)</span><br><span class="line">print(t2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1019962b0</span>&gt;</span><br><span class="line">[<span class="number">6</span>, <span class="number">40</span>, <span class="number">46</span>, <span class="number">58</span>, <span class="number">68</span>, <span class="number">72</span>, <span class="number">88</span>, <span class="number">89</span>, <span class="number">93</span>, <span class="number">97</span>]</span><br></pre></td></tr></table></figure>

<h1 id="集合排序"><a href="#集合排序" class="headerlink" title="集合排序"></a>集合排序</h1><p> 集合本身是无序的, 本身也没有<code>.sort</code>方法. 但是集合也可以间接的通过先转化为列表的方式来使用<code>.sort</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = &#123;random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)&#125;</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">s2 = sorted(s)</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">100</span>, <span class="number">6</span>, <span class="number">71</span>, <span class="number">11</span>, <span class="number">50</span>, <span class="number">21</span>, <span class="number">62</span>, <span class="number">89</span>, <span class="number">26</span>, <span class="number">94</span>&#125;</span><br><span class="line">[<span class="number">6</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">50</span>, <span class="number">62</span>, <span class="number">71</span>, <span class="number">89</span>, <span class="number">94</span>, <span class="number">100</span>]</span><br></pre></td></tr></table></figure>

<h1 id="字典排序"><a href="#字典排序" class="headerlink" title="字典排序"></a>字典排序</h1><h2 id="依据-key-排序"><a href="#依据-key-排序" class="headerlink" title="依据 key 排序"></a>依据 key 排序</h2><p>使用 sorted 对一个字典进行排序, 只需要把对象传进去即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;chr(random.randint(<span class="number">97</span>, <span class="number">122</span>)):random.randint(<span class="number">1</span>,<span class="number">20</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)&#125;</span><br><span class="line">print(d)</span><br><span class="line">d2 = sorted(d)</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'m'</span>: <span class="number">11</span>, <span class="string">'s'</span>: <span class="number">18</span>, <span class="string">'e'</span>: <span class="number">1</span>, <span class="string">'n'</span>: <span class="number">15</span>, <span class="string">'v'</span>: <span class="number">17</span>, <span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'h'</span>: <span class="number">6</span>, <span class="string">'i'</span>: <span class="number">20</span>, <span class="string">'l'</span>: <span class="number">10</span>&#125;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'s'</span>, <span class="string">'v'</span>]</span><br></pre></td></tr></table></figure>

<p>当我们拿到这个排序过后的列表之后, 就可以依据列表里的”键”的顺序, 到对应的字典中取值了</p>
<h2 id="依据-value-排序"><a href="#依据-value-排序" class="headerlink" title="依据 value 排序"></a>依据 value 排序</h2><p>依据 value 排序就需要用到 sorted 函数中的<code>key</code>参数了, <code>key</code>参数接收一个函数, 此函数即为处理迭代对象每一个元素的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;chr(random.randint(<span class="number">97</span>, <span class="number">122</span>)):random.randint(<span class="number">1</span>, <span class="number">20</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>)&#125;</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># 字典对象.items() 会把每个键值对转化成元组, 并把字典的最外层转化为列表</span></span><br><span class="line">print(d.items())</span><br><span class="line">d2 = sorted(d.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'y'</span>: <span class="number">8</span>, <span class="string">'h'</span>: <span class="number">4</span>, <span class="string">'d'</span>: <span class="number">17</span>, <span class="string">'p'</span>: <span class="number">9</span>, <span class="string">'x'</span>: <span class="number">10</span>, <span class="string">'o'</span>: <span class="number">14</span>, <span class="string">'c'</span>: <span class="number">15</span>, <span class="string">'a'</span>: <span class="number">9</span>, <span class="string">'z'</span>: <span class="number">9</span>&#125;</span><br><span class="line">dict_items([(<span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'h'</span>, <span class="number">4</span>), (<span class="string">'d'</span>, <span class="number">17</span>), (<span class="string">'p'</span>, <span class="number">9</span>), (<span class="string">'x'</span>, <span class="number">10</span>), (<span class="string">'o'</span>, <span class="number">14</span>), (<span class="string">'c'</span>, <span class="number">15</span>), (<span class="string">'a'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="number">9</span>)])</span><br><span class="line">[(<span class="string">'h'</span>, <span class="number">4</span>), (<span class="string">'y'</span>, <span class="number">8</span>), (<span class="string">'p'</span>, <span class="number">9</span>), (<span class="string">'a'</span>, <span class="number">9</span>), (<span class="string">'z'</span>, <span class="number">9</span>), (<span class="string">'x'</span>, <span class="number">10</span>), (<span class="string">'o'</span>, <span class="number">14</span>), (<span class="string">'c'</span>, <span class="number">15</span>), (<span class="string">'d'</span>, <span class="number">17</span>)]</span><br></pre></td></tr></table></figure>

<p>从结果的第一行和第二行可以看出<code>字典. items()</code>的执行效果.</p>
<p>key 后面的 lambda 函数, 将循环接收前面迭代元素的每一个值, 第一次迭代时, 第一个值 <code>(&#39;y&#39;, 8)</code>被传递给 lambda 函数的参数. lambda 函数接收这个参数, 并取这个参数值的第二位值, 也就是取得 <code>(&#39;y&#39;, 8)</code>的第二个值, 并依据此值进行排序</p>
<h1 id="列表嵌套字典混合排序"><a href="#列表嵌套字典混合排序" class="headerlink" title="列表嵌套字典混合排序"></a>列表嵌套字典混合排序</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'lvrui'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'yyy'</span>, <span class="string">'age'</span>: <span class="number">26</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ps'</span>, <span class="string">'age'</span>:<span class="number">28</span>&#125;</span><br><span class="line">]</span><br><span class="line">print(dd)</span><br><span class="line">dd.sort(key=<span class="keyword">lambda</span> x: x[<span class="string">'age'</span>])</span><br><span class="line">print(dd)</span><br></pre></td></tr></table></figure>

<p>以上的方式是通过列表自身的<code>.sort</code>方法实现的, 修改了元列表内部元素的位置</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dd = [</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'lvrui'</span>, <span class="string">'age'</span>: <span class="number">27</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'yyy'</span>, <span class="string">'age'</span>: <span class="number">26</span>&#125;,</span><br><span class="line">    &#123;<span class="string">'name'</span>: <span class="string">'ps'</span>, <span class="string">'age'</span>:<span class="number">28</span>&#125;</span><br><span class="line">]</span><br><span class="line">print(dd)</span><br><span class="line"></span><br><span class="line">dd2 = sorted(dd, key=<span class="keyword">lambda</span> x: x[<span class="string">'age'</span>])</span><br><span class="line">print(dd2)</span><br></pre></td></tr></table></figure>

<p>以上则是通过<code>sorted</code>函数实现.</p>
<p>列举这种用法主要是为了体现 sorted 函数中, key 参数的使用方法, 前面的迭代对象的中每个值, 都会依次传递给 key 中的函数, key 中的函数需要接收一个参数, 并对这个参数的值进行处理, 返回需要排序的对象</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Python在集合中根据条件筛选数据</title>
    <url>/2017/07/25/Python%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>首选创建一个集合</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">l = [random.randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)]</span><br><span class="line">s = set(l)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">-9</span>, <span class="number">-6</span>, <span class="number">-5</span>, <span class="number">-4</span>, <span class="number">-2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现有一个需求, 需要此集合中筛选出可以被3整除的数字都有哪些, 以下给出四种实现方式</p>
<h2 id="第一种方式-循环迭代"><a href="#第一种方式-循环迭代" class="headerlink" title="第一种方式: 循环迭代"></a>第一种方式: 循环迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">s1 = set()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> item % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">        s1.add(item)</span><br><span class="line">print(time.time())</span><br><span class="line">print(s1)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500954512.77478</span></span><br><span class="line"><span class="number">1500954512.774822</span></span><br><span class="line">&#123;<span class="number">-6</span>, <span class="number">3</span>, <span class="number">-9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000042</code></p>
<h2 id="第二种方式-filter-函数"><a href="#第二种方式-filter-函数" class="headerlink" title="第二种方式: filter 函数"></a>第二种方式: filter 函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'---'</span>)</span><br><span class="line">print(time.time())</span><br><span class="line">s2 = list(filter(<span class="keyword">lambda</span> x: x % <span class="number">3</span> == <span class="number">0</span>, s))</span><br><span class="line">print(time.time())</span><br><span class="line">print(s2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500954512.774839</span></span><br><span class="line"><span class="number">1500954512.774854</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">-9</span>, <span class="number">-6</span>]</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000015</code></p>
<h2 id="第三种方式-集合解析式"><a href="#第三种方式-集合解析式" class="headerlink" title="第三种方式: 集合解析式"></a>第三种方式: 集合解析式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">s3 = &#123;i <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>&#125;</span><br><span class="line">print(time.time())</span><br><span class="line">print(s3)</span><br></pre></td></tr></table></figure>

<p>执行结果为: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500954512.774865</span></span><br><span class="line"><span class="number">1500954512.774885</span></span><br><span class="line">&#123;<span class="number">-6</span>, <span class="number">3</span>, <span class="number">-9</span>&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000020</code></p>
<h2 id="第四种方式-生成器表达式"><a href="#第四种方式-生成器表达式" class="headerlink" title="第四种方式: 生成器表达式"></a>第四种方式: 生成器表达式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">s4 = (i <span class="keyword">for</span> i <span class="keyword">in</span> s <span class="keyword">if</span> i % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">print(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> s4:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>执行结果为: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500954512.774917</span></span><br><span class="line"><span class="number">1500954512.774934</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">-9</span></span><br><span class="line"><span class="number">-6</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>集合与之前的字典,列表一样, 要实现数据的筛选依然有四种选择, 小数据量下依然推荐使用<code>集合解析式</code>, 大数据量的情况下推荐使用<code>生成器表达式</code>或 <code>filter 函数</code>(直接返回 filter 迭代对象, 而不直接使用 list 转换)</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>集合解析式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python在字典中根据条件筛选数据</title>
    <url>/2017/07/25/Python%E5%9C%A8%E5%AD%97%E5%85%B8%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>首先创建一个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">d = &#123;str(x): random.randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">21</span>)&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'16'</span>: <span class="number">61</span>, <span class="string">'3'</span>: <span class="number">66</span>, <span class="string">'17'</span>: <span class="number">70</span>, <span class="string">'10'</span>: <span class="number">82</span>, <span class="string">'1'</span>: <span class="number">71</span>, <span class="string">'18'</span>: <span class="number">89</span>, <span class="string">'5'</span>: <span class="number">83</span>, <span class="string">'4'</span>: <span class="number">97</span>, <span class="string">'19'</span>: <span class="number">77</span>, <span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'8'</span>: <span class="number">73</span>, <span class="string">'11'</span>: <span class="number">74</span>, <span class="string">'15'</span>: <span class="number">60</span>, <span class="string">'13'</span>: <span class="number">68</span>, <span class="string">'20'</span>: <span class="number">80</span>, <span class="string">'7'</span>: <span class="number">62</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'6'</span>: <span class="number">85</span>, <span class="string">'14'</span>: <span class="number">83</span>, <span class="string">'9'</span>: <span class="number">87</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现有一个需求, 需要此列表中筛选出值大于90的 id(key) 都有哪些, 以下给出四种实现方式</p>
<h2 id="第一种方法-循环迭代"><a href="#第一种方法-循环迭代" class="headerlink" title="第一种方法: 循环迭代"></a>第一种方法: 循环迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">d2 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    <span class="keyword">if</span> d[k] &gt; <span class="number">90</span>:</span><br><span class="line">        d2[k] = d[k]</span><br><span class="line">print(time.time())</span><br><span class="line">print(d2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500951937.126503</span></span><br><span class="line"><span class="number">1500951937.126532</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000029</code></p>
<h2 id="第二种方法-filter-函数"><a href="#第二种方法-filter-函数" class="headerlink" title="第二种方法: filter 函数"></a>第二种方法: filter 函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">d5 = list(filter(<span class="keyword">lambda</span> x: d[x] &gt; <span class="number">90</span>, d))</span><br><span class="line">print(time.time())</span><br><span class="line">print(d5)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500951937.126604</span></span><br><span class="line"><span class="number">1500951937.126618</span></span><br><span class="line">[<span class="string">'4'</span>, <span class="string">'12'</span>, <span class="string">'2'</span>]</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000014</code></p>
<h2 id="第三种方法-字典解析式"><a href="#第三种方法-字典解析式" class="headerlink" title="第三种方法: 字典解析式"></a>第三种方法: 字典解析式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">d3 = &#123;k:v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>&#125;</span><br><span class="line">print(time.time())</span><br><span class="line">print(d3)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500951937.126555</span></span><br><span class="line"><span class="number">1500951937.126564</span></span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>, <span class="string">'2'</span>: <span class="number">99</span>, <span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000009</code></p>
<h2 id="第四种方法-生成器表达式"><a href="#第四种方法-生成器表达式" class="headerlink" title="第四种方法: 生成器表达式"></a>第四种方法: 生成器表达式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">d4 = (&#123;k: v&#125; <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items() <span class="keyword">if</span> v &gt; <span class="number">90</span>)</span><br><span class="line">print(time.time())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d4:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1500951937.126576</span></span><br><span class="line"><span class="number">1500951937.126581</span></span><br><span class="line">&#123;<span class="string">'4'</span>: <span class="number">97</span>&#125;</span><br><span class="line">&#123;<span class="string">'12'</span>: <span class="number">92</span>&#125;</span><br><span class="line">&#123;<span class="string">'2'</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为: <code>0.000005</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>在字典数据量较小时, 依然推荐使用<code>字典解析式</code>去筛选数据, 在数据量较大且数据需要一条一条处理时, 生成器依然是最佳的选择</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>字典解析式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python在列表中根据条件筛选数据</title>
    <url>/2017/07/25/Python%E5%9C%A8%E5%88%97%E8%A1%A8%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>首先我们创建一个列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">l = [random.randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[-1, 0, 8, 3, 5, 0, 4, 0, -2, 5]</span><br></pre></td></tr></table></figure>

<p>现有一个需求, 需要在这个列表中筛选出大于0的数字, 以下给出四种实现方式</p>
<h2 id="第一种方法-循环迭代"><a href="#第一种方法-循环迭代" class="headerlink" title="第一种方法: 循环迭代"></a>第一种方法: 循环迭代</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l2 = []</span><br><span class="line">print(time.time())</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> l:</span><br><span class="line">    <span class="keyword">if</span> item &gt; <span class="number">0</span>:</span><br><span class="line">        l2.append(item)</span><br><span class="line">print(time.time())</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1500915233.146998</span><br><span class="line">1500915233.147016</span><br><span class="line">[8, 3, 5, 4, 5]</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为<code>0.000018</code></p>
<h2 id="第二种方法-filter函数"><a href="#第二种方法-filter函数" class="headerlink" title="第二种方法: filter函数"></a>第二种方法: filter函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">l3 = list(filter(<span class="keyword">lambda</span> x: x&gt;<span class="number">0</span>, l))</span><br><span class="line">print(time.time())</span><br><span class="line">print(l3)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1500915233.147029</span><br><span class="line">1500915233.147039</span><br><span class="line">[8, 3, 5, 4, 5]</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为<code>0.000010</code></p>
<h2 id="第三种方法-列表解析式"><a href="#第三种方法-列表解析式" class="headerlink" title="第三种方法: 列表解析式"></a>第三种方法: 列表解析式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">l4 = [item <span class="keyword">for</span> item <span class="keyword">in</span> l <span class="keyword">if</span> item &gt; <span class="number">0</span>]</span><br><span class="line">print(time.time())</span><br><span class="line">print(l4)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1500915233.14705</span><br><span class="line">1500915233.147056</span><br><span class="line">[8, 3, 5, 4, 5]</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为<code>0.000006</code></p>
<h2 id="第四种方法-生成器表达式"><a href="#第四种方法-生成器表达式" class="headerlink" title="第四种方法: 生成器表达式"></a>第四种方法: 生成器表达式</h2><p>如果列表数据量巨大, 应该考虑的不是使用列表解析器, 而是生成器表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(time.time())</span><br><span class="line">l5 = (item <span class="keyword">for</span> item <span class="keyword">in</span> l <span class="keyword">if</span> item &gt; <span class="number">0</span>)</span><br><span class="line">print(time.time())</span><br><span class="line">print(type(l5))</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1500916299.74144</span><br><span class="line">1500916299.741445</span><br><span class="line">&lt;class &#39;generator&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>得到结果需要的时间为<code>0.000005</code></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h2><p>通过以上的四种实践方式得出, 使用循环迭代的方式性能最低, 小数据量时, 使用列表解析式是最好的选择; 如果数据量巨大, 应该使用生成器表达式生成一个可迭代对象提供使用</p>
<h2 id="备注"><a href="#备注" class="headerlink" title="备注:"></a>备注:</h2><ul>
<li><p>列表解析 <code>[expr for iter_var in iterable if cond_expr]</code></p>
</li>
<li><p>生成器表达式 <code>(expr for iter_var in iterable if cond_expr)</code></p>
</li>
</ul>
<p>两者的语法非常相似, 但生成器表达式返回的不是一个列表类型对象, 而是一个生成器对象, 生成器是一个内存使用友好的结构</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>生成器</tag>
        <tag>列表解析器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类中资源的访问</title>
    <url>/2017/07/20/Python%E7%B1%BB%E4%B8%AD%E8%B5%84%E6%BA%90%E7%9A%84%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<blockquote>
<p>Python 的类中有三种资源类型, 分别为字段, 方法和属性. </p>
<p>字段又分为静态字段和普通字段</p>
<p>方法分为静态方法,  普通方法和类方法</p>
<p>而字段和方法又能有私有字段和私有方法的形态</p>
<p>本篇文章就来介绍 Python 类中各个资源的访问规则</p>
</blockquote>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="公有静态字段"><a href="#公有静态字段" class="headerlink" title="公有静态字段"></a>公有静态字段</h2><ul>
<li>在类的外部使用对象名访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.name)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<p>此种形态是使用实例化后的对象去访问的静态字段, 一般情况下, 最好用对象去访问对象自己的普通字段, 不要用对象来访问静态字段</p>
<ul>
<li>在类的外部使用类名访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">print(A.name)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<p>此种形态是一般情况下, 正确访问类中静态字段的方式, 即使用类名访问</p>
<ul>
<li>在类的内部使用对象访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.f())</span><br></pre></td></tr></table></figure>

<p>此种情况是在类的内部, 通过一个方法来获取类中静态字段的值, 在方法中, 使用了对象的名字去调用获取了类中静态字段的值, 一般情况下, 上面也说了, 对于类中对静态字段的访问, 需要使用类名去实现, 不推荐使用对象名去调用</p>
<ul>
<li>在类的内部使用类名访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> A.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.f())</span><br><span class="line">print(a.f2())</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br><span class="line">polarsnow</span><br></pre></td></tr></table></figure>



<p>此种情况下, 我通过两种方式, 用类名获取了静态字段的值. 如果使用普通方法的话, 默认方法内的形参只传递了对象的名字, 如果想显示地调用类中的静态字段的话, 需要明确地指定类名; 但是如果是用对象方法的话, 对象方法默认帮我们传递了对象的名字, 所以我们可以使用<code>cls</code>变量直接调用静态字段</p>
<h2 id="私有静态字段"><a href="#私有静态字段" class="headerlink" title="私有静态字段"></a>私有静态字段</h2><ul>
<li>在类的内部使用类方法访问</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    __name = <span class="string">'polarsnow'</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> A.__name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__name</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.f())</span><br><span class="line">print(a.f2())</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<p>私有的静态字段, 不能在外部使用对象或类名调用, 只能通过在类的内部访问. 上面的例子提供了两种方式来访问私有的静态字段. 一种是在普通方法内通过显示指定来访问, 一种是在类方法中, 通过形参, 隐式地通过<code>cls</code>类名来访问</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="公有方法"><a href="#公有方法" class="headerlink" title="公有方法"></a>公有方法</h2><ul>
<li>静态方法</li>
<li>普通方法</li>
<li>类方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'123'</span></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">'lvrui'</span>)</span><br><span class="line">print(a.f())</span><br><span class="line">print(a.f2())</span><br><span class="line">print(a.f3())</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvrui</span><br><span class="line">polarsnow</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>在普通方法中, python 隐式传递了对象名; 在类方法总, python 隐式传递了类名; 而静态方法的本质既没有用到对象也没有用到类, 如果静态方法拿到外面来, 就是 python 中普通的函数而已, 之所以把这种函数也放到类中,  是为了方便类中相关操作的聚合, 同一类的操作放到同一个类下</p>
<h2 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ff</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__f()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ff2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.__f2()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f3</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'123'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ff3</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> A.__f3()</span><br><span class="line"></span><br><span class="line">a = A(<span class="string">'lvrui'</span>)</span><br><span class="line">print(a.ff())</span><br><span class="line">print(a.ff2())</span><br><span class="line">print(a.ff3())</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lvrui</span><br><span class="line">polarsnow</span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<p>每种类型的方法访问均可以访问自己的私有方法. 在共有静态方法调用私有静态方法时需要注意, 只能使用类名去访问私有静态方法</p>
<p>在实际使用中, 对于私有方法的访问, 也可以跨类型访问, 比如我可以用一个普通方法去调用一个私有的类方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    name = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__f2()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__f2</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">'lvrui'</span>)</span><br><span class="line">print(a.f())</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.n)</span><br></pre></td></tr></table></figure>

<p>执行结果为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">polarsnow</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>方法</tag>
        <tag>字段</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>修改gitlab管理员账户密码</title>
    <url>/2017/07/11/%E4%BF%AE%E6%94%B9gitlab%E7%AE%A1%E7%90%86%E5%91%98%E8%B4%A6%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@cord-gitlab-128-92 ~]<span class="comment"># gitlab-rails console production</span></span><br><span class="line">Loading production environment (Rails 4.2.7.1)</span><br><span class="line">irb(main):001:0&gt; u = User.where(id: 1).first</span><br><span class="line">=&gt; <span class="comment">#&lt;User id: 1, email: "admin@example.com", created_at: "2016-11-03 10:17:48", updated_at: "2017-07-11 03:21:27", name: "Administrator", admin: true, projects_limit: 10, skype: "", linkedin: "", twitter: "", authentication_token: "eTsFFy-5tb7qXAKLS1jf", theme_id: 2, bio: nil, username: "root", can_create_group: true, can_create_team: false, state: "active", color_scheme_id: 1, password_expires_at: nil, created_by_id: nil, last_credential_check_at: nil, avatar: nil, hide_no_ssh_key: false, website_url: "", notification_email: "admin@example.com", hide_no_password: false, password_automatically_set: false, location: nil, encrypted_otp_secret: nil, encrypted_otp_secret_iv: nil, encrypted_otp_secret_salt: nil, otp_required_for_login: false, otp_backup_codes: nil, public_email: "", dashboard: 0, project_view: 0, consumed_timestep: nil, layout: 0, hide_project_limit: false, otp_grace_period_started_at: nil, ldap_email: false, external: false, organization: nil&gt;</span></span><br><span class="line">irb(main):002:0&gt; u.password = <span class="string">'NewPassword2017'</span></span><br><span class="line">=&gt; <span class="string">"NewPassword2017"</span></span><br><span class="line">irb(main):003:0&gt; u.save!</span><br><span class="line">Enqueued ActionMailer::DeliveryJob (Job ID: 6b4cf332-80c1-4b3e-a158-efb04e66940c) to Sidekiq(mailers) with arguments: <span class="string">"DeviseMailer"</span>, <span class="string">"password_change"</span>, <span class="string">"deliver_now"</span>, gid://gitlab/User/1</span><br><span class="line">=&gt; <span class="literal">true</span></span><br><span class="line">irb(main):004:0&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>编写 docker-entrypoint.sh 入口文件</title>
    <url>/2017/06/09/%E7%BC%96%E5%86%99docker-entrypoint-sh%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 的官方 Registry 中(store.docker.com) 流行的第三方应用在自己的页面中都提供了 dockerfile 的链接. 而很多 dockerfile 的 ENTRYPOINT 命令都是这么写的 <code>[&quot;docker-entrypoint.sh&quot;]</code> 本篇文章就扫盲下 docker-entrypoint.sh 的特殊用法和设计逻辑</p>
</blockquote>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p>你写的每个脚本都应该在文件开头加上<code>set -e</code>, 这句语句告诉bash如果任何语句的执行结果不是<code>true</code>则应该退出. 这样的好处是防止错误像滚雪球般变大导致一个致命的错误, 而这些错误本应该在之前就被处理掉. 如果要增加可读性, 可以使用<code>set -o errexit</code>, 它的作用与<code>set -e</code>相同</p>
<h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p>设计用途同上, 就是希望在执行错误之后立即退出, 不要再向下执行了. 而 <code>-o pipefail</code> 的作用域是管道, 也就是说在 Linux 脚本中的管道, 如果前面的命令执行出了问题, 应该立即退出</p>
<h2 id="shopt-s-nullglob"><a href="#shopt-s-nullglob" class="headerlink" title="shopt -s nullglob"></a>shopt -s nullglob</h2><p>在使用 Linux 中的通配符时 <code>* ?等</code> 如果没有匹配到任何文件, 不会报 <code>No such file or directory</code> 而是将命令后面的参数去掉执行</p>
<h2 id="if-“-1-0-1-”-‘-‘-then…"><a href="#if-“-1-0-1-”-‘-‘-then…" class="headerlink" title="if [ “${1:0:1}” = ‘-‘ ]; then…"></a>if [ “${1:0:1}” = ‘-‘ ]; then…</h2><p>这是一个判断语句, 在官方文件中, 上一行已经给出了注释: <code>if command starts with an option, prepend mysqld</code></p>
<p>这个判断语句是 <code>${1:0:1}</code> 意思是判断 $1(调用该脚本的第一个参数), 偏移量0(不偏移), 取一个字符(取字符串的长度)</p>
<p>如果判断出来调用这个脚本后面所跟的参数第一个字符是<code>-</code>中横线的话, 就认为后面的所有字符串都是 mysqld 的启动参数</p>
<p>上面的这个操作类似于 Python 的字符串切片</p>
<h2 id="set-–-mysqld-“-”"><a href="#set-–-mysqld-“-”" class="headerlink" title="set – mysqld “$@”"></a>set – mysqld “$@”</h2><p>在上面判断完第一个参数是<code>-</code>开头之后,  紧接着就执行了 <code>set -- mysqld &quot;$@&quot;</code> 这个命令. 使用了 <code>set --</code> 的用法. <code>set —</code>会将他后面所有以空格区分的字符串, 按顺序分别存储到$1, $2, $3 变量中, 其中新的<code>$@</code> 为 <code>set —</code> 后面的全部内容</p>
<p>举例来说: <code>bash docker-entrypoint.sh -f xxx.conf</code></p>
<p>在这种情况下, <code>set -- mysqld &quot;$@&quot;</code> 中的 <code>$@</code> 的值为 <code>-f xxx.conf</code></p>
<p>当执行完 <code>set -- mysqld &quot;$@&quot;</code> 这条命令后:</p>
<ul>
<li><code>$1=mysqld</code></li>
<li><code>$2=-f</code></li>
<li><code>$3=xxx.conf</code></li>
<li><code>$@=mysqld -f xxx.conf</code></li>
</ul>
<p>可以看到, 当执行 <code>docker-entrypoint.sh</code>脚本的时候后面加了 <code>-x</code>形式的参数之后, $@的值发生的改变, 在原有$@值的基础之上, 在前面又预添加了 mysqld 命令</p>
<h2 id="exec-“-”"><a href="#exec-“-”" class="headerlink" title="exec “$@”"></a>exec “$@”</h2><p>几乎在每个 <code>docker-entrypoint.sh</code> 脚本的最后一行, 执行的都是 <code>exec &quot;$@&quot;</code>命令</p>
<p>这个命令的意义在于你已经为你的镜像预想到了应该有的调用情况, 当实际使用镜像的人执行了你没有预料到的可执行命令时, 将会走到脚本的这最后一行, 去执行用户新的可执行命令</p>
<h2 id="情况判断"><a href="#情况判断" class="headerlink" title="情况判断"></a>情况判断</h2><p>上面直接说了脚本的最后一行, 在之前的脚本中, 需要充分的去考虑你自己的脚本可能会被调用的情况. 还是拿 MySQL 官方的 dockerfile 来说, 他判断以下情况:</p>
<ul>
<li>开头是 <code>-</code> , 认为是参数的情况</li>
<li>开头是 <code>mysqld</code>, 且用户 id 为0 (root 用户) 的情况</li>
<li>开头是 <code>mysqld</code> 的情况</li>
</ul>
<p>判断完自己应用的所有调用形态之后, 最后应该加上<code>exec &quot;$@&quot;</code> 命令兜底</p>
<h2 id="mysql"><a href="#mysql" class="headerlink" title="${mysql[@]}"></a>${mysql[@]}</h2><p>Shell 中的数组, 直接执行 <code>${mysql[@]}</code> 会把这个数组当做可执行程序来执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  /tmp mysql=( mysql --protocol=socket -uroot -hlocalhost --socket=<span class="string">"<span class="variable">$&#123;SOCKET&#125;</span>"</span> )</span><br><span class="line">➜  /tmp <span class="built_in">echo</span> <span class="variable">$&#123;mysql[1]&#125;</span></span><br><span class="line">mysql</span><br><span class="line">➜  /tmp <span class="built_in">echo</span> <span class="variable">$&#123;mysql[2]&#125;</span></span><br><span class="line">--protocol=socket</span><br><span class="line">➜  /tmp <span class="built_in">echo</span> <span class="variable">$&#123;mysql[3]&#125;</span></span><br><span class="line">-uroot</span><br><span class="line">➜  /tmp <span class="built_in">echo</span> <span class="variable">$&#123;mysql[4]&#125;</span></span><br><span class="line">-hlocalhost</span><br><span class="line">➜  /tmp <span class="built_in">echo</span> <span class="variable">$&#123;mysql[@]&#125;</span></span><br><span class="line">mysql --protocol=socket -uroot -hlocalhost --socket=</span><br></pre></td></tr></table></figure>



<h2 id="exec-gosu-mysql-“-BASH-SOURCE”-“-”"><a href="#exec-gosu-mysql-“-BASH-SOURCE”-“-”" class="headerlink" title="exec gosu mysql “$BASH_SOURCE” “$@”"></a>exec gosu mysql “$BASH_SOURCE” “$@”</h2><p>这里的 gosu 命令, 是 Linux 中 sudo 命令的轻量级”替代品”</p>
<p>gosu 是一个 golang 语言开发的工具, 用来取代 shell 中的 sudo 命令. su 和 sudo 命令有一些缺陷, 主要是会引起不确定的 TTY, 对信号量的转发也存在问题. 如果仅仅为了使用特定的用户运行程序, 使用 su 或 sudo 显得太重了, 为此 gosu 应运而生.</p>
<p>gosu 直接借用了 libcontainer 在容器中启动应用程序的原理, 使用 <code>/etc/passwd</code> 处理应用程序. gosu 首先找出指定的用户或用户组, 然后切换到该用户或用户组. 接下来, 使用 exec 启动应用程序. 到此为止, gosu 完成了它的工作, 不会参与到应用程序后面的声明周期中. 使用这种方式避免了 gosu 处理 TTY 和转发信号量的问题, 把这两个工作直接交给了应用程序去完成</p>
<hr>
<p>参考文档:</p>
<ul>
<li>set -e: <a href="http://blog.csdn.net/todd911/article/details/9954961" target="_blank" rel="noopener">http://blog.csdn.net/todd911/article/details/9954961</a></li>
<li>set -o pipefail: <a href="http://blog.sina.com.cn/s/blog_8bb0a3bd010171cp.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_8bb0a3bd010171cp.html</a></li>
<li>shopt -s nullglob: <a href="http://mywiki.wooledge.org/glob#nullglob" target="_blank" rel="noopener">http://mywiki.wooledge.org/glob#nullglob</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>entrypoint</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7 字符集设置</title>
    <url>/2017/06/07/MySQL57%E5%AD%97%E7%AC%A6%E9%9B%86%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MySQL5-7-字符集设置"><a href="#MySQL5-7-字符集设置" class="headerlink" title="MySQL5.7 字符集设置"></a>MySQL5.7 字符集设置</h1><blockquote>
<ul>
<li>character-set-client-handshake = FALSE</li>
<li>character-set-server = utf8mb4</li>
<li>collation-server = utf8mb4_unicode_ci</li>
<li>init_connect=’SET NAMES utf8mb4’</li>
</ul>
</blockquote>
<h1 id="character-set-client-handshake"><a href="#character-set-client-handshake" class="headerlink" title="character-set-client-handshake"></a>character-set-client-handshake</h1><p>用来控制客户端声明使用字符集和服务端声明使用的字符集在不一致的情况下的兼容性.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">character-set-client-handshake = <span class="literal">false</span></span><br><span class="line"><span class="comment"># 设置为 False, 在客户端字符集和服务端字符集不同的时候将拒绝连接到服务端执行任何操作</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认为 true</span></span><br><span class="line">character-set-client-handshake = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 设置为 True, 即使客户端字符集和服务端字符集不同, 也允许客户端连接</span></span><br></pre></td></tr></table></figure>



<h1 id="character-set-server"><a href="#character-set-server" class="headerlink" title="character-set-server"></a>character-set-server</h1><p>声明服务端的字符编码, 推荐使用<code>utf8mb4</code> , 该字符虽然占用空间会比较大, 但是可以兼容 emoji 😈 表情的存储</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">character-set-server = utf8mb4</span><br></pre></td></tr></table></figure>



<h1 id="collation-server"><a href="#collation-server" class="headerlink" title="collation-server"></a>collation-server</h1><p>声明服务端的字符集, 字符编码和字符集一一对应, 既然使用了<code>utf8mb4</code>的字符集, 就要声明使用对应的字符编码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">collation-server = utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>



<h1 id="init-connect"><a href="#init-connect" class="headerlink" title="init_connect"></a>init_connect</h1><p><code>init_connect</code> 是用户登录到数据库上之后, 在执行第一次查询之前执行里面的内容. 如果 <code>init_connect</code> 的内容有语法错误, 导致执行失败, 会导致用户无法执行查询, 从mysql 退出</p>
<p>使用 <code>init_connect</code> 执行 <code>SET NAMES utf8mb4</code> 意为:</p>
<ul>
<li>声明自己(客户端)使用的是 <code>utf8mb4</code> 的字符编码</li>
<li>希望服务器返回给自己 <code>utf8mb4</code> 的查询结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">init_connect = <span class="string">'SET NAMES utf8mb4'</span></span><br></pre></td></tr></table></figure>



<h1 id="完整配置"><a href="#完整配置" class="headerlink" title="完整配置"></a>完整配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">init_connect = <span class="string">'SET NAMES utf8mb4'</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考文章:</p>
<ul>
<li><a href="http://www.jb51.net/article/29576.htm" target="_blank" rel="noopener">http://www.jb51.net/article/29576.htm</a></li>
<li><a href="http://www.jb51.net/article/52511.htm" target="_blank" rel="noopener">http://www.jb51.net/article/52511.htm</a></li>
<li><a href="http://www.tuicool.com/articles/2IRVV3" target="_blank" rel="noopener">http://www.tuicool.com/articles/2IRVV3</a></li>
<li><a href="http://jbisbee.blogspot.com/2013/07/set-utf-8-as-default-mysql-encoding.html" target="_blank" rel="noopener">http://jbisbee.blogspot.com/2013/07/set-utf-8-as-default-mysql-encoding.html</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7 高可用高性能配置调优</title>
    <url>/2017/06/07/MySQL57%E9%AB%98%E5%8F%AF%E7%94%A8%E9%AB%98%E6%80%A7%E8%83%BD%E6%9E%B6%E6%9E%84%E6%8C%81%E7%BB%AD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<blockquote>
<p>MySQL5.7 在 5.6 版本的基础之上做了大量的优化, 本篇文章开篇将重点围绕经过优化的基于 GTID 的多线程复制和半同步复制的特性介绍, 后续会持续增加 MySQL5.7 的调优参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[client]</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"></span><br><span class="line">### 基本属性配置</span><br><span class="line">port &#x3D; 3306</span><br><span class="line">datadir&#x3D;&#x2F;data&#x2F;mysql</span><br><span class="line"># 禁用主机名解析</span><br><span class="line">skip-name-resolve</span><br><span class="line"># 默认的数据库引擎</span><br><span class="line">default-storage-engine &#x3D; InnoDB</span><br><span class="line"></span><br><span class="line">### 字符集配置</span><br><span class="line">character-set-client-handshake &#x3D; FALSE</span><br><span class="line">character-set-server &#x3D; utf8mb4</span><br><span class="line">collation-server &#x3D; utf8mb4_unicode_ci</span><br><span class="line">init_connect&#x3D;&#39;SET NAMES utf8mb4&#39;</span><br><span class="line"></span><br><span class="line">### GTID</span><br><span class="line">server_id &#x3D; 59</span><br><span class="line"># 为保证 GTID 复制的稳定, 行级日志</span><br><span class="line">binlog_format &#x3D; row</span><br><span class="line"># 开启 gtid 功能</span><br><span class="line">gtid_mode &#x3D; on</span><br><span class="line"># 保障 GTID 事务安全</span><br><span class="line"># 当启用enforce_gtid_consistency功能的时候,</span><br><span class="line"># MySQL只允许能够保障事务安全, 并且能够被日志记录的SQL语句被执行,</span><br><span class="line"># 像create table ... select 和 create temporarytable语句, </span><br><span class="line"># 以及同时更新事务表和非事务表的SQL语句或事务都不允许执行</span><br><span class="line">enforce-gtid-consistency &#x3D; true</span><br><span class="line"># 以下两条配置为主从切换, 数据库高可用的必须配置</span><br><span class="line"># 开启 binlog 日志功能</span><br><span class="line">log_bin &#x3D; on</span><br><span class="line"># 开启从库更新 binlog 日志</span><br><span class="line">log-slave-updates &#x3D; on</span><br><span class="line"></span><br><span class="line">### 慢查询日志</span><br><span class="line"># 打开慢查询日志功能</span><br><span class="line">slow_query_log &#x3D; 1</span><br><span class="line"># 超过2秒的查询记录下来</span><br><span class="line">long_query_time &#x3D; 2</span><br><span class="line"># 记录下没有使用索引的查询</span><br><span class="line">log_queries_not_using_indexes &#x3D; 1</span><br><span class="line"></span><br><span class="line">### 自动修复</span><br><span class="line"># 记录 relay.info 到数据表中</span><br><span class="line">relay_log_info_repository &#x3D; TABLE</span><br><span class="line"># 记录 master.info 到数据表中 </span><br><span class="line">master_info_repository &#x3D; TABLE</span><br><span class="line"># 启用 relaylog 的自动修复功能</span><br><span class="line">relay_log_recovery &#x3D; on</span><br><span class="line"># 在 SQL 线程执行完一个 relaylog 后自动删除</span><br><span class="line">relay_log_purge &#x3D; 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 数据安全性配置</span><br><span class="line"># 关闭 master 创建 function 的功能</span><br><span class="line">log_bin_trust_function_creators &#x3D; off</span><br><span class="line"># 每执行一个事务都强制写入磁盘</span><br><span class="line">sync_binlog &#x3D; 1</span><br><span class="line"># timestamp 列如果没有显式定义为 not null, 则支持null属性</span><br><span class="line"># 设置 timestamp 的列值为 null, 不会被设置为 current timestamp</span><br><span class="line">explicit_defaults_for_timestamp&#x3D;true</span><br><span class="line"></span><br><span class="line">### 优化配置</span><br><span class="line"># 优化中文全文模糊索引</span><br><span class="line">ft_min_word_len &#x3D; 1</span><br><span class="line"># 默认库名表名保存为小写, 不区分大小写</span><br><span class="line">lower_case_table_names &#x3D; 1</span><br><span class="line"># 单条记录写入最大的大小限制</span><br><span class="line"># 过小可能会导致写入(导入)数据失败</span><br><span class="line">max_allowed_packet &#x3D; 256M</span><br><span class="line"># 半同步复制开启</span><br><span class="line">rpl_semi_sync_master_enabled &#x3D; 1</span><br><span class="line">rpl_semi_sync_slave_enabled &#x3D; 1</span><br><span class="line"># 半同步复制超时时间设置</span><br><span class="line">rpl_semi_sync_master_timeout &#x3D; 1000</span><br><span class="line"># 复制模式(保持系统默认)</span><br><span class="line">rpl_semi_sync_master_wait_point &#x3D; AFTER_SYNC</span><br><span class="line"># 后端只要有一台收到日志并写入 relaylog 就算成功</span><br><span class="line">rpl_semi_sync_master_wait_slave_count &#x3D; 1</span><br><span class="line"># 多线程复制</span><br><span class="line">slave_parallel_type &#x3D; logical_clock</span><br><span class="line">slave_parallel_workers &#x3D; 4</span><br><span class="line"></span><br><span class="line">### 连接数限制</span><br><span class="line">max_connections &#x3D; 1500</span><br><span class="line"># 验证密码超过20次拒绝连接</span><br><span class="line">max_connect_errors &#x3D; 20</span><br><span class="line"># back_log值指出在mysql暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中</span><br><span class="line"># 也就是说，如果MySql的连接数达到max_connections时，新来的请求将会被存在堆栈中</span><br><span class="line"># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log</span><br><span class="line"># 将不被授予连接资源</span><br><span class="line">back_log &#x3D; 500</span><br><span class="line">open_files_limit &#x3D; 65535</span><br><span class="line"># 服务器关闭交互式连接前等待活动的秒数</span><br><span class="line">interactive_timeout &#x3D; 3600</span><br><span class="line"># 服务器关闭非交互连接之前等待活动的秒数</span><br><span class="line">wait_timeout &#x3D; 3600</span><br><span class="line"></span><br><span class="line">### 内存分配</span><br><span class="line"># 指定表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间</span><br><span class="line"># 该表就被打开并放入其中，这样可以更快地访问表内容</span><br><span class="line">table_open_cache &#x3D; 1024</span><br><span class="line"># 为每个session 分配的内存, 在事务过程中用来存储二进制日志的缓存</span><br><span class="line">binlog_cache_size &#x3D; 2M</span><br><span class="line"># 在内存的临时表最大大小</span><br><span class="line">tmp_table_size &#x3D; 128M</span><br><span class="line"># 创建内存表的最大大小(保持系统默认, 不允许创建过大的内存表)</span><br><span class="line"># 如果有需求当做缓存来用, 可以适当调大此值</span><br><span class="line">max_heap_table_size &#x3D; 16M</span><br><span class="line"># 顺序读, 读入缓冲区大小设置</span><br><span class="line"># 全表扫描次数多的话, 可以调大此值</span><br><span class="line">read_buffer_size &#x3D; 1M</span><br><span class="line"># 随机读, 读入缓冲区大小设置</span><br><span class="line">read_rnd_buffer_size &#x3D; 8M</span><br><span class="line"># 高并发的情况下, 需要减小此值到64K-128K</span><br><span class="line">sort_buffer_size &#x3D; 1M</span><br><span class="line"># 每个查询最大的缓存大小是1M, 最大缓存64M 数据</span><br><span class="line">query_cache_size &#x3D; 64M</span><br><span class="line">query_cache_limit &#x3D; 1M</span><br><span class="line"># 提到 join 的效率</span><br><span class="line">join_buffer_size &#x3D; 16M</span><br><span class="line"># 线程连接重复利用</span><br><span class="line">thread_cache_size &#x3D; 64</span><br><span class="line"></span><br><span class="line">### InnoDB 优化</span><br><span class="line">## 内存利用方面的设置</span><br><span class="line"># 数据缓冲区</span><br><span class="line">innodb_buffer_pool_size&#x3D;2G</span><br><span class="line">## 日志方面设置</span><br><span class="line"># 事务日志大小</span><br><span class="line">innodb_log_file_size &#x3D; 256M</span><br><span class="line"># 日志缓冲区大小</span><br><span class="line">innodb_log_buffer_size &#x3D; 4M</span><br><span class="line"># 事务在内存中的缓冲</span><br><span class="line">innodb_log_buffer_size &#x3D; 3M</span><br><span class="line"># 主库保持系统默认, 事务立即写入磁盘, 不会丢失任何一个事务</span><br><span class="line">innodb_flush_log_at_trx_commit &#x3D; 1</span><br><span class="line"># mysql 的数据文件设置, 初始100, 以10M 自动扩展</span><br><span class="line">innodb_data_file_path &#x3D; ibdata1:100M:autoextend</span><br><span class="line"># 为提高性能, MySQL可以以循环方式将日志文件写到多个文件</span><br><span class="line">innodb_log_files_in_group &#x3D; 3</span><br><span class="line">##其他设置</span><br><span class="line"># 如果库里的表特别多的情况，请增加此值</span><br><span class="line">innodb_open_files &#x3D; 800</span><br><span class="line"># 为每个 InnoDB 表分配单独的表空间</span><br><span class="line">innodb_file_per_table &#x3D; 1</span><br><span class="line"># InnoDB 使用后台线程处理数据页上写 I&#x2F;O（输入）请求的数量</span><br><span class="line">innodb_write_io_threads &#x3D; 8</span><br><span class="line"># InnoDB 使用后台线程处理数据页上读 I&#x2F;O（输出）请求的数量</span><br><span class="line">innodb_read_io_threads &#x3D; 8</span><br><span class="line"># 启用单独的线程来回收无用的数据</span><br><span class="line">innodb_purge_threads &#x3D; 1</span><br><span class="line"># 脏数据刷入磁盘(先保持系统默认, swap 过多使用时, 调小此值, 调小后, 与磁盘交互增多, 性能降低)</span><br><span class="line"># innodb_max_dirty_pages_pct &#x3D; 90</span><br><span class="line"># 事务等待获取资源等待的最长时间</span><br><span class="line">innodb_lock_wait_timeout &#x3D; 120</span><br><span class="line"># 开启 InnoDB 严格检查模式, 不警告, 直接报错</span><br><span class="line">innodb_strict_mode&#x3D;1</span><br><span class="line"># 允许列索引最大达到3072</span><br><span class="line"> innodb_large_prefix &#x3D; on</span><br><span class="line"></span><br><span class="line">[mysqldump]</span><br><span class="line"># 开启快速导出</span><br><span class="line">quick</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br><span class="line">max_allowed_packet &#x3D; 256M</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line"># 开启 tab 补全</span><br><span class="line">auto-rehash</span><br><span class="line">default-character-set &#x3D; utf8mb4</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>高可用</tag>
        <tag>高性能</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器的时区设置</title>
    <url>/2017/06/05/Docker%E5%AE%B9%E5%99%A8%E7%9A%84%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 的使用时, 经常会 pull 下来一些官方镜像或第三方的镜像,  毕竟绝大部分自己做的镜像也是基于官方镜像而来的, 其中一些对时间比较敏感的应用可能会因为时区的问题而导致异常, 本篇文章介绍两类系统下时区的修改</p>
</blockquote>
<h1 id="CentOS-RedHat-Fedora"><a href="#CentOS-RedHat-Fedora" class="headerlink" title="CentOS/RedHat/Fedora"></a>CentOS/RedHat/Fedora</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure>
<p><strong>执行命令后立即生效</strong></p>
<h1 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">echo</span> <span class="string">"Asia/shanghai"</span> &gt; /etc/timezone</span><br></pre></td></tr></table></figure>

<p><strong>执行命令后立即生效</strong></p>
<p>#特别说明</p>
<p>在测试中发现, Debian 系统虽然应该和 Ubuntu 划分为一类, 但是却需要使用 CentOS 的做法来修改时区</p>
<p>到底需要使用哪种方式来修改时区可以使用以下的小技巧</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先进入到容器中</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 6170cc378e95 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不管是哪个系统版本, 先查看当前的时区配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是出现一堆"乱码" 最后还带有时区标识的就使用上面 CentOS 的方式修改时区</span></span><br><span class="line">cat /etc/localtime                                    </span><br><span class="line">xxxxxxxxxxxxxx</span><br><span class="line">UTC0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果是直接出现 xxx/yyy 这种地区字符的结果, 那么就使用上面 Ubuntu 的方式修改时区</span></span><br><span class="line">cat /etc/timezone </span><br><span class="line">Asia/Shanghai</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>时区</tag>
      </tags>
  </entry>
  <entry>
    <title>docker image 镜像管理</title>
    <url>/2017/06/05/docker-image-%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Docker 管理命令<ul>
<li>容器管理</li>
<li><strong>镜像管理</strong></li>
<li>网络管理</li>
<li>系统管理</li>
<li>数据卷管理</li>
<li>快照管理</li>
<li>插件管理</li>
<li>其他</li>
<li>swarmkit 管理<ul>
<li>模式管理</li>
<li>节点管理</li>
<li>秘钥管理</li>
<li>服务管理</li>
<li>服务栈管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="镜像管理-image"><a href="#镜像管理-image" class="headerlink" title="镜像管理 image"></a>镜像管理 image</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>根据 dockerfile 构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image build -t centos2 .</span></span><br><span class="line">Sending build context to Docker daemon  19.46kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"> ---&gt; a8493f5f50ff</span><br><span class="line">Step 2/2 : LABEL author <span class="string">"lvrui"</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9a996772de96</span><br><span class="line"> ---&gt; 61b7efba9133</span><br><span class="line">Removing intermediate container 9a996772de96</span><br><span class="line">Successfully built 61b7efba9133</span><br><span class="line">root@ubuntu:~<span class="comment"># cat dockerfile </span></span><br><span class="line">FROM centos</span><br><span class="line">LABEL author=<span class="string">"lvrui"</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">centos2             latest              61b7efba9133        About a minute ago   192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        2 hours ago          204MB</span><br><span class="line">centos              latest              a8493f5f50ff        37 hours ago         192MB</span><br><span class="line">nginx               latest              5766334bdaa0        41 hours ago         183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago         1.84kB</span><br></pre></td></tr></table></figure>

<p>-t 的作用是打标签, 可以直接打成 Registry 的形式, 方便直接 push 到 Registry</p>
<p>如果没有打赏 Registry 地址也没有关系,后期可以通过 tag 命令修改</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>显示镜像的历史构建信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos2             latest              61b7efba9133        2 minutes ago       192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        2 hours ago         204MB</span><br><span class="line">centos              latest              a8493f5f50ff        37 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        41 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br><span class="line">root@ubuntu:~<span class="comment"># docker image history centos2</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">61b7efba9133        2 minutes ago       /bin/sh -c <span class="comment">#(nop)  LABEL author=lvrui           0B                  </span></span><br><span class="line">a8493f5f50ff        37 hours ago        /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0B                  </span></span><br><span class="line">&lt;missing&gt;           37 hours ago        /bin/sh -c <span class="comment">#(nop)  LABEL name=CentOS Base ...   0B                  </span></span><br><span class="line">&lt;missing&gt;           37 hours ago        /bin/sh -c <span class="comment">#(nop) ADD file:807143da05d7013...   192MB</span></span><br></pre></td></tr></table></figure>

<h2 id="import-save-load"><a href="#import-save-load" class="headerlink" title="import/save/load"></a>import/save/load</h2><ul>
<li>import 导入镜像, 导入 export 出来的镜像</li>
<li>save 导出镜像</li>
<li>load 导入镜像, 导入 save 出来的镜像</li>
</ul>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p>查看镜像详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image inspect centos2</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"sha256:61b7efba9133e4ceaf4046e76a2f455a1204a8a794f16920c7543010e2759323"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"centos2:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [],</span><br><span class="line">        <span class="string">"Parent"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">        <span class="string">"Comment"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-04-08T09:12:50.750877048Z"</span>,</span><br><span class="line">        <span class="string">"Container"</span>: <span class="string">"9a996772de96183b48460aa1f02b907d1e8d97f8d322cc41aff909d2a8a74b61"</span>,</span><br><span class="line">        <span class="string">"ContainerConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"f85c553c1496"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/sh"</span>,</span><br><span class="line">                <span class="string">"-c"</span>,</span><br><span class="line">                <span class="string">"#(nop) "</span>,</span><br><span class="line">                <span class="string">"LABEL author=lvrui"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: null,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: [],</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"lvrui"</span>,</span><br><span class="line">                <span class="string">"build-date"</span>: <span class="string">"20170406"</span>,</span><br><span class="line">                <span class="string">"license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="string">"vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"DockerVersion"</span>: <span class="string">"17.04.0-ce"</span>,</span><br><span class="line">        <span class="string">"Author"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"f85c553c1496"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/bash"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: null,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: [],</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"lvrui"</span>,</span><br><span class="line">                <span class="string">"build-date"</span>: <span class="string">"20170406"</span>,</span><br><span class="line">                <span class="string">"license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="string">"vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">        <span class="string">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="string">"Size"</span>: 192481139,</span><br><span class="line">        <span class="string">"VirtualSize"</span>: 192481139,</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: null,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"aufs"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"RootFS"</span>: &#123;</span><br><span class="line">            <span class="string">"Type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">            <span class="string">"Layers"</span>: [</span><br><span class="line">                <span class="string">"sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>作用等同于 <code>docker images</code> 查看镜像列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos2             latest              61b7efba9133        3 hours ago         192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        5 hours ago         204MB</span><br><span class="line">centos              latest              a8493f5f50ff        40 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        44 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br></pre></td></tr></table></figure>

<h2 id="prune"><a href="#prune" class="headerlink" title="prune"></a>prune</h2><p>删除没有被引用的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image prune</span></span><br></pre></td></tr></table></figure>

<h2 id="tag-pull-push"><a href="#tag-pull-push" class="headerlink" title="tag/pull/push"></a>tag/pull/push</h2><ul>
<li>tag: 打标签</li>
<li>pull: 从远程仓库 Registry 拉取镜像</li>
<li>push: 从本地上传镜像</li>
</ul>
<h4 id="从registry中拉取镜像："><a href="#从registry中拉取镜像：" class="headerlink" title="从registry中拉取镜像："></a>从registry中拉取镜像：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h4 id="将镜像推送到registry："><a href="#将镜像推送到registry：" class="headerlink" title="将镜像推送到registry："></a>将镜像推送到registry：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username=lvrui03@126.com registry.cn-beijing.aliyuncs.com</span><br><span class="line">$ sudo docker tag [ImageId] registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br><span class="line">$ sudo docker push registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>注意: 如果 Registry 有密码, 还需要先 login 到镜像仓库才可以上传镜像</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除指定的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image rm centos2:latest</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ3.3.1版本之后默认不允许guest登录</title>
    <url>/2017/06/02/Rabbitmq3-3-1%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8E%E9%BB%98%E8%AE%A4%E4%B8%8D%E5%85%81%E8%AE%B8guest%E7%99%BB%E5%BD%95-0/</url>
    <content><![CDATA[<blockquote>
<p>在 rabbitmq 3.3.1 版本之后, 取消了 guest 登录的权限, 如果需要强制开启需要以下操作</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">echo</span> <span class="string">"[&#123;rabbit, [&#123;loopback_users, []&#125;]&#125;]."</span> &gt; /etc/rabbitmq/rabbitmq.config </span><br><span class="line">➜  ~ systemctl restart rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>尝试登陆访问: <code>http://rabbitmq-server-IP:15672</code></p>
<ul>
<li>username: <code>guest</code></li>
<li>password: <code>guest</code></li>
</ul>
<p><strong>注意</strong>:</p>
<ul>
<li>在执行上面的重定向之前, 最好先检查你系统中有没有这个文件, 如果是新装的 rabbitmq, 默认是没有的, 可以直接执行上面的命令创建并写入内容</li>
<li>上面写入的内容中一定不要忘记最后的 <code>.</code> 没有这个 <code>.</code> 重启 rabbitmq 会报错的</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>强制卸载无响应的nfs挂载目录</title>
    <url>/2017/06/02/%E5%BC%BA%E5%88%B6%E5%8D%B8%E8%BD%BD%E6%97%A0%E5%93%8D%E5%BA%94%E7%9A%84nfs%E6%8C%82%E8%BD%BD%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>在日常的运维中, 经常有需要使用 nfs 挂载远程服务器目录的需求, 但是照我个人实际使用的经验来看, nfs 并不是”一劳永逸”, 故障率还是蛮高的, 其中最长遇到的就是由于网络原因/远程 nfs 服务器原因或其他原因导致的 nfs 客户端与 nfs 服务器失联. 失联并不可怕, 可怕的是它并不会自动重连. 这个时候需要我们手动介入到重连的操作中</p>
</blockquote>
<p>nfs 客户端与服务端失去连接, 最直观的现象就是在 Linux 命令行中,执行 <code>df -h</code> 命令, 整个 terminal 终端就会卡在那里一动不动(挂起), 你可以参考以下方案解决该问题</p>
<h1 id="新开一个-session"><a href="#新开一个-session" class="headerlink" title="新开一个 session"></a>新开一个 session</h1><p>也许你当前的 session 已经被卡住了, 这时需要打开一个新的 session, 如果你是直接登录到 linux 系统界面的, 可以同时按下 “Ctrl+Alt+F2” 切换到第二个 terminal</p>
<h1 id="查询之前挂载的路径"><a href="#查询之前挂载的路径" class="headerlink" title="查询之前挂载的路径"></a>查询之前挂载的路径</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ nfsstat -m</span><br><span class="line">nfsstat -m</span><br><span class="line">/webserver/page from 192.168.1.112:/webserver/page</span><br><span class="line"> Flags: rw,relatime,vers=4.0,rsize=524288,wsize=524288,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=192.168.1.4,local_lock=none,addr=192.168.1.112</span><br></pre></td></tr></table></figure>

<p>以上命令不仅仅会显示出当前的挂载点信息, 还会显示出详细的 nfs 属性信息</p>
<p>当然, 你也可以通过 <code>mount</code> 命令来查询 nfs 的挂载点, 前面写着 IP 的就是 nfs 的挂载信息</p>
<h1 id="使用-umount-f-PATH-卸载"><a href="#使用-umount-f-PATH-卸载" class="headerlink" title="使用 umount -f PATH 卸载"></a>使用 umount -f PATH 卸载</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cd</span></span><br><span class="line">➜  ~ umount -f /webserver/page</span><br></pre></td></tr></table></figure>

<p>先 cd 到家目录, 再强制卸载, 如果执行此命令后, 还是提示磁盘”busily” 就使用以下命令卸载</p>
<h1 id="使用-umount-l-PATH-卸载"><a href="#使用-umount-l-PATH-卸载" class="headerlink" title="使用 umount -l PATH 卸载"></a>使用 umount -l PATH 卸载</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ <span class="built_in">cd</span></span><br><span class="line">➜  ~ umount -l /webserver/page</span><br></pre></td></tr></table></figure>

<p>注意: 这里是使用的小写的<code>L</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables流量转发(网关)</title>
    <url>/2017/06/02/iptables%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/</url>
    <content><![CDATA[<blockquote>
<p>在 A 局域网环境中, 一台服务器使用 VPN 技术拨通了 B 局域网的一台服务器. 如果需要实现 A 局域网的所有服务器到 B 局域网通信, 那么首先需要实现 A 局域网中 VPN(隧道) 服务器的流量转发</p>
</blockquote>
<h1 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h1><ul>
<li>保存规则</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables-save &gt; /etc/iptables-script</span><br></pre></td></tr></table></figure>

<ul>
<li>恢复规则</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ iptables-restore &lt; &#x2F;etc&#x2F;iptables-script</span><br></pre></td></tr></table></figure>

<h1 id="转发流量的防火墙规则"><a href="#转发流量的防火墙规则" class="headerlink" title="转发流量的防火墙规则"></a>转发流量的防火墙规则</h1><ul>
<li>查看规则</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat iptables.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Mon Nov 21 14:49:30 2016</span></span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [75958158:4710517785]</span><br><span class="line">:INPUT ACCEPT [11156433:697999260]</span><br><span class="line">:OUTPUT ACCEPT [11270560:679018758]</span><br><span class="line">:POSTROUTING ACCEPT [0:0]</span><br><span class="line">-A POSTROUTING -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Mon Nov 21 14:49:30 2016</span></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.21 on Mon Nov 21 14:49:30 2016</span></span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [1937717187:1020106795408]</span><br><span class="line">:FORWARD ACCEPT [2772458722:1915560771769]</span><br><span class="line">:OUTPUT ACCEPT [2100892309:1998825790936]</span><br><span class="line">COMMIT</span><br><span class="line"><span class="comment"># Completed on Mon Nov 21 14:49:30 2016</span></span><br></pre></td></tr></table></figure>

<ul>
<li>导入规则</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ iptables-restore &lt; iptables.conf</span><br></pre></td></tr></table></figure>

<h1 id="开启网卡转发"><a href="#开启网卡转发" class="headerlink" title="开启网卡转发"></a>开启网卡转发</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>iptables</tag>
        <tag>网卡转发</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的变量</title>
    <url>/2017/06/02/MySQL%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h1><p>用户变量与数据库连接有关, 这某个连接中声明变量, 在断开连接时这个变量就会消失, 且在这个连接中声明的变量无法在另一个连接中使用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用户变量语法</span><br><span class="line"></span><br><span class="line">set @varName&#x3D;value</span><br></pre></td></tr></table></figure>

<p>声明一个变量 <code>varName</code>, 并将它赋值为 <code>value</code></p>
<p><em>mysql 中的变量是动态数据类型, 它的数据类型会根据它的值的类型而变化</em></p>
<h1 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h1><p>系统变量中, 又分为 <code>全局变量</code> 和 <code>会话变量</code></p>
<p>全局变量与会话变量的区别在于, 对全局变量的修改会影响到整个MySQL服务 (所有会话) 而对局部变量的修改只会影响到当前会话的连接</p>
<p>利用select语句我们可以查询单个会话变量或者全局变量的值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@session.sort_buffer_size</span><br><span class="line"><span class="keyword">select</span> @@global.sort_buffer_size</span><br><span class="line"><span class="keyword">select</span> @@global.tmpdir</span><br></pre></td></tr></table></figure>

<p>凡是上面提到的session，都可以用local这个关键字来代替。</p>
<p>比如： <code>select @@local.sort_buffer_size</code></p>
<p><em>local 是 session的近义词</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">无论是在设置系统变量还是查询系统变量值的时候，只要没有指定到底是全局变量还是会话变量, 都当做会话变量来处理。</span><br><span class="line"></span><br><span class="line">比如：</span><br><span class="line">set @@sort_buffer_size &#x3D; 50000;</span><br><span class="line">select @@sort_buffer_size;</span><br><span class="line"></span><br><span class="line">上面都没有指定是GLOBAL还是SESSION，所以全部当做SESSION处理。</span><br></pre></td></tr></table></figure>

<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>全局变量在 MySQL 启动的时候由服务器自动初始化他们的值, 这些默认的值可以在 <code>/etc/my.cnf</code> 中修改</p>
<h3 id="查看全局变量"><a href="#查看全局变量" class="headerlink" title="查看全局变量"></a>查看全局变量</h3><p><code>show global variables;</code></p>
<h3 id="修改全局变量"><a href="#修改全局变量" class="headerlink" title="修改全局变量"></a>修改全局变量</h3><p><code>set global varname = value;</code> 或 <code>set @@global.varname = value;</code></p>
<h2 id="会话变量"><a href="#会话变量" class="headerlink" title="会话变量"></a>会话变量</h2><p>会话变量在每一个数据库连接建立后, 由 MySQL 来初始化. MySQL 会将当前所有的全局变量都复制一份作为会话变量</p>
<h3 id="查看会话变量"><a href="#查看会话变量" class="headerlink" title="查看会话变量"></a>查看会话变量</h3><p><code>show session variables;</code>  或 <code>show variables;</code></p>
<h3 id="修改会话变量"><a href="#修改会话变量" class="headerlink" title="修改会话变量"></a>修改会话变量</h3><p><code>set session varname = value;</code> 或 <code>set @@session.varname = value;</code></p>
<h1 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h1><p>有些系统变量的值是可以利用语句来动态进行更改的，但是有些系统变量的值却是只读的</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装killall命令</title>
    <url>/2017/06/02/CentOS7%E5%AE%89%E8%A3%85killall%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>yum install psmisc -y</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>killall</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker集群模式的落地方案尝试</title>
    <url>/2017/06/02/Docker%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E8%90%BD%E5%9C%B0%E6%96%B9%E6%A1%88%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<h1 id="docker-集群模式的落地方案尝试"><a href="#docker-集群模式的落地方案尝试" class="headerlink" title="docker 集群模式的落地方案尝试"></a>docker 集群模式的落地方案尝试</h1><p>最近一直在探索 docker 的集群模式在公司实际环境中的落地方案. 公司现有docker 的使用方式为单机, 且在日志收集, 网络模式, 存储引擎等方面的配置和用法比较分散, 尤其是现有使用的 devicemapper 存储引擎模式, 官方明确表示不适合生产环境中使用. </p>
<p>docker 的集群方案目前比较火热的有三种, 一种是 docker 在1.12版本中集成的 swarmkit, 一种是 Google 开源的 kubernetes, 还有一种是 Apache 开源的 mesos. 虽然 kubernetes 是被认为是轻量级的 PaaS 平台, 但如果考虑在公司落地, kubernetes 对我们来说仍然是”重量级”的产品, 考虑到公司现有基于的架构(IaaS), 最终还是选择了 docker 自家的 swarmkit 集群平台进行 PaaS 平台的初步尝试.</p>
<p>swarmkit 的一大好处是安装好 docker 引擎后, 不需要安装任何其他组件, 只需要开启 docker 的 swarm 模式即可. dev 环境现有的 swarmkit 平台由 3 台入口服务器和6台后端应用服务器组成, 其中入口的3台服务器也可以当做应用服务器来部署 docker 应用, 加起来整个平台有9个节点可以分布式的部署 docker 应用.</p>
<p>平台搭建好后, 我首先拿 Apache 服务做测试, 使用 Apache 镜像运行了一个静态页面, 指定后端启动6个容器提供服务, 服务启动后, 可以通过3台入口服务器的任何一个入口进行访问, 请求会被打到后端的 Apache 容器中. 在这个模式下, 我们老雪进行压力测试, 最终在并发1000, 循环100次的量级下, 错误率达到将近50%的情况下结束测试, 寻找瓶颈. 经过排查, 瓶颈不是平台的吞吐量到达上线, 也不是容器处理的请求到达上限, 而是宿主机的日志收集导致宿主机的 IO wait 飙升, 在严苛的测试要求下(500ms的响应时间), 导致大量的请求由于宿主机的 IO wait 而导致响应超时. 我们当初已这样的模式进行测试的目的其实是测试平台的吞吐量, 以及平台网络的稳定性, 没想到这样的量级下,这两点都没有任何问题, 反而是 IO 拖了后腿. </p>
<p>在北京三区生产环境中, 每台 Nginx 网络的瞬时最大吞吐量为30MB左右, 在 swarmkit 平台测试的一个入口的网络瞬时吞吐量也达到了将近20MB, 由于大量的 IO wait, 导致没有测试到入口的实际最大承载量. 但是按照现有三个入口的架构来看, 每个入口20MB 的流量, 加起来也可以承受60MB的吞吐能力, 相当于将近500Mb 带宽的水平, 而三区生产环境的公网 IP 也只有300Mb 的带宽, 在平台稳定性, 以及虚拟网络稳定性及吞吐量上来看, swarmkit 就已经完全符合我们生产环境入口量级的吞吐能力.</p>
<p>接下来的测试中, 上线了用户体系的一个服务, 后端仍旧为6个节点提供服务, 在压力测试中, 基本上所有的错误都来自数据库连接的错误</p>
<p>接下来我们打算上线用户体系第二个服务的时候遇到了问题, 该服务需要向 Zookeeper 注册信息, 而在集群中, 整个集群是一个大型的 VLAN 网络, 每个容器拥有三个 IP, 一个是 docker 桥接给每个容器的 IP, 一个是 VLAN 网络的 IP, 一个是前端用于负载均衡用的 VIP(虚 IP), 当容器内的服务向Zookeeper 注册时, 默认拿的是自己主机上 hosts 中 localhost 对应的 IP 地址, 而且最重要的是, 不管这三个拿哪个 IP 地址, 都只能从内往外连通, 外部主机不可能主动连接进来. 这也就导致了容器内的服务向 Zookeeper 注册时的 IP, 在其他消费者拿到此 IP 的时候, 发现这个 IP 根本就连不上.</p>
<p>对于上面的问题, 我们想了很多解决办法, 我们想过通过路由的方式, 让集群外部主机连通集群内部的网络, 但是这样做的后果是又多增加了一个不稳定因素, 集群外所有需要连进来的流量都会通过我们自己的一台网关服务器做转发, 这相当于我们自己维护了一个虚拟交换机, 增加了两个环境之间交互的稳定性的风险.</p>
<p>还有一个办法是把 docker 集群模式关闭, 当做单机来使用, 但是又发现一个问题, 我们测试的这个服务, 在dubbo 向 Zookeeper 注册时, 默认监听了自己的20880端口(记不清了, 好像是这个) 不管是使用网桥模式映射出去, 还是使用<br>host 模式让他监听宿主机的端口, 问题都是一个: 这一台 docker 宿主机上, 只能启动一个监听20880的服务, 也就是说, 在发布应用容器的时候, 我们需要人为的去判断, 或是用其他方式去判断目标 docker 主机上是否已经存在与自己端口冲突的服务, 这无疑也是加大了 docker 使用难度, 而且这种模式明显是把 docker 当做虚拟机来使用, 仍然是 IaaS 平台的老思路, 违背了 docker 倡导的使用规则.</p>
<p>由于Zookeeper 的原因, 到目前为止, 对 docker 集群平台(PaaS) 平台的探索将放慢脚步, 也希望在以后的一段时间能找到行之有效的完美解决方案, 如果大家有什么想法, 可以沟通一下, 让我开阔一下眼界.</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>集群</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7下升级内核版本</title>
    <url>/2017/06/02/CentOS%E4%B8%8B%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br><span class="line"></span><br><span class="line">rpm -Uvh https://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可以安装的内核版本</span></span><br><span class="line">yum --disablerepo=<span class="string">"*"</span> --enablerepo=<span class="string">"elrepo-kernel"</span> list available</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 LTS 版本的内核</span></span><br><span class="line">yum --enablerepo=elrepo-kernel  install  kernel<span class="_">-lt</span> -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者安装最新版本的内核</span></span><br><span class="line">yum --enablerepo=elrepo-kernel install  kernel-ml-devel kernel-ml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核列表</span></span><br><span class="line">awk -F\<span class="string">' '</span><span class="variable">$1</span>==<span class="string">"menuentry "</span> &#123;<span class="built_in">print</span> i++ <span class="string">" : "</span> <span class="variable">$2</span>&#125;<span class="string">' /etc/grub2.cfg</span></span><br><span class="line"><span class="string"># 新安装的内核会插入在当前使用内核的前面</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 查看当前使用的内核</span></span><br><span class="line"><span class="string">grub2-editenv list</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#修改内核启动顺序，按照上面命令的回显, 指定启动使用第0号内核版本</span></span><br><span class="line"><span class="string">grub2-set-default 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">reboot</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">uname -a</span></span><br></pre></td></tr></table></figure>

<p>参考文档</p>
<ul>
<li><a href="http://elrepo.org/tiki/tiki-index.php" target="_blank" rel="noopener">http://elrepo.org/tiki/tiki-index.php</a></li>
<li>手动下载 RPM 包: <a href="http://elrepo.org/tiki/Download" target="_blank" rel="noopener">http://elrepo.org/tiki/Download</a></li>
<li><a href="https://blog.csdn.net/kikajack/article/details/79396793" target="_blank" rel="noopener">https://blog.csdn.net/kikajack/article/details/79396793</a></li>
<li><a href="https://wiki.centos.org/zh/HowTos/Grub2" target="_blank" rel="noopener">https://wiki.centos.org/zh/HowTos/Grub2</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>内核</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统开机时加载指定模块</title>
    <url>/2017/06/02/Linux%E7%B3%BB%E7%BB%9F%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8A%A0%E8%BD%BD%E6%8C%87%E5%AE%9A%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h1 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h1><p>在 <code>/etc/sysconfig/modules/</code> 下创建 <code>*.modules</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/sysconfig/modules/my.modules</span><br><span class="line"></span><br><span class="line">modprobe overlay</span><br><span class="line"></span><br><span class="line">&gt; chmod 755 /etc/sysconfig/modules/my.modules</span><br></pre></td></tr></table></figure>

<h1 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h1><p>在 <code>/etc/rc.modules</code> 里面加上 <code>modprobe fuse</code>, 没有的话创建该文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/rc.modules</span><br><span class="line"></span><br><span class="line">modprobe overlay</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>reboot</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ lsmod | grep over</span><br><span class="line">overlay                42451  0</span><br></pre></td></tr></table></figure>

<h1 id="第三种方式"><a href="#第三种方式" class="headerlink" title="第三种方式"></a>第三种方式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"overlay"</span> &gt; /etc/modules-load.d/overlay.conf</span><br><span class="line"></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>模块</tag>
      </tags>
  </entry>
  <entry>
    <title>Swap的使用频率</title>
    <url>/2017/06/02/Swap%E7%9A%84%E4%BD%BF%E7%94%A8%E9%A2%91%E7%8E%87/</url>
    <content><![CDATA[<p>通过调整<code>swappiness</code>的值, 可以调整系统使用 swap 的频率</p>
<p>该值越小, 表示越大限度的使用物理内存, 最小值=0</p>
<p>该值越大, 表示越积极的使用 swap 交换分区, 最大值=100</p>
<h1 id="查看-swappiness-值"><a href="#查看-swappiness-值" class="headerlink" title="查看 swappiness 值"></a>查看 swappiness 值</h1><p><code>cat /proc/sys/vm/swappiness</code></p>
<p>centos 中默认为10, Ubuntu 中默认为60</p>
<h1 id="临时修改-重启失效"><a href="#临时修改-重启失效" class="headerlink" title="临时修改 (重启失效)"></a>临时修改 (重启失效)</h1><p> sysctl vm.swappiness=59</p>
<h1 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h1><p><code>echo &quot;vm.swappiness=59&quot; &gt;&gt; /etc/sysctl.conf</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>swap</tag>
      </tags>
  </entry>
  <entry>
    <title>docker network 网络管理</title>
    <url>/2017/04/23/docker-network-%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Docker 管理命令<ul>
<li>容器管理</li>
<li>镜像管理</li>
<li><strong>网络管理</strong></li>
<li>系统管理</li>
<li>数据卷管理</li>
<li>快照管理</li>
<li>插件管理</li>
<li>其他</li>
<li>swarmkit 管理<ul>
<li>模式管理</li>
<li>节点管理</li>
<li>秘钥管理</li>
<li>服务管理</li>
<li>服务栈管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="网络管理-network"><a href="#网络管理-network" class="headerlink" title="网络管理 network"></a>网络管理 network</h1><p>Docker 的网络模式繁多, 截止至当前版本(17.04.0-ce), Docker 内置了5种网络引擎供大家使用</p>
<ul>
<li>bridge 默认的网桥+NAT模式</li>
<li>host 主机模式(性能损耗最少, 但是有安全性问题, 因为容器内部可以直接修改宿主机网卡配置文件)</li>
<li>macvlan 引入之初在于解决本宿主机的容器互联问题(1.13版本之后默认集成进来的网络插件)</li>
<li>null 不设置任何网络引擎</li>
<li>overlay 跨主机互联, 集群模式下使用较多</li>
</ul>
<h2 id="create"><a href="#create" class="headerlink" title="create"></a>create</h2><p>创建网络一般用于对容器内网 IP 地址段有要求的情况, 一般在集群模式下创建自定义 overlay 网络的情况较多</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker network create --driver overlay my-network</span></span><br></pre></td></tr></table></figure>

<p>在集群模式中创建 overlay 网络后, 创建的服务可以指定加入到新的网络中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker service ceate --replicas 3 --network my-network --name my-web nginx</span></span><br></pre></td></tr></table></figure>

<h2 id="connect-disconnect"><a href="#connect-disconnect" class="headerlink" title="connect/disconnect"></a>connect/disconnect</h2><p>将容器加入/离开指定的网络</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network connect [OPTIONS] NETWORK CONTAINER</span><br><span class="line">docker network disconnect [OPTIONS] NETWORK CONTAINER</span><br></pre></td></tr></table></figure>

<h2 id="ls-inspect"><a href="#ls-inspect" class="headerlink" title="ls/inspect"></a>ls/inspect</h2><p>查看网络配置列表/查看网络详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">docker network inspect [OPTIONS] NETWORK [NETWORK...]</span><br></pre></td></tr></table></figure>

<h2 id="rm-prune"><a href="#rm-prune" class="headerlink" title="rm/prune"></a>rm/prune</h2><p>删除指定网络/删除没有引用的网络</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker network rm NETWORK [NETWORK...]</span><br><span class="line">docker network prune [OPTIONS]</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>docker image 容器管理</title>
    <url>/2017/04/23/docker-image-%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Docker 管理命令<ul>
<li>容器管理</li>
<li><strong>镜像管理</strong></li>
<li>网络管理</li>
<li>系统管理</li>
<li>数据卷管理</li>
<li>快照管理</li>
<li>插件管理</li>
<li>其他</li>
<li>swarmkit 管理<ul>
<li>模式管理</li>
<li>节点管理</li>
<li>秘钥管理</li>
<li>服务管理</li>
<li>服务栈管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h1 id="镜像管理-image"><a href="#镜像管理-image" class="headerlink" title="镜像管理 image"></a>镜像管理 image</h1><h2 id="build"><a href="#build" class="headerlink" title="build"></a>build</h2><p>根据 dockerfile 构建镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image build -t centos2 .</span></span><br><span class="line">Sending build context to Docker daemon  19.46kB</span><br><span class="line">Step 1/2 : FROM centos</span><br><span class="line"> ---&gt; a8493f5f50ff</span><br><span class="line">Step 2/2 : LABEL author <span class="string">"lvrui"</span></span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9a996772de96</span><br><span class="line"> ---&gt; 61b7efba9133</span><br><span class="line">Removing intermediate container 9a996772de96</span><br><span class="line">Successfully built 61b7efba9133</span><br><span class="line">root@ubuntu:~<span class="comment"># cat dockerfile </span></span><br><span class="line">FROM centos</span><br><span class="line">LABEL author=<span class="string">"lvrui"</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">centos2             latest              61b7efba9133        About a minute ago   192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        2 hours ago          204MB</span><br><span class="line">centos              latest              a8493f5f50ff        37 hours ago         192MB</span><br><span class="line">nginx               latest              5766334bdaa0        41 hours ago         183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago         1.84kB</span><br></pre></td></tr></table></figure>

<p>-t 的作用是打标签, 可以直接打成 Registry 的形式, 方便直接 push 到 Registry</p>
<p>如果没有打赏 Registry 地址也没有关系,后期可以通过 tag 命令修改</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>显示镜像的历史构建信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos2             latest              61b7efba9133        2 minutes ago       192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        2 hours ago         204MB</span><br><span class="line">centos              latest              a8493f5f50ff        37 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        41 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br><span class="line">root@ubuntu:~<span class="comment"># docker image history centos2</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">61b7efba9133        2 minutes ago       /bin/sh -c <span class="comment">#(nop)  LABEL author=lvrui           0B                  </span></span><br><span class="line">a8493f5f50ff        37 hours ago        /bin/sh -c <span class="comment">#(nop)  CMD ["/bin/bash"]            0B                  </span></span><br><span class="line">&lt;missing&gt;           37 hours ago        /bin/sh -c <span class="comment">#(nop)  LABEL name=CentOS Base ...   0B                  </span></span><br><span class="line">&lt;missing&gt;           37 hours ago        /bin/sh -c <span class="comment">#(nop) ADD file:807143da05d7013...   192MB</span></span><br></pre></td></tr></table></figure>

<h2 id="import-save-load"><a href="#import-save-load" class="headerlink" title="import/save/load"></a>import/save/load</h2><ul>
<li>import 导入镜像, 导入 export 出来的镜像</li>
<li>save 导出镜像</li>
<li>load 导入镜像, 导入 save 出来的镜像</li>
</ul>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p>查看镜像详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image inspect centos2</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"sha256:61b7efba9133e4ceaf4046e76a2f455a1204a8a794f16920c7543010e2759323"</span>,</span><br><span class="line">        <span class="string">"RepoTags"</span>: [</span><br><span class="line">            <span class="string">"centos2:latest"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"RepoDigests"</span>: [],</span><br><span class="line">        <span class="string">"Parent"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">        <span class="string">"Comment"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-04-08T09:12:50.750877048Z"</span>,</span><br><span class="line">        <span class="string">"Container"</span>: <span class="string">"9a996772de96183b48460aa1f02b907d1e8d97f8d322cc41aff909d2a8a74b61"</span>,</span><br><span class="line">        <span class="string">"ContainerConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"f85c553c1496"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/sh"</span>,</span><br><span class="line">                <span class="string">"-c"</span>,</span><br><span class="line">                <span class="string">"#(nop) "</span>,</span><br><span class="line">                <span class="string">"LABEL author=lvrui"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: null,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: [],</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"lvrui"</span>,</span><br><span class="line">                <span class="string">"build-date"</span>: <span class="string">"20170406"</span>,</span><br><span class="line">                <span class="string">"license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="string">"vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"DockerVersion"</span>: <span class="string">"17.04.0-ce"</span>,</span><br><span class="line">        <span class="string">"Author"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"f85c553c1496"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"/bin/bash"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"sha256:a8493f5f50ffda70c2eeb2d09090debf7d39c8ffcd63b43ff81b111ece6f28bf"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: null,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: [],</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"lvrui"</span>,</span><br><span class="line">                <span class="string">"build-date"</span>: <span class="string">"20170406"</span>,</span><br><span class="line">                <span class="string">"license"</span>: <span class="string">"GPLv2"</span>,</span><br><span class="line">                <span class="string">"name"</span>: <span class="string">"CentOS Base Image"</span>,</span><br><span class="line">                <span class="string">"vendor"</span>: <span class="string">"CentOS"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Architecture"</span>: <span class="string">"amd64"</span>,</span><br><span class="line">        <span class="string">"Os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">        <span class="string">"Size"</span>: 192481139,</span><br><span class="line">        <span class="string">"VirtualSize"</span>: 192481139,</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: null,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"aufs"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"RootFS"</span>: &#123;</span><br><span class="line">            <span class="string">"Type"</span>: <span class="string">"layers"</span>,</span><br><span class="line">            <span class="string">"Layers"</span>: [</span><br><span class="line">                <span class="string">"sha256:36018b5e978717a047892794aebab513ba6856dbe1bdfeb478ca1219df2c7e9c"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p>作用等同于 <code>docker images</code> 查看镜像列表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image ls</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos2             latest              61b7efba9133        3 hours ago         192MB</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        5 hours ago         204MB</span><br><span class="line">centos              latest              a8493f5f50ff        40 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        44 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br></pre></td></tr></table></figure>

<h2 id="prune"><a href="#prune" class="headerlink" title="prune"></a>prune</h2><p>删除没有被引用的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image prune</span></span><br></pre></td></tr></table></figure>

<h2 id="tag-pull-push"><a href="#tag-pull-push" class="headerlink" title="tag/pull/push"></a>tag/pull/push</h2><ul>
<li>tag: 打标签</li>
<li>pull: 从远程仓库 Registry 拉取镜像</li>
<li>push: 从本地上传镜像</li>
</ul>
<h4 id="从registry中拉取镜像："><a href="#从registry中拉取镜像：" class="headerlink" title="从registry中拉取镜像："></a>从registry中拉取镜像：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker pull registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br></pre></td></tr></table></figure>

<h4 id="将镜像推送到registry："><a href="#将镜像推送到registry：" class="headerlink" title="将镜像推送到registry："></a>将镜像推送到registry：</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker login --username=lvrui03@126.com registry.cn-beijing.aliyuncs.com</span><br><span class="line">$ sudo docker tag [ImageId] registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br><span class="line">$ sudo docker push registry.cn-beijing.aliyuncs.com/lvreg/webconsole:[镜像版本号]</span><br></pre></td></tr></table></figure>

<p>注意: 如果 Registry 有密码, 还需要先 login 到镜像仓库才可以上传镜像</p>
<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除指定的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker image rm centos2:latest</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>image</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile最佳实践</title>
    <url>/2017/04/22/dockerfile%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<blockquote>
<p>通过 dockerfile 可以制作镜像, 通过优化 dockerfile 中的指令, 可以减少镜像的体积. 按照一些规范制作 dockerfile, 可以增加 dockerfile 的可读性和可维护性</p>
</blockquote>
<h1 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h1><ul>
<li>容器的生命周期是短暂的(无状态容器)<br>通过 dockerfile 制作出的镜像, 从镜像启动容器, 这些容器的生命周期应尽量短暂. 这里的短暂意味着容器随时可以被停止和删除. 通过简单的配置可以立即启动一个新的容器</li>
<li>尽量使用干净的目录去制作镜像, 避免不必要的性能损耗, 必要时可以使用<code>.dockerignore</code>文件排除不需要扫描的目录</li>
<li>只安装需要的包<br>为了减少镜像的体积和编译时间, 应该避免安装额外的, 不需要的包</li>
<li>每个容器只运行一个进程</li>
<li>减少镜像层<br>dockerfile 中的指令会生成新的镜像层, 一个镜像最多有127层</li>
<li>把多个参数排在不同的行中提高可读性<code>\</code></li>
</ul>
<p><strong>注意: 编译缓存的问题<br>针对 ADD 和 COPY 命令, docker 会检查镜像层中所有源文件的元数据和文件内容. 其中检查元数据的时候, 不会检查最后修改时间和访问时间.<br>docker 在镜像缓存中寻找镜像层时, 不会检查文件. 例如, 在执行 RUN yum update 时, docker 仅仅会比较 RUN 命令的本身.</strong></p>
<h1 id="FROM-指令最佳实践"><a href="#FROM-指令最佳实践" class="headerlink" title="FROM 指令最佳实践"></a>FROM 指令最佳实践</h1><p>尽量使用官方镜像作为基础镜像. 如果考虑镜像的大小, 可以使用 Debian 的官方镜像, 该镜像体积小而且 Docker 对他进行了优化, store.docker.com 中有很多官方镜像都是基于 Debian 的镜像打造</p>
<h1 id="RUN-指令最佳实践"><a href="#RUN-指令最佳实践" class="headerlink" title="RUN 指令最佳实践"></a>RUN 指令最佳实践</h1><ul>
<li>从可读性的角度考虑, 使用 RUN 命令时, 应使用 <code>\</code> 将指令分成多行</li>
<li>避免更新基础镜像中的基础软件包, 避免执行类似于 <code>yum update</code> 或 <code>apt upgrade</code>的命令. 在没有使用 <code>--privileged</code>的运行容器中, 基础镜像中的很多基础包是不能升级的. </li>
<li>由于镜像的缓存机制, 在安装软件包时, 更新软件仓库索引和安装软件包必须在同一个 RUN 里执行, 否则可能会导致安装失败</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ✔️正确写法</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install -y \</span></span><br><span class="line"><span class="bash">	dstat \</span></span><br><span class="line"><span class="bash">    htop \</span></span><br><span class="line"><span class="bash">    lsof</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ❌错误写法</span><br><span class="line">RUN apt update</span><br><span class="line">RUN apt install -y \</span><br><span class="line">	dstat \</span><br><span class="line">    htop \</span><br><span class="line">    lsof</span><br></pre></td></tr></table></figure>

<p>由于镜像的缓存机制, 只验证的 RUN 后面的命令, 会导致执行过一次 <code>apt update</code> 之后, 再次遇到更新时将会使用缓存镜像, 从而导致以后安装不到最新的软件包</p>
<p>使用<code>RUN apt update &amp;&amp; apt install -y \</code>的方式可以保证每次编译镜像时, 都是安装的最新的包. 这种技术叫做”缓存失效”</p>
<ul>
<li>尽量在一条 RUN 指令中包含所有需要的安装包. 如果安装包很多, 建议以首字母进行排序,每行只列出一个安装包, 方便后期维护.</li>
<li>在安装命令的最后, 应该清理安装缓存, 减少镜像体积. 执行 <code>... &amp;&amp; yum clean all</code> 或 <code>... &amp;&amp; rm -fr /var/lib/apt/lists/*</code></li>
</ul>
<h1 id="CMD-amp-ENTRYPOINT-指令最佳实践"><a href="#CMD-amp-ENTRYPOINT-指令最佳实践" class="headerlink" title="CMD &amp; ENTRYPOINT 指令最佳实践"></a>CMD &amp; ENTRYPOINT 指令最佳实践</h1><h2 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h2><p>CMD 指令设置镜像中的默认启动命令和参数. 容器启动之后, 如果没有加入任何启动命令(也就是在镜像参数之后没有添加任何内容) 则默认执行镜像中 CMD 设置的默认的启动命令</p>
<ul>
<li><p>设置启动命令时, 应该尽量使用 JSON 格式 <code>CMD [&quot;command&quot;, &quot;arg1&quot;, &quot;arg2&quot;]</code><br>例如 Apache 的启动方式: <code>CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;]</code></p>
</li>
<li><p>如果开发者和使用者都不是很熟悉 CMD 和 ENTRYPOINT 的工作原理的情况下, 尽量避免这两个指令配合使用<br>例如 Django 的启动方式: <code>CMD [&quot;python&quot;, &quot;manage.py&quot;, &quot;runserver&quot;, &quot;0.0.0.0:8000&quot;]</code></p>
</li>
<li><p>相反, 如果开发者和使用者都很熟悉 CMD 和 ENTRYPOINT 的工作原理, 推荐 CMD 作为 ENTRYPOINT 的参数来配套使用</p>
</li>
</ul>
<h2 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h2><p>当需要把容器当做一个命令行工具使用时, 推荐通过 ENTRYPOINT 指令设置镜像的入口程序</p>
<ul>
<li>当启动主程序之前还需要执行大量的前置操作时, 可以将 ENTRYPOINT 的入口指令设置为一个脚本 <code>entrypoint.sh</code></li>
</ul>
<p>例如 postgres 的官方用法:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"docker-entrypoint.sh"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"postgres"</span>]</span></span><br></pre></td></tr></table></figure>
<p>docker-entrypoint.sh ⬇️</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># usage: file_env VAR [DEFAULT]</span></span><br><span class="line"><span class="comment">#    ie: file_env 'XYZ_DB_PASSWORD' 'example'</span></span><br><span class="line"><span class="comment"># (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of</span></span><br><span class="line"><span class="comment">#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)</span></span><br><span class="line"><span class="function"><span class="title">file_env</span></span>() &#123;</span><br><span class="line">	<span class="built_in">local</span> var=<span class="string">"<span class="variable">$1</span>"</span></span><br><span class="line">	<span class="built_in">local</span> fileVar=<span class="string">"<span class="variable">$&#123;var&#125;</span>_FILE"</span></span><br><span class="line">	<span class="built_in">local</span> def=<span class="string">"<span class="variable">$&#123;2:-&#125;</span>"</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;!var:-&#125;</span>"</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$&#123;!fileVar:-&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		<span class="built_in">echo</span> &gt;&amp;2 <span class="string">"error: both <span class="variable">$var</span> and <span class="variable">$fileVar</span> are set (but are exclusive)"</span></span><br><span class="line">		<span class="built_in">exit</span> 1</span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="built_in">local</span> val=<span class="string">"<span class="variable">$def</span>"</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;!var:-&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		val=<span class="string">"<span class="variable">$&#123;!var&#125;</span>"</span></span><br><span class="line">	<span class="keyword">elif</span> [ <span class="string">"<span class="variable">$&#123;!fileVar:-&#125;</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		val=<span class="string">"<span class="variable">$(&lt; "$&#123;!fileVar&#125;")</span>"</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line">	<span class="built_in">export</span> <span class="string">"<span class="variable">$var</span>"</span>=<span class="string">"<span class="variable">$val</span>"</span></span><br><span class="line">	<span class="built_in">unset</span> <span class="string">"<span class="variable">$fileVar</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$&#123;1:0:1&#125;</span>"</span> = <span class="string">'-'</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">set</span> -- postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># allow the container to be started with `--user`</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ] &amp;&amp; [ <span class="string">"<span class="variable">$(id -u)</span>"</span> = <span class="string">'0'</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir -p <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line">	chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line">	chmod 700 <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">	mkdir -p /var/run/postgresql</span><br><span class="line">	chown -R postgres /var/run/postgresql</span><br><span class="line">	chmod g+s /var/run/postgresql</span><br><span class="line"></span><br><span class="line">	<span class="comment"># Create the transaction log directory before initdb is run (below) so the directory is owned by the correct user</span></span><br><span class="line">	<span class="keyword">if</span> [ <span class="string">"<span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">		mkdir -p <span class="string">"<span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span></span><br><span class="line">		chown -R postgres <span class="string">"<span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span></span><br><span class="line">		chmod 700 <span class="string">"<span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span></span><br><span class="line">	<span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$BASH_SOURCE</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">	mkdir -p <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line">	chown -R <span class="string">"<span class="variable">$(id -u)</span>"</span> <span class="string">"<span class="variable">$PGDATA</span>"</span> 2&gt;/dev/null || :</span><br><span class="line">	chmod 700 <span class="string">"<span class="variable">$PGDATA</span>"</span> 2&gt;/dev/null || :</span><br><span class="line"></span><br><span class="line">	<span class="comment"># look specifically for PG_VERSION, as it is expected in the DB dir</span></span><br><span class="line">	<span class="keyword">if</span> [ ! -s <span class="string">"<span class="variable">$PGDATA</span>/PG_VERSION"</span> ]; <span class="keyword">then</span></span><br><span class="line">		file_env <span class="string">'POSTGRES_INITDB_ARGS'</span></span><br><span class="line">		<span class="keyword">if</span> [ <span class="string">"<span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">			<span class="built_in">export</span> POSTGRES_INITDB_ARGS=<span class="string">"<span class="variable">$POSTGRES_INITDB_ARGS</span> --xlogdir <span class="variable">$POSTGRES_INITDB_XLOGDIR</span>"</span></span><br><span class="line">		<span class="keyword">fi</span></span><br><span class="line">		<span class="built_in">eval</span> <span class="string">"initdb --username=postgres <span class="variable">$POSTGRES_INITDB_ARGS</span>"</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># check password first so we can output the warning before postgres</span></span><br><span class="line">		<span class="comment"># messes it up</span></span><br><span class="line">		file_env <span class="string">'POSTGRES_PASSWORD'</span></span><br><span class="line">		<span class="keyword">if</span> [ <span class="string">"<span class="variable">$POSTGRES_PASSWORD</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">			pass=<span class="string">"PASSWORD '<span class="variable">$POSTGRES_PASSWORD</span>'"</span></span><br><span class="line">			authMethod=md5</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="comment"># The - option suppresses leading tabs but *not* spaces. :)</span></span><br><span class="line">			cat &gt;&amp;2 &lt;&lt;-<span class="string">'EOWARN'</span></span><br><span class="line">				****************************************************</span><br><span class="line">				WARNING: No password has been <span class="built_in">set</span> <span class="keyword">for</span> the database.</span><br><span class="line">				         This will allow anyone with access to the</span><br><span class="line">				         Postgres port to access your database. In</span><br><span class="line">				         Docker<span class="string">'s default configuration, this is</span></span><br><span class="line"><span class="string">				         effectively any other container on the same</span></span><br><span class="line"><span class="string">				         system.</span></span><br><span class="line"><span class="string">				         Use "-e POSTGRES_PASSWORD=password" to set</span></span><br><span class="line"><span class="string">				         it in "docker run".</span></span><br><span class="line"><span class="string">				****************************************************</span></span><br><span class="line"><span class="string">			EOWARN</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">			pass=</span></span><br><span class="line"><span class="string">			authMethod=trust</span></span><br><span class="line"><span class="string">		fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		&#123;</span></span><br><span class="line"><span class="string">			echo</span></span><br><span class="line"><span class="string">			echo "host all all all $authMethod"</span></span><br><span class="line"><span class="string">		&#125; &gt;&gt; "$PGDATA/pg_hba.conf"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		# internal start of server in order to allow set-up using psql-client		</span></span><br><span class="line"><span class="string">		# does not listen on external TCP/IP and waits until start finishes</span></span><br><span class="line"><span class="string">		PGUSER="$&#123;PGUSER:-postgres&#125;" \</span></span><br><span class="line"><span class="string">		pg_ctl -D "$PGDATA" \</span></span><br><span class="line"><span class="string">			-o "-c listen_addresses='</span>localhost<span class="string">'" \</span></span><br><span class="line"><span class="string">			-w start</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		file_env '</span>POSTGRES_USER<span class="string">' '</span>postgres<span class="string">'</span></span><br><span class="line"><span class="string">		file_env '</span>POSTGRES_DB<span class="string">' "$POSTGRES_USER"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		psql=( psql -v ON_ERROR_STOP=1 )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if [ "$POSTGRES_DB" != '</span>postgres<span class="string">' ]; then</span></span><br><span class="line"><span class="string">			"$&#123;psql[@]&#125;" --username postgres &lt;&lt;-EOSQL</span></span><br><span class="line"><span class="string">				CREATE DATABASE "$POSTGRES_DB" ;</span></span><br><span class="line"><span class="string">			EOSQL</span></span><br><span class="line"><span class="string">			echo</span></span><br><span class="line"><span class="string">		fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		if [ "$POSTGRES_USER" = '</span>postgres<span class="string">' ]; then</span></span><br><span class="line"><span class="string">			op='</span>ALTER<span class="string">'</span></span><br><span class="line"><span class="string">		else</span></span><br><span class="line"><span class="string">			op='</span>CREATE<span class="string">'</span></span><br><span class="line"><span class="string">		fi</span></span><br><span class="line"><span class="string">		"$&#123;psql[@]&#125;" --username postgres &lt;&lt;-EOSQL</span></span><br><span class="line"><span class="string">			$op USER "$POSTGRES_USER" WITH SUPERUSER $pass ;</span></span><br><span class="line"><span class="string">		EOSQL</span></span><br><span class="line"><span class="string">		echo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		psql+=( --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		echo</span></span><br><span class="line"><span class="string">		for f in /docker-entrypoint-initdb.d/*; do</span></span><br><span class="line"><span class="string">			case "$f" in</span></span><br><span class="line"><span class="string">				*.sh)     echo "$0: running $f"; . "$f" ;;</span></span><br><span class="line"><span class="string">				*.sql)    echo "$0: running $f"; "$&#123;psql[@]&#125;" -f "$f"; echo ;;</span></span><br><span class="line"><span class="string">				*.sql.gz) echo "$0: running $f"; gunzip -c "$f" | "$&#123;psql[@]&#125;"; echo ;;</span></span><br><span class="line"><span class="string">				*)        echo "$0: ignoring $f" ;;</span></span><br><span class="line"><span class="string">			esac</span></span><br><span class="line"><span class="string">			echo</span></span><br><span class="line"><span class="string">		done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		PGUSER="$&#123;PGUSER:-postgres&#125;" \</span></span><br><span class="line"><span class="string">		pg_ctl -D "$PGDATA" -m fast -w stop</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">		echo</span></span><br><span class="line"><span class="string">		echo '</span>PostgreSQL init process complete; ready <span class="keyword">for</span> start up.<span class="string">'</span></span><br><span class="line"><span class="string">		echo</span></span><br><span class="line"><span class="string">	fi</span></span><br><span class="line"><span class="string">fi</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exec "$@"</span></span><br></pre></td></tr></table></figure>

<h2 id="CMD-和-ENTRYPOINT的区别"><a href="#CMD-和-ENTRYPOINT的区别" class="headerlink" title="CMD 和 ENTRYPOINT的区别"></a>CMD 和 ENTRYPOINT的区别</h2><ul>
<li>当 dockerfile 中指定了 ENTRYPOINT 的时候, docker run 如果在镜像之后添加的指令, 那么这些指令将被当做 ENTRYPOINT 的参数执行</li>
<li>如果 dockerfile 中同时有 CMD 和 ENTRYPOINT 指令, 当 CMD 指令可执行时, 它将在 ENTRYPOINT 之前运行; 如果 CMD 不是可执行的命令, 则将作为 ENTRYPOINT 的命令参数追加</li>
</ul>
<h1 id="EXPOSE-最佳实践"><a href="#EXPOSE-最佳实践" class="headerlink" title="EXPOSE 最佳实践"></a>EXPOSE 最佳实践</h1><ul>
<li><p>EXPOSE 用来声明未来容器内需要监听的端口, 在 bridge 模式下, 这些容器内部的端口会映射到宿主机的端口上, 建议在容器内部不要更改应用原生的端口号</p>
</li>
<li><p>EXPOSE 中只能指定未来容器内部需要暴露的端口, 不能指定未来容器外部与内部端口之间的映射关系, 比如设置 <code>EXPOSE 8800:80</code> 是没有任何意义的</p>
</li>
</ul>
<h1 id="ENV-最佳实践"><a href="#ENV-最佳实践" class="headerlink" title="ENV 最佳实践"></a>ENV 最佳实践</h1><ul>
<li>通过环境变量来配置服务的相关设置, 通过这种方式可以方便的在不同环境中修改配置, 快速启动服务, 加快开发, 测试, 部署的流程</li>
<li>设置系统环境变量, 比如二进制包安装的 nginx, 在 ENV 设置 PATH</li>
<li>也可以借鉴 LABEL 的使用哲学, 标记一些版本号或版本编码信息</li>
</ul>
<h1 id="ADD-与-COPY-最佳实践"><a href="#ADD-与-COPY-最佳实践" class="headerlink" title="ADD 与 COPY 最佳实践"></a>ADD 与 COPY 最佳实践</h1><p>ADD 与 COPY 都是将外部文件拷贝到镜像内部的指令, 相比之下可能 ADD 的功能更加强大一下, 但是我的建议如下:</p>
<ul>
<li>尽量不要拷贝远程文件, 这样也就用不着 ADD 的功能, 用 COPY 就可以了</li>
<li>如果压缩包拷贝进镜像后, 不希望这个压缩包被自动解压缩, 用 COPY 就对了. 反之如果希望拷贝进镜像之后就自动解压做, 那就用 ADD 拷贝进去</li>
</ul>
<p>如果涉及到远程文件, 建议使用 <code>RUN curl</code> 或 <code>RUN wget</code> 命令替代 ADD</p>
<h1 id="VOLUME-最佳实践"><a href="#VOLUME-最佳实践" class="headerlink" title="VOLUME 最佳实践"></a>VOLUME 最佳实践</h1><p>VOLUME 的作用是持久化容器内的文件, 声明某个目录需要在宿主机挂载后, 当 docker run 起镜像时, docker 会在宿主机默认目录下随机生成一个文件夹挂载到容器内部的指定文件夹.</p>
<p>当该容器被删除时, 宿主机上的这个文件夹并不会被删除. 当删除容器时加入了<code>-v</code> 参数, 那么对应的数据卷就会被删除</p>
<h1 id="USER-最佳实践"><a href="#USER-最佳实践" class="headerlink" title="USER 最佳实践"></a>USER 最佳实践</h1><p>如果容器中的应用程序运行时不需要特殊的权限, 可以通过 USER 指令把应用程序的所有者设置为非 root 用户. 如果该用户不存在, 首先需要使用 RUN 命令在镜像中创建用户.</p>
<ul>
<li>如果在每次编译镜像时, 对用户的 UID/GID 有要求需要保持一致, 应该在新建用户和组的时候指定 UID和 GID</li>
<li>在镜像中避免使用sudo 命令. 应为该命令使用的 TTY 不确定, 对接收信号量也会造成影响. 如果确实需要使用 sudo 功能, 则可是使用 gosu 命令替代</li>
<li>可以用 root 用户初始化一个 daemon, 然后用非 root 用户启动这个 daemon</li>
<li>为了减少镜像体积, 应该避免不必要的用户切换</li>
</ul>
<h1 id="WORKDIR-最佳实践"><a href="#WORKDIR-最佳实践" class="headerlink" title="WORKDIR 最佳实践"></a>WORKDIR 最佳实践</h1><ul>
<li>尽量使用绝对路径</li>
<li>切换目录的时候尽量使用 WORKDIR, 而不是使用 <code>RUN cd /dir</code></li>
</ul>
<h1 id="gosu-工具"><a href="#gosu-工具" class="headerlink" title="gosu 工具"></a>gosu 工具</h1><p>gosu 是一个 golang 语言开发的工具, 用来取代 shell 中的 sudo 命令. su 和 sudo 命令有一些缺陷, 主要是会引起不确定的 TTY, 对信号量的转发也存在问题. 如果仅仅为了使用特定的用户运行程序, 使用 su 或 sudo 显得太重了, 为此 gosu 应运而生.</p>
<p>gosu 直接借用了 libcontainer 在容器中启动应用程序的原理, 使用 <code>/etc/passwd</code> 处理应用程序. gosu 首先找出指定的用户或用户组, 然后切换到该用户或用户组. 接下来, 使用 exec 启动应用程序. 到此为止, gosu 完成了它的工作, 不会参与到应用程序后面的声明周期中. 使用这种方式避免了 gosu 处理 TTY 和转发信号量的问题, 把这两个工作直接交给了应用程序去完成</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>dockerfile详解</title>
    <url>/2017/04/21/dockerfile%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Dockerfile是由一系列命令和参数构成的脚本，一个Dockerfile里面包含了构建整个image的完整命令。Docker通过docker build执行Dockerfile中的一系列命令自动构建image</p>
</blockquote>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p><code>dockerfile</code> 使用 <code>docker build</code> 命令来生成 <code>image</code> 镜像, <code>docker build</code>的语法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:	docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<ul>
<li>PATH 是本地文件路径</li>
<li>URL 是 git repository 的路径</li>
</ul>
<p>构建镜像时, docker 将会递归地读取路径下的所有文件. 因此, PATH包括任何子目录，URL包括repository及submodules</p>
<p><strong>官方推荐: 在构建镜像的时候, 最好使用干净的目录进行构建, 减少不必要的索引性能损耗, 提高构建效率</strong></p>
<p>如果在特殊环境的限制下, 一定要在有众多干扰文件的目录下构建镜像, 可以使用 <code>.dockerignore</code> 文件来屏蔽索引这些文件</p>
<p>你可以使用如下方式进行构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的执行方式</span></span><br><span class="line">$ docker build .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果文件名不是dockerfile, 那么需要显示的精确指定文件</span></span><br><span class="line">$ docker build -f /path/to/a/Dockerfile .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顺便打个标签🏷</span></span><br><span class="line">$ docker build -t shykes/myapp .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打多个标签</span></span><br><span class="line">$ docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</span><br></pre></td></tr></table></figure>

<p>只要有可能，Docker将重新使用中间images（缓存），以显着加速docker build过程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4 : CMD env | grep _TCP= | (sed <span class="string">'s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/'</span> &amp;&amp; <span class="built_in">echo</span> <span class="built_in">wait</span>) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br></pre></td></tr></table></figure>

<p>构建成功后，就可以准备Pushing a repository to its registry</p>
<h1 id="Format-语法格式"><a href="#Format-语法格式" class="headerlink" title="Format 语法格式"></a>Format 语法格式</h1><p>Dockerfile的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span><br><span class="line">INSTRUCTION arguments</span><br></pre></td></tr></table></figure>

<ul>
<li>Line1 第一行是解析器指令</li>
<li>INSTRUCTION 是不区分大小写的，不过建议大写. 这里写 dockerfile 中支持的指令集</li>
<li>arguments 这里写对应的命令</li>
<li>dockerfile 中的第一个指令必须是<code>FORM</code> 指定构建镜像的Base Image, 这个 Base Image 基础镜像可以是一个系统的镜像比如<code>CentOS</code> <code>Ubuntu</code>等, 也可以是一个应用镜像, 用来做二次定制, 比如 <code>nginx</code> <code>httpd</code> <code>mysql</code> 等</li>
<li>dockerfile中以<code>#</code>开头的行都将视为注释，除非是 Parser directives 解析器指令, 而且 dockerfile 中不支持连续注释</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Comment</span><br><span class="line">RUN echo &#39;we are running some # of cool things&#39;</span><br></pre></td></tr></table></figure>

<h1 id="ParserDirectives-解析器指令"><a href="#ParserDirectives-解析器指令" class="headerlink" title="ParserDirectives 解析器指令"></a>ParserDirectives 解析器指令</h1><p>解析器指令是可选的,  并且影响处理 dockerfile 中后续的执行方式. 解析器的指令不会向构建中添加图层, 并且不会显示在构建的步骤当中. 解析器的指令是以 <code># directive = value</code> 的形式写成一种特殊类型的注释, 且单个指令只能使用一次.(到目前为止 2017/04/19 dockerfile 只支持一种解析器指令)<br>当 docker 遇到普通注释行或空行或是已经被执行过的解析器指令, docker 都不会再寻找任何解析器的指令. 因此, 所有的解析器指令都必须位于 dockerfile 的最顶端</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96;</span><br><span class="line"></span><br><span class="line">FROM windowsservercore</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>目前解析器指令只支持:</p>
<ul>
<li>escape</li>
</ul>
<h1 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h1><p>escape 作为 dockerfile 解析器目前为止唯一支持的指令, 目前有以下两种用法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;\ (backslash)</span><br><span class="line">或者</span><br><span class="line"># escape&#x3D;&#96; (backtick)</span><br></pre></td></tr></table></figure>

<p>escape 的作用是声明 dockerfile 中的转义符, 在不指定的默认情况下,  转义符是反斜杠 <code>\</code> 但是如果是在 Windows 中, 反斜杠是正常的路径分隔符, 不属于转义的范畴, 这种情况下就需要使用两个反斜杠 <code>\\</code> 来表示一个路径中的反斜杠 <code>\</code></p>
<p>转义字符既用于转义行中的字符，也用于转义换行符. 这允许Dockerfile指令跨越多行. <strong>注意，不管escape解析器指令是否包括在Dockerfile中，在RUN命令中不执行转义，除非在行的末尾, 用来转义换行符</strong></p>
<p>请考虑以下示例，这将在Windows上以非显而易见的方式失败。第二行末尾的第二个\将被解释为换行符，而不是从第一个\转义的目标。类似地，假设第三行结尾处的\实际上作为一条指令处理，它将被视为行继续。这个dockerfile的结果是第二行和第三行被认为是单个指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM windowsservercore</span><br><span class="line">COPY testfile.txt c:\\</span><br><span class="line">RUN dir c:\</span><br><span class="line"></span><br><span class="line"># 结果:</span><br><span class="line">PS C:\John&gt; docker build -t cmd .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1 : FROM windowsservercore</span><br><span class="line"> ---&gt; dbfee88ee9fd</span><br><span class="line">Step 2 : COPY testfile.txt c:RUN dir c:</span><br><span class="line">GetFileAttributesEx c:RUN: The system cannot find the file specified.</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>

<p>上述的一个解决方案是使用<code>/</code>作为<code>COPY</code>指令和<code>dir</code>的目标. 这种语法, 最好的情况是混乱, 因为它在<code>Windows</code>上是不平常的路径, 最坏的情况下, 错误倾向, 因为并不是<code>Windows</code>上的所有命令支持<code>/</code>作为路径分隔符.</p>
<p>通过添加转义解析器指令，下面的Dockerfile在Windows上使用文件路径的自然平台语义成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96;</span><br><span class="line"></span><br><span class="line">FROM windowsservercore</span><br><span class="line">COPY testfile.txt c:\</span><br><span class="line">RUN dir c:\</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">PS C:\John&gt; docker build -t succeeds --no-cache&#x3D;true .</span><br><span class="line">Sending build context to Docker daemon 3.072 kB</span><br><span class="line">Step 1 : FROM windowsservercore</span><br><span class="line"> ---&gt; dbfee88ee9fd</span><br><span class="line">Step 2 : COPY testfile.txt c:\</span><br><span class="line"> ---&gt; 99ceb62e90df</span><br><span class="line">Removing intermediate container 62afbe726221</span><br><span class="line">Step 3 : RUN dir c:\</span><br><span class="line"> ---&gt; Running in a5ff53ad6323</span><br><span class="line"> Volume in drive C has no label.</span><br><span class="line"> Volume Serial Number is 1440-27FA</span><br><span class="line"></span><br><span class="line"> Directory of c:\</span><br><span class="line"></span><br><span class="line">03&#x2F;25&#x2F;2016  05:28 AM    &lt;DIR&gt;          inetpub</span><br><span class="line">03&#x2F;25&#x2F;2016  04:22 AM    &lt;DIR&gt;          PerfLogs</span><br><span class="line">04&#x2F;22&#x2F;2016  10:59 PM    &lt;DIR&gt;          Program Files</span><br><span class="line">03&#x2F;25&#x2F;2016  04:22 AM    &lt;DIR&gt;          Program Files (x86)</span><br><span class="line">04&#x2F;18&#x2F;2016  09:26 AM                 4 testfile.txt</span><br><span class="line">04&#x2F;22&#x2F;2016  10:59 PM    &lt;DIR&gt;          Users</span><br><span class="line">04&#x2F;22&#x2F;2016  10:59 PM    &lt;DIR&gt;          Windows</span><br><span class="line">               1 File(s)              4 bytes</span><br><span class="line">               6 Dir(s)  21,252,689,920 bytes free</span><br><span class="line"> ---&gt; 2569aa19abef</span><br><span class="line">Removing intermediate container a5ff53ad6323</span><br><span class="line">Successfully built 2569aa19abef</span><br><span class="line">PS C:\John&gt;</span><br></pre></td></tr></table></figure>

<h1 id="ENV-环境变量替换"><a href="#ENV-环境变量替换" class="headerlink" title="ENV 环境变量替换"></a>ENV 环境变量替换</h1><p>环境变量使用<code>ENV</code>命令声明, 使用<code>$variable_name</code>或<code>${variable_name}</code>来调用, 带大括号的语法是被用来解决不带空格的变量名字问题, 例如:<code>${foo}_bar</code></p>
<p><code>${variable_name}</code>语法还支持以下指定的一些标准bash修饰符：</p>
<ul>
<li><code>${variable:-word}</code>表示如果设置了<code>variable</code>, 则结果将是该值; 如果<code>variable</code>未设置, 那么word将是结果</li>
<li><code>${variable:+word}</code>表示如果设置了<code>variable</code>, 那么<code>word</code>将是结果, 否则结果是空字符串</li>
</ul>
<p>在所有情况下, <code>word</code>可以是任何字符串, 包括额外的环境变量</p>
<p>可以通过在变量之前添加<code>\</code>来转义: <code>\$foo</code>或<code>\${foo}</code>, 分别转换为<code>$foo</code>和<code>${foo}</code></p>
<p>示例（解析的表示显示在#后面）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ENV foo &#x2F;bar</span><br><span class="line">WORKDIR $&#123;foo&#125;   # WORKDIR &#x2F;bar</span><br><span class="line">ADD . $foo       # ADD . &#x2F;bar</span><br><span class="line">COPY \$foo &#x2F;quux # COPY $foo &#x2F;quux</span><br></pre></td></tr></table></figure>

<p>Dockerfile中的以下指令列表支持环境变量：</p>
<ul>
<li>ADD</li>
<li>COPY</li>
<li>ENV</li>
<li>EXPOSE</li>
<li>LABEL</li>
<li>USER</li>
<li>WORKDIR</li>
<li>VOLUME</li>
<li>STOPSIGNAL</li>
</ul>
<p>以及：</p>
<ul>
<li>ONBUILD（当与上面支持的指令之一组合时）</li>
</ul>
<p><strong>注意: 在1.4之前, ONBUILD指令不支持环境变量, 即使与上面列出的任何指令相结合</strong></p>
<p>在<code>ENV</code>的使用中, 要特别注意以下情况:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENV abc&#x3D;hello</span><br><span class="line">ENV abc&#x3D;bye def&#x3D;$abc</span><br><span class="line">ENV ghi&#x3D;$abc</span><br></pre></td></tr></table></figure>

<p>最终的结果为:</p>
<ul>
<li>def 的值为 hello</li>
<li>ghi 的值为 bye</li>
</ul>
<p>为什么<code>def</code>的值不是<code>bye</code>呢? 因为第一行设置<code>abc</code>变量的值为<code>hello</code>后, 到第二行执行的时候, 首先进行变量的渲染(替换), 然后再执行环境变量的设置</p>
<h1 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h1><p>docker执行构建后, 会首先去根目录中查找<code>.dockerignore</code>文件, 由于在构建的时候, docker 会递归索引当前目录下的所有文件, 为了避免索引不必要的目录, 可以使用<code>.dockerignore</code>文件声明不需要索引的目录</p>
<ul>
<li><code>#</code> 注释</li>
<li><code>*</code> 任意多个字符</li>
<li><code>?</code> 任意一个字符</li>
<li><code>!</code> 异常模式, 用于排除例外</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># comment</span><br><span class="line">    *&#x2F;temp*</span><br><span class="line">    *&#x2F;*&#x2F;temp*</span><br><span class="line">    temp?</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*.md</span><br><span class="line">!README.md</span><br></pre></td></tr></table></figure>

<h1 id="FORM"><a href="#FORM" class="headerlink" title="FORM"></a>FORM</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line"># 或则</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"># 或则</span><br><span class="line">FROM &lt;image&gt;@&lt;digest&gt;</span><br></pre></td></tr></table></figure>

<p><code>FROM</code>指令为后续指令设置Base Image. 因此, 有效的Dockerfile必须具有<code>FROM</code>作为其第一条指令. image可以是任何有效的image, 可以从镜像仓库中拉取镜像.</p>
<ul>
<li>FROM必须是Dockerfile中的第一个非注释指令</li>
<li>FROM可以在单个Dockerfile中多次出现，以创建多个镜像。每个新的FROM命令之前会输出最一个image ID</li>
<li>tag或digest是可选的. 如果省略其中任何一个, 构建器将默认使用latest. 如果构建器与tag值不匹配, 则构建器将返回错误</li>
</ul>
<h1 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h1><p>RUN 指令有两种运行方式:</p>
<ul>
<li>RUN <command> (shell form, the command is run in a shell, which by default is /bin/sh -c on Linux or cmd /S /C on Windows)</li>
<li>RUN [“executable”, “param1”, “param2”] (exec form)</li>
</ul>
<p><code>RUN</code>指令将在当前image之上的新层中执行任何命令, 并提交结果. 生成的已提交image将用于Dockerfile中的下一步</p>
<p>exec形式使得可以避免shell字符串变化, 以及使用不包含指定的shell可执行文件的基本image来运行RUN命令</p>
<p>在shell形式中，可以使用\（反斜杠）将单个RUN指令继续到下一行, 这也是大部分 dockerfile 使用的形式</p>
<p>在<code>RUN</code>命令的使用中, 需要注意一下几点:</p>
<ul>
<li>要使用不同的shell，而不是’/bin/sh’，请使用在所需shell中传递的exec形式。例如，RUN [“/bin/bash”,“-c”,“echo hello”]</li>
<li>exec形式作为JSON数组解析，这意味着你必须在单词之外必须要使用双引号<code>&quot;</code> 而不是单引号<code>&#39;</code></li>
<li>与 shell 执行的方式不同, exec 执行方式不调用命令 shell. 这意味着正常的 shell 处理不会发生. 例如, <code>RUN [&quot;echo&quot;,&quot;$HOME&quot;]</code>不会在<code>$HOME</code>上进行可变替换. 如果你想要shell处理，那么使用shell形式或直接执行一个shell，例如, <code>RUN [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $HOME&quot;]</code> </li>
<li>在JSON形式中, 有必要转义反斜杠. 这在Windows上特别相关, 其中反斜杠是路径分隔符. 因为不是有效的JSON, 并且以意外的方式失败, 以下行将被视为shell形式: <code>RUN [&quot;c:\windows\system32\tasklist.exe&quot;]</code> 此示例的正确语法为: <code>RUN [&quot;c:\\windows\\system32\\tasklist.exe&quot;]</code></li>
</ul>
<p>用于<code>RUN</code>指令的高速缓存在下一次构建期间不会自动失效. 用于诸如<code>RUN apt-get dist-upgrade</code>之类的指令的高速缓存将在下一次构建期间被重用. 可以通过使用<code>--no-cache</code>标志来使用于<code>RUN</code>指令的高速缓存无效, 例如 <code>docker build --no-cache</code></p>
<p><strong>Known issues（RUN</strong></p>
<p>Issue 783是关于在使用AUFS文件系统时可能发生的文件权限问题。例如，您可能会在尝试rm文件时注意到它。对于具有最近aufs版本的系统（即，可以设置dirperm1安装选项），docker将尝试通过使用dirperm1选项安装image来自动解决问题。</p>
<h1 id="MAINTAINER-作者信息-已废弃"><a href="#MAINTAINER-作者信息-已废弃" class="headerlink" title="MAINTAINER 作者信息(已废弃)"></a>MAINTAINER 作者信息(已废弃)</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAINTAINER &lt;name&gt;</span><br></pre></td></tr></table></figure>

<p>MAINTAINER指令允许您设置生成的images的作者字段</p>
<p>在新的 docker 版本中, 该指令将被<code>LABEL</code>替代</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LABEL maintainer &quot;SvenDowideit@home.org.au&quot;</span><br></pre></td></tr></table></figure>

<h1 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h1><p>CMD指令三种形式：</p>
<ul>
<li>CMD [“executable”,”param1”,”param2”] (exec格式, 首选形式)</li>
<li>CMD [“param1”,”param2”] (作为 ENTRYPOINT 指令的默认参数)</li>
<li>CMD command param1 param2 (shell 格式)</li>
</ul>
<p>在Dockerfile中只能有一个<code>CMD</code>指令. 如果列出了多个<code>CMD</code>, 则只有最后一个<code>CMD</code>生效</p>
<p><code>CMD</code>的主要目的是为执行容器提供默认值. 这些默认值可以包括可执行文件, 或者它们可以省略可执行文件, 在这种情况下, 你还必须指定<code>ENTRYPOINT</code>指令</p>
<p>当以shell或exec格式使用时，<code>CMD</code>指令设置运行image时要执行的命令</p>
<p>如果使用CMD的shell形式，那么<command>将在/bin/sh -c中执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD echo &quot;This is a test.&quot; | wc -</span><br></pre></td></tr></table></figure>

<p>如果你想运行你的<command>没有shell，那么你必须将该命令表示为一个JSON数组，并给出可执行文件的完整路径。此数组形式是CMD的首选格式。任何其他参数必须单独表示为数组中的字符串(注意使用双引号)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">CMD [&quot;&#x2F;usr&#x2F;bin&#x2F;wc&quot;,&quot;--help&quot;]</span><br></pre></td></tr></table></figure>

<p>如果你希望你的容器每次运行相同的可执行文件，那么你应该考虑使用ENTRYPOINT结合CMD</p>
<p>如果用户指定docker run参数，那么它们将覆盖CMD中指定的默认值</p>
<p><strong>注意:</strong></p>
<ul>
<li>不要将RUN和CMD混淆. RUN实际上运行一个命令并提交结果;CMD在构建时不执行任何操作, 但指定了image的预期命令</li>
<li>如果使用CMD为ENTRYPOINT指令提供默认参数, CMD和ENTRYPOINT指令都应以JSON数组格式指定</li>
<li>exec形式作为JSON数组解析, 这意味着您必须在单词之外使用双引号<code>&quot;</code>而不是单引号<code>&#39;</code></li>
<li>与shell表单不同, exec表单不调用命令shell. 这意味着正常的shell处理不会发生. 例如, <code>CMD [&quot;echo&quot;，&quot;$HOME&quot;]</code> 不会在<code>$HOME</code>上进行可变替换. 如果你想要shell处理, 那么使用shell形式或直接执行一个shell, 例如: <code>CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $HOME&quot;]</code></li>
</ul>
<h1 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt;</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt;</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> &lt;key&gt;=&lt;value&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>LABEL</code> 指令向image添加元数据. LABEL是键值对. 要在LABEL值中包含空格, 需要使用引号和反斜杠, 就像在命令行解析中一样</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> <span class="string">"com.example.vendor"</span>=<span class="string">"ACME Incorporated"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> com.example.label-with-value=<span class="string">"foo"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">"1.0"</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">"This text illustrates \</span></span></span><br><span class="line"><span class="bash">that label-values can span multiple lines.<span class="string">"</span></span></span><br></pre></td></tr></table></figure>

<p>一个<code>image</code>可以有多个<code>label</code>. 要指定多个<code>label</code>, Docker建议在可能的情况下将标签合并到单个<code>LABEL</code>指令中. 每个<code>LABEL</code>指令产生一个新层, 如果使用许多标签, 可能会导致镜像的效率低下. 该示例产生单个镜像层</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> multi.label2=<span class="string">"value2"</span> other=<span class="string">"value3"</span></span></span><br></pre></td></tr></table></figure>

<p>上面的也可写为：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="bash"> multi.label1=<span class="string">"value1"</span> \</span></span><br><span class="line"><span class="bash">      multi.label2=<span class="string">"value2"</span> \</span></span><br><span class="line"><span class="bash">      other=<span class="string">"value3"</span></span></span><br></pre></td></tr></table></figure>

<p><strong>如果Docker遇到已经存在的label/key，则新值将覆盖具有相同键的任何先前标签</strong></p>
<h1 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;...]</span><br></pre></td></tr></table></figure>

<p><code>EXPOSE</code>指令通知Docker容器在运行时监听指定的网络端口. <code>EXPOSE</code>不使主机的容器的端口可访问, 为此, 必须使用<code>-p</code>标志发布一系列端口, 或者使用<code>-P</code>标志发布所有暴露的端口。可以公开一个端口号，并用另一个端口号在外部发布</p>
<p>这里指定的所有端口都是容器内部声明容器运行后要监听的端口, 不能在这里定义宿主机与容器之间端口的对应关系! 比如一个 nginx 的镜像, 内部监听80端口, 在容器运行之后, 你想映射到8080端口, 此时在 dockerfile 中写 8080:80 是没有任何意义的, 镜像(dockerfile)里的声明的端口与容器运行指定的端口是分开的, 不能在 dockerfile 中指定未来容器运行时映射的端口</p>
<h1 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ... (首选形式)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一种形式只能设置一个环境变量</li>
<li>第二种形式可以在一个高速缓存层中设置多个变量, 即使是一个变量要设置也推荐使用这种模式来设置</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> myName=<span class="string">"John Doe"</span> myDog=Rex\ The\ Dog \</span><br><span class="line">    myCat=fluffy</span><br><span class="line"><span class="comment"># 和</span></span><br><span class="line"><span class="keyword">ENV</span> myName John Doe</span><br><span class="line"><span class="keyword">ENV</span> myDog Rex The Dog</span><br><span class="line"><span class="keyword">ENV</span> myCat fluffy</span><br></pre></td></tr></table></figure>

<p>将在最终容器中产生相同的结果，但第一种形式是优选的，因为它产生单个高速缓存层</p>
<h1 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h1><p>两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>] (对于包含空格的路径，此形式是必需的)</span></span><br></pre></td></tr></table></figure>

<p><code>ADD</code> 指令从<src>复制新文件, 目录或远程文件<code>URL</code>, 并将它们添加到容器的文件系统, 路径<dest></p>
<p>可以指定多个<src>资源, 但如果它们是文件或目录, 那么它们必须是相对于正在构建的源目录</p>
<p>每个<src>可能包含通配符, 匹配将使用Go的filepath.Match规则完成. 例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> hom* /mydir/        <span class="comment"># adds all files starting with "hom"</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hom?.txt /mydir/    <span class="comment"># ? is replaced with any single character, e.g., "home.txt"</span></span></span><br></pre></td></tr></table></figure>

<p><dest>是绝对路径或相对于<code>WORKDIR</code>的路径, 源将在目标容器中复制到其中</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> relativeDir/          <span class="comment"># adds "test" to `WORKDIR`/relativeDir/</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> <span class="built_in">test</span> /absoluteDir/         <span class="comment"># adds "test" to /absoluteDir/</span></span></span><br></pre></td></tr></table></figure>

<p>所有新文件和目录都使用UID和GID为0创建</p>
<p><strong>ADD遵守以下规则：</strong></p>
<ul>
<li><p><src>路径必须在构建的上下文中, 不能<code>ADD ../something /something</code> 因为docker构建的第一步是发送上下文目录（和子目录）到docker守护进程. </p>
</li>
<li><p>如果<src>是URL并且<dest>不以尾部斜杠结尾，则从URL下载文件并将其复制到<dest></p>
</li>
<li><p>如果<src>是URL并且<dest>以尾部斜杠结尾，则从URL中推断文件名，并将文件下载到<dest>/<filename> 例如, <code>ADD http://example.com/foobar /</code>会创建文件<code>/foobar</code> 网址必须有一个非普通的路径, 以便在这种情况下可以发现一个适当的文件名<code>http://example.com不会工作</code></p>
</li>
<li><p>如果<src>是目录, 则复制目录的整个内容, 包括文件系统元数据<br><strong>注意：目录本身不被复制，只是其内容</strong></p>
</li>
<li><p>如果<src>是识别的压缩格式（identity，gzip，bzip2或xz）的本地tar存档，则将其解包为目录. 来自远程URL的资源不会解压缩. 当目录被复制或解压缩时, 它具有与tar -x相同的行为<br><strong>注意：文件是否被识别为识别的压缩格式, 仅基于文件的内容, 而不是文件的名称. 例如, 如果一个空文件以<code>.tar.gz</code>结尾, 则不会被识别为压缩文件, 并且不会生成任何解压缩错误消息, 而是将该文件简单地复制到目的地</strong></p>
</li>
<li><p>如果<src>是任何其他类型的文件, 它会与其元数据一起单独复制. 在这种情况下, 如果<dest>以尾部斜杠<code>/</code>结尾，它将被认为是一个目录, 并且<src>的内容将被写在<dest>/base(<src>)</p>
</li>
<li><p>如果直接或由于使用通配符指定了多个<src>资源, 则<dest>必须是目录, 并且必须以斜杠<code>/</code>结尾</p>
</li>
<li><p>如果<dest>不以尾部斜杠结尾，它将被视为常规文件，<src>的内容将写在<dest></p>
</li>
<li><p>如果<dest>不存在, 则会与其路径中的所有缺少的目录一起创建</p>
</li>
</ul>
<h1 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h1><p>两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="bash"> &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">"&lt;src&gt;"</span>,... <span class="string">"&lt;dest&gt;"</span>] (this form is required <span class="keyword">for</span> paths containing whitespace)</span></span><br></pre></td></tr></table></figure>

<p>基本和ADD类似，不过COPY的<src>不能为URL</p>
<p>与 ADD 不同的一点是, 遇到压缩文件, COPY 不会去检测文件的压缩属性, 不会做任何的解压缩操作, 会直接把源文件原封不动的拷贝到目标地址</p>
<h1 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h1><p>两种形式：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [“executable”, “param1”, “param2”] （<span class="built_in">exec</span> 形式, 首选）</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">command</span> param1 param2 (shell 形式)</span></span><br></pre></td></tr></table></figure>

<p><code>ENTRYPOINT</code>允许您配置容器, 运行执行的可执行文件</p>
<p>例如, 以下将使用其默认内容启动nginx, 监听端口80：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -i -t --rm -p 80:80 nginx</span><br></pre></td></tr></table></figure>

<p><code>docker run &lt;image&gt;</code>的命令行参数将附跟在 exec 形式的<code>ENTRYPOINT</code>中的所有元素之后, 并将覆盖使用<code>CMD</code>指定的所有元素. 这允许将参数传递到入口点, 即<code>docker run &lt;image&gt; -d</code>将把<code>-d</code>参数传递给入口点. 您可以使用<code>docker run --entrypoint</code>标志覆盖<code>ENTRYPOINT</code>指令</p>
<p>shell 形式防止使用任何<code>CMD</code>或运行命令行参数, 但是缺点是<code>ENTRYPOINT</code>将作<code>/bin/sh -c</code>的子命令启动, 它不传递信号. 这意味着可执行文件将不是容器的<code>PID 1</code>, 并且不会接收<code>Unix</code>信号, 因此你的可执行文件将不会从<code>docker stop &lt;container&gt;</code>接收到<code>SIGTERM</code></p>
<p>只有Dockerfile中最后一个<code>ENTRYPOINT</code>指令会有效果</p>
<h2 id="Exec-form-ENTRYPOINT-example"><a href="#Exec-form-ENTRYPOINT-example" class="headerlink" title="Exec form ENTRYPOINT example"></a>Exec form ENTRYPOINT example</h2><p>可以使用ENTRYPOINT的<code>exec</code>形式设置相当稳定的默认命令和参数, 然后使用任一形式的<code>CMD</code>设置更可能更改的其他默认值</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"top"</span>, <span class="string">"-b"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"-c"</span>]</span></span><br></pre></td></tr></table></figure>

<p>以下Dockerfile显示使用ENTRYPOINT在前台运行Apache, 作为PID 1</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> debian:stable</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y --force-yes apache2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span> <span class="number">443</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/var/www"</span>, <span class="string">"/var/log/apache2"</span>, <span class="string">"/etc/apache2"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/usr/sbin/apache2ctl"</span>, <span class="string">"-D"</span>, <span class="string">"FOREGROUND"</span>]</span></span><br></pre></td></tr></table></figure>

<p>如果需要为单个可执行文件编写启动脚本，可以使用exec和gosu命令确保最终可执行文件接收到Unix信号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$1</span>"</span> = <span class="string">'postgres'</span> ]; <span class="keyword">then</span></span><br><span class="line">    chown -R postgres <span class="string">"<span class="variable">$PGDATA</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$(ls -A "$PGDATA")</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">        gosu postgres initdb</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">exec</span> gosu postgres <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exec</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>set -e : 在脚本的执行中任何一行出现执行失败都立即退出脚本</li>
<li>set -eo pipefail : 在管道的使用中, 任意一个环节出现问题都立即退出</li>
<li>set – postgres “$@” : 将后面的每一个值依次放入 $1 $2 $3 …</li>
<li>$@ : 传给脚本的所有参数的列表</li>
</ul>
<p>上面脚本的意思是, 首先判断第一个参数是不是预期中的可执行命令, 如果第一个参数是预期中的可执行命令, 那么后面参数默认均为第一个(参数)命令的参数; 如果第一个参数不是预期中的可行性命令, 那么就认为这是一个全新的命令要执行, 所以使用<code>exec $@</code>完整地执行命令</p>
<p>如果需要在关闭时进行一些额外的清理（或与其他容器通信）或者协调多个可执行文件, 需要确保<code>ENTRYPOINT</code>脚本接收到Unix信号, 传递它们, 然后做一些更多的善后工作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment"># Note: I've written this using sh so it works in the busybox container too</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># USE the trap if you need to also do manual cleanup after the service is stopped,</span></span><br><span class="line"><span class="comment">#     or need to start multiple services in the one container</span></span><br><span class="line"><span class="built_in">trap</span> <span class="string">"echo TRAPed signal"</span> HUP INT QUIT TERM</span><br><span class="line"></span><br><span class="line"><span class="comment"># start service in background here</span></span><br><span class="line">/usr/sbin/apachectl start</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"[hit enter key to exit] or run 'docker stop &lt;container&gt;'"</span></span><br><span class="line"><span class="built_in">read</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># stop service and clean up here</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"stopping apache"</span></span><br><span class="line">/usr/sbin/apachectl stop</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"exited <span class="variable">$0</span>"</span></span><br></pre></td></tr></table></figure>

<h2 id="Shell-form-ENTRYPOINT-example"><a href="#Shell-form-ENTRYPOINT-example" class="headerlink" title="Shell form ENTRYPOINT example"></a>Shell form ENTRYPOINT example</h2><p>你可以为<code>ENTRYPOINT</code>指定一个纯字符串，它将在<code>/bin/sh -c</code>中执行。这种形式将使用shell处理来替换shell环境变量，并且将忽略任何<code>CMD</code>或<code>docker run</code>命令行参数。要确保<code>docker stop</code>将正确地控制<code>ENTRYPOINT</code>可执行文件，必须用<code>exec</code>启动它：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">exec</span> top -b</span></span><br></pre></td></tr></table></figure>

<p>运行此image时，您将看到单个<code>PID 1</code>进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --rm --name <span class="built_in">test</span> top</span><br><span class="line">Mem: 1704520K used, 352148K free, 0K shrd, 0K buff, 140368121167873K cached</span><br><span class="line">CPU:   5% usr   0% sys   0% nic  94% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.08 0.03 0.05 2/98 6</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>

<p>使用<code>docker stop</code>可以干净的退出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real    0m 0.20s</span><br><span class="line">user    0m 0.02s</span><br><span class="line">sys 0m 0.04s</span><br></pre></td></tr></table></figure>

<p>如果忘记将<code>exec</code>添加到您的<code>ENTRYPOINT</code>的开头：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> top -b</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> --ignored-param1</span></span><br></pre></td></tr></table></figure>

<p>然后，你可以运行它（给它一个名称为下一步）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker run -it --name <span class="built_in">test</span> top --ignored-param2</span><br><span class="line">Mem: 1704184K used, 352484K free, 0K shrd, 0K buff, 140621524238337K cached</span><br><span class="line">CPU:   9% usr   2% sys   0% nic  88% idle   0% io   0% irq   0% sirq</span><br><span class="line">Load average: 0.01 0.02 0.05 2/101 7</span><br><span class="line">  PID  PPID USER     STAT   VSZ %VSZ %CPU COMMAND</span><br><span class="line">    1     0 root     S     3168   0%   0% /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7     1 root     R     3164   0%   0% top -b</span><br></pre></td></tr></table></figure>

<p>您可以从top的输出中看到指定的ENTRYPOINT不是PID 1。</p>
<p>如果你运行docker停止测试，容器将不会完全退出, 超时后停止命令将强制发送SIGKILL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it <span class="built_in">test</span> ps aux</span><br><span class="line">PID   USER     COMMAND</span><br><span class="line">    1 root     /bin/sh -c top -b cmd cmd2</span><br><span class="line">    7 root     top -b</span><br><span class="line">    8 root     ps aux</span><br><span class="line">$ /usr/bin/time docker stop <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">real    0m 10.19s</span><br><span class="line">user    0m 0.04s</span><br><span class="line">sys 0m 0.03s</span><br></pre></td></tr></table></figure>

<h2 id="Understand-how-CMD-and-ENTRYPOINT-interact"><a href="#Understand-how-CMD-and-ENTRYPOINT-interact" class="headerlink" title="Understand how CMD and ENTRYPOINT interact"></a>Understand how CMD and ENTRYPOINT interact</h2><p><code>CMD</code>和<code>ENTRYPOINT</code>指令定义在运行容器时执行什么命令, 有如下使用规则</p>
<ul>
<li><code>Dockerfile</code>应该至少指定一个<code>CMD</code>或<code>ENTRYPOINT</code>命令</li>
<li>当使用容器作为可执行文件时，应该定义<code>ENTRYPOINT</code></li>
<li><code>CMD</code>应该用作定义<code>ENTRYPOINT</code>命令的默认参数或在容器中执行ad-hoc命令的一种方法</li>
<li>当运行带有替代参数的容器时，<code>CMD</code>将被覆盖</li>
</ul>
<p>下表显示了对不同<code>ENTRYPOINT</code>/<code>CMD</code>组合执行的命令：</p>
<table>
<thead>
<tr>
<th></th>
<th>no ENTRYPOINT</th>
<th>ENTRYPOINT exec_enty p1_entry</th>
<th>ENTRYPOINT [“exec_entry”,“p1_entry”]</th>
</tr>
</thead>
<tbody><tr>
<td>No CMD</td>
<td>error, not allowed</td>
<td>/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr>
<td>CMD [“exec_cmd”,“p1_cmd”]</td>
<td>exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry exec_cmd p1_cmd</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr>
<td>CMD [“p1_cmd”, “p2_cmd”]</td>
<td>p1_cmd p2_cmd</td>
<td>/bin/sh -c exec_entry p1_entry p1_cmd p2_cmd</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr>
<td>CMD exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_cmd p1_cmd</td>
<td>/bin/sh -c exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
<td>exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
</tr>
</tbody></table>
<h1 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">"/data"</span>]</span></span><br></pre></td></tr></table></figure>

<p><code>VOLUME</code>指令创建具有指定名称的挂载点，并将其标记为从本机主机或其他容器保留外部挂载的卷。该值可以是JSON数组<code>VOLUME [&quot;/var/log/&quot;]</code>或具有多个参数的纯字符串，例如<code>VOLUME /var/log</code>或<code>VOLUME /var/log /var/db</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /myvol</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"hello world"</span> &gt; /myvol/greeting</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> /myvol</span></span><br></pre></td></tr></table></figure>

<h1 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> daemon</span><br></pre></td></tr></table></figure>

<p><code>USER</code>指令设置运行image时使用的用户名或UID, 以及<code>Dockerfile</code>中的任何RUN，<code>CMD</code>和<code>ENTRYPOINT</code>指令</p>
<h1 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /path/to/workdir</span></span><br></pre></td></tr></table></figure>

<p><code>WORKDIR</code>指令为<code>Dockerfile</code>中的任何<code>RUN</code>，<code>CMD</code>，<code>ENTRYPOINT</code>，<code>COPY</code>和<code>ADD</code>指令设置工作目录。如果<code>WORKDIR</code>不存在，它将被创建，即使它没有在任何后续的<code>Dockerfile</code>指令中使用</p>
<p>它可以在一个<code>Dockerfile</code>中多次使用. 如果提供了相对路径, 它将相对于先前WORKDIR指令的路径.  例如:</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> c</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p>在这个<code>Dockerfile</code>中的最终<code>pwd</code>命令的输出是<code>/a/b/c</code></p>
<p><code>WORKDIR</code>指令可以解析先前使用<code>ENV</code>设置的环境变量。您只能使用在<code>Dockerfile</code>中显式设置的环境变量.  例如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> <span class="variable">$DIRPATH</span>/<span class="variable">$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">pwd</span></span></span><br></pre></td></tr></table></figure>

<p><code>pwd</code>命令在该<code>Dockerfile</code>中输出的最后结果是<code>/path/$DIRNAME</code></p>
<h1 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h1><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<p><code>ARG</code>指令定义一个变量, 用户可以使用<code>docker build</code>命令使用<code>--build-arg &lt;varname&gt; = &lt;value&gt;</code>标志，在构建时将其传递给构建器. 如果用户指定了一个未在<code>Dockerfile</code>中定义的构建参数, 构建将输出错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">One or more build-args were not consumed, failing build.</span><br></pre></td></tr></table></figure>

<p>Dockerfile作者可以通过指定<code>ARG</code>一个或多个变量, 通过多次指定<code>ARG</code>来定义单个变量. 例如, 一个有效的<code>Dockerfile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1</span><br><span class="line">ARG buildno</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>Dockerfile作者可以可选地指定<code>ARG</code>指令的默认值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1&#x3D;someuser</span><br><span class="line">ARG buildno&#x3D;1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果<code>ARG</code>值具有缺省值，并且如果在构建时没有传递值，则构建器使用缺省值。</p>
<p><code>ARG</code>变量定义从在<code>Dockerfile</code>中定义的行开始生效，而不是从命令行或其他地方的参数使用。例如，考虑这个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM busybox</span><br><span class="line">2 USER $&#123;user:-some_user&#125;</span><br><span class="line">3 ARG user</span><br><span class="line">4 USER $user</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>用户构建此文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg user&#x3D;what_user Dockerfile</span><br></pre></td></tr></table></figure>

<p>第2行的<code>USER</code>将评估为<code>some_user</code>，因为用户变量在后续行3上定义。第4行的<code>USER</code>在定义用户时估计为<code>what_user</code>，在命令行中传递<code>what_user</code>值。在通过<code>ARG</code>指令定义之前，变量的任何使用都将导致空字符串。</p>
<blockquote>
<p><code>警告</code>：不建议使用build-time变量来传递诸如github密钥, 用户凭证等密码. 构建时变量值使用<code>docker history</code>命令对镜像的任何用户可见</p>
</blockquote>
<p>可以使用<code>ARG</code>或<code>ENV</code>指令来指定<code>RUN</code>指令可用的变量。使用<code>ENV</code>指令定义的环境变量总是覆盖同名的<code>ARG</code>指令。思考这个<code>Dockerfile</code>带有<code>ENV</code>和<code>ARG</code>指令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 ENV CONT_IMG_VER v1.0.0</span><br><span class="line">4 RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>然后，假设此image是使用此命令构建的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build --build-arg CONT_IMG_VER&#x3D;v2.0.1 Dockerfile</span><br></pre></td></tr></table></figure>

<p>在这种情况下，<code>RUN</code>指令使用<code>v1.0.0</code>而不是用户传递的<code>ARG</code>设置：<code>v2.0.1</code>此行为类似于shell脚本，其中本地作用域变量覆盖作为参数传递或从环境继承的变量，从其定义点。</p>
<p>使用上述示例，但使用不同的<code>ENV</code>规范，您可以在<code>ARG</code>和<code>ENV</code>指令之间创建更有用的交互：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 ENV CONT_IMG_VER $&#123;CONT_IMG_VER:-v1.0.0&#125;</span><br><span class="line">4 RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>与<code>ARG</code>指令不同, <code>ENV</code>值始终保留在image中. 考虑一个没有<code>-build-arg</code>标志的docker构建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build Dockerfile</span><br></pre></td></tr></table></figure>

<p>使用这个Dockerfile示例，<code>CONT_IMG_VER</code>仍然保留在映像中，但它的值将是<code>v1.0.0</code>，因为它是<code>ENV</code>指令在第3行中的默认设置。</p>
<p>此示例中的变量扩展技术允许您从命令行传递参数，并通过利用<code>ENV</code>指令将它们持久保存在最终image中</p>
<p>Docker有一组预定义的<code>ARG</code>变量，您可以在Dockerfile中使用相应的ARG指令。</p>
<ul>
<li>HTTP_PROXY</li>
<li>http_proxy</li>
<li>HTTPS_PROXY</li>
<li>https_proxy</li>
<li>FTP_PROXY</li>
<li>ftp_proxy</li>
<li>NO_PROXY</li>
<li>no_proxy</li>
</ul>
<p>要使用这些，只需在命令行使用标志传递它们：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--build-arg &lt;varname&gt;&#x3D;&lt;value&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Impact-on-build-caching"><a href="#Impact-on-build-caching" class="headerlink" title="Impact on build caching"></a>Impact on build caching</h2><p><code>ARG</code>变量不会持久化到构建的image中，因为<code>ENV</code>变量是。但是，<code>ARG</code>变量会以类似的方式影响构建缓存。如果一个<code>Dockerfile</code>定义一个<code>ARG</code>变量，它的值不同于以前的版本，那么在它的第一次使用时会出现一个“cache miss”，而不是它的定义。特别地，在<code>ARG</code>指令之后的所有<code>RUN</code>指令都隐式地使用ARG变量（作为环境变量），因此可能导致高速缓存未命中。</p>
<p>例如，考虑这两个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 RUN echo hello</span><br></pre></td></tr></table></figure>

<p>如果在命令行上指定<code>--build-arg CONT_IMG_VER = &lt;value&gt;</code>，则在这两种情况下，第2行的规范不会导致高速缓存未命中;行3确实导致高速缓存未命中。<code>ARG CONT_IMG_VER</code>导致<code>RUN</code>行被标识为与运行<code>CONT_IMG_VER = &lt;value&gt; echo hello</code>相同，因此如果<code>&lt;value&gt;</code>更改，我们将得到高速缓存未命中。</p>
<p>考虑在同一命令行下的另一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 ENV CONT_IMG_VER $CONT_IMG_VER</span><br><span class="line">4 RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>在此示例中，高速缓存未命中发生在第3行。由于变量在<code>ENV</code>中的值引用<code>ARG</code>变量并且该变量通过命令行更改，因此发生了未命中。在此示例中，<code>ENV</code>命令使image包括该值。</p>
<p>如果<code>ENV</code>指令覆盖同名的<code>ARG</code>指令，就像这个Dockerfile：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 FROM ubuntu</span><br><span class="line">2 ARG CONT_IMG_VER</span><br><span class="line">3 ENV CONT_IMG_VER hello</span><br><span class="line">4 RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<p>第3行不会导致高速缓存未命中，因为<code>CONT_IMG_VER</code>的值是一个常量（hello）因此，<code>RUN</code>（第4行）上使用的环境变量和值在构建之间不会更改</p>
<h1 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br></pre></td></tr></table></figure>

<p><code>ONBUILD</code>指令在image被用作另一个构建的基础时，向image添加要在以后执行的<em>trigger</em>指令。trigger将在下游构建的上下文中执行，就好像它已经在下游Dockerfile中的1FROM1指令之后立即插入。</p>
<p>任何构建指令都可以注册为trigger。</p>
<p>如果您正在构建将用作构建其他image的基础的图像，例如应用程序构建环境或可以使用用户特定配置自定义的后台驻留程序，这将非常有用。</p>
<p>例如，如果您的image是可重用的Python应用程序构建器，则需要将应用程序源代码添加到特定目录中，并且可能需要在此之后调用构建脚本。你不能只是调用<code>ADD</code>和<code>RUN</code>现在，因为你还没有访问应用程序源代码，它将是不同的每个应用程序构建。您可以简单地为应用程序开发人员提供一个样板Dockerfile以将其复制粘贴到其应用程序中，但这是低效，容易出错，并且很难更新，因为它与应用程序特定的代码混合。</p>
<p>解决方案是使用<code>ONBUILD</code>来注册提前指令，以便稍后在下一个构建阶段运行。</p>
<p>以下是它的工作原理：</p>
<ol>
<li>当遇到<code>ONBUILD</code>指令时，构建器会向正在构建的image的元数据添加trigger。该指令不会另外影响当前构建。</li>
<li>在构建结束时，所有trigger的列表存储在image清单中的OnBuild键下。可以使用<code>docker inspect</code>命令检查它们。</li>
<li>稍后，可以使用<code>FROM</code>指令将image用作新构建的基础。作为处理<code>FROM</code>指令的一部分，下游构建器会查找<code>ONBUILD</code>triggers，并按照它们注册的顺序执行它们。如果任何触发器失败，则<code>FROM</code>指令中止，这又导致构建失败。如果所有触发器都成功，则<code>FROM</code>指令完成并且构建如常继续。触发器在执行后从最终image中清除。换句话说，它们不会被“grand-children”构建继承。 例如，您可以添加如下： <code>[...] ONBUILD ADD . /app/src ONBUILD RUN /usr/local/bin/python-build --dir /app/src [...]</code>&gt; <code>警告</code>：不允许使用<code>ONBUILD ONBUILD</code>链接<code>ONBUILD</code>指令。 &gt; <code>警告</code>：<code>ONBUILD</code>指令可能不会触发<code>FROM</code>或<code>MAINTAINER</code>指令。</li>
</ol>
<h1 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<p><code>STOPSIGNAL</code>指令设置将发送到容器以退出的系统调用信号。该信号可以是与内核系统调用表中的位置匹配的有效无符号数，例如9，或者是SIGNAME格式的信号名称，例如SIGKILL</p>
<h1 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h1><p>两种形式：</p>
<ul>
<li>HEALTHCHECK [OPTIONS] CMD command (通过在容器中运行命令来检查容器运行状况)</li>
<li>HEALTHCHECK NONE (禁用从基本映像继承的任何运行状况检查)</li>
</ul>
<p><code>HEALTHCHECK</code>指令告诉Docker如何测试容器以检查它是否仍在工作。这可以检测到诸如Web服务器被卡在无限循环中并且无法处理新连接的情况，即使服务器进程仍在运行。</p>
<p>当容器指定了healthcheck时，除了其正常状态外，它还具有健康状态。此状态最初开始。 每当健康检查通过，它变得健康（无论之前的状态）。在一定数量的连续故障后，它变得不健康。</p>
<p>在CMD之前可以出现的选项有：</p>
<ul>
<li><code>--interval=DURATION</code> (default: 30s)</li>
<li><code>--timeout=DURATION</code> (default: 30s)</li>
<li><code>--retries=N</code> (default: 3)</li>
</ul>
<p>运行状况检查将首先在容器启动后运行<strong>interval</strong>秒，然后在每次上次检查完成后再次运行<strong>interval</strong>秒。</p>
<p>如果检查的单次运行所花费的时间超过<strong>timeout</strong>秒数，则该检查被认为已失败。</p>
<p>它需要<strong>retries</strong>连续的健康检查的故障，容器被认为是不健康的。</p>
<p>在Dockerfile中只能有一个<code>HEALTHCHECK</code>指令。如果您列出多个，则只有最后一个<code>HEALTHCHECK</code>将生效。</p>
<p><code>CMD</code>关键字之后的命令可以是shell命令（例如<code>HEALTHCHECK CMD /bin/check-running</code>）或exec数组（如同其他Dockerfile命令一样;详情参见<code>ENTRYPOINT</code>）。</p>
<p>命令的退出状态表示容器的运行状况。 可能的值为：</p>
<ul>
<li>0: success - the container is healthy and ready for use</li>
<li>1: unhealthy - the container is not working correctly</li>
<li>2: reserved - do not use this exit code</li>
</ul>
<p>例如，要每五分钟检查一次Web服务器能够在三秒钟内为网站的主页提供服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval&#x3D;5m --timeout&#x3D;3s \</span><br><span class="line">  CMD curl -f http:&#x2F;&#x2F;localhost&#x2F; || exit 1</span><br></pre></td></tr></table></figure>

<p>为了帮助调试失败的探测器，命令在stdout或stderr上写入的任何输出文本（UTF-8编码）将存储在运行状况状态，并可以使用<code>docker inspect</code>查询。这样的输出应该保持短路（只存储当前的4096个字节）。</p>
<p>当容器的运行状况发生更改时，将生成具有新状态的<code>health_status</code>事件。</p>
<p><code>HEALTHCHECK</code>功能在Docker 1.12中添加。</p>
<h1 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br></pre></td></tr></table></figure>

<p><code>SHELL</code>指令允许用于命令的shell形式的默认shell被覆盖。 Linux上的默认shell是<code>[&quot;/bin/sh&quot;,&quot;-c&quot;]</code>，在Windows上是<code>[&quot;cmd&quot;,&quot;/S&quot;,&quot;/C&quot;]</code>。<code>SHELL</code>指令必须以JSON格式写在Dockerfile中。</p>
<p><code>SHELL</code>指令在Windows上特别有用，其中有两个常用的和完全不同的本机shell：<code>cmd</code>和<code>powershell</code>，以及包括<code>sh</code>的备用Shell。</p>
<p><code>SHELL</code>指令可以多次出现。每个<code>SHELL</code>指令覆盖所有先前的<code>SHELL</code>指令，并影响所有后续指令。 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd &#x2F;S &#x2F;C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;&#x2F;S&quot;&quot;, &quot;&#x2F;C&quot;]</span><br><span class="line">RUN echo hello</span><br></pre></td></tr></table></figure>

<p>以下指令可能受<code>SHELL</code>指令的影响，当它们的shell形式用于Dockerfile：<code>RUN</code>，<code>CMD</code>和<code>ENTRYPOINT</code>。</p>
<p>以下示例是Windows上的常见模式，可以使用SHELL指令进行简化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">RUN powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>docker调用的命令将是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd &#x2F;S &#x2F;C powershell -command Execute-MyCmdlet -param1 &quot;c:\foo.txt&quot;</span><br></pre></td></tr></table></figure>

<p>这是低效的，有两个原因。首先，有一个不必要的cmd.exe命令处理器（也称为shell）被调用。其次，shell中的每个<code>RUN</code>指令都需要一个额外的<code>powershell -command</code>。</p>
<p>为了更有效率，可以采用两种机制之一。 一种是使用JSON形式的RUN命令，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">RUN [&quot;powershell&quot;, &quot;-command&quot;, &quot;Execute-MyCmdlet&quot;, &quot;-param1 \&quot;c:\\foo.txt\&quot;&quot;]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>虽然JSON形式是明确的，并且不使用不必要的cmd.exe，但它需要通过双引号和转义更详细。 备用机制是使用<code>SHELL</code>指令和shell形式，为Windows用户提供更自然的语法，特别是与<code>escape</code> 解析指令结合使用时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># escape&#x3D;&#96;</span><br><span class="line"></span><br><span class="line">FROM windowsservercore</span><br><span class="line">SHELL [&quot;powershell&quot;,&quot;-command&quot;]</span><br><span class="line">RUN New-Item -ItemType Directory C:\Example</span><br><span class="line">ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line">RUN c:\example\Execute-MyCmdlet -sample &#39;hello world&#39;</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS E:\docker\build\shell&gt; docker build -t shell .</span><br><span class="line">Sending build context to Docker daemon 3.584 kB</span><br><span class="line">Step 1 : FROM windowsservercore</span><br><span class="line"> ---&gt; 5bc36a335344</span><br><span class="line">Step 2 : SHELL powershell -command</span><br><span class="line"> ---&gt; Running in 87d7a64c9751</span><br><span class="line"> ---&gt; 4327358436c1</span><br><span class="line">Removing intermediate container 87d7a64c9751</span><br><span class="line">Step 3 : RUN New-Item -ItemType Directory C:\Example</span><br><span class="line"> ---&gt; Running in 3e6ba16b8df9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Directory: C:\</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line">----                -------------         ------ ----</span><br><span class="line">d-----         6&#x2F;2&#x2F;2016   2:59 PM                Example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ---&gt; 1f1dfdcec085</span><br><span class="line">Removing intermediate container 3e6ba16b8df9</span><br><span class="line">Step 4 : ADD Execute-MyCmdlet.ps1 c:\example\</span><br><span class="line"> ---&gt; 6770b4c17f29</span><br><span class="line">Removing intermediate container b139e34291dc</span><br><span class="line">Step 5 : RUN c:\example\Execute-MyCmdlet -sample &#39;hello world&#39;</span><br><span class="line"> ---&gt; Running in abdcf50dfd1f</span><br><span class="line">Hello from Execute-MyCmdlet.ps1 - passed hello world</span><br><span class="line"> ---&gt; ba0e25255fda</span><br><span class="line">Removing intermediate container abdcf50dfd1f</span><br><span class="line">Successfully built ba0e25255fda</span><br><span class="line">PS E:\docker\build\shell&gt;</span><br></pre></td></tr></table></figure>

<p><code>SHELL</code>指令还可以用于修改外壳操作的方式。例如，在Windows上使用<code>SHELL cmd /S /C /V:ON|OFF</code>，可以修改延迟的环境变量扩展语义。</p>
<p><code>SHELL</code>指令也可以在Linux上使用，如果需要一个替代shell，如<code>zsh</code>，<code>csh</code>，<code>tcsh</code>和其他。</p>
<p><code>SHELL</code>功能在Docker 1.12中添加</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>docker container 容器管理</title>
    <url>/2017/04/16/docker-container%E5%AE%B9%E5%99%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>Docker 管理命令<ul>
<li><strong>容器管理</strong></li>
<li>镜像管理</li>
<li>网络管理</li>
<li>系统管理</li>
<li>数据卷管理</li>
<li>快照管理</li>
<li>插件管理</li>
<li>其他</li>
<li>swarmkit 管理<ul>
<li>模式管理</li>
<li>节点管理</li>
<li>秘钥管理</li>
<li>服务管理</li>
<li>服务栈管理</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>Docker 的每一级命令都可以使用<code>--help</code> 的参数来查看帮助信息</p>
<h1 id="Docker-一级命令"><a href="#Docker-一级命令" class="headerlink" title="Docker 一级命令"></a>Docker 一级命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime <span class="keyword">for</span> containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default <span class="string">"/root/.docker"</span>)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">      --<span class="built_in">help</span>               Print usage</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to (default [])</span><br><span class="line">  -l, --<span class="built_in">log</span>-level string   Set the logging level (<span class="string">"debug"</span>|<span class="string">"info"</span>|<span class="string">"warn"</span>|<span class="string">"error"</span>|<span class="string">"fatal"</span>) (default <span class="string">"info"</span>)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default <span class="string">"/root/.docker/ca.pem"</span>)</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default <span class="string">"/root/.docker/cert.pem"</span>)</span><br><span class="line">      --tlskey string      Path to TLS key file (default <span class="string">"/root/.docker/key.pem"</span>)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  container   Manage containers</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string">  cp          Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">  create      Create a new container</span></span><br><span class="line"><span class="string">  diff        Inspect changes to files or directories on a container'</span>s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  <span class="built_in">exec</span>        Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">  <span class="built_in">export</span>      Export a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string">  history     Show the history of an image</span></span><br><span class="line"><span class="string">  images      List images</span></span><br><span class="line"><span class="string">  import      Import the contents from a tarball to create a filesystem image</span></span><br><span class="line"><span class="string">  info        Display system-wide information</span></span><br><span class="line"><span class="string">  inspect     Return low-level information on Docker objects</span></span><br><span class="line"><span class="string">  kill        Kill one or more running containers</span></span><br><span class="line"><span class="string">  load        Load an image from a tar archive or STDIN</span></span><br><span class="line"><span class="string">  login       Log in to a Docker registry</span></span><br><span class="line"><span class="string">  logout      Log out from a Docker registry</span></span><br><span class="line"><span class="string">  logs        Fetch the logs of a container</span></span><br><span class="line"><span class="string">  pause       Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">  port        List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">  ps          List containers</span></span><br><span class="line"><span class="string">  pull        Pull an image or a repository from a registry</span></span><br><span class="line"><span class="string">  push        Push an image or a repository to a registry</span></span><br><span class="line"><span class="string">  rename      Rename a container</span></span><br><span class="line"><span class="string">  restart     Restart one or more containers</span></span><br><span class="line"><span class="string">  rm          Remove one or more containers</span></span><br><span class="line"><span class="string">  rmi         Remove one or more images</span></span><br><span class="line"><span class="string">  run         Run a command in a new container</span></span><br><span class="line"><span class="string">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span></span><br><span class="line"><span class="string">  search      Search the Docker Hub for images</span></span><br><span class="line"><span class="string">  start       Start one or more stopped containers</span></span><br><span class="line"><span class="string">  stats       Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">  stop        Stop one or more running containers</span></span><br><span class="line"><span class="string">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span></span><br><span class="line"><span class="string">  top         Display the running processes of a container</span></span><br><span class="line"><span class="string">  unpause     Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">  update      Update configuration of one or more containers</span></span><br><span class="line"><span class="string">  version     Show the Docker version information</span></span><br><span class="line"><span class="string">  wait        Block until one or more containers stop, then print their exit codes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run '</span>docker COMMAND --<span class="built_in">help</span><span class="string">' for more information on a command.</span></span><br></pre></td></tr></table></figure>

<p>在 Docker1.13版本之前, 是没有二级管理命令的, 随着 Docker 的功能越来越多, 命令参数也越来越多, 到1.13版本后, Docker 终于对他们做出了归类, 之前的语法也兼容, 但是 Docker 推荐使用最新的语法格式.</p>
<p>1.13版本后, Docker 对命令做出了如下归类:</p>
<ul>
<li>container   Manage containers</li>
<li>image       Manage images</li>
<li>network     Manage networks</li>
<li>node        Manage Swarm nodes</li>
<li>plugin      Manage plugins</li>
<li>secret      Manage Docker secrets</li>
<li>service     Manage services</li>
<li>stack       Manage Docker stacks</li>
<li>swarm       Manage Swarm</li>
<li>system      Manage Docker</li>
<li>volume      Manage volumes</li>
</ul>
<h1 id="容器管理-container"><a href="#容器管理-container" class="headerlink" title="容器管理 container"></a>容器管理 container</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container COMMAND</span><br><span class="line"></span><br><span class="line">Manage containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach to a running container</span><br><span class="line">  commit      Create a new image from a container<span class="string">'s changes</span></span><br><span class="line"><span class="string">  cp          Copy files/folders between a container and the local filesystem</span></span><br><span class="line"><span class="string">  create      Create a new container</span></span><br><span class="line"><span class="string">  diff        Inspect changes to files or directories on a container'</span>s filesystem</span><br><span class="line">  <span class="built_in">exec</span>        Run a <span class="built_in">command</span> <span class="keyword">in</span> a running container</span><br><span class="line">  <span class="built_in">export</span>      Export a container<span class="string">'s filesystem as a tar archive</span></span><br><span class="line"><span class="string">  inspect     Display detailed information on one or more containers</span></span><br><span class="line"><span class="string">  kill        Kill one or more running containers</span></span><br><span class="line"><span class="string">  logs        Fetch the logs of a container</span></span><br><span class="line"><span class="string">  ls          List containers</span></span><br><span class="line"><span class="string">  pause       Pause all processes within one or more containers</span></span><br><span class="line"><span class="string">  port        List port mappings or a specific mapping for the container</span></span><br><span class="line"><span class="string">  prune       Remove all stopped containers</span></span><br><span class="line"><span class="string">  rename      Rename a container</span></span><br><span class="line"><span class="string">  restart     Restart one or more containers</span></span><br><span class="line"><span class="string">  rm          Remove one or more containers</span></span><br><span class="line"><span class="string">  run         Run a command in a new container</span></span><br><span class="line"><span class="string">  start       Start one or more stopped containers</span></span><br><span class="line"><span class="string">  stats       Display a live stream of container(s) resource usage statistics</span></span><br><span class="line"><span class="string">  stop        Stop one or more running containers</span></span><br><span class="line"><span class="string">  top         Display the running processes of a container</span></span><br><span class="line"><span class="string">  unpause     Unpause all processes within one or more containers</span></span><br><span class="line"><span class="string">  update      Update configuration of one or more containers</span></span><br><span class="line"><span class="string">  wait        Block until one or more containers stop, then print their exit codes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Run '</span>docker container COMMAND --<span class="built_in">help</span><span class="string">' for more information on a command.</span></span><br></pre></td></tr></table></figure>



<h2 id="attach"><a href="#attach" class="headerlink" title="attach"></a>attach</h2><p>进入容器的方式之一, 翻译过来叫”附着”到运行的容器中. 他与<code>exec</code> 有本质的区别, exec 进入容器是在主进程的基础之上, 再开通一个进程实现的进入容器. 而 attach 则意味着进入到容器的主进程中. 产生的后果也不一样, 由于 attach 进入到了主进程, 一旦 Ctrl+C 退出终端, 将导致主进程退出, 从而容器也随之退出. 而 exec 的方式进入容器是单独开启了一个进程, 该进程的产生于销毁并不影响主进程, 所以不会因为终端的退出而导致容器退出.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run -d centos ping 123.57.233.243</span></span><br><span class="line">2ad157c779469961faabec0e836f7d2ab03a7e6193d932647e83626231fa0560</span><br><span class="line">root@ubuntu:~<span class="comment"># </span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker container attach 2ad</span></span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=40 ttl=127 time=8.05 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=41 ttl=127 time=7.46 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=42 ttl=127 time=8.86 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=43 ttl=127 time=9.80 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=44 ttl=127 time=6.24 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=45 ttl=127 time=6.01 ms</span><br><span class="line">^C</span><br><span class="line">--- 123.57.233.243 ping statistics ---</span><br><span class="line">62 packets transmitted, 62 received, 0% packet loss, time 61130ms</span><br><span class="line">rtt min/avg/max/mdev = 5.407/18.181/204.154/32.140 ms</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>在一个运行中的容器内执行命令. 就如上面所说, 使用 exec 执行命令意味着在主进程的基础之上, 再启动其他的进程, 其他进程的启动与销毁不会直接影响容器的退出.</p>
<p>exec 的用法很多, 使用频率最高的是进入容器的操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container exec -it b9704931408c /bin/bash</span></span><br><span class="line">root@b9704931408c:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>也可以运行任何bash命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container exec 11610baab1ce echo "haha"</span></span><br><span class="line">haha</span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                        NAMES</span><br><span class="line">b9704931408c        nginx               <span class="string">"nginx -g 'daemon ..."</span>   About an hour ago   Up About an hour    0.0.0.0:443-&gt;443/tcp, 0.0.0.0:8080-&gt;80/tcp   my-third-nginx</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   About an hour ago   Up About an hour    443/tcp, 0.0.0.0:8800-&gt;80/tcp                my-second-nginx</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   About an hour ago   Up 12 minutes       80/tcp, 443/tcp                              my-first-nginx</span><br></pre></td></tr></table></figure>

<h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><p>基于一个现有的容器创建新的镜像. commit 多用在做容器迁移的时候, 当容器为由状态时, 我们需要保存现有容器的所有运行状态以保证迁移后的一致性, 这时 commit 就派上了用场.</p>
<p>运行一个初始的镜像, 我们通过 exec 进入到容器, 并做了一些修改, 当需要迁移此容器时, 可以把当前修改过后的容器保存为一个新的镜像. 然后将镜像迁移至新主机, 再 run 起来.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改容器内容</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it my-first-nginx /bin/bash</span></span><br><span class="line">root@11610baab1ce:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@11610baab1ce:/tmp<span class="comment"># ls</span></span><br><span class="line">root@11610baab1ce:/tmp<span class="comment"># echo "commit test" &gt; /tmp/c.txt</span></span><br><span class="line">root@11610baab1ce:/tmp<span class="comment"># ls</span></span><br><span class="line">c.txt</span><br><span class="line">root@11610baab1ce:/tmp<span class="comment"># cat /tmp/c.txt </span></span><br><span class="line">commit <span class="built_in">test</span></span><br><span class="line">root@11610baab1ce:/tmp<span class="comment"># exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"><span class="comment"># commit 镜像</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker commit my-first-nginx nginx2:0.1</span></span><br><span class="line">sha256:7cb5220c81d58a56471b6ce69e40bf4d15f89652b4b4bd78ec4579b6473bfc91</span><br><span class="line">root@ubuntu:~<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx2              0.1                 7cb5220c81d5        4 seconds ago       204MB</span><br><span class="line">centos              latest              a8493f5f50ff        35 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        39 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br><span class="line"><span class="comment"># 基于新镜像运行新容器</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it new-first-nginx /bin/bash</span></span><br><span class="line">root@b4e6f8620ba3:/<span class="comment"># cd /tmp/</span></span><br><span class="line">root@b4e6f8620ba3:/tmp<span class="comment"># ls</span></span><br><span class="line">c.txt</span><br><span class="line">root@b4e6f8620ba3:/tmp<span class="comment"># cat c.txt </span></span><br><span class="line">commit <span class="built_in">test</span></span><br><span class="line">root@b4e6f8620ba3:/tmp<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>注意: 挂载的数据是不会被 commit 到镜像中的. 迁移之后需要用相同的参数启动起来</p>
<p>迁移有两种方式:</p>
<ul>
<li>一种是导入导出的方式(通过 tar.gz 文件)</li>
<li>一种是通过 Registry 的方式 push 和 pull</li>
</ul>
<p>如果是通过 Registry 的方式的话, 需要在 commit 时, 镜像名字中加入 Registry 地址</p>
<p><code>docker container commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></p>
<p>注意: commit 的过程中, 容器处于 pause 的状态, 类似于 MySQL 的排它锁</p>
<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>通过 cp 命令可以把容器中的文件拷贝到宿主机(把文件拿出来)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container cp --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-</span><br><span class="line">	docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">Copy files/folders between a container and the <span class="built_in">local</span> filesystem</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -L, --follow-link   Always follow symbol link <span class="keyword">in</span> SRC_PATH</span><br><span class="line">      --<span class="built_in">help</span>          Print usage</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container cp my-first-nginx:/tmp/c.txt ./</span></span><br><span class="line">root@ubuntu:~<span class="comment"># ls</span></span><br><span class="line">c.txt  web</span><br></pre></td></tr></table></figure>

<p>注意: 两种执行方式的语法不同</p>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><p>列出与原始镜像相比,容器中变化的内容.</p>
<ul>
<li>A: 增加</li>
<li>D: 删除</li>
<li>C: 修改</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container diff  --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container diff CONTAINER</span><br><span class="line"></span><br><span class="line">Inspect changes to files or directories on a container<span class="string">'s filesystem</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">      --help   Print usage</span></span><br><span class="line"><span class="string">root@ubuntu:~# docker container diff  my-second-nginx</span></span><br><span class="line"><span class="string">C /run</span></span><br><span class="line"><span class="string">A /run/nginx.pid</span></span><br><span class="line"><span class="string">C /var</span></span><br><span class="line"><span class="string">C /var/cache</span></span><br><span class="line"><span class="string">C /var/cache/nginx</span></span><br><span class="line"><span class="string">A /var/cache/nginx/client_temp</span></span><br><span class="line"><span class="string">A /var/cache/nginx/fastcgi_temp</span></span><br><span class="line"><span class="string">A /var/cache/nginx/proxy_temp</span></span><br><span class="line"><span class="string">A /var/cache/nginx/scgi_temp</span></span><br><span class="line"><span class="string">A /var/cache/nginx/uwsgi_temp</span></span><br></pre></td></tr></table></figure>

<h2 id="export-amp-import-save-amp-load"><a href="#export-amp-import-save-amp-load" class="headerlink" title="export&amp;import/save&amp;load"></a>export&amp;import/save&amp;load</h2><p>Docker 的导入导出</p>
<p><a href="https://docs.lvrui.io/2017/02/19/docker的导入导出/">https://docs.lvrui.io/2017/02/19/docker的导入导出/</a></p>
<p>export&amp;import 操作的对象是容器, 导出到一个新的镜像, 该镜像只有一层</p>
<p>save&amp;load 操作对象是镜像, 原镜像层数保留</p>
<p>如果导出容器还需要保留层数, 那就需要使用 commit+save+load 黄金组合啦</p>
<h2 id="inspect"><a href="#inspect" class="headerlink" title="inspect"></a>inspect</h2><p>查看容器详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container inspect my-third-nginx</span></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2017-04-08T06:22:29.186834559Z"</span>,</span><br><span class="line">        <span class="string">"Path"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">        <span class="string">"Args"</span>: [</span><br><span class="line">            <span class="string">"-g"</span>,</span><br><span class="line">            <span class="string">"daemon off;"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"State"</span>: &#123;</span><br><span class="line">            <span class="string">"Status"</span>: <span class="string">"running"</span>,</span><br><span class="line">            <span class="string">"Running"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Paused"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Restarting"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OOMKilled"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Dead"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Pid"</span>: 2648,</span><br><span class="line">            <span class="string">"ExitCode"</span>: 0,</span><br><span class="line">            <span class="string">"Error"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"StartedAt"</span>: <span class="string">"2017-04-08T06:22:29.555131293Z"</span>,</span><br><span class="line">            <span class="string">"FinishedAt"</span>: <span class="string">"0001-01-01T00:00:00Z"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Image"</span>: <span class="string">"sha256:5766334bdaa0bc37f1f0c02cb94c351f9b076bcffa042d6ce811b0fd9bc31f3b"</span>,</span><br><span class="line">        <span class="string">"ResolvConfPath"</span>: <span class="string">"/var/lib/docker/containers/b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6/resolv.conf"</span>,</span><br><span class="line">        <span class="string">"HostnamePath"</span>: <span class="string">"/var/lib/docker/containers/b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6/hostname"</span>,</span><br><span class="line">        <span class="string">"HostsPath"</span>: <span class="string">"/var/lib/docker/containers/b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6/hosts"</span>,</span><br><span class="line">        <span class="string">"LogPath"</span>: <span class="string">"/var/lib/docker/containers/b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6/b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6-json.log"</span>,</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"/my-third-nginx"</span>,</span><br><span class="line">        <span class="string">"RestartCount"</span>: 0,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"aufs"</span>,</span><br><span class="line">        <span class="string">"MountLabel"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"ProcessLabel"</span>: <span class="string">""</span>,</span><br><span class="line">        <span class="string">"AppArmorProfile"</span>: <span class="string">"docker-default"</span>,</span><br><span class="line">        <span class="string">"ExecIDs"</span>: null,</span><br><span class="line">        <span class="string">"HostConfig"</span>: &#123;</span><br><span class="line">            <span class="string">"Binds"</span>: [</span><br><span class="line">                <span class="string">"/root/web:/usr/share/nginx/html:ro"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"ContainerIDFile"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"LogConfig"</span>: &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"json-file"</span>,</span><br><span class="line">                <span class="string">"Config"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"NetworkMode"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"PortBindings"</span>: &#123;</span><br><span class="line">                <span class="string">"443/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"443"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"80/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">""</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"8080"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"RestartPolicy"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"no"</span>,</span><br><span class="line">                <span class="string">"MaximumRetryCount"</span>: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"AutoRemove"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"VolumeDriver"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"VolumesFrom"</span>: null,</span><br><span class="line">            <span class="string">"CapAdd"</span>: null,</span><br><span class="line">            <span class="string">"CapDrop"</span>: null,</span><br><span class="line">            <span class="string">"Dns"</span>: [],</span><br><span class="line">            <span class="string">"DnsOptions"</span>: [],</span><br><span class="line">            <span class="string">"DnsSearch"</span>: [],</span><br><span class="line">            <span class="string">"ExtraHosts"</span>: null,</span><br><span class="line">            <span class="string">"GroupAdd"</span>: null,</span><br><span class="line">            <span class="string">"IpcMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Cgroup"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Links"</span>: null,</span><br><span class="line">            <span class="string">"OomScoreAdj"</span>: 0,</span><br><span class="line">            <span class="string">"PidMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Privileged"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"PublishAllPorts"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"ReadonlyRootfs"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"SecurityOpt"</span>: null,</span><br><span class="line">            <span class="string">"UTSMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"UsernsMode"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"ShmSize"</span>: 67108864,</span><br><span class="line">            <span class="string">"Runtime"</span>: <span class="string">"runc"</span>,</span><br><span class="line">            <span class="string">"ConsoleSize"</span>: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Isolation"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"CpuShares"</span>: 0,</span><br><span class="line">            <span class="string">"Memory"</span>: 0,</span><br><span class="line">            <span class="string">"NanoCpus"</span>: 0,</span><br><span class="line">            <span class="string">"CgroupParent"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"BlkioWeight"</span>: 0,</span><br><span class="line">            <span class="string">"BlkioWeightDevice"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceReadBps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceWriteBps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceReadIOps"</span>: null,</span><br><span class="line">            <span class="string">"BlkioDeviceWriteIOps"</span>: null,</span><br><span class="line">            <span class="string">"CpuPeriod"</span>: 0,</span><br><span class="line">            <span class="string">"CpuQuota"</span>: 0,</span><br><span class="line">            <span class="string">"CpuRealtimePeriod"</span>: 0,</span><br><span class="line">            <span class="string">"CpuRealtimeRuntime"</span>: 0,</span><br><span class="line">            <span class="string">"CpusetCpus"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"CpusetMems"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Devices"</span>: [],</span><br><span class="line">            <span class="string">"DeviceCgroupRules"</span>: null,</span><br><span class="line">            <span class="string">"DiskQuota"</span>: 0,</span><br><span class="line">            <span class="string">"KernelMemory"</span>: 0,</span><br><span class="line">            <span class="string">"MemoryReservation"</span>: 0,</span><br><span class="line">            <span class="string">"MemorySwap"</span>: 0,</span><br><span class="line">            <span class="string">"MemorySwappiness"</span>: -1,</span><br><span class="line">            <span class="string">"OomKillDisable"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"PidsLimit"</span>: 0,</span><br><span class="line">            <span class="string">"Ulimits"</span>: null,</span><br><span class="line">            <span class="string">"CpuCount"</span>: 0,</span><br><span class="line">            <span class="string">"CpuPercent"</span>: 0,</span><br><span class="line">            <span class="string">"IOMaximumIOps"</span>: 0,</span><br><span class="line">            <span class="string">"IOMaximumBandwidth"</span>: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"GraphDriver"</span>: &#123;</span><br><span class="line">            <span class="string">"Data"</span>: null,</span><br><span class="line">            <span class="string">"Name"</span>: <span class="string">"aufs"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Mounts"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Type"</span>: <span class="string">"bind"</span>,</span><br><span class="line">                <span class="string">"Source"</span>: <span class="string">"/root/web"</span>,</span><br><span class="line">                <span class="string">"Destination"</span>: <span class="string">"/usr/share/nginx/html"</span>,</span><br><span class="line">                <span class="string">"Mode"</span>: <span class="string">"ro"</span>,</span><br><span class="line">                <span class="string">"RW"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="string">"Propagation"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"Hostname"</span>: <span class="string">"b9704931408c"</span>,</span><br><span class="line">            <span class="string">"Domainname"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"User"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"AttachStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStdout"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"AttachStderr"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"ExposedPorts"</span>: &#123;</span><br><span class="line">                <span class="string">"443/tcp"</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">"80/tcp"</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"Tty"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"OpenStdin"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"StdinOnce"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"Env"</span>: [</span><br><span class="line">                <span class="string">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</span>,</span><br><span class="line">                <span class="string">"NGINX_VERSION=1.11.13-1~jessie"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"Cmd"</span>: [</span><br><span class="line">                <span class="string">"nginx"</span>,</span><br><span class="line">                <span class="string">"-g"</span>,</span><br><span class="line">                <span class="string">"daemon off;"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">"ArgsEscaped"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"Image"</span>: <span class="string">"nginx"</span>,</span><br><span class="line">            <span class="string">"Volumes"</span>: null,</span><br><span class="line">            <span class="string">"WorkingDir"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"Entrypoint"</span>: null,</span><br><span class="line">            <span class="string">"OnBuild"</span>: null,</span><br><span class="line">            <span class="string">"Labels"</span>: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"NetworkSettings"</span>: &#123;</span><br><span class="line">            <span class="string">"Bridge"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"SandboxID"</span>: <span class="string">"916a8bef0178b4e8e2ff1c246a9e04c85686b8ddf8493946de7103577ff8158b"</span>,</span><br><span class="line">            <span class="string">"HairpinMode"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"LinkLocalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"LinkLocalIPv6PrefixLen"</span>: 0,</span><br><span class="line">            <span class="string">"Ports"</span>: &#123;</span><br><span class="line">                <span class="string">"443/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"443"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ],</span><br><span class="line">                <span class="string">"80/tcp"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="string">"HostIp"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">                        <span class="string">"HostPort"</span>: <span class="string">"8080"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"SandboxKey"</span>: <span class="string">"/var/run/docker/netns/916a8bef0178"</span>,</span><br><span class="line">            <span class="string">"SecondaryIPAddresses"</span>: null,</span><br><span class="line">            <span class="string">"SecondaryIPv6Addresses"</span>: null,</span><br><span class="line">            <span class="string">"EndpointID"</span>: <span class="string">"7a9c71aae5980ccd513c1e7a4e8cefaf56a87e1d796669bbfb70ffc728d1e0bb"</span>,</span><br><span class="line">            <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">            <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">            <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br><span class="line">            <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">            <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">            <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:04"</span>,</span><br><span class="line">            <span class="string">"Networks"</span>: &#123;</span><br><span class="line">                <span class="string">"bridge"</span>: &#123;</span><br><span class="line">                    <span class="string">"IPAMConfig"</span>: null,</span><br><span class="line">                    <span class="string">"Links"</span>: null,</span><br><span class="line">                    <span class="string">"Aliases"</span>: null,</span><br><span class="line">                    <span class="string">"NetworkID"</span>: <span class="string">"26d72edf89c3ae77e1de636d4357b819a12c24ae64ab0da4d9b2d43610c44f24"</span>,</span><br><span class="line">                    <span class="string">"EndpointID"</span>: <span class="string">"7a9c71aae5980ccd513c1e7a4e8cefaf56a87e1d796669bbfb70ffc728d1e0bb"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"172.17.0.1"</span>,</span><br><span class="line">                    <span class="string">"IPAddress"</span>: <span class="string">"172.17.0.4"</span>,</span><br><span class="line">                    <span class="string">"IPPrefixLen"</span>: 16,</span><br><span class="line">                    <span class="string">"IPv6Gateway"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6Address"</span>: <span class="string">""</span>,</span><br><span class="line">                    <span class="string">"GlobalIPv6PrefixLen"</span>: 0,</span><br><span class="line">                    <span class="string">"MacAddress"</span>: <span class="string">"02:42:ac:11:00:04"</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="ls-ps-list"><a href="#ls-ps-list" class="headerlink" title="ls/ps/list"></a>ls/ps/list</h2><p>查看 container 列表</p>
<ul>
<li>docker ps</li>
<li>docker container ls</li>
<li>docker container list</li>
</ul>
<p>以上三条命令的用法和作用都是一样的, 之间做了别名</p>
<p>最实用的参数<code>-s</code> 可以显示出容器占用空间大小, 括号中的是镜像大小, 前面是可写层(容器)大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container list -s</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                        NAMES               SIZE</span><br><span class="line">b4e6f8620ba3        nginx2:0.1          <span class="string">"nginx -g 'daemon ..."</span>   29 minutes ago      Up 29 minutes       80/tcp, 443/tcp                              new-first-nginx     413B (virtual 204MB)</span><br><span class="line">b9704931408c        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          0.0.0.0:443-&gt;443/tcp, 0.0.0.0:8080-&gt;80/tcp   my-third-nginx      7B (virtual 183MB)</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          443/tcp, 0.0.0.0:8800-&gt;80/tcp                my-second-nginx     2B (virtual 183MB)</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up About an hour    80/tcp, 443/tcp                              my-first-nginx      21.3MB (virtual 204MB)</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h2><p>查看容器的前台回显日志. 由于容器必须以阻塞前台的方式运行, 那么我们就可以通过 logs 命令来查看容器前台的回显(在默认是 json-file 日志引擎下)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run -d centos ping 123.57.233.243</span></span><br><span class="line">791a4ad7ffa83f81a78e2bba1a5d5366a099be443beb19f66ee0d51e83cd020d</span><br><span class="line">root@ubuntu:~<span class="comment"># </span></span><br><span class="line">root@ubuntu:~<span class="comment"># </span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker logs -f 791a4ad7ffa8</span></span><br><span class="line">PING 123.57.233.243 (123.57.233.243) 56(84) bytes of data.</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=1 ttl=127 time=7.89 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=2 ttl=127 time=6.66 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=3 ttl=127 time=6.55 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=4 ttl=127 time=6.46 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=5 ttl=127 time=175 ms</span><br><span class="line">64 bytes from 123.57.233.243: icmp_seq=6 ttl=127 time=267 ms</span><br></pre></td></tr></table></figure>

<h2 id="kill-start-stop-restart-rm-pause-unpause-prune"><a href="#kill-start-stop-restart-rm-pause-unpause-prune" class="headerlink" title="kill/start/stop/restart/rm/pause/unpause/prune"></a>kill/start/stop/restart/rm/pause/unpause/prune</h2><ul>
<li>kill 给容器发送 kill 信号, 非正常退出容器</li>
<li>start 启动退出状态的容器</li>
<li>stop 退出运行状态的容器</li>
<li>restart 重启容器</li>
<li>rm 删除退出状态的容器</li>
<li>pause 暂停运行中的容器(处于阻塞状态)</li>
<li>unpause 恢复暂停的容器至运行状态</li>
<li>prune 删除所有 stopped 状态的容器(1.13的新特性, 救世主!)</li>
</ul>
<h2 id="port"><a href="#port" class="headerlink" title="port"></a>port</h2><p>查看端口的映射关系</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container port my-third-nginx</span></span><br><span class="line">443/tcp -&gt; 0.0.0.0:443</span><br><span class="line">80/tcp -&gt; 0.0.0.0:8080</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container port my-second-nginx</span></span><br><span class="line">80/tcp -&gt; 0.0.0.0:8800</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container port my-first-nginx</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker container port my-second-nginx 80/tcp</span></span><br><span class="line">0.0.0.0:8800</span><br></pre></td></tr></table></figure>

<h2 id="rename"><a href="#rename" class="headerlink" title="rename"></a>rename</h2><p>更改容器名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                        NAMES</span><br><span class="line">b4e6f8620ba3        nginx2:0.1          <span class="string">"nginx -g 'daemon ..."</span>   About an hour ago   Up About an hour    80/tcp, 443/tcp                              new-first-nginx</span><br><span class="line">b9704931408c        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          0.0.0.0:443-&gt;443/tcp, 0.0.0.0:8080-&gt;80/tcp   my-third-nginx</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          443/tcp, 0.0.0.0:8800-&gt;80/tcp                my-second-nginx</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up About an hour    80/tcp, 443/tcp                              my-first-nginx</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container rename --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container rename CONTAINER NEW_NAME</span><br><span class="line"></span><br><span class="line">Rename a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container rename new-first-nginx new-first-nginx2</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                        NAMES</span><br><span class="line">b4e6f8620ba3        nginx2:0.1          <span class="string">"nginx -g 'daemon ..."</span>   About an hour ago   Up About an hour    80/tcp, 443/tcp                              new-first-nginx2</span><br><span class="line">b9704931408c        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          0.0.0.0:443-&gt;443/tcp, 0.0.0.0:8080-&gt;80/tcp   my-third-nginx</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up 2 hours          443/tcp, 0.0.0.0:8800-&gt;80/tcp                my-second-nginx</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   2 hours ago         Up About an hour    80/tcp, 443/tcp                              my-first-nginx</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="stats"><a href="#stats" class="headerlink" title="stats"></a>stats</h2><p>实时查看容器资源使用状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container stats </span></span><br><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT     MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">b4e6f8620ba3        0.00%               1.457MiB / 975.1MiB   0.15%               690B / 0B           0B / 4.1kB          2</span><br><span class="line">b9704931408c        0.00%               1.449MiB / 975.1MiB   0.15%               732B / 0B           0B / 0B             2</span><br><span class="line">d0a4936e940e        0.00%               1.512MiB / 975.1MiB   0.16%               1.36kB / 671B       0B / 0B             2</span><br><span class="line">11610baab1ce        0.00%               1.465MiB / 975.1MiB   0.15%               732B / 0B           0B / 0B             2</span><br></pre></td></tr></table></figure>

<h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>查看容器的进程信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container top --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container top CONTAINER [ps OPTIONS]</span><br><span class="line"></span><br><span class="line">Display the running processes of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --<span class="built_in">help</span>   Print usage</span><br><span class="line">root@ubuntu:~<span class="comment"># docker container top my-third-nginx</span></span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD</span><br><span class="line">root                2648                2631                0                   Apr07               ?                   00:00:00            nginx: master process nginx -g daemon off;</span><br><span class="line">syslog              2669                2648                0                   Apr07               ?                   00:00:00            nginx: worker process</span><br></pre></td></tr></table></figure>

<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>调整分配给容器的计算资源, 可以更改该容器可以使用的 CPU 计算资源与内存资源等</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker container update --help</span></span><br><span class="line"></span><br><span class="line">Usage:	docker container update [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Update configuration of one or more containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --blkio-weight uint16        Block IO (relative weight), between 10 and 1000, or 0 to <span class="built_in">disable</span> (default 0)</span><br><span class="line">      --cpu-period int             Limit CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int              Limit CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">      --cpu-rt-period int          Limit the CPU real-time period <span class="keyword">in</span> microseconds</span><br><span class="line">      --cpu-rt-runtime int         Limit the CPU real-time runtime <span class="keyword">in</span> microseconds</span><br><span class="line">  -c, --cpu-shares int             CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string         CPUs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string         MEMs <span class="keyword">in</span> <span class="built_in">which</span> to allow execution (0-3, 0,1)</span><br><span class="line">      --<span class="built_in">help</span>                       Print usage</span><br><span class="line">      --kernel-memory bytes        Kernel memory <span class="built_in">limit</span></span><br><span class="line">  -m, --memory bytes               Memory <span class="built_in">limit</span></span><br><span class="line">      --memory-reservation bytes   Memory soft <span class="built_in">limit</span></span><br><span class="line">      --memory-swap bytes          Swap <span class="built_in">limit</span> equal to memory plus swap: <span class="string">'-1'</span> to <span class="built_in">enable</span> unlimited swap</span><br><span class="line">      --restart string             Restart policy to apply when a container exits</span><br></pre></td></tr></table></figure>

<h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p>阻塞容器的运行直到停止为止, 然后打印该容器的退出状态码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 终端1</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker container wait new-first-nginx2</span></span><br><span class="line"><span class="comment"># 终端被阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端2</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker container stop new-first-nginx2</span></span><br><span class="line">new-first-nginx2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端1</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker container wait new-first-nginx2</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="run"><a href="#run" class="headerlink" title="run"></a>run</h2><p>运行一个容器, 这个命令的参数非常多, 可以定制的属性也非常多, 常用参数如下</p>
<ul>
<li><code>-e</code>: 设置环境变量</li>
<li><code>-h</code>: 设置 hostname</li>
<li><code>-i</code>: 开放标准输入</li>
<li><code>-t</code>: 分配伪终端</li>
<li><code>-l</code>: 打标签</li>
<li><code>-p</code>: 指定映射出来的端口(可随机分配, 可以指定)</li>
<li><code>-P</code>: 映射容器内所有开放的端口(端口号随机分配)</li>
<li><code>-v</code>: 数据卷的挂载</li>
<li><code>--volumes-driver</code>: 指定存储引擎</li>
<li><code>-w</code>: 容器运行的工作目录</li>
<li><code>--restart</code>: 默认为 no, 容器异常退出后禁止自动重启<ul>
<li>设置为 <code>--restart=on-failure:10</code> , 意味对该容器的非0退出状态进行重启, 最多重启10次</li>
<li>设置为 <code>--restart=always</code> 始终重启</li>
</ul>
</li>
<li><code>--network</code>: 指定网络类型</li>
<li><code>--name</code>: 指定容器名称</li>
<li><code>--log-driver</code>: 指定日志引擎</li>
<li><code>--link</code>: 网络层连通指定容器</li>
<li><code>--dns</code>: 指定容器内使用的 DNS 服务器</li>
<li><code>--privileged</code>: 提权,在容器内获取扩展的执行权限</li>
<li><code>--add-host</code>: hosts 配置. 例如: <code>--add-host polarsnow:123.57.233.243</code></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>container</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker初体验</title>
    <url>/2017/04/15/Docker%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<blockquote>
<ul>
<li>bash 前台运行</li>
<li>容器持久运行的条件</li>
<li>nginx 后台运行</li>
<li>后台运行的条件</li>
<li>Docker数据存储的哲学</li>
<li>Docker使用的哲学</li>
</ul>
</blockquote>
<h1 id="前台运行容器"><a href="#前台运行容器" class="headerlink" title="前台运行容器"></a>前台运行容器</h1><h2 id="拉取-centos-镜像"><a href="#拉取-centos-镜像" class="headerlink" title="拉取 centos 镜像"></a>拉取 centos 镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker pull centos</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/centos</span><br><span class="line">93857f76ae30: Pull complete </span><br><span class="line">Digest: sha256:4eda692c08e0a065ae91d74e82fff4af3da307b4341ad61fa61771cc4659af60</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> centos:latest</span><br></pre></td></tr></table></figure>

<h2 id="查看镜像列表"><a href="#查看镜像列表" class="headerlink" title="查看镜像列表"></a>查看镜像列表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">centos              latest              a8493f5f50ff        33 hours ago        192MB</span><br><span class="line">nginx               latest              5766334bdaa0        37 hours ago        183MB</span><br><span class="line">hello-world         latest              48b5124b2768        2 months ago        1.84kB</span><br></pre></td></tr></table></figure>

<h2 id="以前台运行方式运行容器"><a href="#以前台运行方式运行容器" class="headerlink" title="以前台运行方式运行容器"></a>以前台运行方式运行容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --name "mycentos" -it centos /bin/bash</span></span><br><span class="line">[root@e4b1ccd2600b /]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<ul>
<li>run: 运行一个容器</li>
<li>—name “mycentos”: 给容器命名</li>
<li>-i: 打开容器的标准输入</li>
<li>-t: 分配一个伪终端 tty</li>
<li>centos: 镜像名</li>
<li>运行容器后执行的命令</li>
</ul>
<p>语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --help</span></span><br><span class="line"></span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br><span class="line"></span><br><span class="line">Run a <span class="built_in">command</span> <span class="keyword">in</span> a new container</span><br></pre></td></tr></table></figure>

<h1 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install dstat htop lsof curl wget lrzsz</span><br></pre></td></tr></table></figure>



<h2 id="退出终端-退出容器"><a href="#退出终端-退出容器" class="headerlink" title="退出终端/退出容器"></a>退出终端/退出容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@e4b1ccd2600b /]<span class="comment"># </span></span><br><span class="line">[root@e4b1ccd2600b /]<span class="comment"># exit</span></span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>随着终端的退出, 容器也随之退出</p>
<hr>
<h1 id="容器持久运行的条件"><a href="#容器持久运行的条件" class="headerlink" title="容器持久运行的条件"></a>容器持久运行的条件</h1><p><strong>阻塞!!!</strong></p>
<p>Docker 容器持久运行的基本条件是-进程的阻塞!</p>
<p>Docker 的哲学中, 主张一个容器只启动”一个进程”, 这里的一个进程可以理解为一个程序 或是一个主进程, 比如一个 Apache, 一个 Apache 可以启动一个主进程和若干个子进程.</p>
<p>如果想让 Docker 持久化运行, 那么在容器启动时, 必须有一个进程阻塞住终端. Docker 判断容器内服务是否正常的方式很简单, 就是判断最后阻塞的进程是否挂掉, 如果最后阻塞的进程挂掉, 那么容器退出. </p>
<p>Docker 认为, 容器即服务, 容器即程序, 一个容器就是一个程序, 如果一个容器内启动了多个服务, 比如 A, B 和 C服务, C 作为最后一个程序阻塞住容器使其运行起来, 此时, 如果容器内部的 A 或 B 服务挂掉, 容器仍然认为自己是正常的, 因为 Docker 只关心最后阻塞的进程是否退出. 反之, A 和 B 服务正常, 如果 C 服务挂掉, 那么则整个容器退出!</p>
<hr>
<h1 id="后台运行容器"><a href="#后台运行容器" class="headerlink" title="后台运行容器"></a>后台运行容器</h1><h2 id="获取-nginx-镜像"><a href="#获取-nginx-镜像" class="headerlink" title="获取 nginx 镜像"></a>获取 nginx 镜像</h2><p><a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
<p>右边是拉取 nginx latest 版本镜像的命令</p>
<p>左边 repo info 标签内是 nginx 简短说明/完整说明</p>
<p>完整说明中包括:</p>
<ul>
<li>版本的介绍</li>
<li>软件的介绍</li>
<li>使用方式的介绍</li>
</ul>
<p>左边 tag 是所有版本的列表</p>
<p><a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p>
<h2 id="下载最新稳定发行版的-nginx-镜像"><a href="#下载最新稳定发行版的-nginx-镜像" class="headerlink" title="下载最新稳定发行版的 nginx 镜像"></a>下载最新稳定发行版的 nginx 镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker pull nginx</span></span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/nginx</span><br><span class="line">6d827a3ef358: Pull complete </span><br><span class="line">f8f2e0556751: Pull complete </span><br><span class="line">5c9972dca3fd: Pull complete </span><br><span class="line">451b9524cb06: Pull complete </span><br><span class="line">Digest: sha256:e6693c20186f837fc393390135d8a598a96a833917917789d63766cab6c59582</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> nginx:latest</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="运行-nginx-镜像"><a href="#运行-nginx-镜像" class="headerlink" title="运行 nginx 镜像"></a>运行 nginx 镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先创建一个 web 目录</span></span><br><span class="line">root@ubuntu:~<span class="comment"># mkdir web</span></span><br><span class="line">root@ubuntu:~<span class="comment"># echo "Hello Docker" &gt; web/index.html</span></span><br><span class="line"><span class="comment"># 运行 nginx 镜像</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker run --name "my-first-nginx" -v /root/web:/usr/share/nginx/html:ro -d nginx</span></span><br><span class="line">11610baab1ce0b684367a44313fc0401489b115399f0a4469bec15bd4b8f6769</span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   6 seconds ago       Up 6 seconds        80/tcp, 443/tcp     my-first-nginx</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-v: 挂载卷  <code>宿主机目录:容器内目录:挂载方式</code>  其中挂载方式支持以只读<code>ro</code>或读写<code>rw</code>方式挂载, 默认为<code>rw</code></li>
<li>-d: 以守护进程<code>daemon</code>方式放入到后台运行</li>
</ul>
<p>此方式没有对外映射端口, 所以只能在容器内部访问</p>
<h3 id="在容器内部访问页面"><a href="#在容器内部访问页面" class="headerlink" title="在容器内部访问页面"></a>在容器内部访问页面</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入容器</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker exec -it 11610 /bin/bash</span></span><br><span class="line"><span class="comment"># 查看命令是否安装</span></span><br><span class="line">root@11610baab1ce:/<span class="comment"># curl</span></span><br><span class="line">bash: curl: <span class="built_in">command</span> not found</span><br><span class="line"><span class="comment"># 查看发行版</span></span><br><span class="line">root@11610baab1ce:/<span class="comment"># cat /etc/issue</span></span><br><span class="line">Debian GNU/Linux 8 \n \l</span><br><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">root@11610baab1ce:/<span class="comment"># apt install curl</span></span><br><span class="line"><span class="comment"># 测试页面</span></span><br><span class="line">root@11610baab1ce:/<span class="comment"># curl http://127.0.0.1</span></span><br><span class="line">Hello Docker</span><br></pre></td></tr></table></figure>



<h2 id="运行暴露端口的-nginx-镜像"><a href="#运行暴露端口的-nginx-镜像" class="headerlink" title="运行暴露端口的 nginx 镜像"></a>运行暴露端口的 nginx 镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --name "my-second-nginx" -v /root/web:/usr/share/nginx/html:ro -d -p 8800:80 nginx</span></span><br><span class="line">d0a4936e940e5d3b9e2d96be3b08133ddb7f5d9f9a28a81e3b99dff03fb1d747</span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                           NAMES</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   3 seconds ago       Up 2 seconds        443/tcp, 0.0.0.0:8800-&gt;80/tcp   my-second-nginx</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   12 minutes ago      Up 12 minutes       80/tcp, 443/tcp                 my-first-nginx</span><br><span class="line">root@ubuntu:~<span class="comment"># </span></span><br><span class="line">root@ubuntu:~<span class="comment"># curl http://127.0.0.1:8800</span></span><br><span class="line">Hello Docker</span><br></pre></td></tr></table></figure>

<ul>
<li>-p: 对外映射端口 <code>宿主机端口:容器内端口</code> </li>
</ul>
<h2 id="运行暴露多个端口的-nginx-镜像"><a href="#运行暴露多个端口的-nginx-镜像" class="headerlink" title="运行暴露多个端口的 nginx 镜像"></a>运行暴露多个端口的 nginx 镜像</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --name "my-third-nginx" -v /root/web:/usr/share/nginx/html:ro -d -p 8080:80 -p 443:443 nginx</span></span><br><span class="line">b9704931408c6d054bc9c510878e10467a71d412bef065afa7414403982001b6</span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                        NAMES</span><br><span class="line">b9704931408c        nginx               <span class="string">"nginx -g 'daemon ..."</span>   6 seconds ago       Up 6 seconds        0.0.0.0:443-&gt;443/tcp, 0.0.0.0:8080-&gt;80/tcp   my-third-nginx</span><br><span class="line">d0a4936e940e        nginx               <span class="string">"nginx -g 'daemon ..."</span>   3 minutes ago       Up 3 minutes        443/tcp, 0.0.0.0:8800-&gt;80/tcp                my-second-nginx</span><br><span class="line">11610baab1ce        nginx               <span class="string">"nginx -g 'daemon ..."</span>   15 minutes ago      Up 15 minutes       80/tcp, 443/tcp                              my-first-nginx</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h1 id="Docker-数据存储的哲学"><a href="#Docker-数据存储的哲学" class="headerlink" title="Docker 数据存储的哲学"></a>Docker 数据存储的哲学</h1><p>Docker 主张运行无状态的容器, 什么样的容器是无状态的容器呢?</p>
<p>打个比方: 以上面的 nginx 实例为例</p>
<ul>
<li>以如上方式<code>-v</code>挂载的方式即为有状态</li>
<li>以 dockerfile 的形式将数据目录预先拷贝到镜像的方式即为无状态</li>
</ul>
<p>也可以简单的理解为: </p>
<ul>
<li>镜像内包含数据且数据可随时随着镜像销毁的容器为无状态容器</li>
<li>镜像内只包含运行环境, 数据需要靠挂载目录的, 或是容器内数据不可随意销毁的容器为有状态容器</li>
</ul>
<p>这两种用法各有利弊, 直至现在也争论不休, 没有最好的使用方式, 只有最合适的使用方式(注意: 在集群中, 最好使用无状态的方式. 但是最新版本的 k8s 已经支持有状态容器集群)</p>
<h1 id="Docker-使用的哲学"><a href="#Docker-使用的哲学" class="headerlink" title="Docker 使用的哲学"></a>Docker 使用的哲学</h1><p>由于 Docker 容器的生命周期完全取决于最后阻塞容器入口的进程的存活状态, 所以在使用容器的时候, 一定要多加注意阻塞入口的进程和主进程的关系. 比如 node.js 容器, 在里面使用pm2 管理的 node 项目, 最后阻塞入口的进程是 pm2, 那么里面 node 项目的管理就脱离了容器的控制, 而由 pm2 去接管, 在node 进程出问题时也是由pm2去控制重启的. 在实际使用情况中, 一定要注意这样的使用方式会不会对后续的维护造成不便. 我推荐使用原生的命令启动主进程, 不要在主进程外面再套一层程序管理层.</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>快速安装Docker</title>
    <url>/2017/04/15/%E5%BF%AB%E9%80%9F%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h1 id="安装命令"><a href="#安装命令" class="headerlink" title="安装命令"></a>安装命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 公网通用</span></span><br><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 阿里云专用</span></span><br><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/intranet | sh -</span><br></pre></td></tr></table></figure>



<h1 id="安装完成后的结束信息"><a href="#安装完成后的结束信息" class="headerlink" title="安装完成后的结束信息:"></a>安装完成后的结束信息:</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span></span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">+ sh -c docker version</span><br><span class="line">Client:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Mon Apr  3 18:07:42 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line"> Version:      17.04.0-ce</span><br><span class="line"> API version:  1.28 (minimum version 1.12)</span><br><span class="line"> Go version:   go1.7.5</span><br><span class="line"> Git commit:   4845c56</span><br><span class="line"> Built:        Mon Apr  3 18:07:42 2017</span><br><span class="line"> OS/Arch:      linux/amd64</span><br><span class="line"> Experimental: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">If you would like to use Docker as a non-root user, you should now consider</span><br><span class="line">adding your user to the <span class="string">"docker"</span> group with something like:</span><br><span class="line"></span><br><span class="line">  sudo usermod -aG docker your-user</span><br><span class="line"></span><br><span class="line">Remember that you will have to <span class="built_in">log</span> out and back <span class="keyword">in</span> <span class="keyword">for</span> this to take effect!</span><br></pre></td></tr></table></figure>

<p>重点注意: <code>sudo usermod -aG docker your-user</code></p>
<p>在 Ubuntu 系统中, 使用普通用户登录的情况很多, 如果普通用户需要直接有权限控制 docker 所有的操作的话, 需要将该普通用户加入到 docker 组中.</p>
<p>Docker 是 C/S 架构, 一般情况下, C 和 S 是在安装在一台主机上的, 本地的 C 控制本地的 S, 后期控制大规模 Docker 的时候, 需要开放Docker API 来远程控制 Docker Server 端</p>
<h1 id="检查-Docker-运行状态"><a href="#检查-Docker-运行状态" class="headerlink" title="检查 Docker 运行状态"></a>检查 Docker 运行状态</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># systemctl status docker</span></span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Fri 2017-04-07 20:43:48 PDT; 9min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 4082 (dockerd)</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─4082 /usr/bin/dockerd -H fd://</span><br><span class="line">           └─4095 docker-containerd -l unix:///var/run/docker/libcontainerd/docker-containerd.sock --metri</span><br><span class="line"></span><br><span class="line">Apr 07 20:43:48 ubuntu dockerd[4082]: time=<span class="string">"2017-04-07T20:43:48.175051418-07:00"</span> level=warning msg=<span class="string">"Your k</span></span><br><span class="line"><span class="string">Apr 07 20:43:48 ubuntu dockerd[4082]: time="</span>2017-04-07T20:43:48.175185511-07:00<span class="string">" level=warning msg="</span>Your k</span><br><span class="line">Apr 07 20:43:48 ubuntu dockerd[4082]: time=<span class="string">"2017-04-07T20:43:48.175683715-07:00"</span> level=info msg=<span class="string">"Loading c</span></span><br><span class="line"><span class="string">Apr 07 20:43:48 ubuntu dockerd[4082]: time="</span>2017-04-07T20:43:48.228757745-07:00<span class="string">" level=info msg="</span>Firewalld</span><br><span class="line">Apr 07 20:43:48 ubuntu dockerd[4082]: time=<span class="string">"2017-04-07T20:43:48.327388388-07:00"</span> level=info msg=<span class="string">"Default b</span></span><br><span class="line"><span class="string">Apr 07 20:43:48 ubuntu dockerd[4082]: time="</span>2017-04-07T20:43:48.383792709-07:00<span class="string">" level=info msg="</span>Loading c</span><br><span class="line">Apr 07 20:43:48 ubuntu dockerd[4082]: time=<span class="string">"2017-04-07T20:43:48.420530516-07:00"</span> level=info msg=<span class="string">"Daemon ha</span></span><br><span class="line"><span class="string">Apr 07 20:43:48 ubuntu dockerd[4082]: time="</span>2017-04-07T20:43:48.420807227-07:00<span class="string">" level=info msg="</span>Docker da</span><br><span class="line">Apr 07 20:43:48 ubuntu systemd[1]: Started Docker Application Container Engine.</span><br><span class="line">Apr 07 20:43:48 ubuntu dockerd[4082]: time=<span class="string">"2017-04-07T20:43:48.434958396-07:00"</span> level=info msg=<span class="string">"API liste</span></span><br><span class="line"><span class="string">lines 1-19/19 (END)</span></span><br></pre></td></tr></table></figure>



<h2 id="操作-Docker-进程"><a href="#操作-Docker-进程" class="headerlink" title="操作 Docker 进程"></a>操作 Docker 进程</h2><ul>
<li>关闭 Docker 服务 <code>systemctl stop docker</code></li>
<li>重启 Docker 服务 <code>systemctl restart docker</code></li>
<li>开启 Docker 服务 <code>systemctl start docker</code></li>
<li>开机启动 Docker <code>systemctl enable docker</code></li>
</ul>
<h1 id="检查-Docker-服务"><a href="#检查-Docker-服务" class="headerlink" title="检查 Docker 服务"></a>检查 Docker 服务</h1><ul>
<li>Docker 服务运行正常的回显</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker info</span></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.04.0-ce</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 0</span><br><span class="line"> Dirperm1 Supported: <span class="literal">true</span></span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins: </span><br><span class="line"> Volume: <span class="built_in">local</span></span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: </span><br><span class="line">containerd version: 422e31ce907fd9c3833a38d7b8fdd023e5a76e73</span><br><span class="line">runc version: 9c2d8d184e5da67c95d601382adf14862e4f2228</span><br><span class="line">init version: 949e6fa</span><br><span class="line">Security Options:</span><br><span class="line"> apparmor</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.4.0-21-generic</span><br><span class="line">Operating System: Ubuntu 16.04 LTS</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 975.1MiB</span><br><span class="line">Name: ubuntu</span><br><span class="line">ID: VK2Y:PFFS:OEDA:7RIL:PLF5:SA4F:RJNS:7VEF:ODLG:LX6M:OVY4:BECX</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): <span class="literal">false</span></span><br><span class="line">Debug Mode (server): <span class="literal">false</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Experimental: <span class="literal">false</span></span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Live Restore Enabled: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support</span><br></pre></td></tr></table></figure>

<ul>
<li>Docker 服务运行异常的回显(普通用户如果没有加入到 docker 组中, 执行 docker 命令也会出现以下的报错)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker info</span></span><br><span class="line">Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</span><br></pre></td></tr></table></figure>

<ul>
<li>还有一种情况, 可能由于某些原因导致终端阻塞, 大多数情况下, 即使使用 <code>systemctl</code> 关闭 Docker 服务也无法正常关闭, 只能重启服务器宿主机</li>
</ul>
<h1 id="Docker-信息解读"><a href="#Docker-信息解读" class="headerlink" title="Docker 信息解读"></a>Docker 信息解读</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker info</span></span><br><span class="line">Containers: 0   <span class="comment"># 总容器数量</span></span><br><span class="line"> Running: 0     <span class="comment"># 运行中的容器数量</span></span><br><span class="line"> Paused: 0      <span class="comment"># 暂停的容器数量</span></span><br><span class="line"> Stopped: 0     <span class="comment"># 停止的容器数量</span></span><br><span class="line">Images: 0       <span class="comment"># 总镜像数量</span></span><br><span class="line">Server Version: 17.04.0-ce      <span class="comment"># Docker Server 版本</span></span><br><span class="line">Storage Driver: aufs            <span class="comment"># 存储引擎</span></span><br><span class="line"> Root Dir: /var/lib/docker/aufs <span class="comment"># 存储引擎根目录</span></span><br><span class="line"> Backing Filesystem: extfs      <span class="comment"># 后端文件系统类型</span></span><br><span class="line"> Dirs: 0                        <span class="comment"># aufs 的属性</span></span><br><span class="line"> Dirperm1 Supported: <span class="literal">true</span>       <span class="comment"># aufs 的属性</span></span><br><span class="line">Logging Driver: json-file       <span class="comment"># 日志引擎</span></span><br><span class="line">Cgroup Driver: cgroupfs         <span class="comment"># Cgroup 引擎</span></span><br><span class="line">Plugins:        <span class="comment"># 插件信息</span></span><br><span class="line"> Volume: <span class="built_in">local</span>  <span class="comment"># 数据卷插件</span></span><br><span class="line"> Network: bridge host macvlan null overlay <span class="comment"># 网络插件</span></span><br><span class="line">Swarm: inactive <span class="comment"># swarmkit 模式状态</span></span><br><span class="line">Runtimes: runc  <span class="comment"># 容器执行引擎</span></span><br><span class="line">Default Runtime: runc           <span class="comment"># 默认容器执行引擎</span></span><br><span class="line">Init Binary: </span><br><span class="line">containerd version: 422e31ce907fd9c3833a38d7b8fdd023e5a76e73</span><br><span class="line">runc version: 9c2d8d184e5da67c95d601382adf14862e4f2228</span><br><span class="line">init version: 949e6fa</span><br><span class="line">Security Options:       <span class="comment"># 安全项</span></span><br><span class="line"> apparmor       <span class="comment"># Linux内核中的强制访问控制系统</span></span><br><span class="line"> seccomp        <span class="comment"># Linux kernel(2.6.23版本之后)所支持的一种简洁的沙箱机制</span></span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.4.0-21-generic    <span class="comment"># 宿主机内核版本</span></span><br><span class="line">Operating System: Ubuntu 16.04 LTS  <span class="comment"># 宿主机系统发行版</span></span><br><span class="line">OSType: linux           <span class="comment"># 宿主机系统类型</span></span><br><span class="line">Architecture: x86_64    <span class="comment"># 宿主机 CPU 架构</span></span><br><span class="line">CPUs: 1                 <span class="comment"># 宿主机总 CPU 容量</span></span><br><span class="line">Total Memory: 975.1MiB  <span class="comment"># 宿主机总内存容量</span></span><br><span class="line">Name: ubuntu            <span class="comment"># 宿主机系统名称</span></span><br><span class="line">ID: VK2Y:PFFS:OEDA:7RIL:PLF5:SA4F:RJNS:7VEF:ODLG:LX6M:OVY4:BECX</span><br><span class="line">Docker Root Dir: /var/lib/docker    <span class="comment"># Docker 家目录</span></span><br><span class="line">Debug Mode (client): <span class="literal">false</span>          <span class="comment"># 客户端是否开启 debug 模式</span></span><br><span class="line">Debug Mode (server): <span class="literal">false</span>          <span class="comment"># 服务端是否开启 debug 模式</span></span><br><span class="line">Registry: https://index.docker.io/v1/   <span class="comment"># 默认仓库地址</span></span><br><span class="line">Experimental: <span class="literal">false</span>     <span class="comment"># 是否是体验版 Docker(edge)</span></span><br><span class="line">Insecure Registries:    <span class="comment"># 不安全的仓库</span></span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Live Restore Enabled: <span class="literal">false</span>  <span class="comment"># 在线恢复/热恢复</span></span><br><span class="line"></span><br><span class="line">WARNING: No swap <span class="built_in">limit</span> support  <span class="comment"># cgroups中的swap account没有开启</span></span><br></pre></td></tr></table></figure>

<p>注意: 生产环境中, 依据自己的需要, 可以适当调整<code>swap limit support</code>的支持情况. </p>
<p>宁宕勿慢, 宁慢勿宕, 两个考量系统健壮性的思路, 没有最好的方案, 各有利弊, 需要综合自己的实际情况考量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Edit the /etc/default/grub file.</span><br><span class="line">Set the GRUB_CMDLINE_LINUX value as follows:</span><br><span class="line"></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"cgroup_enable=memory swapaccount=1"</span></span><br><span class="line">Save and close the file.</span><br><span class="line"></span><br><span class="line">Update GRUB.</span><br><span class="line"></span><br><span class="line">$ sudo update-grub</span><br><span class="line">Reboot your system.</span><br></pre></td></tr></table></figure>



<h1 id="运行-hello-word容器"><a href="#运行-hello-word容器" class="headerlink" title="运行 hello word容器"></a>运行 hello word容器</h1><h2 id="添加代理仓库-daocloud"><a href="#添加代理仓库-daocloud" class="headerlink" title="添加代理仓库-daocloud"></a>添加代理仓库-daocloud</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://172d594a.m.daocloud.io</span></span><br><span class="line">docker version &gt;= 1.12</span><br><span class="line">&#123;<span class="string">"registry-mirrors"</span>: [<span class="string">"http://172d594a.m.daocloud.io"</span>]&#125;</span><br><span class="line">Success.</span><br><span class="line">You need to restart docker to take effect: sudo systemctl restart docker.service</span><br><span class="line">root@ubuntu:~<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>



<h2 id="查看代理信息"><a href="#查看代理信息" class="headerlink" title="查看代理信息"></a>查看代理信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker info</span></span><br><span class="line">Containers: 0</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 17.04.0-ce</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 0</span><br><span class="line"> Dirperm1 Supported: <span class="literal">true</span></span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins: </span><br><span class="line"> Volume: <span class="built_in">local</span></span><br><span class="line"> Network: bridge host macvlan null overlay</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: </span><br><span class="line">containerd version: 422e31ce907fd9c3833a38d7b8fdd023e5a76e73</span><br><span class="line">runc version: 9c2d8d184e5da67c95d601382adf14862e4f2228</span><br><span class="line">init version: 949e6fa</span><br><span class="line">Security Options:</span><br><span class="line"> apparmor</span><br><span class="line"> seccomp</span><br><span class="line">  Profile: default</span><br><span class="line">Kernel Version: 4.4.0-21-generic</span><br><span class="line">Operating System: Ubuntu 16.04 LTS</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 1</span><br><span class="line">Total Memory: 975.1MiB</span><br><span class="line">Name: ubuntu</span><br><span class="line">ID: VK2Y:PFFS:OEDA:7RIL:PLF5:SA4F:RJNS:7VEF:ODLG:LX6M:OVY4:BECX</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): <span class="literal">false</span></span><br><span class="line">Debug Mode (server): <span class="literal">false</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Experimental: <span class="literal">false</span></span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br><span class="line">Registry Mirrors:       <span class="comment"># 镜像代理</span></span><br><span class="line"> http://172d594a.m.daocloud.io/</span><br><span class="line">Live Restore Enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure>



<h2 id="运行-hello-world-容器"><a href="#运行-hello-world-容器" class="headerlink" title="运行 hello-world 容器"></a>运行 hello-world 容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run hello-world</span></span><br><span class="line">Unable to find image <span class="string">'hello-world:latest'</span> locally   <span class="comment"># 在本地没有找到该镜像</span></span><br><span class="line">latest: Pulling from library/hello-world        <span class="comment"># 在远程仓库中查找镜像</span></span><br><span class="line">78445dd45222: Pull complete         <span class="comment"># 拉取镜像</span></span><br><span class="line">Digest: sha256:c5515758d4c5e1e838e9cd307f6c6a0d620b5e07e6f927b07d05f6d12a1ac8d7</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest <span class="comment"># 镜像拉取完毕</span></span><br><span class="line"><span class="comment">#  ------以下内容是运行容器时打印到屏幕的内容------</span></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the <span class="string">"hello-world"</span> image from the Docker Hub.</span><br><span class="line"> 3. The Docker daemon created a new container from that image <span class="built_in">which</span> runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, <span class="built_in">which</span> sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://cloud.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/engine/userguide/</span><br></pre></td></tr></table></figure>



<h1 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h1><h2 id="查看运行状态的容器"><a href="#查看运行状态的容器" class="headerlink" title="查看运行状态的容器"></a>查看运行状态的容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<p>查看所有状态的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">9c6fd12bef22        hello-world         <span class="string">"/hello"</span>            4 minutes ago       Exited (0) 4 minutes ago                       wizardly_mccarthy</span><br><span class="line">root@ubuntu:~<span class="comment">#</span></span><br></pre></td></tr></table></figure>



<h1 id="更改容器名称"><a href="#更改容器名称" class="headerlink" title="更改容器名称"></a>更改容器名称</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~<span class="comment"># docker run --name "sayHi" hello-world</span></span><br><span class="line">root@ubuntu:~<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">a74123af6f47        hello-world         <span class="string">"/hello"</span>            5 seconds ago       Exited (0) 4 seconds ago                       sayHi</span><br><span class="line">9c6fd12bef22        hello-world         <span class="string">"/hello"</span>            7 minutes ago       Exited (0) 7 minutes ago                       wizardly_mccarthy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx配置http强制跳转https</title>
    <url>/2017/04/01/nginx%E9%85%8D%E7%BD%AEhttp%E5%BC%BA%E5%88%B6%E8%B7%B3%E8%BD%AChttps/</url>
    <content><![CDATA[<blockquote>
<p>很多网站虽然支持 https, 但是直接在浏览器地址栏输入网址后, 默认仍是以 http 协议去访问的, http 强制跳转 https 的需求应运而生, 以下介绍三种实现的方式</p>
</blockquote>
<h1 id="rewrite-方法"><a href="#rewrite-方法" class="headerlink" title="rewrite 方法"></a>rewrite 方法</h1><p>这是最常用的实现方法, 将所有 http 请求通过 rewrite 重定向到 https 即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen  80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">      </span><br><span class="line">    rewrite ^(.*)$  https:&#x2F;&#x2F;$host$1 permanent;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="497-状态码"><a href="#497-状态码" class="headerlink" title="497 状态码"></a>497 状态码</h1><p>error code 497: normal request was sent to HTTPS</p>
<p>在一个站点只允许 https 访问时, 如果使用 http 访问会报出497错误码</p>
<p>利用497状态码重定向到 https</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io</span><br><span class="line">    </span><br><span class="line">    error_page 497  https:&#x2F;&#x2F;$host$uri?$args;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="index-html-刷新网页"><a href="#index-html-刷新网页" class="headerlink" title="index.html 刷新网页"></a>index.html 刷新网页</h1><p>上面两种方法均会耗费服务器资源, 我们使用 <code>curl</code> 来看下百度是如何实现的 <code>baidu.com</code> 向 <code>www.baidu.com</code> 的跳转</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl baidu.com -vv </span><br><span class="line">* Rebuilt URL to: baidu.com/</span><br><span class="line">*   Trying 220.181.57.217...</span><br><span class="line">* TCP_NODELAY <span class="built_in">set</span></span><br><span class="line">* Connected to baidu.com (220.181.57.217) port 80 (<span class="comment">#0)</span></span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/7.51.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt; </span><br><span class="line">&lt; HTTP/1.1 200 OK</span><br><span class="line">&lt; Date: Sat, 01 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Server: Apache</span><br><span class="line">&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT</span><br><span class="line">&lt; ETag: <span class="string">"51-47cf7e6ee8400"</span></span><br><span class="line">&lt; Accept-Ranges: bytes</span><br><span class="line">&lt; Content-Length: 81</span><br><span class="line">&lt; Cache-Control: max-age=86400</span><br><span class="line">&lt; Expires: Sun, 02 Apr 2017 06:32:35 GMT</span><br><span class="line">&lt; Connection: Keep-Alive</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; </span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"refresh"</span> content=<span class="string">"0;url=http://www.baidu.com/"</span>&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Curl_http_done: called premature == 0</span><br><span class="line">* Connection <span class="comment">#0 to host baidu.com left intact</span></span><br></pre></td></tr></table></figure>

<p>可以看到百度很巧妙的利用meta的刷新作用，将baidu.com跳转到<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>同理, 我们也可以用这个特性来实现 http 向 https 的跳转</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># index.html</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"0;url=https://docs.lvrui.io/"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 将 index.html 文件放到下面的目录下</span><br><span class="line">        root &#x2F;var&#x2F;www&#x2F;html&#x2F;refresh&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name docs.lvrui.io;</span><br><span class="line">    index index.html index.htm;</span><br><span class="line">    access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;docs.log  main;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.crt;</span><br><span class="line">    ssl_certificate_key  &#x2F;etc&#x2F;ssl&#x2F;docs.20150509.cn.key;</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">	    root &#x2F;var&#x2F;www&#x2F;html&#x2F;docs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>https</tag>
        <tag>rewrite</tag>
      </tags>
  </entry>
  <entry>
    <title>找回Jenkins密码</title>
    <url>/2017/04/01/%E6%89%BE%E5%9B%9EJenkins%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>通过修改 Jenkins 的配置文件, 将登录需要密码验证的功能临时取消, 重启 Jenkins, 无密码登录后再修改对应用户的密码, 最后可以改回密码验证模式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入 Jenkins 家目录</span></span><br><span class="line">$ <span class="built_in">cd</span> /var/lib/jenkins/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份配置文件</span></span><br><span class="line">$ cp config.xml config.xml.20170401</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim config.xml</span><br><span class="line"></span><br><span class="line">&lt;useSecurity&gt;<span class="literal">true</span>&lt;/useSecurity&gt;  </span><br><span class="line"><span class="comment"># 修改成  </span></span><br><span class="line">&lt;useSecurity&gt;<span class="literal">false</span>&lt;/useSecurity&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 Jenkins 即可无密码登录</span></span><br><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux中搭建点对点IPsec隧道</title>
    <url>/2017/03/31/%E5%9C%A8Linux%E4%B8%AD%E6%90%AD%E5%BB%BA%E7%82%B9%E5%AF%B9%E7%82%B9IPsec%E9%9A%A7%E9%81%93/</url>
    <content><![CDATA[<blockquote>
<p>隧道技术近年来多用于实现混合云的场景, 实现云环境到自己的 IDC 机房, A 云到 B 云等需求.本篇文档主要介绍两个云之间, 使用 Linux 服务器做对接的情况. </p>
</blockquote>
<p>具体原理这里不讲, 主要讲具体搭建步骤, 这里我准备了两个脚本来搭建隧道环境</p>
<p><strong>configIPsec.sh</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装软件</span></span><br><span class="line">yum install -y openswan lsof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置内核参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span><span class="string">"net.ipv4.tcp_syncookies = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_tw_reuse = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_tw_recycle = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_fin_timeout = 30</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">net.ipv6.conf.all.disable_ipv6 = 1</span></span><br><span class="line"><span class="string">net.ipv6.conf.default.disable_ipv6 = 1</span></span><br><span class="line"><span class="string">net.ipv6.conf.lo.disable_ipv6 = 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">vm.swappiness = 0</span></span><br><span class="line"><span class="string">net.ipv4.neigh.default.gc_stale_time = 120</span></span><br><span class="line"><span class="string">net.ipv4.conf.all.rp_filter = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.rp_filter = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.arp_announce = 2</span></span><br><span class="line"><span class="string">net.ipv4.conf.lo.arp_announce = 2</span></span><br><span class="line"><span class="string">net.ipv4.conf.all.arp_announce = 2</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_tw_buckets = 5000</span></span><br><span class="line"><span class="string">net.ipv4.tcp_syncookies = 1</span></span><br><span class="line"><span class="string">net.ipv4.tcp_max_syn_backlog = 1024</span></span><br><span class="line"><span class="string">net.ipv4.tcp_synack_retries = 2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">net.ipv4.conf.all.accept_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.all.send_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.accept_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.send_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.eth0.accept_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.eth0.send_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.lo.accept_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.lo.send_redirects = 0</span></span><br><span class="line"><span class="string">net.ipv4.conf.default.rp_filter=0</span></span><br><span class="line"><span class="string">net.ipv4.conf.eth0.rp_filter=0</span></span><br><span class="line"><span class="string">#net.ipv4.conf.ip_vti0.rp_filter=0</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward = 1"</span><span class="string">""</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让配置的内核参数立即生效</span></span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 ipsec 服务</span></span><br><span class="line">systemctl restart ipsec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 休眠2秒是为了让 udp 4500 和 500端口正常监听</span></span><br><span class="line">sleep 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境是否符合要求</span></span><br><span class="line">ipsec verify</span><br></pre></td></tr></table></figure>

<p>在执行 <code>ipsec verify</code> 命令后, 必须保证如下回显中所有的状态均为绿色 (Hardware random device 可以为[N/A]; Opportunistic Encryption 可以为 [DISABLE]; 其他均为 ok)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@99-5 ~]<span class="comment"># ipsec verify</span></span><br><span class="line">Verifying installed system and configuration files</span><br><span class="line"></span><br><span class="line">Version check and ipsec on-path                         [OK]</span><br><span class="line">Libreswan 3.15 (netkey) on 3.10.0-327.18.2.el7.x86_64</span><br><span class="line">Checking <span class="keyword">for</span> IPsec support <span class="keyword">in</span> kernel                    [OK]</span><br><span class="line"> NETKEY: Testing XFRM related proc values</span><br><span class="line">         ICMP default/send_redirects                    [OK]</span><br><span class="line">         ICMP default/accept_redirects                  [OK]</span><br><span class="line">         XFRM larval drop                               [OK]</span><br><span class="line">Pluto ipsec.conf syntax                                 [OK]</span><br><span class="line">Hardware random device                                  [N/A]</span><br><span class="line">Two or more interfaces found, checking IP forwarding    [OK]</span><br><span class="line">Checking rp_filter                                      [OK]</span><br><span class="line">Checking that pluto is running                          [OK]</span><br><span class="line"> Pluto listening <span class="keyword">for</span> IKE on udp 500                     [OK]</span><br><span class="line"> Pluto listening <span class="keyword">for</span> IKE/NAT-T on udp 4500              [OK]</span><br><span class="line"> Pluto ipsec.secret syntax                              [OK]</span><br><span class="line">Checking <span class="string">'ip'</span> <span class="built_in">command</span>                                   [OK]</span><br><span class="line">Checking <span class="string">'iptables'</span> <span class="built_in">command</span>                             [OK]</span><br><span class="line">Checking <span class="string">'prelink'</span> <span class="built_in">command</span> does not interfere with FIPSChecking <span class="keyword">for</span> obsolete ipsec.conf options                 [OK]</span><br><span class="line">Opportunistic Encryption                                [DISABLED]</span><br></pre></td></tr></table></figure>

<p>保证上面的环境检查通过后, 执行如下脚本 <code>configTunnel.sh</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 对端网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对端公网 IP</span></span><br><span class="line">ip_remote=<span class="string">"59.110.174.253"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对端内网网段</span></span><br><span class="line">ip_remote_vlan=<span class="string">"192.168.20.0/24"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 本端网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取公网 IP</span></span><br><span class="line">ip_public=`curl http://members.3322.org/dyndns/getip`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取内网 IP</span></span><br><span class="line">ip_private=`ifconfig  | grep <span class="string">"inet"</span> | grep <span class="string">"192.168"</span> | awk <span class="string">'&#123;print $2&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取内网 IP 的第三段作为隧道名和配置文件名字的一部分</span></span><br><span class="line">net_vlan=`ifconfig  | grep <span class="string">"inet"</span> | grep <span class="string">"192.168"</span> | awk <span class="string">'&#123;print $2&#125;'</span> | awk -F <span class="string">"."</span> <span class="string">'&#123;print $3&#125;'</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地网段</span></span><br><span class="line">subnet=<span class="string">"192.168.59.0/24"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 秘钥</span></span><br><span class="line">token=<span class="string">"20150509"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### 配置文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改 ipsec 配置文件</span></span><br><span class="line">sed -i <span class="string">'s/#version 2/version 2/g'</span> /etc/ipsec.conf </span><br><span class="line">sed -i <span class="string">'/protostack=netkey/a\        nat_traversal=yes\n        oe=off'</span> /etc/ipsec.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建隧道配置文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span><span class="string">"conn tunnel<span class="variable">$net_vlan</span></span></span><br><span class="line"><span class="string">        ike=3des-sha</span></span><br><span class="line"><span class="string">        authby=secret</span></span><br><span class="line"><span class="string">        phase2=esp</span></span><br><span class="line"><span class="string">        phase2alg=3des-sha</span></span><br><span class="line"><span class="string">        compress=no</span></span><br><span class="line"><span class="string">        pfs=yes</span></span><br><span class="line"><span class="string">        type=tunnel</span></span><br><span class="line"><span class="string">        left=<span class="variable">$ip_private</span></span></span><br><span class="line"><span class="string">        leftid=<span class="variable">$ip_public</span></span></span><br><span class="line"><span class="string">        leftsubnet=<span class="variable">$subnet</span></span></span><br><span class="line"><span class="string">        leftnexthop=%defaultroute</span></span><br><span class="line"><span class="string">        right=<span class="variable">$ip_remote</span></span></span><br><span class="line"><span class="string">        rightid=<span class="variable">$ip_remote</span></span></span><br><span class="line"><span class="string">        rightsubnet=<span class="variable">$ip_remote_vlan</span></span></span><br><span class="line"><span class="string">        rightnexthop=%defaultroute</span></span><br><span class="line"><span class="string">        auto=start"</span><span class="string">""</span> &gt;&gt; /etc/ipsec.d/tunnel<span class="string">"<span class="variable">$net_vlan</span>"</span>.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置秘钥认证</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"0.0.0.0 <span class="variable">$ip_remote</span>: PSK \"<span class="variable">$token</span>\""</span> &gt;&gt; /etc/ipsec.secrets </span><br><span class="line"></span><br><span class="line">systemctl restart ipsec</span><br></pre></td></tr></table></figure>

<p>配置完毕后, 启动该条隧道</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ipsec auto --up tunnelName</span><br></pre></td></tr></table></figure>

<p><em>注意: 这里的 tunnelName 是上面的脚本中根据网段序号生成的, 换成上面生成的隧道名即可</em></p>
<hr>
<p>单边配置好后, 在对端以同样的方式配置并启动隧道即可</p>
<hr>
<p>参考文档:</p>
<p><a href="http://blog.leanote.com/post/251689658@qq.com/阿里云openwan与网康实现IPsec对接" target="_blank" rel="noopener">http://blog.leanote.com/post/251689658@qq.com/阿里云openwan与网康实现IPsec对接</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IPsec</tag>
        <tag>隧道</tag>
      </tags>
  </entry>
  <entry>
    <title>Install Docker From Ali Mirror</title>
    <url>/2017/03/21/Install-Docker-From-Ali-Mirror/</url>
    <content><![CDATA[<blockquote>
<p>虽然前面介绍了多种系统上的安装方式, 但是有一点避不开的就是伟大的长城防🔥墙, 即使是在生产环境,  从官方源安装 Docker也是一件痛苦的事情, 解决这个问题的思路无非就两种. 一种是我们自己在内网维护一套 Docker 的软件源. 另一种就是用其他人在🇨🇳搭建的 Docker 源. 本篇文件就介绍如果通过阿里的 Docker 软件源来解决国内 Docker 的安装问题</p>
</blockquote>
<p>阿里镜像网站官方地址: &lt; <a href="http://mirrors.aliyun.com/help/docker-engine" target="_blank" rel="noopener">docker-engine</a> &gt;</p>
<p>阿里很贴心的不仅提供了国内的镜像源, 而且还提供了一键安装脚本, 该脚本在我的 Ubuntu16.04 和 Fedora 25 上通过了测试. </p>
<p>阿里官方提供以下系统安装 Docker 的支持</p>
<ul>
<li>Ubuntu 14.04 16.04</li>
</ul>
<ul>
<li>Debian 7.7 8.0</li>
<li>CentOS 7</li>
<li>Fedora 20 21 22</li>
<li>Oracle Linux 6 7</li>
</ul>
<p>安装方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh -</span><br></pre></td></tr></table></figure>

<p>阿里云主机内网安装方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/intranet | sh -</span><br></pre></td></tr></table></figure>

<p>执行完上面的命令后即安装完成, 最后我们 看下, 上面的脚本是怎么帮我们配置 yum/dnf 源的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@191 yum.repos.d]<span class="comment"># cat docker-main.repo </span></span><br><span class="line">[docker-main-repo]</span><br><span class="line">name=Docker main Repository</span><br><span class="line">baseurl=http://mirrors.aliyun.com/docker-engine/yum/repo/main/fedora/25</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/docker-engine/yum/gpg</span><br></pre></td></tr></table></figure>

<p>以上是我在<code>Fedora 25</code>上执行安装 Docker 的脚本后的软件源配置</p>
<hr>
<p><strong>更新</strong></p>
<p>在Docker区分CE版本和EE版本之后, 阿里原有的安装镜像网站已不再提供支持, 最新的地址如下:</p>
<ul>
<li><a href="https://yq.aliyun.com/articles/110806" target="_blank" rel="noopener">https://yq.aliyun.com/articles/110806</a></li>
</ul>
<p>可以根据自己的需求安装对应的版本</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Mirror</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker For Fedora</title>
    <url>/2017/03/21/Docker-For-Fedora/</url>
    <content><![CDATA[<blockquote>
<p>熟悉 RHEL 和 CentOS 的亲一定也听说过 Fedora 发行版, 相比于”精仿版”的 CentOS, Fedora 更像是 RHEL 的近亲, 甚至是亲儿子的地位. 在 RHEL 上不支持 Docker CE 不说, 在 CentOS 上还依旧使用了 3.10+这样古老级的内核版本. 直接导致 Docker 的一些最新特性无法在该内核版本上实现. 顺理成章的 Fedora Server 版成了完美体验 Docker 的最佳”RHEL” 平台</p>
</blockquote>
<p>本篇文章只介绍 Docker CE 版本在  Fedora 系统中的部署</p>
<h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul>
<li>64bit Fedora 24 Server</li>
</ul>
<ul>
<li>64bit Fedora 25 Server</li>
</ul>
<h2 id="卸载老版本-Docker-Engine"><a href="#卸载老版本-Docker-Engine" class="headerlink" title="卸载老版本 Docker Engine"></a>卸载老版本 Docker Engine</h2><p>老版本的 Docker 被叫做 <code>docker</code> 或 <code>docker-engine</code> 如果系统当前有这些版本的系统, 那么你需要先卸载他们 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  container-selinux \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>需要 <code>dnf</code> 命令的回显显示没有相关的软件包被安装</p>
<p>在 <code>/var/lib/docker</code> 目录下, 包含了<code>镜像</code>, <code>容器</code>, <code>数据卷</code>和 <code>网络配置</code></p>
<p><em>说明: 在 Fedora 中, 软件包管理器早就已经变成使用 dnf 管理了, 你仍旧可以使用 yum 命令, 但是最终还是会被重定向到 dnf. 值得欣慰的是 dnf 的用法和 yum 的用法几乎是完全一样的, 就连软件源配置文件的位置和格式也是通用的</em></p>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="从软件源中安装-Docker"><a href="#从软件源中安装-Docker" class="headerlink" title="从软件源中安装 Docker"></a>从软件源中安装 Docker</h3><h4 id="配置软件仓库-Docker-CE"><a href="#配置软件仓库-Docker-CE" class="headerlink" title="配置软件仓库 Docker-CE"></a>配置软件仓库 Docker-CE</h4><ul>
<li>安装 <code>dnf-plugins-core</code> 工具集, 以提供 <code>dnf config-manager</code>命令的支持</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf -y install dnf-plugins-core</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 Docker 软件源 (Stable)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/fedora/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>开启/关闭 开发版(edge) Docker 软件源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf config-manager --<span class="built_in">enable</span> docker-ce-edge</span><br><span class="line">$ sudo dnf config-manager --<span class="built_in">disable</span> docker-ce-edge</span><br></pre></td></tr></table></figure>

<h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><ul>
<li>更新软件源索引</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf makecache fast</span><br></pre></td></tr></table></figure>

<p>接受 GPG key</p>
<ul>
<li>安装 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf install docker-ce  <span class="comment"># 安装最新版本</span></span><br><span class="line">$ sudo dnf -y install docker-ce-&lt;VERSION&gt;  <span class="comment"># 安装指定版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker EE 正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<ul>
<li>升级 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf makecache fast</span><br><span class="line">$ sudo dnf update docker-ce <span class="comment"># sudo dnf upgrade docker-ce 两者等价</span></span><br></pre></td></tr></table></figure>


<h3 id="使用软件包直接安装"><a href="#使用软件包直接安装" class="headerlink" title="使用软件包直接安装"></a>使用软件包直接安装</h3><ul>
<li>下载对应版本的 <code>.rpm</code> 软件包</li>
</ul>
<p>Docker CE: Go to <a href="https://download.docker.com/linux/fedora/7/x86_64/stable/" target="_blank" rel="noopener">https://download.docker.com/linux/fedora/7/x86_64/stable/</a>  and download the <code>.rpm</code></p>
<ul>
<li>安装软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf -y install /path/to/package.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 Docker 服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker 服务正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="卸载-Docker-CE"><a href="#卸载-Docker-CE" class="headerlink" title="卸载 Docker CE"></a>卸载 Docker CE</h2><ul>
<li>卸载 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dnf remove docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像/容器/数据卷和自定义配置文件不会随着卸载而自动删除, 你需要手动去清除他们</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<hr>
<p>参考官方文档:</p>
<ul>
<li><a href="https://docs.docker.com/engine/installation/linux/fedora/" target="_blank" rel="noopener">Get Docker for Fedora - Docker Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker For CentOS</title>
    <url>/2017/03/21/Docker-For-CentOS/</url>
    <content><![CDATA[<blockquote>
<p>CentOS是 RHEL 的近亲, 在于对 Docker 的支持方面, CentOS 要比 RHEL 好一些, 至少, CentOS 支持 Docker CE 版本的部署. 在实际生产环境中, CentOS 服务器占有很大的比重, 但是如果需要在 CentOS 系统中使用 Docker, 比较推荐将内核升级到4.0+</p>
</blockquote>
<p>本篇文章只介绍 Docker CE 版本在 CentOS 系统中的部署</p>
<h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul>
<li>64bit CentOS 7</li>
</ul>
<h2 id="卸载老版本-Docker-Engine"><a href="#卸载老版本-Docker-Engine" class="headerlink" title="卸载老版本 Docker Engine"></a>卸载老版本 Docker Engine</h2><p>老版本的 Docker 被叫做 <code>docker</code> 或 <code>docker-engine</code> 如果系统当前有这些版本的系统, 那么你需要先卸载他们 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  container-selinux \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>需要 <code>yum</code> 命令的回显显示没有相关的软件包被安装</p>
<p>在 <code>/var/lib/docker</code> 目录下, 包含了<code>镜像</code>, <code>容器</code>, <code>数据卷</code>和 <code>网络配置</code></p>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="从软件源中安装-Docker"><a href="#从软件源中安装-Docker" class="headerlink" title="从软件源中安装 Docker"></a>从软件源中安装 Docker</h3><h4 id="配置软件仓库-Docker-CE"><a href="#配置软件仓库-Docker-CE" class="headerlink" title="配置软件仓库 Docker-CE"></a>配置软件仓库 Docker-CE</h4><ul>
<li>安装 <code>yum-utils</code> 工具集, 以提供 <code>yum-config-manager</code>命令的支持</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 Docker 软件源 (Stable)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>开启/关闭 开发版(edge) Docker 软件源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager --<span class="built_in">enable</span> docker-ce-edge</span><br><span class="line">$ sudo yum-config-manager --<span class="built_in">disable</span> docker-ce-edge</span><br></pre></td></tr></table></figure>

<h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><ul>
<li>更新软件源索引</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br></pre></td></tr></table></figure>

<p>接受 GPG key</p>
<ul>
<li>安装 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install docker-ce  <span class="comment"># 安装最新版本</span></span><br><span class="line">$ sudo yum install docker-ce-&lt;VERSION&gt;  <span class="comment"># 安装指定版本</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker EE 正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<ul>
<li>升级 Docker</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br><span class="line">$ sudo yum update docker-ce</span><br></pre></td></tr></table></figure>


<h3 id="使用软件包直接安装"><a href="#使用软件包直接安装" class="headerlink" title="使用软件包直接安装"></a>使用软件包直接安装</h3><ul>
<li>下载对应版本的 <code>.rpm</code> 软件包</li>
</ul>
<p>Docker CE: Go to <a href="https://download.docker.com/linux/centos/7/x86_64/stable/Packages/" target="_blank" rel="noopener">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a>  and download the <code>.rpm</code></p>
<ul>
<li>安装软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install /path/to/package.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 Docker 服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker 服务正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<h2 id="卸载-Docker-CE"><a href="#卸载-Docker-CE" class="headerlink" title="卸载 Docker CE"></a>卸载 Docker CE</h2><ul>
<li>卸载 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像/容器/数据卷和自定义配置文件不会随着卸载而自动删除, 你需要手动去清除他们</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>

<hr>
<p>参考官方文档:</p>
<ul>
<li><a href="https://docs.docker.com/engine/installation/linux/centos/#install-from-a-package" target="_blank" rel="noopener">Get Docker for CentOS - Docker Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于时间和位置查看MySQL binlog</title>
    <url>/2017/03/21/%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E5%92%8C%E4%BD%8D%E7%BD%AE%E6%9F%A5%E7%9C%8BMySQL-binlog/</url>
    <content><![CDATA[<h2 id="基于时间查看-binlog-日志"><a href="#基于时间查看-binlog-日志" class="headerlink" title="基于时间查看 binlog 日志"></a>基于时间查看 binlog 日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlbinlog  --no-defaults --start-datetime=<span class="string">"2016-10-31 23:08:03"</span> mysql-bin.000214 |more</span><br></pre></td></tr></table></figure>



<h2 id="基于位置查看-binlog-日志"><a href="#基于位置查看-binlog-日志" class="headerlink" title="基于位置查看 binlog 日志"></a>基于位置查看 binlog 日志</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --no-defaults --start-position=690271 mysql-bin.000214 |more</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从1061报错</title>
    <url>/2017/03/21/MySQL%E4%B8%BB%E4%BB%8E1061%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>MySQL主从 1061 报错, 键冲突, 产生的原因一般为用户在主库上建立索引导致, 可以通过在从库手动删除冲突的索引解决</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先暂停主从同步</span></span><br><span class="line">mysql&gt; stop slave for channel "dbtest";  # MySQL5.7多源复制语法</span><br><span class="line">mysql&gt; stop slave;  # 单主复制语法</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除冲突的索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`tableNmae`</span> <span class="keyword">DROP</span> <span class="keyword">INDEX</span> <span class="string">`indexName`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启主从同步</span></span><br><span class="line">mysql&gt; start slave for channel "dbtest"; # MySQL5.7多源复制语法</span><br><span class="line">mysql&gt; start slave;  # 单主复制语法</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>主从报错</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL权限管理</title>
    <url>/2017/03/21/MySQL%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>grant 权限 on 数据库.数据表 to &#39;用户&#39;@&#39;主机&#39;;</code></p>
<h2 id="主机的表示方式"><a href="#主机的表示方式" class="headerlink" title="主机的表示方式"></a>主机的表示方式</h2><ul>
<li>192.168.10.85  单主机授权方式</li>
<li>localhost 本地授权 方式</li>
<li>% 不限制远程主机的 IP 地址</li>
<li>192.168.10.% 网段批量授权</li>
</ul>
<h2 id="权限列表"><a href="#权限列表" class="headerlink" title="权限列表"></a>权限列表</h2><table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>usage</td>
<td>连接(登录)MySQL 的权限, 每建立一个用户, 就会自动授予<code>usage</code>权限. 该权限只能用于数据库登录, 不能执行任何操作, 且 usage 权限不能被回收♻️</td>
</tr>
<tr>
<td>file</td>
<td>拥有 file 权限才可以执行 <code>select ... into outfile</code> 和 <code>load data infile…</code> 操作, 但是不要把 <code>file</code>, <code>process</code>, <code>super</code> 权限授予管理员以外的账号, 否则存在严重的安全隐患</td>
</tr>
<tr>
<td>super</td>
<td>该权限允许用户终止任何查询; 修改全局变量的 SET 语句; 使用 <code>change master</code> <code>purge master logs</code></td>
</tr>
<tr>
<td>select</td>
<td>必须拥有 select 权限才可以使用 <code>select</code>查询数据</td>
</tr>
<tr>
<td>insert</td>
<td>必须拥有 insert 权限才可以使用<code>insert</code>向表中插入数据</td>
</tr>
<tr>
<td>update</td>
<td>必须拥有 update 权限才可以使用<code>update</code>更新表中的记录📝</td>
</tr>
<tr>
<td>delete</td>
<td>必须拥有 delete 权限才可以使用<code>delete</code>删除表中的数据</td>
</tr>
<tr>
<td>alter</td>
<td>必须拥有 alter 权限才可以使用<code>alter</code>命令更改表的属性</td>
</tr>
<tr>
<td>alter routine</td>
<td>必须拥有 alter routine 权限才可以执行 <code>alter/drop procedure/function</code>命令</td>
</tr>
<tr>
<td>create</td>
<td>必须拥有 create 权限才可以使用<code>create</code>命令建表</td>
</tr>
<tr>
<td>create routine</td>
<td>必须拥有 create routine 权限才可以执行 <code>create/alter/drop procedure/function</code></td>
</tr>
<tr>
<td>create temporary tables</td>
<td>必须有create  temporary tables的权限，才可以使用<code>create temporary tables</code></td>
</tr>
<tr>
<td>create view</td>
<td>执行<code>create view</code>创建视图的权限</td>
</tr>
<tr>
<td>create user</td>
<td>执行<code>create user</code>创建用户的权限(拥有 insert 权限也可以通过直接向 mysql.user 表中插入数据来创建用户)</td>
</tr>
<tr>
<td>show database</td>
<td>通过 <code>show database</code> 只能看到你拥有的某些权限的数据库, 除非你拥有全局<code>show database</code>权限</td>
</tr>
<tr>
<td>show view</td>
<td>必须拥有<code>show view</code>权限才可以执行<code>show create view</code>查询已经创建的视图</td>
</tr>
<tr>
<td>index</td>
<td>必须拥有 index 权限才能创建和删除索引 <code>create/drop index</code></td>
</tr>
<tr>
<td>excute</td>
<td>必须拥有 excute 权限才可以执行存在的函数(Function)和存储过程(Procedures)</td>
</tr>
<tr>
<td>event</td>
<td>如果event 的使用频率较低, 建议使用 root 用户进行管理和维护. (要使event 起作用, MySQL 的常量 <code>global event_scheduler</code>必须为<code>on</code>或者<code>1</code>)</td>
</tr>
<tr>
<td>lock tables</td>
<td>锁表🔐权限</td>
</tr>
<tr>
<td>references</td>
<td>创建外键约束权限</td>
</tr>
<tr>
<td>reload</td>
<td>flush talbes/logs/privileges 权限</td>
</tr>
<tr>
<td>replication client</td>
<td>拥有此权限可以查询<code>master</code> <code>slave</code>状态</td>
</tr>
<tr>
<td>replication slave</td>
<td>拥有此权限可以从主库读取二进制日志</td>
</tr>
<tr>
<td>shutdown</td>
<td>关闭 mysql 的权限</td>
</tr>
<tr>
<td>grant option</td>
<td>可以将自己拥有的权限授权给其他用户(仅限于自己拥有的权限)</td>
</tr>
<tr>
<td>process</td>
<td>拥有此权限可以执行<code>show processlist</code>和<code>kill</code>命令. 默认情况下, 每个用户都可以执行该命令, 但是只能查看本用户的进程</td>
</tr>
<tr>
<td>all privileges</td>
<td>所有权限. 使用<code>with grant option</code>可以连带授权 <code>grant all privileges on *.* to &#39;polarsnow&#39;@&#39;%&#39; with grant option;</code></td>
</tr>
<tr>
<td>truncate</td>
<td>truncate 权限其实就是 create+drop 权限的组合</td>
</tr>
<tr>
<td>drop</td>
<td>删库删表删索引删视图等权限</td>
</tr>
</tbody></table>
<p><strong>注意:</strong> 管理权限(如 super, process, file 等)  不能指定某个数据库授权, <code>on</code>关键字之后必须跟 <code>*.*</code></p>
<h1 id="查看用户授权"><a href="#查看用户授权" class="headerlink" title="查看用户授权"></a>查看用户授权</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; show grants for username;</span><br></pre></td></tr></table></figure>



<h1 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; revoke select,update,insert,delete on *.* from username;</span><br></pre></td></tr></table></figure>



<h1 id="刷新权限"><a href="#刷新权限" class="headerlink" title="刷新权限"></a>刷新权限</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>权限管理</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker For RHEL</title>
    <url>/2017/03/21/Docker-For-RHEL/</url>
    <content><![CDATA[<blockquote>
<p>RHEL 也是大力支持 Docker 的系统发行版, 但是由于 Docker 最开始使用的 AUFS 存储引擎在 RHEL 上并不支持, 所以 RHEL 自主研发了 <code>device mapper</code> 存储引擎专门适配自己的系统. 这个东西确实很牛 X, 但是实际用起来有多不爽恐怕只有用过才会知道吧. </p>
</blockquote>
<p><strong>最重要的是: Docker 官方声明, RHEL 7 不支持 Docker CE, 在 RHEL 系统上, 只能安装 Docker EE 版本, 所以本篇不做详细介绍</strong></p>
<h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul>
<li>64bit RHEL7</li>
</ul>
<h2 id="卸载老版本-Docker-Engine"><a href="#卸载老版本-Docker-Engine" class="headerlink" title="卸载老版本 Docker Engine"></a>卸载老版本 Docker Engine</h2><p>老版本的 Docker 被叫做 <code>docker</code> 或 <code>docker-engine</code> 如果系统当前有这些版本的系统, 那么你需要先卸载他们 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  container-selinux \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>

<p>需要 <code>yum</code> 命令的回显显示没有相关的软件包被安装</p>
<p>在 <code>/var/lib/docker</code> 目录下, 包含了<code>镜像</code>, <code>容器</code>, <code>数据卷</code>和 <code>网络配置</code></p>
<h2 id="安装-Docker-EE"><a href="#安装-Docker-EE" class="headerlink" title="安装 Docker EE"></a>安装 Docker EE</h2><h3 id="设置软件源"><a href="#设置软件源" class="headerlink" title="设置软件源"></a>设置软件源</h3><ul>
<li>在 <code>/etc/yum.repos.d/</code> 下清除所有跟 docker 相关的软件仓库配置</li>
</ul>
<ul>
<li>在 <code>/etc/yum/vars/</code> 下创建两个变量<ul>
<li>Docker EE 的 URL</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo sh -c <span class="string">'echo "&lt;DOCKER-EE-URL&gt;" &gt; /etc/yum/vars/dockerurl'</span></span><br></pre></td></tr></table></figure>

<pre><code>- RHEL 的版本 </code></pre><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo sh -c <span class="string">'echo "&lt;VERSION-STRING&gt;" &gt; /etc/yum/vars/dockerosversion'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装 yum 工具集<code>yum-utils</code> 以得到 <code>yum-config-manager</code>命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>

<ul>
<li>配置软件源</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    &lt;DOCKER-EE-URL&gt;/docker-ee.repo</span><br></pre></td></tr></table></figure>

<h3 id="安装-Docker-EE-1"><a href="#安装-Docker-EE-1" class="headerlink" title="安装 Docker EE"></a>安装 Docker EE</h3><ul>
<li>更新 yum 软件源索引</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum makecache fast</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 Docker EE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo yum -y install docker-ee</span><br></pre></td></tr></table></figure>

<ul>
<li>启动 Docker EE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker EE 正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<hr>
<p>参考官方文档:</p>
<ul>
<li><a href="https://docs.docker.com/engine/installation/linux/rhel/#install-using-the-repository" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/rhel/#install-using-the-repository</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker For Ubuntu</title>
    <url>/2017/03/20/Docker-For-Ubuntu/</url>
    <content><![CDATA[<blockquote>
<p>Ubuntu 是 docker 第一个支持的系统发行版, 截止到目前, 我们也依然推荐在生产环境中使用 Ubuntu 系统. 虽然我也很喜欢 CentOS, 但是在 docker 这件事儿中, Ubuntu 确实是最合适的系统选择</p>
</blockquote>
<h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul>
<li>64bit Yakkety 16.10</li>
</ul>
<ul>
<li>64bit Xenial 16.04 (LTS)    &lt;== 个人推荐使用此版本的 Ubuntu 发行版</li>
<li>64bit Trusty 14.04 (LTS)</li>
</ul>
<h2 id="卸载老版本-Docker-Engine"><a href="#卸载老版本-Docker-Engine" class="headerlink" title="卸载老版本 Docker Engine"></a>卸载老版本 Docker Engine</h2><p>老版本的 Docker 被叫做 <code>docker</code> 或 <code>docker-engine</code> 如果系统当前有这些版本的系统, 那么你需要先卸载他们 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine</span><br></pre></td></tr></table></figure>

<p>需要 <code>apt-get</code> 命令的回显显示没有相关的软件包被安装</p>
<p>在 <code>/var/lib/docker</code> 目录下, 包含了<code>镜像</code>, <code>容器</code>, <code>数据卷</code>和 <code>网络配置</code></p>
<h2 id="Ubuntu-Trusty-14-04-额外安装的软件包"><a href="#Ubuntu-Trusty-14-04-额外安装的软件包" class="headerlink" title="Ubuntu Trusty 14.04 额外安装的软件包"></a>Ubuntu Trusty 14.04 额外安装的软件包</h2><p>在官方文档中, 强烈推荐 Ubuntu14.04版本如果使用<code>aufs</code> 存储引擎, 那么一定要安装以下软件包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    linux-image-extra-$(uname -r) \</span><br><span class="line">    linux-image-extra-virtual</span><br></pre></td></tr></table></figure>

<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><h3 id="从软件源中安装-Docker"><a href="#从软件源中安装-Docker" class="headerlink" title="从软件源中安装 Docker"></a>从软件源中安装 Docker</h3><h4 id="配置软件仓库-Docker-CE"><a href="#配置软件仓库-Docker-CE" class="headerlink" title="配置软件仓库 Docker-CE"></a>配置软件仓库 Docker-CE</h4><ul>
<li>安装软件包, 以允许<code>apt</code>命令可以通过 https 协议使用软件源(repository)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 Docker 官方 GPG key</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure>

<ul>
<li>配置 <code>stable</code> 版本的软件源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure>

<h4 id="安装-Docker-CE"><a href="#安装-Docker-CE" class="headerlink" title="安装 Docker CE"></a>安装 Docker CE</h4><ul>
<li>更新系统软件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>

<ul>
<li>安装最新版本的 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>在生产环境, 你可能需要安装指定版本的 Docker,</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce=&lt;VERSION&gt;</span><br></pre></td></tr></table></figure>

<p><em>docker-ce 在安装好后自动启动</em></p>
<ul>
<li>启动 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<ul>
<li>验证 Docker 服务正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<ul>
<li>添加用户到 Docker 组</li>
</ul>
<p>在生产环境中, 不是每个人登录都是使用 root 用户, 可能需要给普通用户操作 docker 的权限, 那么将该用户添加到 docker 组是简单方便的方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo usermod -aG docker your-user</span><br></pre></td></tr></table></figure>

<ul>
<li>升级 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure>


<h3 id="使用软件包直接安装"><a href="#使用软件包直接安装" class="headerlink" title="使用软件包直接安装"></a>使用软件包直接安装</h3><ul>
<li>下载对应版本的 <code>.deb</code> 软件包</li>
</ul>
<p>Docker CE: Go to <a href="https://download.docker.com/linux/ubuntu/pool/stable-17.03/amd64/" target="_blank" rel="noopener">https://download.docker.com/linux/ubuntu/pool/stable-17.03/amd64/</a> and download the .deb </p>
<ul>
<li>安装软件包</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo dpkg -i /path/to/package.deb</span><br></pre></td></tr></table></figure>

<p>The Docker daemon starts automatically.</p>
<ul>
<li>验证 Docker 服务正常运行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>


<h2 id="卸载-Docker-CE"><a href="#卸载-Docker-CE" class="headerlink" title="卸载 Docker CE"></a>卸载 Docker CE</h2><ul>
<li>卸载 Docker CE</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get purge docker-ce</span><br></pre></td></tr></table></figure>

<ul>
<li>镜像/容器/数据卷和自定义配置文件不会随着卸载而自动删除, 你需要手动去清除他们</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerForWindows</title>
    <url>/2017/03/20/DockerForWindows/</url>
    <content><![CDATA[<blockquote>
<p>Docker CE For Windows 同样分为了两个版本,  一个是稳定版; 一个是开发版</p>
</blockquote>
<p>下载链接:</p>
<ul>
<li><a href="https://download.docker.com/win/stable/InstallDocker.msi" target="_blank" rel="noopener">Get Docker for Windows Stable</a></li>
</ul>
<ul>
<li><a href="https://download.docker.com/win/beta/InstallDocker.msi" target="_blank" rel="noopener">Get Docker for Windows Edge</a></li>
</ul>
<p>系统要求:</p>
<ul>
<li>Windows 10 Pro Enterprise and Education (1511 November update, Build 10586 or later) 64bit</li>
</ul>
<ul>
<li>Microsoft Hyper-V</li>
</ul>
<p>双击安装文件: InstallDocker.msi 打开安全程序界面.  按照正常的 Windows 软件安装流程, 我接受, 下一步, 下一步即可完成 docker 的安装</p>
<p><em>提示: mac 版本和 windows 版本的 docker 仅限于体验. 甚至连测试环境都不推荐使用 mac 版和 windows 版, 因为在实际生产环境中,  依然还是在 Linux 系统下使用 docker, 而且相同的镜像, 相同的参数, 在 Linux 环境执行没有问题, 而在 mac 上执行出问题的事情已经发生过很多次了. 建议不要给自己铺垫这些不必要的麻烦!</em></p>
<hr>
<p>官方文档: </p>
<ul>
<li><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Install Docker for Windows - Docker Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerForMac</title>
    <url>/2017/03/20/DockerForMac/</url>
    <content><![CDATA[<blockquote>
<p>Docker CE For Mac 同样分为了两个版本,  一个是稳定版; 一个是开发版</p>
</blockquote>
<p>下载链接:</p>
<ul>
<li><a href="https://download.docker.com/mac/stable/Docker.dmg" target="_blank" rel="noopener">Get Docker for Mac Stable</a></li>
</ul>
<ul>
<li><a href="https://download.docker.com/mac/beta/Docker.dmg" target="_blank" rel="noopener">Get Docker for Mac Edge</a></li>
</ul>
<p>双击安装文件: Docker.dmg 打开安全程序界面. 将左边的图标拖拽到右边的文件夹中.</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/docker-app-drag.png" alt=""></p>
<p>在 launchpad 中找到 docker 图标, 单机启动</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/docker-app-in-apps.png" alt=""></p>
<p>启动后会在 macOS 的导航栏中出现 docker 的图标</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/whale-in-menu-bar.png" alt=""></p>
<p>点击导航栏中的 docker 图标, 可以查看运行状态</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/menu.png" alt=""></p>
<p><em>提示: mac 版本和 windows 版本的 docker 仅限于体验. 甚至连测试环境都不推荐使用 mac 版和 windows 版, 因为在实际生产环境中,  依然还是在 Linux 系统下使用 docker, 而且相同的镜像, 相同的参数, 在 Linux 环境执行没有问题, 而在 mac 上执行出问题的事情已经发生过很多次了. 建议不要给自己铺垫这些不必要的麻烦!</em></p>
<hr>
<p>官方文档: </p>
<ul>
<li><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank" rel="noopener">Install Docker for Mac - Docker Documentation</a> </li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Docker</title>
    <url>/2017/03/18/%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><p>在 Docker1.13.1版本之后, 突然改变了 Docker 版本的命令方式, 以<code>v年.月</code>的方式命令, 并且首次明确区分了社区版<code>CE</code>和企业版<code>EE</code></p>
<h2 id="Docker-的版本"><a href="#Docker-的版本" class="headerlink" title="Docker 的版本"></a>Docker 的版本</h2><ul>
<li>Docker Enterprise Edition (Docker EE)  Docker EE 的明显优势不在于 Docker Engine 的本身, 而在于 Docker 周边的生态配件. Docker 官方为 EE 版本设计开发了一套目前集成度极高的 Docker 容器管理平台. 集Docker 企业版 Engine, Docker Registry UI,  CICD,  监控等功能于一身(Docker Datacenter)</li>
</ul>
<ul>
<li>Docker Community Edition (Docker CE)  Docker CE 就是我们之前一直在使用的开源版 Docker-engine. 也是我们将来主要使用的版本. Docker CE的版本发布规则如下:<ul>
<li>Stable 稳定版. 每季度发行一版</li>
<li>Edge 开发版. 每月发行一版</li>
</ul>
</li>
</ul>
<h2 id="平台支持一览表"><a href="#平台支持一览表" class="headerlink" title="平台支持一览表"></a>平台支持一览表</h2><table>
<thead>
<tr>
<th>平台</th>
<th>Docker EE</th>
<th>Docker</th>
</tr>
</thead>
<tbody><tr>
<td>Ubuntu</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Debian</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Red Hat Enterprise Linux</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>CentOS</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>Fedora</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>Oracle Linux</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>SUSE Linux Enterprise Server</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Microsoft WinServer 2016</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>Microsoft Windows 10</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>macOS</td>
<td>❌</td>
<td>✅</td>
</tr>
</tbody></table>
<h2 id="查看官方帮助文档"><a href="#查看官方帮助文档" class="headerlink" title="查看官方帮助文档"></a>查看官方帮助文档</h2><p>截止到目前, 最新版本为 v17.03, 你可以通过<code>latest</code>标签🏷获取最新文档</p>
<ul>
<li>v17.03 (current)<br>Docs for v17.03 (current) are accessible at <a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:latest</code></li>
<li>v1.13<br>Docs for v1.13 are accessible at <a href="https://docs.docker.com/v1.13/" target="_blank" rel="noopener">https://docs.docker.com/v1.13/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.13</code></li>
<li>v1.12<br>Docs for v1.12 are accessible at <a href="https://docs.docker.com/v1.12/" target="_blank" rel="noopener">https://docs.docker.com/v1.12/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.12</code></li>
<li>v1.11<br>Docs for v1.11 are accessible at <a href="https://docs.docker.com/v1.11/" target="_blank" rel="noopener">https://docs.docker.com/v1.11/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.11</code></li>
<li>v1.10<br>Docs for v1.10 are accessible at <a href="https://docs.docker.com/v1.10/" target="_blank" rel="noopener">https://docs.docker.com/v1.10/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.10</code></li>
<li>v1.9<br>Docs for v1.9 are accessible at <a href="https://docs.docker.com/v1.9/" target="_blank" rel="noopener">https://docs.docker.com/v1.9/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.9</code></li>
<li>v1.8<br>Docs for v1.8 are accessible at <a href="https://docs.docker.com/v1.8/" target="_blank" rel="noopener">https://docs.docker.com/v1.8/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.8</code></li>
<li>v1.7<br>Docs for v1.7 are accessible at <a href="https://docs.docker.com/v1.7/" target="_blank" rel="noopener">https://docs.docker.com/v1.7/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.7</code></li>
<li>v1.6<br>Docs for v1.6 are accessible at <a href="https://docs.docker.com/v1.6/" target="_blank" rel="noopener">https://docs.docker.com/v1.6/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.6</code></li>
<li>v1.5<br>Docs for v1.5 are accessible at <a href="https://docs.docker.com/v1.5/" target="_blank" rel="noopener">https://docs.docker.com/v1.5/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.5</code></li>
<li>v1.4<br>Docs for v1.4 are accessible at <a href="https://docs.docker.com/v1.4/" target="_blank" rel="noopener">https://docs.docker.com/v1.4/</a>, or run:<br><code>docker run -ti -p 4000:4000 docs/docker.github.io:v1.4</code></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要使用Docker</title>
    <url>/2017/03/18/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8Docker/</url>
    <content><![CDATA[<h1 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h1><h2 id="Docker-容器虚拟化带来的好处"><a href="#Docker-容器虚拟化带来的好处" class="headerlink" title="Docker 容器虚拟化带来的好处"></a>Docker 容器虚拟化带来的好处</h2><p>传统的 LAMP 架构, 搭建起来费时费力, 需要调整很多依赖环境. 更可怕的是一旦需要做服务迁移, 一切都要重来.</p>
<p>Docker 提供了一种更为简单的方式, 通过容器来打包应用, 意味着迁移服务只需要在新的服务器上启动相应的容器即可. 大大减少迁移的时间和成本, 并大幅降低部署过程中可能会出现的问题和风险</p>
<h2 id="Docker-在开发和运维中的优势"><a href="#Docker-在开发和运维中的优势" class="headerlink" title="Docker 在开发和运维中的优势"></a>Docker 在开发和运维中的优势</h2><p>对于开发和运维来说, 最梦寐以求的就是一次性的创建或配置, 可以在任意环境, 任意时间让应用正常的运行. 而 Docker 就是实现这一目标的利器.</p>
<p>具体来说, Docker 在开发和运维中具有如下优势:</p>
<ul>
<li>更快的交付和部署</li>
</ul>
<ul>
<li>更高效的资源利用</li>
<li>更轻松的迁移扩展</li>
<li>更简单的更新管理</li>
</ul>
<h2 id="Docker-与虚拟机的比较"><a href="#Docker-与虚拟机的比较" class="headerlink" title="Docker 与虚拟机的比较"></a>Docker 与虚拟机的比较</h2><ul>
<li>Docker 启动和关闭容器的速度非常快, 可以在秒级实现, 相比传统的虚拟机速度要快很多</li>
</ul>
<ul>
<li>Docker 容器对系统资源需求很少, 一台主机上可以同时运行数千个 Docker 容器</li>
<li>Docker 通过类似 Git 的操作来方便用户获取/分发和更新应用镜像, 指令简明, 学习成本低</li>
<li>Docker 可以通过 Dockerfile 配置文件来支持灵活的自动化创建和部署机制, 提高工作效率</li>
</ul>
<p>Docker 容器除了运行其中的应用之外, 基本上不消耗额外的系统资源, 保证应用性能的同时, 尽量减小系统开销. 传统的虚拟机运行 N 个不同的应用就要启动 N 个虚拟机, 每个虚拟机需要单独配置独占的内存,硬盘等资源, 而 Docker 只需要启动 N 个隔离的容器, 并将应用放到容器内即可</p>
<p>在隔离性方面, 传统的虚拟机方式多了一层额外的隔离. 但这并不意味这 Docker 不安全. Docker 利用 Linux 系统上的多种防护机制实现了严格可靠的隔离. 从1.3版本开始, Docker 引入了安全选项和镜像签名机制, 极大地提高了 Docker 的安全性.</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动速度</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>5%以上的性能损耗</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个容器</td>
</tr>
<tr>
<td>隔离性</td>
<td>安全隔离</td>
<td>完全隔离</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 在国内的发展现状</title>
    <url>/2017/03/06/Docker-%E5%9C%A8%E5%9B%BD%E5%86%85%E7%9A%84%E5%8F%91%E5%B1%95%E7%8E%B0%E7%8A%B6/</url>
    <content><![CDATA[<p>Docker 在国际上虽然也可以称得上是新兴技术, 但是在国内, 丝毫没有看出 Docker 一个起步不到4年的年轻产品. 在国内, 众多大厂开始大量使用 Docker 基础. 其中 <code>滴滴</code> <code>京东</code> <code>蘑菇街</code> <code>知乎</code> <code>豆瓣</code>等大型互联网公司都在大规模的在线上环境落地 Docker 技术.</p>
<p>在2016年的双11之后, 京东更是首先爆出15万 Docker 服务器的规模. 可见 Docker 现在虽然还是一个快速迭代, 快速完善的系统, 但是已经得到了世界互联网大厂的任何. Docker 的早期线上落地的推广, 大都是由这些互联网大厂实施的. 给后续的中小企业也带来了极高的参考价值.</p>
<p>在5年前, 像 OpenStack 以及 CloudStack 这类云服务基础架构出现时, 在运维领域刮起了一阵飓风🌪 短短几年间, IDC 机房不再是所有互联网公司的标配, 为了减少运维成本, 更多的去关注业务的本身, 越来越多的创业公司选择使用公有云服务. </p>
<p>5年后的今天, IaaS 的公有云服务仍然是主流, 在 IaaS 之上又出现了 CaaS 服务, 即以 Container 为主导的基础服务架构. 将 IaaS 的资源利用到极致. Docker 不是 IaaS 的替代品, 但却是 IaaS 平台强有力的补充, 在为企业提高资源利用率, 减少成本, 提高自动化程度等方面提供了强有力的支持. </p>
<p>即使目前大多中小企业依然在自己的开发环境和测试环境观望 Docker 技术的发展, 但是不可否认的是 Docker 目前已经有能力胜任线上业务的重担. 通过网上大厂们流传出的”最佳实践”, 完全可以指到我们将服务容器化, 并很好的调试和排错.</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 的版本演进</title>
    <url>/2017/03/06/Docker-%E7%9A%84%E7%89%88%E6%9C%AC%E6%BC%94%E8%BF%9B/</url>
    <content><![CDATA[<p>Docker从2013年开源. 2015年是 Docker 开源项目突飞猛进的一年，这段时间Docker 官方先后发布了V1.5、V1.6、V1.7、V1.8、V1.9等5个大版本以及7个修订版本</p>
<p>2016年 Docker发展同样迅速，截止2016年12月7日Docker官方共发布了V1.10, V1.11, V1.12等3个大版本以及8个修订版本.</p>
<p>2017年1月18日, Docker 发布了最重大的一次版本更新 V1.13,  2月8日发布了V1.13.1, 在3月1日, Docker 公布了新的命名规则</p>
<p>V1.13.1版本之后, 所有的版本都会按照 VYY.MM 的格式进行打包. 比如 Docker 在2017年3月的这次更新, 新的版本号变成了 <code>V17.03.0-ce</code></p>
<p>前面是日期不用解释, 后面的<code>CE</code>暴露了 Docker 公司渴望将该容器技术商业化的决心. 从此之后 Docker 的版本划分为商业版本的 <code>EE</code>和开源社区版本的 <code>CE</code> , 其中开源社区版本也分成了两类, 分别为 每季度更新的<code>Stable</code>稳定版和每月更新的<code>Edge</code> 开发版</p>
<ul>
<li>Docker EE</li>
<li>Docker CE<ul>
<li>Docker CE stable</li>
<li>Docker CE edge</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 简介</title>
    <url>/2017/03/06/docker-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="docker-时间轴"><a href="#docker-时间轴" class="headerlink" title="docker 时间轴"></a>docker 时间轴</h2><p>docker 是容器技术中的一种. 最早是由 dotcloud 公司开源的一款产品. dotcloud 公司是2010年新成立的一家公司, 主要基于 PaaS 平台为开发者提供服务. 在 PaaS 平台下, 所有的服务环境已经预先配置好了, 开发者只需要选择服务类型, 上传代码后即可对外提供服务, 不需要花费大量的时间来搭建服务和配置环境.</p>
<p>2013年,  dotcloud 的 CEO 决定把 dotcloud 内部使用的 container 容器技术单独拿出来开源. 2013年3月发布 docker 的 V0.1版本, 并且保持每月一个版本的迭代速度. 到同年8月, docker 技术已经足够火爆. 同年10月, dotcloud 公司更名为 Docker 股份有限公司.</p>
<p>2014年6月9日, Docker 发布 V1.0版本, 并举办了首届 DockerCon 大会, 大会上来自 Google, IBM, RedHat,  Rackspace 等公司的核心人物均发表了主题演讲🗣并纷纷加入 Docker 的阵营.</p>
<p>2014年12月, Docker 发布了集群管理工具 Machine 和 Swarm.</p>
<p>2016年1月, Docker 官方计划全面支持自身的 Alpine Linux, 使用它构建的基础镜像最小只有5M</p>
<h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><p>按照官方的说法, Docker 是一个开源的应用容器引擎.</p>
<p>拿 Java 来说, 在 Java 之前的编程语言, 像 C/C++, 是严重依赖平台的, 在不同的平台下, 需要重新编译才能运行. Java 的一个非常重要的特性就是与平台无关性,  Java 虚拟机(JVM)是实现这一特性的关键. Java 虚拟机屏蔽了与具体平台的相关性, 使得 Java 语言编译程序只需生成可以在 Java 虚拟机上运行的目标代码, 就可以在多种平台上不加修改的运行. Java 虚拟机在执行字节码的时候, 把字节码解释成具体平台上的机器指令执行.</p>
<p>Java 的理念是 “Write Once, Run Anywhere”, 而 Docker 则提出了”Build Once, Run Anywhere, Configure Once, Run Anything”</p>
<p>在 Java 的 JVM 中, 屏蔽了系统平台的干扰; 在 Docker 使用的容器技术中, 则屏蔽了除内核外的所有干扰. 运行在Docker 内的容器, 只对内核敏感. (相对于宿主机而言)</p>
<p>如果说 Java 是帮助我们把应用打包, 可以运行在任何装有 JVM 的服务器上; 那么使用 Docker 就是帮我们实现应用与环境的统一打包, 可以在任何装有 Docker 的服务器上运行. </p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu下添加用户</title>
    <url>/2017/02/24/ubuntu%E4%B8%8B%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7/</url>
    <content><![CDATA[<blockquote>
<p>在 Ubuntu 下直接使用<code>useradd username</code>添加用户可能会导致用户没有家目录或 tab 无法自动补齐的问题, 需要单独制定这些进行配置</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -r -m -s /bin/bash username</span><br></pre></td></tr></table></figure>



<p><code>-r</code>  创建一个系统用户<br><code>-m</code>  声明为该用户创建默认的家目录(可以单独指定)<br><code>-s</code>  指定该用户登录时使用的终端类型</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>useradd</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux添加用户到组</title>
    <url>/2017/02/24/Linux%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E5%88%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 的使用中, 常常需要使用普通用户去操作 docker 命令, 简单的办法就是把需要操作 docker 的普通用户加入到 docker 组中即可, 但是需要注意不要覆盖掉用户原来所属的组</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usermod -a -G docker username</span><br></pre></td></tr></table></figure>

<ul>
<li>-a: append 使用追加的方式添加到组, 不必离开现有的用户组</li>
</ul>
<ul>
<li>-G: 需要加入的目标组</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>usermod</tag>
      </tags>
  </entry>
  <entry>
    <title> history命令显示时间</title>
    <url>/2017/02/24/history%E5%91%BD%E4%BB%A4%E6%98%BE%E7%A4%BA%E6%97%B6%E9%97%B4/</url>
    <content><![CDATA[<blockquote>
<p>默认情况下不管是 centos 系列还是 ubuntu 系列, 默认的 history 命令都只是显示了命令编号和具体命令这两列信息, 在实际生产环境中, 添加时间的显示十分实用和重要</p>
</blockquote>
<p>编辑<code>/etc/profile</code>文件, 添加入下一行即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HISTTIMEFORMAT=<span class="string">"`whoami` %F %T "</span></span><br></pre></td></tr></table></figure>

<ul>
<li>%F: 日期</li>
</ul>
<ul>
<li>%T: 时间</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>history</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump 错误2013 Lost connection</title>
    <url>/2017/02/19/mysqldump-%E9%94%99%E8%AF%AF2013-Lost-connection/</url>
    <content><![CDATA[<blockquote>
<p>导出数据库的时候报如下错误 <code>mysqldump: Error 2013: Lost connection to MySQL server during query when dumping table</code>mail<code>at row: 2637433</code></p>
</blockquote>
<p><strong>查询资料</strong></p>
<p>大概说是因为mysqldump来不及接受mysql server端发送过来的数据，Server端的数据就会积压在内存中等待发送，这个等待不是无限期的，当Server的等待时间超过net_write_timeout（默认是60秒）时它就失去了耐心，mysqldump的连接会被断开，同时抛出错误Got error: 2013: Lost connection。</p>
<p><strong>解决方案一</strong></p>
<p>增加net_write_timeout可以解决上述的问题的。在实践中发现，在增大 net_write_timeout后，Server端会消耗更多的内存，有时甚至会导致swap的使用（并不确定是不是修改 net_write_timeout所至）。建议在mysqldump之前修改net_write_timeout为一个较大的值（如1800），在 mysqldump结束后，在将这个值修改到默认的60。</p>
<p>在sql命令行里面设置临时全局生效用类似如下命令：<br>SET GLOBAL net_write_timeout=1800;</p>
<p>修改了这个参数后再备份，不再报错<br>注意，这个参数不是mysqldump选项，而是mysql的一个配置参数</p>
<p><strong>解决方案二</strong></p>
<p>在执行 mysqldump 的时候可以通过添加 <code>--quick</code> 的参数来避免出现这样的问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> --quick，-q</span><br><span class="line"></span><br><span class="line">该选项用于转储大的表。它强制mysqldump从服务器一次一行地检索表中的行而不是检索所有行并在输出前将它缓存到内存中。</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>参考文档</strong></p>
<p><a href="http://www.linuxyw.com/linux/yunweiguzhang/20130609/566.html" target="_blank" rel="noopener">http://www.linuxyw.com/linux/yunweiguzhang/20130609/566.html</a></p>
<p><a href="http://www.cnblogs.com/haven/archive/2012/10/27/2742141.html" target="_blank" rel="noopener">http://www.cnblogs.com/haven/archive/2012/10/27/2742141.html</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysqldump</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用命令</title>
    <url>/2017/02/19/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>查看全局变量</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; show global variables;</span><br><span class="line">mysql&gt; show global variables like '%timeout';</span><br></pre></td></tr></table></figure>

<p><strong>设置全局变量</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global innodb_ft_min_token_size=1;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>docker中的导入导出</title>
    <url>/2017/02/19/docker%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 的概念中, 有两套导入导出的概念. 分别是<code>export 和 import</code>还有<code>save 和 load</code> 百度搜索🔍它们的区别, 有一篇被引用了很多次的文章虽然讲的很详细, 还加入了一些实验验证, 但是试验中为了实现同一个效果而使用了 commit 命令更改了镜像内容. 理解和使用起来可能会有些偏差, 本文将以最简单明了的方式介绍 docker 中的两套导入导出功能</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">export&amp;import</th>
<th align="center">save&amp;load</th>
</tr>
</thead>
<tbody><tr>
<td align="center">操作对象</td>
<td align="center">容器</td>
<td align="center">镜像</td>
</tr>
<tr>
<td align="center">导出对象</td>
<td align="center">tar 文件</td>
<td align="center">tar 文件</td>
</tr>
<tr>
<td align="center">导入对象</td>
<td align="center">镜像</td>
<td align="center">镜像</td>
</tr>
<tr>
<td align="center">镜像层数</td>
<td align="center">一层</td>
<td align="center">多层</td>
</tr>
</tbody></table>
<p><strong>下面我们来一行一行的解释</strong></p>
<h1 id="操作对象"><a href="#操作对象" class="headerlink" title="操作对象"></a>操作对象</h1><p>操作的对象不同, export 和 import 是用来导入导出容器用的, 而 save 和 load 是用来导入导出镜像用的.</p>
<p>例如: 你需要把 <code>A</code> 机器上的 <code>甲</code> 容器迁移到 <code>B</code> 机器, 且 <code>甲</code> 容器中有重要的数据需要随之一起迁移的, 就可以使用 <code>export 和 import</code> 参数来导入和导出</p>
<p>例如: 你的服务器不能 pull 下来某个镜像, 但是你有一台海外的机器, 你可以在海外的那台机器上把需要的镜像 pull 下来, 然后把该镜像通过 <code>save</code> 命令导出为一个 tar 包, 再将 tar 包拉回到本地导入</p>
<p>所以, 从功能定位上, 你就记住 <code>save 和 load</code>参数是用来迁移镜像的这个场景就行了, 另外的 <code>export 和 import</code>当然就是用来迁容器的</p>
<h1 id="导出对象"><a href="#导出对象" class="headerlink" title="导出对象"></a>导出对象</h1><p>在导出对象这一点, <code>export</code> 和 <code>save</code> 导出的文件形式都是一样的, 两者都是导出为一个 tar 包</p>
<h1 id="导入对象"><a href="#导入对象" class="headerlink" title="导入对象"></a>导入对象</h1><p>在导入上, <code>import</code> 和 <code>load</code> 通过 tar 包导入的都是一个镜像</p>
<h1 id="导入的镜像层数"><a href="#导入的镜像层数" class="headerlink" title="导入的镜像层数"></a>导入的镜像层数</h1><p>最大的区别就在这里, 通过<code>export 和 import</code>导出的容器形成镜像时, 该镜像只有一层</p>
<p>通过<code>save</code> 和 <code>load</code> 导出的镜像保留了原镜像所有的层次结构, 导出时原镜像有几层, 导入的时候就还是有几层</p>
<h1 id="想导出容器-但是还想保留层次结构怎么办"><a href="#想导出容器-但是还想保留层次结构怎么办" class="headerlink" title="想导出容器, 但是还想保留层次结构怎么办?"></a>想导出容器, 但是还想保留层次结构怎么办?</h1><p>导出容器, 很快就想到唯一一个可以导出容器的工具 <code>export</code></p>
<p>但是又想保留底层镜像的层次结构, 那么 <code>export</code> 就不符合需求了</p>
<p>想想导出带层次结构的工具就只有镜像导出工具 <code>save</code> 了, 但是容器在镜像层之上还有一层新的数据怎么一起导出去呢? </p>
<p>这个时候就需要引入一个新的参数 <code>commit</code>, 用来保存容器现有的状态为一个新的镜像 </p>
<p>比如在 <code>A</code> 机器上运行的 <code>甲</code> 容器是基于 <code>甲方乙方</code> 这个镜像跑起来的, 那么我就可以通过 <code>commit</code> 参数, 将 <code>甲</code> 容器的所有内容保存为一个新的镜像, 名字叫 <code>私人订制</code> (内含一梗哦😆) 最后我再通过镜像导出工具 <code>save</code> 就可以完整的将 <code>私人订制</code>镜像(也就是 <code>甲容器</code> )导出为一个 tar 包了</p>
<p>而且包含了 X+1 层镜像, X 层是原镜像 <code>甲方乙方</code> 的所有镜像层数, 1是容器 <code>甲</code> 多的那一层可写层的镜像</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总结来说我也希望大家使用 docker 能遵循 docker 的设计初衷, 运行一个无状态的容器. 如果是无状态的容器, 就不会产生 <code>想导出容器, 但是还想保留层次结构怎么办?</code> 这样的奇葩问题了. </p>
<p>所以最后还是要再次强调:</p>
<ul>
<li>export 和 import 是用来导出导入容器用的, 导出的是容器的文件系统, 导出后的镜像只有一层</li>
<li>save 和 load 是用来导出导入镜像用的, 导出后保持着原镜像的层次结构</li>
</ul>
<p>这里我没有详细介绍这四个参数的具体用法, 因为网上已经有很详细的文章介绍啦, 一下就是百度经常能搜到的关于 docker 导入导出的文章</p>
<p><a href="https://my.oschina.net/zjzhai/blog/225112" target="_blank" rel="noopener">https://my.oschina.net/zjzhai/blog/225112</a></p>
<p>具体用法可以参考以上文章, 但是概念理解, 我还是觉得自己写的比较清楚😆, 因为我没有故意构造出导出容器和导出镜像结果相同的场景</p>
<hr>
<p>参考文档</p>
<p>docker export 官方文档<a href="https://docs.docker.com/engine/reference/commandline/export/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/export/</a></p>
<p>docker save 官方文档<a href="https://docs.docker.com/engine/reference/commandline/save/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/save/</a></p>
<p>docker commit 官方文档<a href="https://docs.docker.com/engine/reference/commandline/commit/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/commit/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>import</tag>
        <tag>export</tag>
        <tag>save</tag>
        <tag>load</tag>
      </tags>
  </entry>
  <entry>
    <title>更改docker的日志引擎为 journald</title>
    <url>/2017/02/19/%E6%9B%B4%E6%94%B9docker%E7%9A%84%E6%97%A5%E5%BF%97%E5%BC%95%E6%93%8E%E4%B8%BA-journald/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 原生支持的众多日志引擎中, 结合实际生产环境的需求, 最终选择了众多linux 发行版都默认支持的 journald 日志系统, journald 日志系统是 systemd 自带的服务, 在实际使用过程中, 上手很快, 而且很符合线上查看 docker 日志的习惯与需求</p>
</blockquote>
<h1 id="docker原生支持的日志引擎"><a href="#docker原生支持的日志引擎" class="headerlink" title="docker原生支持的日志引擎"></a>docker原生支持的日志引擎</h1><ul>
<li>none <strong>关闭 docker 的回显日志, docker logs 看不到任何输出</strong></li>
<li>json-file <strong>把每个 container 的回显日志打到每个 container 的内部, 形式为json 文件</strong></li>
<li>syslog <strong>把所有 container 的回显日志打到系统的 syslog 中</strong></li>
<li>journald <strong>把所有 container 的回显日志打到系统的 journald 服务中</strong></li>
<li>fluentd <strong>把所有 container 的回显日志打到 fluentd 服务中</strong></li>
<li>gelf <strong>把所有 container 的回显日志打到支持 GELF(Graylog Extended Log Format) 格式的服务中, 比如 Graylog 或 Logstash</strong></li>
</ul>
<p>以上原生的日志引擎是最常用的6种,其中 <code>json-file</code> 是 docker 默认使用的日志系统</p>
<h1 id="为什么选择了journald"><a href="#为什么选择了journald" class="headerlink" title="为什么选择了journald"></a>为什么选择了journald</h1><ul>
<li>首先排除了 <code>none</code> 的日志引擎, 因为它抛弃了宿主机中所有 container 的回显日志</li>
<li>之所有排除 <code>json-file</code> 是因为在实际使用中, 有的 container 在启动后有大量的回显日志, 尤其在程序内部报错时打出的日志信息尤其巨大, 而该 json 文件会放到磁盘对应该 container 的文件夹中越来越大, 常常因为某几个 container 的 json 日志而撑爆整个宿主机的磁盘</li>
<li>syslog 日志收集的方式我在使用 harbor 私有镜像服务的时候见过, harbor 官方提供的部署方式中, 所有的 container 的日志都集中收集在某一个 container 中, 执行 docker logs 的时候会提示你 <code>&quot;logs&quot; command is supported only for &quot;json-file&quot; and &quot;journald&quot; logging drivers (got: syslog)</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># syslog 在 harbor 中的应用解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#harbor 服务由多了 container 组成, 其中有一个 container 的名字叫 "harbor-log" 这个就是整个 harbor 服务日志的大本营</span></span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">55917fe77a5d        nginx:1.11.5                     <span class="string">"nginx -g 'daemon off"</span>   5 weeks ago         Up 5 weeks          0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp         nginx</span><br><span class="line">66a5f3fd3c41        vmware/harbor-jobservice:0.5.0   <span class="string">"/harbor/harbor_jobse"</span>   5 weeks ago         Up 5 weeks                                                           harbor-jobservice</span><br><span class="line">732e69978f61        vmware/harbor-ui:0.5.0           <span class="string">"/harbor/harbor_ui"</span>      5 weeks ago         Up 5 weeks                                                           harbor-ui</span><br><span class="line">61678dddbc21        library/registry:2.5.0           <span class="string">"/entrypoint.sh serve"</span>   5 weeks ago         Up 5 weeks          5000/tcp                                         registry</span><br><span class="line">18a49a051913        vmware/harbor-db:0.5.0           <span class="string">"docker-entrypoint.sh"</span>   5 weeks ago         Up 5 weeks          3306/tcp                                         harbor-db</span><br><span class="line">aac08df72abb        vmware/harbor-log:0.5.0          <span class="string">"/bin/sh -c 'crond &amp;&amp;"</span>   5 weeks ago         Up 5 weeks          0.0.0.0:1514-&gt;514/tcp                            harbor-log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 除了 "harbor-log" 这个容器之外, 所有容器的日志类型都是如下指定的</span></span><br><span class="line"></span><br><span class="line"><span class="string">"LogConfig"</span>: &#123;</span><br><span class="line">    <span class="string">"Type"</span>: <span class="string">"syslog"</span>,</span><br><span class="line">        <span class="string">"Config"</span>: &#123;</span><br><span class="line">            <span class="string">"syslog-address"</span>: <span class="string">"tcp://127.0.0.1:1514"</span>,</span><br><span class="line">            <span class="string">"tag"</span>: <span class="string">"proxy"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有容器的回显日志都发送到了 "127.0.0.1:1514" 这个地址, 而这个地址就是 "harbor-log" 容器对外映射的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看出 harbor 的用法是单独创建一个容器用来收集所有相关容器的日志</span></span><br></pre></td></tr></table></figure>

<p>这个模式在我们生产环境中并不适用, 因为无法通过 <code>docker logs</code> 直接查看日志, 而是需要到指定的容器中去找, 这对于研发查看日志拍错来说无疑是个巨大的麻烦.所以这个日志引擎也不适用于我们的生产环境</p>
<ul>
<li>fluentd 和 gelf 这两个日志服务类型一般是配合 elasticsearch/kibana 来一起使用, 因为回显日志是程序回显, 不是业务日志回显, 所以没有进入到 elasticsearch 分析的需求, 业务日志一部分在 nginx 那一层就分析了, 还有的是通过把日志目录挂载出来, 让宿主机的 Log 服务去处理的. 因为规模比较小, 所以暂时用不到这个重的日志服务. 如果你需要分析很多 container 的日志, 可以考虑使用 fluentd 或 logstash</li>
</ul>
<p><strong>小结:</strong> 因为量级不够大, 用不到 fluentd 和 logstash; 因为研发有需求通过 <code>docker logs</code> 快速查看日志, 所以不能用 syslog; 因为 json-file 有让日志文件无止境变大的问题, 而清掉这个日志只能通过停止⏹docker 服务后才能<code>echo &gt; filename</code>被重定向掉, 否则会引起 docker 服务的崩溃; 最终选择了现在大多数 Linux 发行版默认支持的 journald 日志服务.</p>
<h1 id="更改-docker-的默认存储引擎"><a href="#更改-docker-的默认存储引擎" class="headerlink" title="更改 docker 的默认存储引擎"></a>更改 docker 的默认存储引擎</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; vim &#x2F;etc&#x2F;docker&#x2F;daemon.js</span><br><span class="line">&#123;</span><br><span class="line">    &quot;log-driver&quot;: &quot;journald&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需在 json 配置文件中加入一行日志引擎的配置即可, 最后重启 docker 服务</p>
<p>可以通过 <code>docker info</code> 查看更改后的日志引擎</p>
<h1 id="指定-container-启动时的存储引擎"><a href="#指定-container-启动时的存储引擎" class="headerlink" title="指定 container 启动时的存储引擎"></a>指定 container 启动时的存储引擎</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">         --<span class="built_in">log</span>-driver=journald \</span><br><span class="line">         alpine ash</span><br></pre></td></tr></table></figure>

<p>更换为 journald 日志引擎后, 所有使用 journald 引擎的 container 依然可以通过 <code>docker logs containerName</code> 的方式查看回显日志, 也可以在宿主机中使用 <code>journalctl</code> 命令来查看日志的集合,以下是 journalctl 的常用配置及用法简介</p>
<h1 id="journald-配置文件"><a href="#journald-配置文件" class="headerlink" title="journald 配置文件"></a>journald 配置文件</h1><p>journald 的配置文件存放在 <code>/etc/systemd/journald.conf</code></p>
<p>默认的内容如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Journal]</span><br><span class="line">#Storage&#x3D;auto  存储为自动模式, 其他模式有无日志模式, 纯内存模式和纯磁盘模式</span><br><span class="line">#Compress&#x3D;yes  默认启动压缩功能</span><br><span class="line">#Seal&#x3D;yes   默认加密, 日志文件为二进制文件, 无法 vim或tail 查看</span><br><span class="line">#SplitMode&#x3D;uid</span><br><span class="line">#SyncIntervalSec&#x3D;5m</span><br><span class="line">#RateLimitIntervalSec&#x3D;30s</span><br><span class="line">#RateLimitBurst&#x3D;1000</span><br><span class="line">#SystemMaxUse&#x3D;  精确设置日志可以占用的最大磁盘空间</span><br><span class="line">#SystemKeepFree&#x3D;  保证系统剩余的空间大小</span><br><span class="line">#SystemMaxFileSize&#x3D;</span><br><span class="line">#SystemMaxFiles&#x3D;100</span><br><span class="line">#RuntimeMaxUse&#x3D;</span><br><span class="line">#RuntimeKeepFree&#x3D;</span><br><span class="line">#RuntimeMaxFileSize&#x3D;</span><br><span class="line">#RuntimeMaxFiles&#x3D;100</span><br><span class="line">#MaxRetentionSec&#x3D;</span><br><span class="line">#MaxFileSec&#x3D;1month</span><br><span class="line">#ForwardToSyslog&#x3D;no</span><br><span class="line">#ForwardToKMsg&#x3D;no</span><br><span class="line">#ForwardToConsole&#x3D;no</span><br><span class="line">#ForwardToWall&#x3D;yes</span><br><span class="line">#TTYPath&#x3D;&#x2F;dev&#x2F;console</span><br><span class="line">#MaxLevelStore&#x3D;debug</span><br><span class="line">#MaxLevelSyslog&#x3D;debug</span><br><span class="line">#MaxLevelKMsg&#x3D;notice</span><br><span class="line">#MaxLevelConsole&#x3D;info</span><br><span class="line">#MaxLevelWall&#x3D;emerg</span><br></pre></td></tr></table></figure>

<p>journald 默认配置下, 默认日志最大限制为所在文件系统容量的 10%</p>
<p>默认配置下, journald 的日志存放在 <code>/var/log/journal</code> 下, 如果该目录在根分区下, 且根分区空间大小为10G, 那么 journald 存放日志最大的大小为1G, 超出1G 后将删除最早的日志</p>
<p>也可以精确指定占用的空间大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SystemMaxUse&#x3D;50M</span><br></pre></td></tr></table></figure>

<p>其他 journald 的配置也没有细研究过, 主要还是没有需求<del>~</del> 😆</p>
<h1 id="journalctl-的使用"><a href="#journalctl-的使用" class="headerlink" title="journalctl 的使用"></a>journalctl 的使用</h1><ul>
<li><code>journalctl</code> 从头查看所有日志</li>
<li><code>journalctl -b</code> 查看本次开机后的所有系统引导日志 <code>journalctl -b -1</code> 显示上次开机后的系统引导日志, 以此类推</li>
<li><code>journalctl -f</code> 类似于 <code>tail -f</code>或<code>tailf</code></li>
<li><code>journalctl /usr/bin/dockerd</code> 后加程序的绝对路径,可以显示该程序的所有日志信息</li>
<li><code>journalctl -xe</code> systemd 启动程序失败时会提示你使用这个命令查看错误信息, 其中<code>x</code> 表示在日志输出中增加一些解释性的短文本, <code>e</code>表示立即跳转至日志的尾部</li>
</ul>
<h1 id="journald-使用注意事项"><a href="#journald-使用注意事项" class="headerlink" title="journald 使用注意事项"></a>journald 使用注意事项</h1><p>在 journald 日志引擎的实际使用中, 我们发现了另一个问题, 就是 journald 的默认配置文件中的一个问题. 在 journald 默认的配置文件中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@larry-ali:~<span class="comment"># cat /etc/systemd/journald.conf</span></span><br><span class="line"><span class="comment">#  This file is part of systemd.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span><br><span class="line"><span class="comment">#  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="comment">#  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="comment">#  (at your option) any later version.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Entries in this file show the compile time defaults.</span></span><br><span class="line"><span class="comment"># You can change settings by editing this file.</span></span><br><span class="line"><span class="comment"># Defaults can be restored by simply deleting this file.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># See journald.conf(5) for details.</span></span><br><span class="line"></span><br><span class="line">[Journal]</span><br><span class="line"><span class="comment">#Storage=auto</span></span><br><span class="line"><span class="comment">#Compress=yes</span></span><br><span class="line"><span class="comment">#Seal=yes</span></span><br><span class="line"><span class="comment">#SplitMode=uid</span></span><br><span class="line"><span class="comment">#SyncIntervalSec=5m</span></span><br><span class="line"><span class="comment">#RateLimitInterval=30s</span></span><br><span class="line"><span class="comment">#RateLimitBurst=1000</span></span><br><span class="line"><span class="comment">#SystemMaxUse=</span></span><br><span class="line"><span class="comment">#SystemKeepFree=</span></span><br><span class="line"><span class="comment">#SystemMaxFileSize=</span></span><br><span class="line"><span class="comment">#SystemMaxFiles=100</span></span><br><span class="line"><span class="comment">#RuntimeMaxUse=</span></span><br><span class="line"><span class="comment">#RuntimeKeepFree=</span></span><br><span class="line"><span class="comment">#RuntimeMaxFileSize=</span></span><br><span class="line"><span class="comment">#RuntimeMaxFiles=100</span></span><br><span class="line"><span class="comment">#MaxRetentionSec=</span></span><br><span class="line"><span class="comment">#MaxFileSec=1month</span></span><br><span class="line"><span class="comment">#ForwardToSyslog=yes</span></span><br><span class="line"><span class="comment">#ForwardToKMsg=no</span></span><br><span class="line"><span class="comment">#ForwardToConsole=no</span></span><br><span class="line"><span class="comment">#ForwardToWall=yes</span></span><br><span class="line"><span class="comment">#TTYPath=/dev/console</span></span><br><span class="line"><span class="comment">#MaxLevelStore=debug</span></span><br><span class="line"><span class="comment">#MaxLevelSyslog=debug</span></span><br><span class="line"><span class="comment">#MaxLevelKMsg=notice</span></span><br><span class="line"><span class="comment">#MaxLevelConsole=info</span></span><br><span class="line"><span class="comment">#MaxLevelWall=emerg</span></span><br></pre></td></tr></table></figure>

<p>有以下几个非常重要的优化项目</p>
<ul>
<li><code>ForwardToSyslog=yes</code></li>
<li><code>ForwardToWall=yes</code></li>
</ul>
<p>以上两个参数默认都是 <code>yes</code> 意味着 journald 收集日志后还会转发到 syslog 中</p>
<p>由此造成的影响是: journald 虽然可以乖乖的按照上面的配置进行日志的清理, 但是 syslog 却不在 journald 的控制范围之内</p>
<p>在日志量很大的情况下, 我们发现 syslog 中的日志量也变得巨大, 而且里面都是容器的日志, 所以我们需要把上面两个参数的值改为<code>no</code></p>
<p>禁止🚫journald 收到日志后转发给 syslog</p>
<p>更改完配置文件后, 重启 journald 服务 <code>systemctl restart systemd-journald.service</code></p>
<hr>
<p><strong>参考文档</strong></p>
<p>docker 日志引擎官方文档: <a href="https://docs.docker.com/engine/admin/logging/overview/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/logging/overview/</a></p>
<p>journald 配置文件官方文档: <a href="https://www.freedesktop.org/software/systemd/man/journald.conf.html#" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/journald.conf.html#</a></p>
<p>journalctl 命令官方文档: <a href="https://www.freedesktop.org/software/systemd/man/journalctl.html#" target="_blank" rel="noopener">https://www.freedesktop.org/software/systemd/man/journalctl.html#</a></p>
<p>journalctl 中文man手册:<a href="http://www.jinbuguo.com/systemd/journalctl.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/journalctl.html</a></p>
<p>journald.conf 中文手册:<a href="http://www.jinbuguo.com/systemd/journald.conf.html" target="_blank" rel="noopener">http://www.jinbuguo.com/systemd/journald.conf.html</a></p>
<p>journald 初级指南:<a href="http://os.51cto.com/art/201405/440886.htm" target="_blank" rel="noopener">http://os.51cto.com/art/201405/440886.htm</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>journald</tag>
      </tags>
  </entry>
  <entry>
    <title>更改docker存储引擎为overlayfs2</title>
    <url>/2017/02/19/%E6%9B%B4%E6%94%B9docker%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%BAoverlayfs2/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 1.13版本发布后, 在众多的存储引擎中, overlayfs2 脱颖而出, 即将用作为未来主要的存储引擎. 本篇文章介绍如何更改 docker 的存储引擎为 overlayfs2</p>
</blockquote>
<h1 id="require"><a href="#require" class="headerlink" title="require"></a>require</h1><ul>
<li>kernel 4.0+</li>
</ul>
<p>overlayfs 的使用需要保证内核版本不低于3.8, 但是如果使用 overlayfs2 则需要保证内核版本不低于 4.0 </p>
<p><strong>overlayfs2 相比较于 overlayfs 有大量的性能优化和新的特性, 建议使用 overlayfs2</strong></p>
<ul>
<li>Ubuntu 16.04 LTS 中的内核版本为 4.4+</li>
<li>Fedora 25 server 中的内核版本为 4.8+</li>
<li>CentOS 7+ 中的内核版本为 3.10+ 可以使用 yum 安装长期支持版的内核 4.4+ (亲测可用, 但是线上环境慎用)</li>
</ul>
<h1 id="指定存储引擎"><a href="#指定存储引擎" class="headerlink" title="指定存储引擎"></a>指定存储引擎</h1><p>Ubuntu 安装好 docker 后, docker 默认还是使用了 aufs 存储引擎.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/docker/daemon.js</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 docker 的 js 配置文件中, 添加以上一行配置即可, 如果已经有其他配置选项, 记得添加逗号<del>~</del></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [</span><br><span class="line">        <span class="string">"http://172d594a.m.daocloud.io"</span></span><br><span class="line">    ],     <span class="comment"># &lt;--- 一定要注意这个逗号, json 的格式不用再多说了吧...</span></span><br><span class="line">    <span class="string">"storage-driver"</span>: <span class="string">"overlay2"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>overlayfs</tag>
        <tag>overlayfs2</tag>
      </tags>
  </entry>
  <entry>
    <title>docker socket设置</title>
    <url>/2017/02/19/docker-socket%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>在 docker 的官方文档中, 介绍了三种访问 docker Remote API 的方式, 分别是 unix 套接字文件/ tcp 监听端口和 fd 文件描述符. 由于 docker 默认会为我们开启本地 socket 套接字(/var/run/docker.sock) 所以本篇文章主要介绍如何让 docker 监听 tcp端口</p>
</blockquote>
<h1 id="在-docker-配置文件中设置"><a href="#在-docker-配置文件中设置" class="headerlink" title="在 docker 配置文件中设置"></a>在 docker 配置文件中设置</h1><p>docker 1.12 版本之后, 建议在 docker 的 js 配置文件中配置, 路径为 <code>/etc/docker/daemon.js</code> 默认没有这个文件, 可以手动创建此文件, docker 启动时默认会读取此配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/docker/daemon.js</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"hosts"</span>: [</span><br><span class="line">        <span class="string">"tcp://0.0.0.0:2375"</span>,</span><br><span class="line">        <span class="string">"unix:///var/run/docker.sock"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意上面👆一定要写上本地的 socket 位置, 不然无法使用本地的 CLI 控制 docker</p>
<p><code>unix:///var/run/docker.sock</code></p>
<p>修改完js配置文件后, 重启 docker 服务, 出现了如下报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; systemctl restart docker.service</span><br><span class="line">Job <span class="keyword">for</span> docker.service failed because the control process exited with error code. See <span class="string">"systemctl status docker.service"</span> and <span class="string">"journalctl -xe"</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure>

<p>查看日志发现关键信息如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: failed (Result: <span class="built_in">exit</span>-code) since Mon 2017-02-06 12:16:57 CST; 13s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line">  Process: 21952 ExecStart=/usr/bin/dockerd -H fd:// (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 21952 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">Feb 06 12:16:57 xsl systemd[1]: Starting Docker Application Container Engine...</span><br><span class="line">Feb 06 12:16:57 xsl dockerd[21952]: unable to configure the Docker daemon with file /etc/docker/daemon.json: the following directives are specified both as a flag and <span class="keyword">in</span> the configuration file: hosts: (from flag: [fd://], from file: [tcp://0.0.0.0:2375, unix:///var/run/docker.socket])</span><br><span class="line">Feb 06 12:16:57 xsl systemd[1]: docker.service: Main process exited, code=exited, status=1/FAILURE</span><br><span class="line">Feb 06 12:16:57 xsl systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">Feb 06 12:16:57 xsl systemd[1]: docker.service: Unit entered failed state.</span><br><span class="line">Feb 06 12:16:57 xsl systemd[1]: docker.service: Failed with result <span class="string">'exit-code'</span>.</span><br></pre></td></tr></table></figure>

<p>从上面👆的报错信息中可以判断出, 是因为 docker 的 socket 配置出现了冲突, 接下来查看 docker 的启动入口文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /lib/systemd/system/docker.service <span class="comment"># Ubuntu的路径; CentOS 的路径为: /usr/lib/systemd/system/docker.service</span></span><br><span class="line"><span class="comment"># ...省略</span></span><br><span class="line"><span class="comment"># 关键行</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H fd://</span><br><span class="line"><span class="comment"># ...省略</span></span><br></pre></td></tr></table></figure>

<p>从上面可以看出, 在 docker 的启动入口文件中配置了 host 相关的信息, 而在 docker 的配置文件中也配置了 host 的信息, 所以发生了冲突. 解决办法, 建议将 docker 启动入口文件中的 <code>-H fd://</code> 删除, 再重启 docker 服务即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd -H fd://</span></span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br></pre></td></tr></table></figure>

<h1 id="在-docker-启动入口中设置"><a href="#在-docker-启动入口中设置" class="headerlink" title="在 docker 启动入口中设置"></a>在 docker 启动入口中设置</h1><p>当然你也可以在启动入口配置监听的端口和本地 socket 信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /lib/systemd/system/docker.service <span class="comment"># Ubuntu的路径; CentOS 的路径为: /usr/lib/systemd/system/docker.service</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd -H fd://</span></span><br><span class="line">ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock</span><br><span class="line"><span class="comment"># ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375</span></span><br></pre></td></tr></table></figure>

<p>最下面两条配置是等价的, docker 默认的本地 socket 文件就在 <code>/var/run/docker.sock</code> 这个位置, 如果没有特殊需求, 不需要显示的进行配置</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的启动文件和配置文件</title>
    <url>/2017/02/19/docker%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E5%92%8C%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>接触 docker 时间也不短了, 但是 docker 的配置文件一直是个”神秘”的东西, 我在CentOS/Ubuntu/Fedora 平台上都使用过 docker, 而且 docker 的版本从1.9到最新的1.13都用过, 可以说 docker 的配置文件真的是 “乱花渐欲迷人眼”, 写在哪儿的都有. 而且 docker 的启动方式不同读取的配置文件位置也不同, 有的时候改了半天配置文件发现不生效… 今天我们就来找找 docker 的配置文件!</p>
</blockquote>
<h1 id="1-12版本后的万能配置文件"><a href="#1-12版本后的万能配置文件" class="headerlink" title="1.12版本后的万能配置文件"></a>1.12版本后的万能配置文件</h1><p>1.12版本后, 用户可以自行创建 <code>/etc/docker/daemon.js</code> 该文件, 该文件是 docker 进程的配置管理文件, 里面几乎包含了所有 docker 命令行启动可以配置的参数, 不管是哪个平台, 不管是以何种方式启动, 默认都会来这里读取配置, 所以如果你会配置这个文件, 就不会再费力气去找 docker 的普通配置文件或是 docker 的启动入口了</p>
<p>这个文件在前面的文章里有介绍, 官方也给出了使用模板, 有需要的话可以翻看前面的文章查看或是到 docker 的官方文档中查看</p>
<h1 id="查找配置文件"><a href="#查找配置文件" class="headerlink" title="查找配置文件"></a>查找配置文件</h1><p>不管是 CentOS7+/Fedora24+ 还是 Ubuntu16+, 他们现在都使用 <code>systemctl</code> 来管理程序, 所以在以上平台上, 启动 docker 的时候都推荐使用如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; systemctl start docker.service</span><br></pre></td></tr></table></figure>

<p>即使在 Ubuntu 下使用<code>/etc/init.d/docker start</code>的方式启动, 回显也会告诉你他还是使用了 systemd 去管理的. service 也是一样, service 找的就是<code>/etc/init.d/docker</code> 所以使用 service 启动其本质也还是使用了 systemctl 的方式启动的(Ubuntu16.04LTS)</p>
<p>docker启动成功后(当然启动失败也行) 执行如下命令查看 docker 的启动状态(日志)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Mon 2017-02-06 12:43:32 CST; 1s ago</span><br><span class="line">     Docs: https:&#x2F;&#x2F;docs.docker.com</span><br><span class="line"> Main PID: 22100 (dockerd)</span><br><span class="line">    Tasks: 18</span><br><span class="line">   Memory: 12.5M</span><br><span class="line">      CPU: 434ms</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;docker.service</span><br><span class="line">           ├─22100 &#x2F;usr&#x2F;bin&#x2F;dockerd -H fd:&#x2F;&#x2F;</span><br><span class="line">           └─22109 docker-containerd -l unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker&#x2F;libcontainerd&#x2F;docker-containerd.sock --metrics-interval&#x3D;0 --start-timeout 2m --state-dir &#x2F;var&#x2F;run&#x2F;docker&#x2F;libcontainerd&#x2F;containerd --shim docker-containerd-shim --runtime docker-runc</span><br><span class="line"></span><br><span class="line">Feb 06 12:43:31 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:31.890635900+08:00&quot; level&#x3D;warning msg&#x3D;&quot;Your kernel does not support cgroup rt period&quot;</span><br><span class="line">Feb 06 12:43:31 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:31.891099470+08:00&quot; level&#x3D;warning msg&#x3D;&quot;Your kernel does not support cgroup rt runtime&quot;</span><br><span class="line">Feb 06 12:43:31 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:31.892444087+08:00&quot; level&#x3D;info msg&#x3D;&quot;Loading containers: start.&quot;</span><br><span class="line">Feb 06 12:43:31 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:31.903230791+08:00&quot; level&#x3D;info msg&#x3D;&quot;Firewalld running: false&quot;</span><br><span class="line">Feb 06 12:43:32 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:32.205131505+08:00&quot; level&#x3D;info msg&#x3D;&quot;Default bridge (docker0) is assigned with an IP address 172.17.0.0&#x2F;16. Daemon option --bip can be used to set a preferred IP address&quot;</span><br><span class="line">Feb 06 12:43:32 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:32.346345114+08:00&quot; level&#x3D;info msg&#x3D;&quot;Loading containers: done.&quot;</span><br><span class="line">Feb 06 12:43:32 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:32.397174805+08:00&quot; level&#x3D;info msg&#x3D;&quot;Daemon has completed initialization&quot;</span><br><span class="line">Feb 06 12:43:32 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:32.397651049+08:00&quot; level&#x3D;info msg&#x3D;&quot;Docker daemon&quot; commit&#x3D;49bf474 graphdriver&#x3D;aufs version&#x3D;1.13.0</span><br><span class="line">Feb 06 12:43:32 xsl dockerd[22100]: time&#x3D;&quot;2017-02-06T12:43:32.419960532+08:00&quot; level&#x3D;info msg&#x3D;&quot;API listen on &#x2F;var&#x2F;run&#x2F;docker.sock&quot;</span><br><span class="line">Feb 06 12:43:32 xsl systemd[1]: Started Docker Application Container Engine.</span><br></pre></td></tr></table></figure>

<p>在回显的第二行就可以看到<code>Loaded</code>字样, 这行就提示了 docker 启动的入口文件, 如果有需要添加的启动配置, 来这里找就对了!</p>
<p>以上查出来的 docker 文件是 docker 的入口文件, 你可以在入口文件的 docker 启动方式中, 添加一些参数, 也可以像上面写的, 把配置写进”万能配置文件中(js 文件)”</p>
<h1 id="其他配置文件"><a href="#其他配置文件" class="headerlink" title="其他配置文件"></a>其他配置文件</h1><p>让人眼花缭乱的配置文件</p>
<h2 id="etc-default-docker"><a href="#etc-default-docker" class="headerlink" title="/etc/default/docker"></a>/etc/default/docker</h2><p>这个文件在开头的注释中就写到了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Docker Upstart and SysVinit configuration file</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line"># THIS FILE DOES NOT APPLY TO SYSTEMD</span><br><span class="line">#</span><br><span class="line">#   Please see the documentation for &quot;systemd drop-ins&quot;:</span><br><span class="line">#   https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;articles&#x2F;systemd&#x2F;</span><br><span class="line">#</span><br></pre></td></tr></table></figure>

<p>这个配置文件只有在 Linux 使用<code>Sysvinit</code>和<code>Upstart</code>作为初始化 init 系统的时候才会生效, 才会读取这个配置文件, 紧接着下面一行又说了 <code>systemd</code>系统并不适用</p>
<p>而在 Ubuntu16.04 LTS中, 系统默认使用的是 systemd 来管理的, 即使你使用 service, 最后还是重定向到了 systemctl. 所以上面这个配置文件在默认使用 systemd 的 CentOS7+/Fedora24+/Ubuntu16+ 系统中都是没有任何卵用的配置文件!!!</p>
<p>如果你想深入了解三大 init 系统的历史以及发展现状, 可以点开以下参考文档中的链接查看</p>
<ul>
<li><a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html" target="_blank" rel="noopener">sysvinit</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html" target="_blank" rel="noopener">UpStart</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html" target="_blank" rel="noopener">Systemd</a></li>
</ul>
<p><strong>下面我简单区分一下这三大初始化系统</strong></p>
<ol>
<li><p>Sysvinit: CentOS6时代, 我们最熟悉的 <code>service docker restart</code> 命令就出自这个系统管理; 在 Ubuntu 中的 <code>/etc/init.d/docker restart</code> 也是这个系统来管理的</p>
</li>
<li><p>Upstart: 这个初始化系统比较少见, 在 Ubuntu 上比较多见, 启动软件的方式为 <code>restart docker</code> 在 docker 的官方网站中, 介绍基于 Ubuntu14和15版本 docker 启动方式时, 就是使用的这个初始化系统<a href="https://docs.docker.com/engine/admin/" target="_blank" rel="noopener">https://docs.docker.com/engine/admin/</a></p>
</li>
<li><p>Systemd: systemd 是目前大多数 Linux 发行版默认的初始化管理系统, CentOS7+ 和 Ubuntu16+ 都是使用 Systemd 进行管理, 软件启动方式为 <code>systemctl restart docker.service</code></p>
</li>
</ol>
<h2 id="etc-init-d-docker"><a href="#etc-init-d-docker" class="headerlink" title="/etc/init.d/docker"></a>/etc/init.d/docker</h2><p>这个文件只有在系统使用 sysvinit 来管理时才会用到, 因为我的系统默认都使用了 systemd 进行管理, 所以这个文件对我来说也没有任何卵用, 即使我用了 sysvinit 管理程序的语法, 也会被重定向到 systemd 去管理程序. 这个 docker 入口读取的是 <code>/etc/default/docker</code> 这个配置文件</p>
<h2 id="etc-init-docker-conf"><a href="#etc-init-docker-conf" class="headerlink" title="/etc/init/docker.conf"></a>/etc/init/docker.conf</h2><p>这个文件只有在系统使用 Upstart 来管理时才会用到, 无用的道理同上. 这个 docker 入口读取的也是 <code>/etc/default/docker</code> 这个配置文件</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>入口文件</p>
<ul>
<li>/etc/init/docker.conf == service docker start 的入口文件==</li>
<li>/etc/init.d/docker == start docker 的入口文件 ==</li>
<li>/usr/lib/systemd/system/docker == RHEL 系列中 systemctl start docker.service 的入口文件 ==</li>
<li>/lib/systemd/system/docker == Ubuntu 系列中 systemctl start docker.service 的入口文件 ==</li>
</ul>
<p>配置文件</p>
<ul>
<li>/etc/default/docker == service 和 start 的配置文件==</li>
<li>/etc/docker/daemon.js ==1.12版本后万能配置文件==</li>
</ul>
<p><em>如果你使用的是 docker 1.11(含)之前的版本, 如果能升级的话还是升级到最新版本吧. 如果不能升级, 还找不到配置文件, 可以在对应的入口文件中直接在启动命令后面添加参数</em></p>
<p>不知道的时候对 docker 这么多的入口和配置文件感觉真的很烦, 明白了他们的对应关系之后才恍然大悟, 原来 docker 不仅仅为跨平台付出了大量的精力, 连初始化系统也全部都适配到了, 让你不管使用什么系统, 系统使用什么初始化工具都能运用自如, 这里给 docker 点👍 (虽然用不到这么多文件, 而且给我带来了很长时间的困扰)</p>
<hr>
<p><strong>参考文档</strong></p>
<p>Linux文件目录/etc/init和/etc/init.d的前世今生: <a href="https://my.oschina.net/lvyi/blog/183123" target="_blank" rel="noopener">https://my.oschina.net/lvyi/blog/183123</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>为docker配置镜像下载加速</title>
    <url>/2017/02/19/%E4%B8%BAdocker%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E4%B8%8B%E8%BD%BD%E5%8A%A0%E9%80%9F/</url>
    <content><![CDATA[<blockquote>
<p>前面的文章介绍了 docker 默认的配置文件, 本篇文章介绍如何在配置文件中配置 docker 的镜像下载加速</p>
</blockquote>
<h1 id="daocloud-方案"><a href="#daocloud-方案" class="headerlink" title="daocloud 方案"></a>daocloud 方案</h1><p>daocloud 不仅仅为我们提供了镜像加速的地址, 而且为我们提供了便捷的配置方式</p>
<p><code>curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://172d594a.m.daocloud.io</code></p>
<p>执行如上命令之后重启 docker 服务即可让镜像加速的配置生效, 你可以查看 <code>/etc/docker/daemon.js</code> 文件里的内容(如果这个文件不存在, daocloud 的脚本会自动创建)</p>
<h1 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/docker/daemon.js</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"registry-mirrors"</span>: [<span class="string">"http://172d594a.m.daocloud.io"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入以上配置, 重启 docker 服务即可生效, 生效后, 可以通过 <code>docker info</code> 命令查看详细信息</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>镜像加速</tag>
      </tags>
  </entry>
  <entry>
    <title>docker配置文件</title>
    <url>/2017/02/19/docker-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>docker 的版本更新比较快, 而且现在几乎支持了包括 windows 和 mac 在内的所有系统平台(不知道啥时候可以在手机上运行 docker🐳 😆) 我在刚接触 docker 的时候使用的是1.9版本, 现在已经更新到了1.13.1版本, 变化很大, 相信有好多友友都找不到docker 的配置文件在哪里, 需要指定一些功能时, 一般会去 docker 的启动文件里配置. 本篇文章就介绍 docker 的默认配置文件在哪里, 怎么用</p>
</blockquote>
<p>docker 1.12 版本之后, Linux 下(Ubuntu/RHEL/CentOS/Fedora/…)docker 的默认配置文件存放在 <code>/etc/docker/daemon.js</code> </p>
<p><strong>如果你的 docker 是新装的, 那么这个文件默认不存在, 需要自己创建</strong></p>
<p>根据官方文档介绍, <code>daemon.js</code>的配置模板如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"api-cors-header"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"authorization-plugins"</span>: [],</span><br><span class="line">    <span class="attr">"bip"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"bridge"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"cgroup-parent"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"cluster-store"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"cluster-store-opts"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"cluster-advertise"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"default-gateway"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"default-gateway-v6"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"default-runtime"</span>: <span class="string">"runc"</span>,</span><br><span class="line">    <span class="attr">"default-ulimits"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"disable-legacy-registry"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"dns"</span>: [],</span><br><span class="line">    <span class="attr">"dns-opts"</span>: [],</span><br><span class="line">    <span class="attr">"dns-search"</span>: [],</span><br><span class="line">    <span class="attr">"exec-opts"</span>: [],</span><br><span class="line">    <span class="attr">"exec-root"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"fixed-cidr"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"fixed-cidr-v6"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"graph"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"group"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"hosts"</span>: [],</span><br><span class="line">    <span class="attr">"icc"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"insecure-registries"</span>: [],</span><br><span class="line">    <span class="attr">"ip"</span>: <span class="string">"0.0.0.0"</span>,</span><br><span class="line">    <span class="attr">"iptables"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"ipv6"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"ip-forward"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"ip-masq"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"labels"</span>: [],</span><br><span class="line">    <span class="attr">"live-restore"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"log-driver"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"log-level"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"log-opts"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"max-concurrent-downloads"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"max-concurrent-uploads"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"mtu"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"oom-score-adjust"</span>: <span class="number">-500</span>,</span><br><span class="line">    <span class="attr">"pidfile"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"raw-logs"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"registry-mirrors"</span>: [],</span><br><span class="line">    <span class="attr">"runtimes"</span>: &#123;</span><br><span class="line">        <span class="attr">"runc"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"runc"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"custom"</span>: &#123;</span><br><span class="line">            <span class="attr">"path"</span>: <span class="string">"/usr/local/bin/my-runc-replacement"</span>,</span><br><span class="line">            <span class="attr">"runtimeArgs"</span>: [</span><br><span class="line">                <span class="string">"--debug"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"selinux-enabled"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"storage-driver"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"storage-opts"</span>: [],</span><br><span class="line">    <span class="attr">"swarm-default-advertise-addr"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tls"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"tlscacert"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tlscert"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tlskey"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"tlsverify"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"userland-proxy"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"userns-remap"</span>: <span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方给出的模板中, 包含了大量的配置参数, 其中大多数如果没有特殊需求, 我们不需要特殊指定, 稍后的文章中, 我会根据此模板文件, 定制自己对 docker 的需求</p>
<hr>
<p>官方文档: <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a></p>
<p>官方文档-启动项加载参数v18.03: <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/dockerd/</a><br>官方文档-启动项加载参数v17.03: <a href="https://docs.docker.com/v17.03/edge/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">https://docs.docker.com/v17.03/edge/engine/reference/commandline/dockerd/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>configfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 程序前台后台之间的切换</title>
    <url>/2017/02/19/Linux-%E7%A8%8B%E5%BA%8F%E5%89%8D%E5%8F%B0%E5%90%8E%E5%8F%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>在 Linux 中, 我们执行命令的时候, 有时会忘记放到后台执行, 而阻塞在终端前台执行, 一般情况下会 control+c 掉再重新执行, 加入放入到后台的命令, 本篇文章介绍一种方法, 不需要 control+c 掉就能直接放入到后台执行, 且支持前台后台的切换</p>
</blockquote>
<ul>
<li>在前台启动程序</li>
</ul>
<p>我这里有个 webtty 的小程序, 现在我在前台执行它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; ttyd -p 8080 bash</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7759] INFO: ttyd 1.2.2 (libwebsockets 1.7.5)</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7759] INFO: tty configuration:</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7760] INFO:   start command: bash</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7760] INFO:   reconnect timeout: 10s</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7760] INFO:   close signal: SIGHUP (1)</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:31:42:7799] INFO: listening on port 8080</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:32:02:1003] INFO: HTTP &#x2F; - 10.1.100.239 (10.1.100.239)</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:32:02:5699] INFO: HTTP &#x2F;auth_token.js - 10.1.100.239 (10.1.100.239)</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:32:03:3588] INFO: WS   &#x2F;ws - 10.1.100.239 (10.1.100.239), clients: 1</span><br><span class="line">[2017&#x2F;01&#x2F;05 14:32:03:3600] INFO: started process, pid: 29018</span><br></pre></td></tr></table></figure>

<p>现在这个程序挂在了我终端的前台执行, 运行正常</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20170205-144740@2x.png" alt=""></p>
<ul>
<li>输入 control+z 暂停程序的执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ttyd -p 8080 bash</span><br><span class="line">[2017/01/05 14:31:42:7759] INFO: ttyd 1.2.2 (libwebsockets 1.7.5)</span><br><span class="line">[2017/01/05 14:31:42:7759] INFO: tty configuration:</span><br><span class="line">[2017/01/05 14:31:42:7760] INFO:   start <span class="built_in">command</span>: bash</span><br><span class="line">[2017/01/05 14:31:42:7760] INFO:   reconnect timeout: 10s</span><br><span class="line">[2017/01/05 14:31:42:7760] INFO:   close signal: SIGHUP (1)</span><br><span class="line">[2017/01/05 14:31:42:7799] INFO: listening on port 8080</span><br><span class="line">[2017/01/05 14:32:02:1003] INFO: HTTP / - 10.1.100.239 (10.1.100.239)</span><br><span class="line">[2017/01/05 14:32:02:5699] INFO: HTTP /auth_token.js - 10.1.100.239 (10.1.100.239)</span><br><span class="line">[2017/01/05 14:32:03:3588] INFO: WS   /ws - 10.1.100.239 (10.1.100.239), clients: 1</span><br><span class="line">[2017/01/05 14:32:03:3600] INFO: started process, pid: 29018</span><br><span class="line">^Z</span><br><span class="line">[1]+  Stopped                 ttyd -p 8080 bash</span><br></pre></td></tr></table></figure>

<p>现在再次访问 webtty 已经没有响应, 但是没有报错退出, 显然程序是被 “暂停⏸” 了, 而不是被退出了, 再开一个终端可以看见, 进程在, 端口也在, 进程状态如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root     29016  0.0  0.1 142632  3504 pts&#x2F;0    Tl   14:31   0:00 ttyd -p 8080 bash</span><br></pre></td></tr></table></figure>

<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20170205-144740@2x.png" alt=""></p>
<ul>
<li>使用 bg 命令将暂停的程序放入到后台继续执行</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">jobs</span> <span class="comment"># 查看后台任务状态</span></span><br><span class="line">[1]+  Stopped                 ttyd -p 8080 bash</span><br><span class="line">&gt; <span class="built_in">bg</span> %1 <span class="comment"># 从上面可以查询到, 有一个任务, 任务 ID 为 1,现在是暂停的状态, 使用 bg %ID 的参数将此任务放入到后台执行</span></span><br><span class="line">[1]+ ttyd -p 8080 bash &amp;</span><br></pre></td></tr></table></figure>

<p>这时, 系统会自动帮我们在启动命令的最后面加入一个 <code>&amp;</code> 后台命令启动</p>
<p>此时 webtty 的工作又恢复了正常, 而且之前暂停时在 webtty 输入的内容也都显示了出来, 由此可以看出, control+z 阻塞了程序的入口</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20170205-144725@2x.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 再次查看后台任务</span><br><span class="line">&gt; jobs</span><br><span class="line">[1]+  Running                 ttyd -p 8080 bash &amp;</span><br></pre></td></tr></table></figure>

<p>状态显示已在运行</p>
<ul>
<li>将已经在后台运行的程序再拉回到前台执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; jobs</span><br><span class="line">[1]+  Running                 ttyd -p 8080 bash &amp;</span><br><span class="line">&gt; fg %1 # 使用 fg %ID 的方式可以把后台运行的程序拉回到前台执行</span><br><span class="line">ttyd -p 8080 bash</span><br></pre></td></tr></table></figure>

<ul>
<li><p>关闭程序</p>
</li>
<li><p>运行在前台的程序需要关闭执行按下 <code>control+c</code> 组合键即可</p>
</li>
<li><p>运行在后台的程序需要关闭执行 <code>kill %ID</code> 即可</p>
</li>
</ul>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20170205-145217@2x.png" alt=""></p>
<p><strong>参考文章</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/wangshuo/archive/2011/04/11/2012620.html" target="_blank" rel="noopener">http://www.cnblogs.com/wangshuo/archive/2011/04/11/2012620.html</a></li>
<li><a href="http://blog.csdn.net/zklth/article/details/8909350" target="_blank" rel="noopener">http://blog.csdn.net/zklth/article/details/8909350</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>jobs</tag>
      </tags>
  </entry>
  <entry>
    <title>Tomcat 时区设置</title>
    <url>/2017/02/19/Tomcat-%E6%97%B6%E5%8C%BA%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>从 tomcat 官网中下载下来的软件包, 默认使用的是格林尼治标准时间, 与中国的时间相差8个小时, 此时我们需要修改 tomcat 中的配置, 让其变为东八区的时间</p>
</blockquote>
<p>最近新装的 tomcat 发现与北京时间相差正好8小时, 查看系统时间没有问题, 是正确的, 问题出在 tomcat 中, 需要对 tomcat 做如下修改</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> apache-tomcat-8.0.39/bin</span><br><span class="line">&gt; vim catalina.sh</span><br><span class="line"><span class="comment"># 在这个启动脚本中, 找到如下行并替换</span></span><br><span class="line"><span class="comment"># JAVA_OPTS="$JAVA_OPTS -Djava.protocol.handler.pkgs=org.apache.catalina.webresources"</span></span><br><span class="line"><span class="comment"># 替换为</span></span><br><span class="line">JAVA_OPTS=<span class="string">"<span class="variable">$JAVA_OPTS</span> -Djava.protocol.handler.pkgs=org.apache.catalina.webresources -Duser.timezone=GMT+08"</span></span><br></pre></td></tr></table></figure>

<p>拷贝你的 Java_OPTS 原有的配置, 注释后, 在下面粘贴, 并在末尾处添加 <code>-Duser.timezone=GMT+08</code> 保存退出, 重启 tomcat 服务器即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>解决docker容器不支持中文的问题</title>
    <url>/2017/02/19/%E8%A7%A3%E5%86%B3docker%E5%AE%B9%E5%99%A8%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>我们 pull 下来的大多镜像时不支持中文的, 网上也有好多文章介绍如何让 container 支持中文, 有的写的挺复杂的, 把运维都看晕了, 有的按照他写的执行过后发现还是不能正常显示中文, 或是又引发了其他问题… 这里给大家介绍一个简单的方法让 docker 容器支持中文</p>
</blockquote>
<h1 id="已经启动的容器"><a href="#已经启动的容器" class="headerlink" title="已经启动的容器"></a>已经启动的容器</h1><p>由于容器是根据镜像而来, 已经启动的容器或已经存在的镜像不支持配置永久生效(当然你也可以在容器内配置之后, 再出来保存容器的状态为一个新的镜像) 所以下面的配置操作, 只对当前容器的生存周期有效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker <span class="built_in">exec</span> -it containerID /bin/bash</span><br><span class="line">&gt;&gt; <span class="built_in">echo</span> <span class="string">'export LANG="en_US.UTF-8"'</span> &gt;&gt; /etc/profile</span><br><span class="line">&gt;&gt; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h1 id="配置镜像支持中文"><a href="#配置镜像支持中文" class="headerlink" title="配置镜像支持中文"></a>配置镜像支持中文</h1><p>只需要在 dockerfile 中加入如下一行配置即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line">ENV LANG=<span class="string">"en_US.UTF-8"</span></span><br></pre></td></tr></table></figure>

<p>有人可能会问为什么不是用<code>zh_CN.UTF-8</code>而是用<code>en_US.UTF-8</code></p>
<p>这个问题很棒👍 我也不清楚, 但是我查阅了资料, 整理如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8：你说英语，你在美国，字符集是utf-8 </span><br><span class="line">zh_CN.UTF-8：你说中文，你在中国，字符集是utf-8 </span><br><span class="line"></span><br><span class="line">如果你的LANG环境变量是en_US.UTF-8，那么系统的菜单、程序的工具栏语言、输入法默认语言就都是英文的</span><br><span class="line"></span><br><span class="line">如果你的LANG环境变量是zh_CN.UTF-8，那么系统的菜单、程序的工具栏语言、输入法默认语言就都是中文的</span><br></pre></td></tr></table></figure>

<p>在运维的实际应用中, 系统一般都是使用英文环境, 且支持中文字符的, 因为在自动化的过程中, 系统的回显是英文会避免很多不必要的问题</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>中文</tag>
      </tags>
  </entry>
  <entry>
    <title>使用淘宝 npm 镜像源</title>
    <url>/2017/02/19/%E4%BD%BF%E7%94%A8%E6%B7%98%E5%AE%9D-npm-%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<p>镜像使用方法（三种办法任意一种都能解决问题，建议使用第三种，将配置写死，下次用的时候配置还在）:</p>
<ul>
<li>通过config命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org </span><br><span class="line">&gt; npm info underscore <span class="comment">#如果上面配置正确这个命令会有字符串response</span></span><br></pre></td></tr></table></figure>

<ul>
<li>命令行指定</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm --registry https://registry.npm.taobao.org info underscore</span><br></pre></td></tr></table></figure>

<ul>
<li>编辑 ~/.npmrc 加入下面内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><strong>参考文章</strong></p>
<p><a href="http://www.cnblogs.com/trying/p/4064518.html" target="_blank" rel="noopener">http://www.cnblogs.com/trying/p/4064518.html</a></p>
<p><strong>官网站点</strong></p>
<p><a href="https://npm.taobao.org" target="_blank" rel="noopener">https://npm.taobao.org</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>Failed to start LSB: Bring up/down networking</title>
    <url>/2017/02/19/Failed-to-start-LSB-Bring-up-down-networking/</url>
    <content><![CDATA[<blockquote>
<p>在执行<code>systemctl restart network</code>的时候,出现了<code>Failed to start LSB: Bring up/down networking</code>的报错</p>
</blockquote>
<p>解决的办法（由于centos7中没有70-persistent-net.rules这个文件，复制出来的虚拟机(vmware）需要修改mac地址），就是修改mac地址</p>
<p>查看网卡配置文件中是否存在 mac 地址的配置, 如果有, 直接删除再重启网卡即可</p>
<p><em>以上问题在虚拟机中出现的比较多, 大多是因为 mac 地址配置的问题, 在 centos6 系列中, 可以直接删除<code>70-persistent-net.rules</code>这个文件, 重启服务器即可(具体位置可以通过 find /etc/ -name “70-persistent-net.rules” 的方式来查找)</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>优秀的web console之codetainer的搭建与使用</title>
    <url>/2016/12/28/codetainer%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>优秀的 web console PasS 服务商 codepicnic <a href="https://codepicnic.com" target="_blank" rel="noopener">https://codepicnic.com</a> 有了开源的克隆版. 搜索了一些codetainer搭建的相关文档, 都引用了 github 的官方介绍, 但是官方说明比较简单, 安装过程中的一些报错严重影响了用户对codetainer的体验, 本篇文章介绍 codetainer 的部署与使用</p>
</blockquote>
<h1 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h1><h2 id="安装-docker-环境"><a href="#安装-docker-环境" class="headerlink" title="安装 docker 环境"></a>安装 docker 环境</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tee /etc/yum.repos.d/docker.repo &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install docker-engine</span><br><span class="line">systemctl <span class="built_in">enable</span> docker.service</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>


<h2 id="安装-golang-环境"><a href="#安装-golang-环境" class="headerlink" title="安装 golang 环境"></a>安装 golang 环境</h2><p>根据自己的平台选择对应的安装包, 这里我使用的环境为 CentOS7.2 所以选择了如下安装包下载</p>
<p><code>go1.7.4.linux-amd64.tar.gz    Archive    Linux    64-bit    80MB    47fda42e46b4c3ec93fa5d4d4cc6a748aa3f9411a2a2b7e08e3a6d80d753ec8b</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://storage.googleapis.com/golang/go1.7.4.linux-amd64.tar.gz</span><br><span class="line">tar -xvzf go1.7.4.linux-amd64.tar.gz</span><br><span class="line">mv go /usr/<span class="built_in">local</span>/</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export GOROOT=/usr/local/go"</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin"</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export GOPATH=<span class="variable">$HOME</span>/work"</span> &gt;&gt; /etc/profile</span><br><span class="line">mkdir <span class="variable">$HOME</span>/work</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h2 id="安装-go-bindata"><a href="#安装-go-bindata" class="headerlink" title="安装 go-bindata"></a>安装 go-bindata</h2><p><code>go get -u github.com/jteeuwen/go-bindata/...</code></p>
<p>安装了 <code>go-bindata</code> 后如果还是报: <code>go-bindata command not found</code> 的话, 就进行如下操作</p>
<p><code>ln -s $GOPATH/bin/go-bindata $GOROOT/bin</code></p>
<p>可以用 <code>cp</code> 也可以用 <code>ln</code>, 当然也可以把这个路径添加到 <code>PATH</code>中, 总之只要环境变量 <code>PATH</code> 能找到就行</p>
<h2 id="安装-godep"><a href="#安装-godep" class="headerlink" title="安装 godep"></a>安装 godep</h2><p><code>go get github.com/tools/godep</code></p>
<h1 id="安装-codetainer"><a href="#安装-codetainer" class="headerlink" title="安装 codetainer"></a>安装 codetainer</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get github.com/codetainerapp/codetainer</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/codetainerapp/codetainer</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>make 成功后会生成这个文件 <code>$GOPATH/src/github.com/codetainerapp/codetainer/bin/codetainer</code></p>
<h2 id="docker-配置"><a href="#docker-配置" class="headerlink" title="docker 配置"></a>docker 配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/systemd/system/docker.service</span><br><span class="line"><span class="comment"># 将 ExecStart=/usr/bin/docker daemon -H fd:// 这行修改为下面这行</span></span><br><span class="line">ExecStart=/usr/bin/docker daemon -H fd:// -H tcp://127.0.0.1:4500 -H unix:///var/run/docker.sock</span><br><span class="line"><span class="comment"># 修改完毕后保存退出</span></span><br></pre></td></tr></table></figure>

<h2 id="codetainer-配置"><a href="#codetainer-配置" class="headerlink" title="codetainer 配置"></a>codetainer 配置</h2><p>codetainer 的默认配置文件只有在 codetainer命令第一次执行之后才会自动创建, 自动创建的配置文件在 <code>$HOME/.codetainer/config.toml</code></p>
<p>默认只有两行, 如果上面你没有修改过 docker API 监听的端口, 那这一步骤你是不需要关心的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DockerServer &#x3D; &quot;localhost&quot;</span><br><span class="line">DockerPort &#x3D; 4500</span><br></pre></td></tr></table></figure>

<p>官方给出的配置说明如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Docker API server and port</span><br><span class="line">DockerServer &#x3D; &quot;localhost&quot;</span><br><span class="line">DockerPort &#x3D; 4500</span><br><span class="line"></span><br><span class="line"># Enable TLS support (optional, if you access to Docker API over HTTPS)</span><br><span class="line"># DockerServerUseHttps &#x3D; true</span><br><span class="line"># Certificate directory path (optional)</span><br><span class="line">#   e.g. if you use Docker Machine: &quot;~&#x2F;.docker&#x2F;machine&#x2F;certs&quot;</span><br><span class="line"># DockerCertPath &#x3D; &quot;&#x2F;path&#x2F;to&#x2F;certs&quot;</span><br><span class="line"></span><br><span class="line"># Database path (optional, default is ~&#x2F;.codetainer&#x2F;codetainer.db)</span><br><span class="line"># DatabasePath &#x3D; &quot;&#x2F;path&#x2F;to&#x2F;codetainer.db&quot;</span><br></pre></td></tr></table></figure>

<h2 id="启动-codetainer"><a href="#启动-codetainer" class="headerlink" title="启动 codetainer"></a>启动 codetainer</h2><p>以下是官方案例, 这里我不做修改, 只说明一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/codetainerapp/codetainer/bin/</span><br><span class="line">$ docker pull ubuntu:14.04  <span class="comment"># 你可以下载任意一个你需要的镜像</span></span><br><span class="line">$ ./codetainer image register ubuntu:14.04  <span class="comment"># 把你需要托管到codetainer的镜像注册给codetainer</span></span><br><span class="line">$ ./codetainer create ubuntu:14.04 my-codetainer-name <span class="comment"># 启动你托管给codetainer的镜像</span></span><br><span class="line">$ ./codetainer server  <span class="comment"># to start the API server on port 3000</span></span><br><span class="line"><span class="comment"># 最后一步是启动 codetainer 服务</span></span><br></pre></td></tr></table></figure>

<p>codetainer 服务启动后默认会卡在前台, 提示你已经监听了 127.0.0.1:3000 这个地址</p>
<p>不用管这个监听了本地3000端口地址的提示, 你可以执行如下命令查看监听的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -antupl</span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp6       0      0 :::3000                 :::*                    LISTEN      20597/./codetainer</span><br></pre></td></tr></table></figure>

<p>这里可以看到 codetainer 的服务监听了所有 IP 的3000端口</p>
<h2 id="登录你的-web-console"><a href="#登录你的-web-console" class="headerlink" title="登录你的 web console"></a>登录你的 web console</h2><p>我试了下, 直接打开 <code>http://IP:3000</code> 是有问题的, 如果需要登录到 console, 需要知道你刚刚使用 codetainer 启动的镜像 id, 可以通过以下方式查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/codetainerapp/codetainer/bin/</span><br><span class="line"></span><br><span class="line">./codetainer list  </span><br><span class="line">Found 1 codetainers.</span><br><span class="line">-- [5ded5ca44ce1d9347a7d8556675b6a269b922660a27eef02df631bd323ed8057] mycode (Running)</span><br></pre></td></tr></table></figure>

<p>通过 <code>./codetainer list</code> 可以查看当前 codetainer 托管的镜像 id (这里我说的镜像<br>id 指的是在 codetainer 里管理的 id, 而不是 docker 管理 container 的 id )</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                  14.04               3f755ca42730        12 days ago         187.9 MB</span><br><span class="line"></span><br><span class="line"> docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">5ded5ca44ce1        3f755ca42730        <span class="string">"/bin/bash"</span>         6 hours ago         Up 6 hours                              mycode</span><br><span class="line"></span><br><span class="line">./codetainer image list  </span><br><span class="line">Found 1 images:</span><br><span class="line">-- [sha256:3f755ca4273009a8b9d08aa156fbb5e601ed69dc698860938f36b2109c19cc39] [ubuntu:14.04]</span><br><span class="line"></span><br><span class="line">./codetainer list  </span><br><span class="line">Found 1 codetainers.</span><br><span class="line">-- [5ded5ca44ce1d9347a7d8556675b6a269b922660a27eef02df631bd323ed8057] mycode (Running)</span><br></pre></td></tr></table></figure>

<p>自行感受他们的区别吧<del>~</del></p>
<p>找到 <code>./codetainer list</code>回显出来的 id 之后就可以访问我们的 web console 啦</p>
<p>访问这个地址: http://<IP>:3000/api/v1/codetainer/<id>/view</p>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20161228-0@2x.png" alt="codetainer"></p>
<p>到这里实现了在一台宿主机中启动一个容器来提供 terminal </p>
<p>下面我来介绍下如何在一台宿主机上启动多个 container 来提供过个 terminal</p>
<h1 id="多-terminal"><a href="#多-terminal" class="headerlink" title="多 terminal"></a>多 terminal</h1><p>不难发现, web console 的服务是 codetainer 来提供的, 他提供了前端页面, 提供与 docker API 的交互, 所以, 只要我们使用 <code>./codetainer create</code> 命令启动多个容器, 就可以在 <code>./codetainer list</code> 上看到多个”主机”, 查到他们的 id, 就可以在 url 中通过更换 id 的值来访问不通的 terminal</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  bin git:(master) ✗ ./codetainer list</span><br><span class="line">Found 1 codetainers.</span><br><span class="line">-- [5ded5ca44ce1d9347a7d8556675b6a269b922660a27eef02df631bd323ed8057] mycode (Running)</span><br><span class="line">➜  bin git:(master) ✗ ./codetainer create ubuntu:14.04 mycode2</span><br><span class="line">Codetainer mycode2 creation succeeded!</span><br><span class="line">You can interact with it here: http://localhost:3000/api/v1/codetainer/c2d2fc896a60d37a7d1fd9d365850518d2ba7da853cc35563d68f4c32533912f/view</span><br><span class="line">➜  bin git:(master) ✗ ./codetainer list                       </span><br><span class="line">Found 2 codetainers.</span><br><span class="line">-- [5ded5ca44ce1d9347a7d8556675b6a269b922660a27eef02df631bd323ed8057] mycode (Running)</span><br><span class="line">-- [c2d2fc896a60d37a7d1fd9d365850518d2ba7da853cc35563d68f4c32533912f] mycode2 (Running)</span><br></pre></td></tr></table></figure>

<p>可以看到我们在使用 <code>ubuntu:14.04</code> 镜像创建第二个容器的时候, 回显自动给出了访问的地址, 因为我现在的 server 已经启动, 在 server 没有启动的时候, 只能通过手动查找 id 的方式来访问</p>
<p>以上我依然使用了 <code>ubuntu:14.04</code> 镜像, 你可以在 pull 下来新的镜像注册到 codetainer服务中. 例如:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos:latest</span><br><span class="line">codetainer image register centos:latest</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>docker 官方安装文档: <a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="noopener">https://docs.docker.com/engine/installation/linux/centos/</a><br>codetainer 项目 github 地址: <a href="https://github.com/codetainerapp/codetainer" target="_blank" rel="noopener">https://github.com/codetainerapp/codetainer</a><br>go-bindata 项目 github 地址: <a href="https://github.com/jteeuwen/go-bindata" target="_blank" rel="noopener">https://github.com/jteeuwen/go-bindata</a><br>godep 项目 github 地址: <a href="https://github.com/tools/godep" target="_blank" rel="noopener">https://github.com/tools/godep</a><br>golang 官方下载地址: <a href="https://golang.org/dl/" target="_blank" rel="noopener">https://golang.org/dl/</a><br>golang 官方安装文档: <a href="https://golang.org/doc/install" target="_blank" rel="noopener">https://golang.org/doc/install</a><br>go-bindata 报错解决:  <a href="http://blog.csdn.net/lampqiu/article/details/48649881" target="_blank" rel="noopener">http://blog.csdn.net/lampqiu/article/details/48649881</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>web console</tag>
        <tag>codetainer</tag>
        <tag>codepicnic</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqldump迁移方案</title>
    <url>/2016/12/12/mysqldump%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="mysqldump迁移方案"><a href="#mysqldump迁移方案" class="headerlink" title="mysqldump迁移方案"></a>mysqldump迁移方案</h1><blockquote>
<p>数据库D从A主机迁往B主机</p>
</blockquote>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><ul>
<li>前端应用操作D库的用户名和密码</li>
</ul>
<p>向研发人员收集用户名和密码，在B主机的数据库实例中，预先建立用户</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">B: mysql&gt; create user 'username'@'%' identified by 'password';</span><br></pre></td></tr></table></figure>

<ul>
<li>在A主机中查询D库中该用户的权限</li>
</ul>
<p>找到该用户对应的D库的权限SQL语句，保存一下，等到B主机建库后，给该用户赋予权限</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">A: mysql&gt; show grants for username;</span><br></pre></td></tr></table></figure>

<ul>
<li>收集需要迁移的目标数据库的建库参数</li>
</ul>
<p><strong>一般情况下午特殊建库参数，注意字符集</strong></p>
<p><em>用户体系的my.cnf中指定字符集默认为<code>character_set_server=utf8</code></em></p>
<p><em>ocrdb的my.cnf中指定字符集默认为<code>character_set_server=utf8mb4</code></em></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">A: mysql&gt; show create database dbname;</span><br></pre></td></tr></table></figure>

<ul>
<li>为上面指定的用户赋予B主机上新库的权限</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">B: mysql&gt; 在B主机上执行第二步保存的grant语句</span><br></pre></td></tr></table></figure>

<h2 id="迁移前的操作"><a href="#迁移前的操作" class="headerlink" title="迁移前的操作"></a>迁移前的操作</h2><ul>
<li>将A主机上D库用户的<code>insert</code> <code>update</code> <code>delete</code>权限撤销</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">A: mysql&gt; revoke INSERT, UPDATE, DELETE ON databasename.* FROM username;</span><br></pre></td></tr></table></figure>

<ul>
<li>停止连接数据库A的所有前端应用</li>
</ul>
<p>尽可能停止连接<code>数据库A</code>的所有前端应用，不能停止的，将在数据库中<code>kill</code>掉<code>ESTABLISHED</code>的连接，让前端应用的连接池重新连接mysql数据库</p>
<p>检查该用户的连接情况</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">A: $&gt; mysql -uroot -p -e 'show processlist;' | grep username</span><br></pre></td></tr></table></figure>

<p>如果前端应用停止后，仍有其他服务器的连接，则kill掉这些连接，让其重连，重新获取该库权限，并记录这些服务器的IP地址，因为该库迁走并剥夺写入权限后，这些服务器可能会有问题</p>
<h2 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h2><ul>
<li>mysqldump</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A: $&gt; mysqldump -uusername -p databasename | gzip &gt; databasename.sql.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>scp </li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">A: $&gt; scp databasename.sql.gz ps@IP:/tmp/</span><br></pre></td></tr></table></figure>

<ul>
<li>load</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">B: $&gt; gunzip &lt; databasename.sql.gz | mysql -uroot -p databasename</span><br></pre></td></tr></table></figure>

<h2 id="迁移后"><a href="#迁移后" class="headerlink" title="迁移后"></a>迁移后</h2><ul>
<li>在三区开启应用服务器，连接三区mysql</li>
</ul>
<h1 id="附"><a href="#附" class="headerlink" title="附"></a>附</h1><ul>
<li>删除某一用户的所有权限</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">revoke</span> <span class="keyword">all</span> <span class="keyword">on</span> *.* <span class="keyword">from</span> sss@localhost ;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysqldump</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins迁移</title>
    <url>/2016/12/12/Jenkins%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<p>下载 jenkins 对应版本的 rpm 安装包到<code>/usr/local/src/</code>下</p>
<h1 id="新-jenkins-服务器的操作"><a href="#新-jenkins-服务器的操作" class="headerlink" title="新 jenkins 服务器的操作"></a>新 jenkins 服务器的操作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk  java-1.8.0-openjdk-devel</span><br><span class="line">yum install jenkins-1.596.1-1.1.noarch.rpm</span><br><span class="line">mkdir /var/jenkins_home</span><br><span class="line">chown jenkins:jenkins /var/jenkins_home -R</span><br><span class="line"><span class="built_in">export</span> JENKINS_HOME=/var/jenkins_home</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export JENKINS_HOME=/var/jenkins_home"</span> &gt;&gt; /etc/profile</span><br><span class="line">systemctl stop jenkins</span><br><span class="line">mv /var/lib/jenkins /var/lib/jenkins.bak</span><br><span class="line">ln -s /var/jenkins_home /var/lib/jenkins</span><br><span class="line">vim /etc/rc.local </span><br><span class="line">route add -net 192.168.2.0/24 gw 192.168.10.85</span><br><span class="line">route add -net 192.168.8.0/24 gw 192.168.10.85</span><br><span class="line">...</span><br><span class="line">mkdir ~/.ssh</span><br><span class="line">chmod 700 ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将老 jenkins 的 /etc/hosts 信息拷贝过来</span></span><br><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.3.9/binaries/apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">tar -xvzf apache-maven-3.3.9-bin.tar.gz</span><br><span class="line">mv apache-maven-3.3.9 /usr/<span class="built_in">local</span>/apache-maven</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/usr/local/node/bin:/usr/local/apache-maven/bin:<span class="variable">$PATH</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH="/usr/local/node/bin:/usr/local/apache-maven/bin:$PATH"'</span> &gt;&gt; /etc/profile</span><br><span class="line">mvn -v</span><br><span class="line">scp /usr/<span class="built_in">local</span>/apache-maven/conf/settings.xml root@192.168.10.170:/usr/<span class="built_in">local</span>/apache-maven/conf/settings.xml</span><br></pre></td></tr></table></figure>

<h1 id="老-jenkins-服务器的操作"><a href="#老-jenkins-服务器的操作" class="headerlink" title="老 jenkins 服务器的操作"></a>老 jenkins 服务器的操作</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - jenkins</span><br><span class="line"><span class="built_in">cd</span> .ssh</span><br><span class="line">scp id_rsa id_rsa.pub root@192.168.10.170:/root/.ssh/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 jenkins home scp 或 rsync 到新 jenkins 的 jenkins home</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>导入导出防火墙规则</title>
    <url>/2016/12/12/%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E9%98%B2%E7%81%AB%E5%A2%99%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<p>保存规则：<code>iptables-save &gt; /etc/iptables-script</code><br>恢复规则：<code>iptables-restore &lt; /etc/iptables-script</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim iptables.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Generated by iptables-save v1.4.21 on Mon Nov 21 14:49:30 2016</span><br><span class="line">*nat</span><br><span class="line">:PREROUTING ACCEPT [75958158:4710517785]</span><br><span class="line">:INPUT ACCEPT [11156433:697999260]</span><br><span class="line">:OUTPUT ACCEPT [11270560:679018758]</span><br><span class="line">:POSTROUTING ACCEPT [0:0]</span><br><span class="line">-A POSTROUTING -j MASQUERADE</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Mon Nov 21 14:49:30 2016</span><br><span class="line"># Generated by iptables-save v1.4.21 on Mon Nov 21 14:49:30 2016</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [1937717187:1020106795408]</span><br><span class="line">:FORWARD ACCEPT [2772458722:1915560771769]</span><br><span class="line">:OUTPUT ACCEPT [2100892309:1998825790936]</span><br><span class="line">COMMIT</span><br><span class="line"># Completed on Mon Nov 21 14:49:30 2016</span><br></pre></td></tr></table></figure>


<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; iptables-restore &lt; iptables.conf</span><br></pre></td></tr></table></figure>

<h1 id="配置网卡转发"><a href="#配置网卡转发" class="headerlink" title="配置网卡转发"></a>配置网卡转发</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>TimeWait状态连接快速回收</title>
    <url>/2016/12/12/TimeWait%E7%8A%B6%E6%80%81%E8%BF%9E%E6%8E%A5%E5%BF%AB%E9%80%9F%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<p><code>vi /etc/sysctl.conf</code></p>
<p>编辑文件，加入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line"></span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure>


<p>然后执行<code>/sbin/sysctl -p</code>让参数生效。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>time wait</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.x下的gcc升级</title>
    <url>/2016/12/12/CentOS6-x%E4%B8%8B%E7%9A%84gcc%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<blockquote>
<p>node.js项目在使用某些模块是，需要更高版本的gcc的支持，但是CentOS6系列的系统，默认的gcc不符合要求，所以需要对其升级</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum -y install make automaker gcc gcc-c++ -y</span><br><span class="line">&gt; gcc -v</span><br><span class="line">&gt; rpm -ivh https://www.softwarecollections.org/en/scls/rhscl/devtoolset-3/epel-6-x86_64/download/rhscl-devtoolset-3-epel-6-x86_64.noarch.rpm</span><br><span class="line">&gt; yum install devtoolset-3-gcc-c++</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">"source /opt/rh/devtoolset-3/enable"</span> &gt;&gt;/etc/profile</span><br><span class="line">&gt; <span class="built_in">source</span> /etc/profile</span><br><span class="line">&gt; gcc -v</span><br></pre></td></tr></table></figure>

<p>至此，升级成功。</p>
<p>注：CentOS7系统默认的gcc版本符合要求</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>gcc</tag>
      </tags>
  </entry>
  <entry>
    <title>nvm安装</title>
    <url>/2016/12/12/nvm%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>可以到<a href="https://github.com/creationix/nvm/releases" target="_blank" rel="noopener">https://github.com/creationix/nvm/releases</a>下载</p>
<h1 id="安装-amp-验证"><a href="#安装-amp-验证" class="headerlink" title="安装&amp;验证"></a>安装&amp;验证</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[suoper@103-7 /usr/<span class="built_in">local</span>/src]<span class="comment"># tar -xvf nvm-0.31.4.tar</span></span><br><span class="line">[suoper@103-7 ~]$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/nvm-0.31.4</span><br><span class="line">[suoper@103-7 /usr/<span class="built_in">local</span>/src/nvm-0.31.4]$ ./install.sh </span><br><span class="line">[suoper@103-7 /usr/<span class="built_in">local</span>/src/nvm-0.31.4]$ <span class="built_in">source</span>  /home/suoper/.bashrc</span><br><span class="line">[suoper@103-7 /usr/<span class="built_in">local</span>/src/nvm-0.31.4]$ nvm --version</span><br><span class="line">0.31.4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>指定tomcat使用的jdk版本</title>
    <url>/2016/12/12/%E6%8C%87%E5%AE%9Atomcat%E4%BD%BF%E7%94%A8%E7%9A%84jdk%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<blockquote>
<p> 操作目标： 192.168.100.150 cloudfollowadmin 项目指定java 1.8</p>
</blockquote>
<p>192.168.100.150 上有多个tomcat项目，起java版本使用了系统默认的1.6，现在要为cloudfollowadmin项目指定使用java1.8版本，以下是操作步骤</p>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><ul>
<li>找到启动加载的配置文件</li>
<li>在配置文件中指定javahome</li>
</ul>
<p>以下是该项目的完整路径<br><code>/webserver/tomcat/cloudfollowadmin/bin/</code></p>
<p>在该路径下，tomcat启动时会加载执行catalina.sh文件，这里设置了一些环境变量，但是在脚本的中间部分</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim catalina.sh</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment"># Get standard Java environment variables</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$os400</span>; <span class="keyword">then</span></span><br><span class="line">  <span class="comment"># -r will Only work on the os400 if the files are:</span></span><br><span class="line">  <span class="comment"># 1. owned by the user</span></span><br><span class="line">  <span class="comment"># 2. owned by the PRIMARY group of the user</span></span><br><span class="line">  <span class="comment"># this will not work if the user belongs in secondary groups</span></span><br><span class="line">  BASEDIR=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span></span><br><span class="line">  . <span class="string">"<span class="variable">$CATALINA_HOME</span>"</span>/bin/setclasspath.sh</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">if</span> [ -r <span class="string">"<span class="variable">$CATALINA_HOME</span>"</span>/bin/setclasspath.sh ]; <span class="keyword">then</span></span><br><span class="line">    BASEDIR=<span class="string">"<span class="variable">$CATALINA_HOME</span>"</span></span><br><span class="line">    . <span class="string">"<span class="variable">$CATALINA_HOME</span>"</span>/bin/setclasspath.sh</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Cannot find <span class="variable">$CATALINA_HOME</span>/bin/setclasspath.sh"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"This file is needed to run this program"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>在获取java环境变量的时候，实际是读取了该bin目录下，setclasspath.sh脚本的执行结果，所以有此可以推导出，只要在setclasspath.sh脚本中，把java的配置写死，那么tomcat启动时，就会去指定的路径下去找javahome了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim setclasspath.sh</span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line">JAVA_HOME=<span class="string">"/usr/local/src/jdk1.8.0_101/"</span></span><br><span class="line">JRE_HOME=<span class="string">"/usr/local/src/jdk1.8.0_101/jre"</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>在setclasspath.sh脚本的开头，设置java的环境变量，如果你本机的其他java应用需要继续使用tomcat老版本，那么在这个脚本中，千万不要在前面加上export关键字，这样会把这个变量的设置提升为全局变量，会影响到其他应用重启时获取到的javaHome路径</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>jdk</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL迁移方案-单实例单库主从同步迁移</title>
    <url>/2016/12/12/MySQL%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88-%E5%8D%95%E5%AE%9E%E4%BE%8B%E5%8D%95%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h1 id="迁库-amp-同步"><a href="#迁库-amp-同步" class="headerlink" title="迁库&amp;同步"></a>迁库&amp;同步</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在主库锁库</span></span><br><span class="line">mysql&gt; flush tables with read lock;</span><br><span class="line"><span class="comment"># dump主库数据库</span></span><br><span class="line">$ mysqldump -uroot -p OcrManagement &gt; OcrManagement.sql</span><br><span class="line"><span class="comment">#查看主库位置</span></span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+------------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position   | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+------------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000014 | 1058718197 |              | mysql            |                   |</span><br><span class="line">+<span class="comment">------------------+------------+--------------+------------------+-------------------+</span></span><br><span class="line"><span class="comment"># 解锁主库</span></span><br><span class="line">mysql&gt; unlock tables;</span><br><span class="line"><span class="comment"># 将dump出来的sql文件传送到从库</span></span><br><span class="line">$ tar -cvzf OcrManagement.sql.tar.gz OcrManagement.sql</span><br><span class="line">$ scp OcrManagement.sql ps@192.168.3.11:/data/</span><br><span class="line"><span class="comment"># 查看主库数据库建库参数</span></span><br><span class="line">mysql&gt; show create database OcrManagement;</span><br><span class="line"></span><br><span class="line"><span class="comment">----------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># 根据主库建库参数，在从库预先建立数据库</span></span><br><span class="line">mysql&gt; create database OcrManagement;</span><br><span class="line"><span class="comment"># 在从库中解压文件</span></span><br><span class="line">$ tar -xvzf OcrManagement.sql.tar.gz</span><br><span class="line"><span class="comment"># 导入数据</span></span><br><span class="line">$ mysql -uroot -p OcrManagement &lt; OcrManagement.sql</span><br><span class="line"><span class="comment"># 设置主库信息</span></span><br><span class="line">mysql&gt; change master to MASTER_HOST='192.168.168.149',MASTER_PORT=33306,MASTER_USER='repl',MASTER_PASSWORD='xxxxxxxx',MASTER_LOG_FILE='mysql-bin.000014',MASTER_LOG_POS=1058718197;</span><br><span class="line"><span class="comment"># 启动从库线程</span></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line"><span class="comment"># 检查同步状态</span></span><br><span class="line">mysql&gt; show slave status\G</span><br></pre></td></tr></table></figure>

<h1 id="切换主从"><a href="#切换主从" class="headerlink" title="切换主从"></a>切换主从</h1><p>[MySQL主从切换]<a href="https://docs.20150509.cn/2016/12/12/MySQL的主从切换/" target="_blank" rel="noopener">https://docs.20150509.cn/2016/12/12/MySQL的主从切换/</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL迁移</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker相关组件的部署</title>
    <url>/2016/12/12/Docker%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="docker-engine"><a href="#docker-engine" class="headerlink" title="docker-engine"></a>docker-engine</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~  tee &#x2F;etc&#x2F;yum.repos.d&#x2F;docker.repo &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">[dockerrepo]</span><br><span class="line">name&#x3D;Docker Repository</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;repo&#x2F;main&#x2F;centos&#x2F;$releasever&#x2F;</span><br><span class="line">enabled&#x3D;1</span><br><span class="line">gpgcheck&#x3D;1</span><br><span class="line">gpgkey&#x3D;https:&#x2F;&#x2F;yum.dockerproject.org&#x2F;gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  ~ yum install python-pip </span><br><span class="line">➜  ~ pip install --upgrade pip</span><br><span class="line">➜  ~ pip install docker-compose</span><br><span class="line"></span><br><span class="line"># 如果执行 docker-compose 命令有如下报错时, 还需要安装以下软件包</span><br><span class="line"># pkg_resources.DistributionNotFound: backports.ssl-match-hostname&gt;&#x3D;3.5</span><br><span class="line"></span><br><span class="line">➜  ~ pip install backports.ssl-match-hostname&#x3D;&#x3D;3.5.0.1</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker-engine</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下获取本地出口IP</title>
    <url>/2016/12/12/Linux%E4%B8%8B%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E5%87%BA%E5%8F%A3IP/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; curl ifconfig.me</span><br><span class="line">或</span><br><span class="line">&gt; curl http://members.3322.org/dyndns/getip</span><br><span class="line">或</span><br><span class="line">&gt; curl ip.cn</span><br></pre></td></tr></table></figure>

<p><code>ifconfig.me</code> 的域名很好记, 但是在国内的访问速度可能极其缓慢</p>
<p><code>ip.cn</code> 域名也很好记, 在国内返回结果的速度也很快, 而且还能返回运营商的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ curl ip.cn</span><br><span class="line">当前 IP：209.9.108.86 来自：香港特别行政区</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>出口IP</tag>
      </tags>
  </entry>
  <entry>
    <title>超线程技术的应用场景</title>
    <url>/2016/12/12/%E8%B6%85%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<blockquote>
<p>超线程技术不能应用在所有的场景中<br>对于不同的情况来说，其有可能帮助提升虚拟服务器的性能表现<br>但是反过来也有可能造成负面影响<br>而获得良好性能表现的关键就在于判断应该何时使用这种技术</p>
</blockquote>
<h1 id="超线程技术介绍"><a href="#超线程技术介绍" class="headerlink" title="超线程技术介绍"></a>超线程技术介绍</h1><p>超线程是一种计算机处理器技术，能够将一个物理处理器变成两个虚拟处理器。这种方式能够提升处理器核心的指令队列工作效率，从而提高处理器的整体性能表现，此外虚拟化技术也能够受益于这种技术。这种技术允许hypervisor为虚拟机提供之前两倍的虚拟处理器数量——但是超线程技术并不是完美的。如果使用超线程技术，那么效率低下、质量不佳的代码甚至是分配不当的负载都有可能对系统性能造成负面影响。</p>
<p>超线程是英特尔公司的私有技术，其能够帮助提升物理处理器的资源使用效率，保证处理器一直处于繁忙状态，以便完成更多工作。</p>
<p>超线程技术——也被称为<code>HTT</code>或<code>HT</code>——的出现是由于传统物理服务器核心在同一时间只能处理一项任务。所有负载都需要使用处理器的指令通道，但是通常指令通道的使用率并不会达到100%或者一直处于繁忙状态。造成这种现象的部分原因在于应用程序的编码和运行方式不同，此外，由于现代处理器的运行速度越来越快，已经完全超出许多应用程序的需求，因此被浪费的处理器周期越来越多。</p>
<p>超线程技术在处理器核心中添加了新的电路，能够提供额外的指令通道来共享物理处理器的执行资源，比如内存总线、处理器缓存以及处理器的执行引擎。增加的超线程电路能够将物理核心分割成两个逻辑核心。在启用超线程技术之后，每个逻辑处理器都相互独立，中断、停止和操作都独立于另外一个共享相同物理核心的虚拟处理器。当某个逻辑核心空闲时，另外一个逻辑核心将会得到更多的执行资源。</p>
<p>关于超线程技术需要记住的重要一点是在相同物理核心上启用第二个逻辑处理器并不会使得处理器的性能提升一倍。这是因为处理器的执行资源是共享的，并没有翻倍。HTT技术允许处理器在特定时间内处理更多的任务或者指令线程，但是仍然需要使用原有的物理资源完成这些任务。这是超线程架构和多核处理器——比如双核或者四核——的最大区别，多核技术拥有多个物理处理器。</p>
<p>而虚拟处理器的性能提升幅度取决于负载对于处理器的资源需求以及操作系统管理和规划逻辑处理器的能力。如果超线程技术不能识别操作系统，就会使用同样的方式管理所有逻辑处理器，可能会将资源需求很大的负载放在相同核心的逻辑处理器上——这样会对应用程序的性能表现造成负面影响——而同时其他核心并没有得到充分利用。与此形成对比的是，能够识别操作系统的超线程技术可以将线程分配到不同的处理器上，最大程度上提升负载的性能表现。</p>
<p>比如，如果某个应用程序需要使用大量处理器资源，就会一直占用指令队列，那么即便同一个物理处理器核心提供额外的逻辑处理器也无济于事——因为物理处理器已经没有额外的资源可以共享。操作系统可以将第二个线程加入到处理队列中，但是通常其性能表现会非常差，此外，由于其会占用当前运行线程的处理器周期，因此还会导致现有应用程序性能受到影响。Hypervisor或者操作系统应该能够识别HTT，并且最大程度上提升负载对于物理处理器的使用效率，这些都是分配逻辑处理器的前提。如果这个前提不能实现，那么超线程（并非虚拟化）功能应该被禁用。</p>
<p>从hypervisor系统角度来看，超线程并不是虚拟化技术——HTT只是一种位于处理器硬件层、以硬件为基础的虚拟化技术。而虚拟化和hypervisor能够带来哪些好处？超线程和hypervisor之间并没有直接的关联。Hypervisor能够工作在不支持超线程技术的物理处理器上，而支持超线程的处理器也可以使用非虚拟化系统。但是这两种方案可以相互补充，而像VMware vSphere这样的现代hypervisor在创建资源池并且将虚拟CPU分配给虚拟机时已经能够识别并且使用超线程技术。这种方式能够在组织和计划任务方面为hypervisor提供更多的灵活性，因此能够提升虚拟服务器的工作效率。</p>
<p>参考文档: <a href="http://tech.idcquan.com/XuNi/101649.shtml" target="_blank" rel="noopener">超线程技术优缺点分析</a></p>
<hr>
<h1 id="超线程在杏树林的应用"><a href="#超线程在杏树林的应用" class="headerlink" title="超线程在杏树林的应用"></a>超线程在杏树林的应用</h1><p>在杏树林的自有机房中, 部分服务器开启了超线程功能, 2U6核心的 R420服务器开启超线程后, 核心数量翻了一番达到了24颗核心</p>
<p>该服务器用在虚拟化 hypervisor 技术之上, 由于磁盘是 SAS 7.2K 的低性能硬盘, io 几乎成了该服务器的绝对瓶颈, hypervisor 中的客户机在执行频繁的 IO 操作时, 大量的 IO wait 产生, 拖慢了整个服务器的性能</p>
<p>超线程在这种使用场景下有着很大的优势, 因为 CPU 的时钟周期被严重拖慢, 绝大部分的 CPU 在等待 IO 操作的完成, 在使用了超线程技术之后, 每个 CPU 核心被掰成了两半儿, 一个核心可以当成两个核心来用</p>
<p>上学的时候, 老师反复强调, 单颗核心在同一时间只能处理一个任务. 单核心的 CPU 之所以支持多任务处理, 是因为一颗核心反复的在各个进程中切换, 为每个进程分配CPU 的计算资源. 之所以我们认为所有的进程在同时工作, 是因为 CPU 的切换速度极快, 快到人感觉不到中间的断点. 如果我们听着音乐打开了一个重 CPU 计算型的应用, 那么音乐就可能产生卡顿的现象.</p>
<p>上面这个故事, 如果还是一颗核心, 如果他开启了英特尔的超线程技术的话, 音乐就不会被卡顿, 因为在程序的角度来看, 看到的是两颗核心, 同时开启两个应用的话, 每个进程都会被分配一颗核心, 当重 CPU 计算型的进程被开启后, 仍然可以保证有一个虚拟的CPU 分配了一定的计算资源给音乐进程</p>
<p>以上是在重 CPU 计算型的场景中,突破了同一颗核心在同一时间只能处理一个任务的限制</p>
<p>还有一种更有价值的用法就是重 IO 操作的场景下, 极大的发挥 CPU 的性能. 拿回最开始我们机房虚拟化的例子, 磁盘频繁的出现 IO 等待, 每颗 CPU 由于同一时间只能处理一个任务, 而导致每个 CPU 核心的使用率极其低下, 但是一旦开启了超线程技术, CPU 的可利用资源立刻翻了一番, 可以抵消一些由于重 IO 操作而被影响了的其他应用性能的影响</p>
<p>最后我们举个反例:</p>
<p>假如某个应用是计算密集型应用, 只会产生较少的 IO 操作, 且这点 IO 操作被放到了内存映射出来的”磁盘”上, 实现了零 IO, 这种应用如果开启了超线程反而会极大的拖慢整个服务器的性能. 因为这种计算密集型的应用, 即使不开启超线程, 单颗核心的利用率也能达到90%以上, 而开启了超线程之后, 程序实际最大只能用到单颗核心的50%, 此时所有的虚拟核心全部被打满, 而且互相征用资源, 导致硬件和系统去维护和调和这些资源征用耗费了大量的资源, 反而拖慢了整体性能</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>如果你不确定怎么使用超线程技术, 可以简单的用以下方式判断</p>
<p><code>在不开启超线程的情况下, 如果你的应用每颗 CPU 核心的使用率都超过了50% (或是说将近50%) 那就不要再开启超线程了</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>超线程</tag>
      </tags>
  </entry>
  <entry>
    <title>更改-设置MySQL用户密码</title>
    <url>/2016/12/12/%E6%9B%B4%E6%94%B9-%E8%AE%BE%E7%BD%AEMySQL%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="管理给自己设置密码"><a href="#管理给自己设置密码" class="headerlink" title="管理给自己设置密码"></a>管理给自己设置密码</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mysql -u root</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET PASSWORD = PASSWORD('123456');</span><br></pre></td></tr></table></figure>

<h1 id="管理员或者有全局权限的用户重设其它用户的密码"><a href="#管理员或者有全局权限的用户重设其它用户的密码" class="headerlink" title="管理员或者有全局权限的用户重设其它用户的密码"></a>管理员或者有全局权限的用户重设其它用户的密码</h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mysql -u root -p</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET password=PASSWORD("new password") WHERE user='username';</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure>

<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mysql -u root -p</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; use mysql; </span><br><span class="line">mysql&gt; SET PASSWORD FOR username=PASSWORD('new password');</span><br><span class="line">mysql&gt; exit</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root <span class="string">"old password"</span> <span class="string">"new password"</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.6二进制包部署</title>
    <url>/2016/12/12/MySQL5-6%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8C%85%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="下载编译mysql"><a href="#下载编译mysql" class="headerlink" title="下载编译mysql"></a>下载编译mysql</h1><p>略 (请在 MySQL 官网下载 tar.gz 的 source 源码包)</p>
<p>官网5.6 下载地址: <a href="http://dev.mysql.com/downloads/mysql/5.6.html#downloads" target="_blank" rel="noopener">http://dev.mysql.com/downloads/mysql/5.6.html#downloads</a></p>
<p><em>编译参数会在其他文章中详细讲解</em></p>
<h1 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h1><p>使用下面的命令检查是否安装有MySQL Server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpm -qa | grep mysql</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; rpm -e mysql <span class="comment">#普通删除模式 </span></span><br><span class="line">&gt; rpm -e --nodeps mysql <span class="comment"># 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</span></span><br><span class="line">&gt; yum remove mysql <span class="comment">#删除依赖的文件</span></span><br></pre></td></tr></table></figure>

<h1 id="安装mysql并初始化"><a href="#安装mysql并初始化" class="headerlink" title="安装mysql并初始化"></a>安装mysql并初始化</h1><p>把下载好的mysql二进制包放在 <code>/usr/local/</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; useradd mysql</span><br><span class="line">&gt; mv /etc/my.cnf /etc/my.conf.d /tmp</span><br><span class="line">&gt; mkdir -p /data/mysql</span><br><span class="line">&gt; chown mysql:mysql /data/mysql</span><br><span class="line">&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/</span><br><span class="line">&gt; tar -xvzf mysql.tar.gz</span><br><span class="line">&gt; chown -R mysql:mysql /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">&gt; scripts/mysql_install_db --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysql --user=mysql</span><br></pre></td></tr></table></figure>

<h1 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h1><h2 id="创建mysql配置文件"><a href="#创建mysql配置文件" class="headerlink" title="创建mysql配置文件"></a>创建mysql配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; chown mysql:mysql /etc/my.cnf</span><br></pre></td></tr></table></figure>

<h2 id="拷贝mysql启动命令"><a href="#拷贝mysql启动命令" class="headerlink" title="拷贝mysql启动命令"></a>拷贝mysql启动命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cp support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">&gt; vim /etc/init.d/mysqld</span><br><span class="line">basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">datadir=/data/mysql</span><br><span class="line">&gt; chkconfig mysqld on </span><br><span class="line">&gt; service mysqld start</span><br></pre></td></tr></table></figure>

<p>这里一定要注意，虽然是在CentOS7系列上安装，CentOS7默认使用systemctl管理程序的启动与关闭，但是mysql5.6提供的脚本是使用service控制程序启动与关闭的脚本，所以需要放在<code>/etc/init.d/</code>下，使用service的方式启动</p>
<h1 id="进入mysql"><a href="#进入mysql" class="headerlink" title="进入mysql"></a>进入mysql</h1><p>进入mysql会碰到环境变量的问题，找不到mysql的执行文件</p>
<p>MySQL启动成功后，root默认没有密码，我们需要设置root密码。<br>设置之前，我们需要先设置PATH，要不不能直接调用mysql<br>修改/etc/profile文件，在文件末尾添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; vim &#x2F;etc&#x2F;profile</span><br><span class="line">PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;bin:$PATH</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure>

<p>关闭文件，运行下面的命令，让配置立即生效</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<p>现在，我们可以在终端内直接输入mysql进入，mysql的环境了<br>执行下面的命令修改root密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot </span><br><span class="line">mysql&gt; SET PASSWORD &#x3D; PASSWORD(&#39;123456&#39;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中使用ShadowSocks+Privoxy代理</title>
    <url>/2016/12/12/Linux%E4%B8%AD%E4%BD%BF%E7%94%A8ShadowSocks-Privoxy%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>ShadowSocks 最近几年大火, 其简单的配置和优秀的速度让大陆地区的墙内用户爱不释手<br>本篇文章不讨论Mac &amp; Windows 等图形界面下的应用, 而是让 linux 在命令行界面下, http/https 访问也能登上梯子, 看一看外面的大千世界</p>
</blockquote>
<p>最近公司的服务器连接 docker hub <a href="http://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a> 仓库和 node.js <a href="http://nodejs.org" target="_blank" rel="noopener">nodejs.org</a> 仓库极其缓慢, 使用了各种国内的各种加速服务才勉强解决了燃眉之急(分别使用了 daocloud 的镜像加速和淘宝的加速服务)</p>
<p>本篇文章就是介绍如何实现 Linux 中的 http/https 请求翻墙的需求</p>
<h1 id="安装-ss-客户端"><a href="#安装-ss-客户端" class="headerlink" title="安装 ss 客户端"></a>安装 ss 客户端</h1><p><em>shadowsocks安装时是不分客户端还是服务器端的, 只不过安装后有两个脚本一个是sslocal代表以客户端模式工作，一个是ssserver代表以服务器端模式工作</em></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum install python-pip</span><br><span class="line">&gt; pip install shadowsocks</span><br></pre></td></tr></table></figure>

<h2 id="在后台启动-ss-客户端"><a href="#在后台启动-ss-客户端" class="headerlink" title="在后台启动 ss 客户端"></a>在后台启动 ss 客户端</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; nohup sslocal -s your_server_ip -p your_server_port -l 1080 -k your_server_passwd -t 600 -m rc4-md5 &gt; /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p><strong>注意:</strong></p>
<ul>
<li>使用的是 <code>sslocal</code> 这个命令，表示 <code>shadowsocks</code> 以客户端模式工作 </li>
<li>将上述命令里的 <code>your_server_ip</code>, <code>your_server_port</code>, <code>your_server_passwd</code> 换成自己的, 这三个分别代表服务器ip, 服务器上 <code>shadowsocks</code> 的端口以及密码.后面的 <code>rc4-md5</code> 加密方式也要换成跟 <code>server</code> 端一致。 </li>
<li>前面的nohub 和最后的 &amp; 表示后台执行且关闭 session 后仍然在后台执行，否则将会阻塞shell端口.<br>为了更方便, 建议新建一个.json的文件, 将上述信息放里面,如新建/etc/shadowsocks.json文件, 内容为：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;your_server_ip&quot;,      #ss服务器IP</span><br><span class="line">    &quot;server_port&quot;:your_server_port, #端口</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,   #本地ip</span><br><span class="line">    &quot;local_port&quot;:1080,              #本地端口</span><br><span class="line">    &quot;password&quot;:&quot;your_server_passwd&quot;,#连接ss密码</span><br><span class="line">    &quot;timeout&quot;:300,                  #等待超时</span><br><span class="line">    &quot;method&quot;:&quot;rc4-md5&quot;,             #加密方式</span><br><span class="line">    &quot;fast_open&quot;: false,             # true 或 false。如果你的服务器 Linux 内核在3.7+，可以开启 fast_open 以降低延迟。开启方法： echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_fastopen 开启之后，将 fast_open 的配置设置为 true 即可</span><br><span class="line">    &quot;workers&quot;: 1                    # 工作线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后运行一下命令启动shadowsocks </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果想增加开启自动启动，执行：echo “ nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;” /etc/rc.local </li>
<li>执行ps aux |grep sslocal |grep -v “grep”查看后台sslocal是否运行</li>
</ul>
<h1 id="安装Privoxy"><a href="#安装Privoxy" class="headerlink" title="安装Privoxy"></a>安装Privoxy</h1><p>上述安好了<code>shadowsocks</code>，但它是 <code>socks5</code> 代理，我门在 <code>shell</code> 里执行的命令，发起的网络请求现在还不支持 <code>socks5</code> 代理，只支持 <code>http/https</code> 代理。为了我门需要安装 <code>privoxy</code> 代理，它能把电脑上所有http请求转发给 <code>shadowsocks</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum install privoxy -y</span><br></pre></td></tr></table></figure>

<ul>
<li>查看 <code>vim /usr/local/etc/privoxy/config</code> 文件，<br>先搜索关键字 <code>listen-address</code> 找到 <code>listen-address 127.0.0.1:8118</code> 这一句，保证这一句没有注释，8118就是将来http代理要输入的端口。<br>然后搜索 <code>forward-socks5t</code>, 将 <code>#forward-socks5t / 127.0.0.1:1080 .</code> 此句前面的注释去掉, 意思是转发流量到本地的1080端口, 而1080端口正是 ss 监听的端口</li>
</ul>
<h2 id="启动privoxy"><a href="#启动privoxy" class="headerlink" title="启动privoxy"></a>启动privoxy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; systemctl restart privoxy </span><br><span class="line">&gt; systemctl <span class="built_in">enable</span> privoxy</span><br></pre></td></tr></table></figure>

<h1 id="转发配置"><a href="#转发配置" class="headerlink" title="转发配置"></a>转发配置</h1><p>写在 profile 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/profile</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><br><span class="line">&gt; <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<p>在当前 session 执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure>

<h1 id="测试翻墙"><a href="#测试翻墙" class="headerlink" title="测试翻墙"></a>测试翻墙</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure>

<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>如果不能访问, 请重启机器, 依次打开shadowsocks和privoxy再测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">&gt; privoxy --user privoxy /usr/<span class="built_in">local</span>/etc/privoxy/config</span><br></pre></td></tr></table></figure>

<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/QQ20161208-1@2x.png" alt=""></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>代理</tag>
        <tag>ShadowSocks</tag>
        <tag>Privoxy</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的主从切换</title>
    <url>/2016/12/12/MySQL%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章不再赘述 MySQL 主从搭建的过程, 只介绍主从切换的过程</p>
</blockquote>
<p>MySQL 的主从切换分成两种情况</p>
<ul>
<li>一种情况是主从高可用, 主从切换后, 原主库还要继续同步原从库的数据</li>
<li>另一种情况是一主一从, 主从切换后, 主库下线, 不需要原主库再去同步原从库</li>
</ul>
<h1 id="第一种情况的主从切换"><a href="#第一种情况的主从切换" class="headerlink" title="第一种情况的主从切换"></a>第一种情况的主从切换</h1><h2 id="分别查看主从状态"><a href="#分别查看主从状态" class="headerlink" title="分别查看主从状态"></a>分别查看主从状态</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slave 中查看从库的状态</span></span><br><span class="line">mysql&gt; show slave status\G</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 中查看主库的状态</span></span><br><span class="line">mysql&gt; show slave hosts;</span><br></pre></td></tr></table></figure>

<h2 id="停止从库的-IO-THREAD-线程"><a href="#停止从库的-IO-THREAD-线程" class="headerlink" title="停止从库的 IO_THREAD 线程"></a>停止从库的 IO_THREAD 线程</h2><p>先停止 IO_THREAD 线程, 即断开了从主库的 sql 消息接收, 有利于当前数据库完成剩余的数据同步</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># slave</span></span><br><span class="line">mysql&gt; stop slave IO_THREAD;</span><br><span class="line">mysql&gt; show slave status\G</span><br></pre></td></tr></table></figure>

<p>检查是否是如下状态;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Slave_IO_Running: No</span><br><span class="line">Slave_SQL_Running: Yes</span><br></pre></td></tr></table></figure>

<h2 id="激活从库"><a href="#激活从库" class="headerlink" title="激活从库"></a>激活从库</h2><p>在停止 IO_THREAD 线程后, 看到 <code>Slave_SQL_Running_State: Slave has read all relay log; waiting for the slave I/O thread to update it</code>这个状态后,  就可以操作完全停止从库,并激活为主库啦</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave;  # 完全停止 slave 复制 </span><br><span class="line">mysql&gt; reset slave all; # 完全清空 slave 复制信息</span><br><span class="line">msyql&gt; reset master; # 清空本机上 master 的位置信息(给原主库同步此原从库做准备)</span><br><span class="line">mysql&gt; show binary logs; # 查看当前数据库的 binlog 信息</span><br><span class="line">+<span class="comment">----------------+-----------+</span></span><br><span class="line">| Log_name       | File_size |</span><br><span class="line">+<span class="comment">----------------+-----------+</span></span><br><span class="line">| bin-log.000001 |       120 |</span><br><span class="line">+<span class="comment">----------------+-----------+</span></span><br></pre></td></tr></table></figure>

<h1 id="将原主库变为从库"><a href="#将原主库变为从库" class="headerlink" title="将原主库变为从库"></a>将原主库变为从库</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master</span></span><br><span class="line">mysql&gt; CHANGE MASTER TO</span><br><span class="line">   MASTER_HOST='192.168.10.59',</span><br><span class="line">   MASTER_PORT=3306,</span><br><span class="line">   MASTER_USER='repl',</span><br><span class="line">   MASTER_PASSWORD='12345678',</span><br><span class="line">   MASTER_LOG_FILE='bin-log.000001',</span><br><span class="line">   MASTER_LOG_POS=120;</span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">mysql&gt; show slave status\G</span><br></pre></td></tr></table></figure>



<hr>
<h1 id="第二种情况的主从切换"><a href="#第二种情况的主从切换" class="headerlink" title="第二种情况的主从切换"></a>第二种情况的主从切换</h1><p>第二种情况的主从切换, 切换后, 主库不需要再去同步之前的从库(新主库), 有下线的需求, 这种情况下, 操作流程跟以上差不多, 只不过可以省去如下步骤:</p>
<ul>
<li>从库中不需要执行<code>reset master</code>了, 因为原主库(现从库)不要再找点啦(Position)</li>
<li>主库直接下线就行了, 不需要执行最后把主库变为从库的操作了</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>主从切换</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker动态扩容Pool大小与container大小</title>
    <url>/2016/12/12/Docker%E5%8A%A8%E6%80%81%E6%89%A9%E5%AE%B9Pool%E5%A4%A7%E5%B0%8F%E4%B8%8Econtainer%E5%A4%A7%E5%B0%8F/</url>
    <content><![CDATA[<blockquote>
<p>docker容器默认的空间是10G, Pool 大小默认是100G. </p>
</blockquote>
<h1 id="查看-docker-信息"><a href="#查看-docker-信息" class="headerlink" title="查看 docker 信息"></a>查看 docker 信息</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker info</span><br><span class="line">Containers: 3</span><br><span class="line"> Running: 3</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 2</span><br><span class="line">Server Version: 1.12.1</span><br><span class="line">Storage Driver: devicemapper</span><br><span class="line"> Pool Name: docker-253:0-117441065-pool</span><br><span class="line"> Pool Blocksize: 65.54 kB</span><br><span class="line"> Base Device Size: 107.4 GB</span><br><span class="line"> Backing Filesystem: xfs</span><br><span class="line"> Data file: /dev/loop0</span><br><span class="line"> Metadata file: /dev/loop1</span><br><span class="line"> Data Space Used: 18.32 GB</span><br><span class="line"> Data Space Total: 107.4 GB</span><br><span class="line"> Data Space Available: 89.05 GB</span><br><span class="line"> Metadata Space Used: 12.45 MB</span><br><span class="line"> Metadata Space Total: 2.147 GB</span><br><span class="line"> Metadata Space Available: 2.135 GB</span><br><span class="line"> Thin Pool Minimum Free Space: 10.74 GB</span><br><span class="line"> Udev Sync Supported: <span class="literal">true</span></span><br><span class="line"> Deferred Removal Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deletion Enabled: <span class="literal">false</span></span><br><span class="line"> Deferred Deleted Device Count: 0</span><br><span class="line"> Data loop file: /var/lib/docker/devicemapper/devicemapper/data</span><br><span class="line"> WARNING: Usage of loopback devices is strongly discouraged <span class="keyword">for</span> production use. Use `--storage-opt dm.thinpooldev` to specify a custom block storage device.</span><br><span class="line"> Metadata loop file: /var/lib/docker/devicemapper/devicemapper/metadata</span><br><span class="line"> Library Version: 1.02.107-RHEL7 (2016-06-09)</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Plugins:</span><br><span class="line"> Volume: <span class="built_in">local</span></span><br><span class="line"> Network: host bridge overlay null</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Security Options: seccomp</span><br><span class="line">Kernel Version: 3.10.0-327.28.3.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 6</span><br><span class="line">Total Memory: 7.624 GiB</span><br><span class="line">Name: mobile-quality</span><br><span class="line">ID: NG64:K27K:ASGU:MCBI:NPOZ:Y554:5HME:3INM:UAMI:IIWC:ZQT5:ZKO6</span><br><span class="line">Docker Root Dir: /var/lib/docker</span><br><span class="line">Debug Mode (client): <span class="literal">false</span></span><br><span class="line">Debug Mode (server): <span class="literal">false</span></span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">WARNING: bridge-nf-call-iptables is disabled</span><br><span class="line">WARNING: bridge-nf-call-ip6tables is disabled</span><br><span class="line">Labels:</span><br><span class="line"> provider=generic</span><br><span class="line">Insecure Registries:</span><br><span class="line"> 127.0.0.0/8</span><br></pre></td></tr></table></figure>
<p> <code>Data Space Total: 107.4 GB</code> 这个就是默认的 Pool 大小</p>
<hr>
<h1 id="调整-container-大小"><a href="#调整-container-大小" class="headerlink" title="调整 container 大小"></a>调整 container 大小</h1><h2 id="新-container-的调整"><a href="#新-container-的调整" class="headerlink" title="新 container 的调整"></a>新 container 的调整</h2><p>如果想指定默认容器的大小（在启动容器的时候指定），可以在docker配置文件里通过dm.basesize参数指定</p>
<h3 id="直接使用-docker-命令启动服务"><a href="#直接使用-docker-命令启动服务" class="headerlink" title="直接使用 docker 命令启动服务"></a>直接使用 docker 命令启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker -d --storage-opt dm.basesize=20G</span><br></pre></td></tr></table></figure>
<h3 id="使用-systemctl-命令启动服务"><a href="#使用-systemctl-命令启动服务" class="headerlink" title="使用 systemctl 命令启动服务"></a>使用 systemctl 命令启动服务</h3><p>对于使用 <code>systemctl</code> 管理的docker服务, 可以编辑 systemctl 的启动脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/systemd/system/docker.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/docker daemon -H tcp://0.0.0.0:2376 -H unix:///var/run/docker.sock --registry-mirror=http://8843165a.m.daocloud.io --storage-driver devicemapper --tl</span><br><span class="line">sverify --tlscacert /etc/docker/ca.pem --tlscert /etc/docker/server.pem --tlskey /etc/docker/server-key.pem --label provider=generic --storage-opt dm.basesize=20G</span><br><span class="line">ExecReload=/bin/<span class="built_in">kill</span> -s HUP</span><br><span class="line">MountFlags=slave</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">LimitCORE=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Environment=</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>

<p>以上方式适用于新 run 起来的 container, 会获取到新的空间</p>
<h2 id="已存在的-container-的调整"><a href="#已存在的-container-的调整" class="headerlink" title="已存在的 container 的调整"></a>已存在的 container 的调整</h2><h3 id="查看所有的虚拟磁盘信息"><a href="#查看所有的虚拟磁盘信息" class="headerlink" title="查看所有的虚拟磁盘信息"></a>查看所有的虚拟磁盘信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup status</span><br><span class="line">docker-253:0-117441065-pool: 0 209715200 thin-pool 39 3039/524288 279539/1638400 - rw discard_passdown queue_if_no_space - </span><br><span class="line">docker-253:0-117441065-bb21427f81836c96a53e7cf0ee97c9e907104ad1ce4d8f2bdade4bbfc0fdd5f5: 0 20971520 thin 17858688 209715199</span><br><span class="line">docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e: 0 20971520 thin 19820928 209715199</span><br><span class="line">docker-253:0-117441065-c57286b3ae5bc1bd675573902d043754aba23349306fd3a52bcd74eed5d144cb: 0 20971520 thin 2968320 209715199</span><br><span class="line">centos-swap: 0 3358720 linear </span><br><span class="line">centos-root: 0 29163520 linear </span><br><span class="line">centos-root: 29163520 71294976 linear </span><br><span class="line">centos-root: 100458496 104849408 linear </span><br><span class="line">centos-root: 205307904 209707008 linear</span><br></pre></td></tr></table></figure>

<p>最上面4条开头写着 docker 的虚拟磁盘就是我们即将操作的对象</p>
<p>其中可以明显的看出, 第一条中带有 <code>pool</code> 的字样, 没错, 这个就是 docker 默认的 pool 大小,现在我们要调整 container 的大小, 暂时不管 pool 的默认配置</p>
<p>其余的三条磁盘信息就是当前宿主机中, 起来的 container 使用的虚拟磁盘, 如果你需要指定其中一个来调整, 那么你需要找到虚拟磁盘和 container name 或 container id 的对应关系, 不要搞错!</p>
<p>对应关系可以使用 <code>docker exec -it xxxx /bin/bash</code> 进入到 container 中使用<code>df -h</code> 命令查看根分区的虚拟磁盘名称<br>也可以在 linux 中使用 <code>docker inspect xxx</code> 来查看 xxx 容器的详细信息</p>
<p>找到了它们的对应关系之后, 接下来就可以对其调整大小了</p>
<h3 id="找到映射的虚拟磁盘"><a href="#找到映射的虚拟磁盘" class="headerlink" title="找到映射的虚拟磁盘"></a>找到映射的虚拟磁盘</h3><p>默认情况下, 所有的虚拟磁盘的映射都在<code>/dev/mapper/</code> 下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ls -l</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 01:45 centos-root -&gt; ../dm-0</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 01:45 centos-swap -&gt; ../dm-1</span><br><span class="line">crw------- 1 root root 10, 236 Dec  7 01:45 control</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 02:20 docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e -&gt; ../dm-3</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 02:21 docker-253:0-117441065-bb21427f81836c96a53e7cf0ee97c9e907104ad1ce4d8f2bdade4bbfc0fdd5f5 -&gt; ../dm-4</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 02:30 docker-253:0-117441065-c57286b3ae5bc1bd675573902d043754aba23349306fd3a52bcd74eed5d144cb -&gt; ../dm-5</span><br><span class="line">lrwxrwxrwx 1 root root       7 Dec  7 01:49 docker-253:0-117441065-pool -&gt; ../dm-2</span><br></pre></td></tr></table></figure>
<p>从上面👆的回显也可以看出实际指向的虚拟磁盘文件(是不是有点绕, 这个文件只不过是虚拟磁盘的软连接而已)</p>
<p>接下来我们需要对其进行扩容操作</p>
<h3 id="第一步-查看指定虚拟磁盘的容量信息"><a href="#第一步-查看指定虚拟磁盘的容量信息" class="headerlink" title="第一步: 查看指定虚拟磁盘的容量信息"></a>第一步: 查看指定虚拟磁盘的容量信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup table docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e</span><br><span class="line">0 20971520 thin 253:2 25</span><br></pre></td></tr></table></figure>

<h3 id="第二步-计算所需的容量-扇区数量"><a href="#第二步-计算所需的容量-扇区数量" class="headerlink" title="第二步: 计算所需的容量(扇区数量)"></a>第二步: 计算所需的容量(扇区数量)</h3><p>假设你想要的容量为 20G</p>
<p>则该值应该为: <code>20*1024*1024*1024/512</code> = 41943040</p>
<p>验算: 20G 的值 41943040 = 默认10G 的值 20971520 *2</p>
<p>公式为: <code>x*1024*1024*1024/512</code></p>
<h3 id="第三步-挂起虚拟磁盘"><a href="#第三步-挂起虚拟磁盘" class="headerlink" title="第三步: 挂起虚拟磁盘"></a>第三步: 挂起虚拟磁盘</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup <span class="built_in">suspend</span> docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e</span><br></pre></td></tr></table></figure>

<p>没有回显, 没有消息就是好消息😆</p>
<h3 id="第四步-写入新参数并重新加载进去"><a href="#第四步-写入新参数并重新加载进去" class="headerlink" title="第四步: 写入新参数并重新加载进去"></a>第四步: 写入新参数并重新加载进去</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup reload docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e --table <span class="string">'0 41943040 thin 253:2 25'</span></span><br></pre></td></tr></table></figure>

<p>把上一步计算出来的值, 覆盖到第一步的回显对应的位置中</p>
<h3 id="第五步-激活挂起的虚拟磁盘"><a href="#第五步-激活挂起的虚拟磁盘" class="headerlink" title="第五步: 激活挂起的虚拟磁盘"></a>第五步: 激活挂起的虚拟磁盘</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup resume docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e</span><br></pre></td></tr></table></figure>

<p>如果执行到这一步的时候报错: </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">device-mapper: resume ioctl on docker-253:0-1700-pool failed: Invalid argument</span><br><span class="line">Command failed</span><br></pre></td></tr></table></figure>

<p>先不要慌, 稍等片刻, 再重新执行</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>由于挂起操作会阻塞住所有的 IO, 为了尽快完成扩容, 我们一般把第三四五步骤用一行命令去执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup <span class="built_in">suspend</span> docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e \</span><br><span class="line">    &amp;&amp; dmsetup reload docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e --table <span class="string">'0 41943040 thin 253:2 25'</span> \</span><br><span class="line">    &amp;&amp; dmsetup resume docker-253:0-117441065-17379f89f95efb5bafb234d95e0e0dfe549f7ba48fbed69c0111e2ea39c0106e</span><br></pre></td></tr></table></figure>

<h3 id="第六步-为磁盘扩容"><a href="#第六步-为磁盘扩容" class="headerlink" title="第六步: 为磁盘扩容"></a>第六步: 为磁盘扩容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mount /dev/dm-3 /mnt</span><br><span class="line">&gt; xfs_growfs /mnt</span><br><span class="line">&gt; umount /mnt</span><br></pre></td></tr></table></figure>

<p>需要先挂载再扩容</p>
<hr>
<h1 id="调整-pool-大小"><a href="#调整-pool-大小" class="headerlink" title="调整 pool 大小"></a>调整 pool 大小</h1><p>调整 pool 大小不同于调整 container 的大小, 需要先对其虚拟文件进行扩容, 再对虚拟磁盘扩容</p>
<p>到这里涉及到了三个概念:</p>
<ul>
<li>虚拟文件大小 —&gt; 硬盘大小/PV/VG</li>
<li>虚拟硬盘设备 —&gt; LV/file system</li>
<li>软连接 —&gt; alias 别名</li>
</ul>
<p>虚拟硬盘设备是基于虚拟文件的, 就好像我们使用的 lvm 卷, 虚拟硬盘设备就相当于 lv 或是说就相当于我们正在使用的文件系统; 而 docker 中的虚拟文件就好比我们物理机的硬盘, 或是说 PV 与 VG 的大小</p>
<ul>
<li>在物理服务器中, 磁盘空间不足的话, 我们可以增加硬盘, 条带化成 PV, 再填入到 VG 池中, 然后分配给对应的 LV, 再对其扩容</li>
<li>在 docker 中, 磁盘空间不足的话(pool 不足的话), 我们可以扩充虚拟文件, 然后让虚拟硬盘设备扩容</li>
</ul>
<h2 id="查看-pool-文件大小信息"><a href="#查看-pool-文件大小信息" class="headerlink" title="查看 pool 文件大小信息"></a>查看 pool 文件大小信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ls -lh /var/lib/docker/devicemapper/devicemapper/</span><br><span class="line">total 244M</span><br><span class="line">-rw-------. 1 root root 100G Dec  8 18:27 data</span><br><span class="line">-rw-------. 1 root root 2.0G Dec  8 18:24 metadata</span><br></pre></td></tr></table></figure>

<p>可以看到 data 是100G 大小, 不要担心他实际占用了100G, 这个是精简配置, 实际用多少就占多少空间, 最大100G</p>
<h2 id="第一步-给文件扩容"><a href="#第一步-给文件扩容" class="headerlink" title="第一步: 给文件扩容"></a>第一步: 给文件扩容</h2><p>上面看到的 data 文件有100G 的大小, 现在我需要200G 的 pool 大小, 所以需要调整 data 文件的属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">truncate -s 214748364800 /var/lib/docker/devicemapper/devicemapper/data</span><br></pre></td></tr></table></figure>

<h2 id="第二步-检查大小"><a href="#第二步-检查大小" class="headerlink" title="第二步: 检查大小"></a>第二步: 检查大小</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ls -lh /var/lib/docker/devicemapper/devicemapper/                      </span><br><span class="line">total 244M</span><br><span class="line">-rw-------. 1 root root 200G Dec  8 18:35 data</span><br><span class="line">-rw-------. 1 root root 2.0G Dec  8 18:24 metadata</span><br></pre></td></tr></table></figure>

<h2 id="第三步-Reload-data-loop-device"><a href="#第三步-Reload-data-loop-device" class="headerlink" title="第三步: Reload data loop device"></a>第三步: Reload data loop device</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; blockdev --getsize64 /dev/loop0</span><br><span class="line">107374182400</span><br><span class="line">&gt; losetup -c /dev/loop0</span><br><span class="line">&gt; blockdev --getsize64 /dev/loop0</span><br><span class="line">214748364800</span><br></pre></td></tr></table></figure>

<h2 id="第四步-Reload-devicemapper-thin-pool"><a href="#第四步-Reload-devicemapper-thin-pool" class="headerlink" title="第四步: Reload devicemapper thin pool"></a>第四步: Reload devicemapper thin pool</h2><p>第四步基本就是重复上面扩容 container 的步骤, 这里省略了前几步的查看和计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; dmsetup <span class="built_in">suspend</span> docker-253:0-1700-pool \</span><br><span class="line">    &amp;&amp; dmsetup reload docker-253:0-1700-pool --table <span class="string">'0 419430400 thin-pool 7:1 7:0 128 32768 1 skip_block_zeroing'</span> \</span><br><span class="line">    &amp;&amp; dmsetup resume docker-253:0-1700-pool</span><br></pre></td></tr></table></figure>

<h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><p>扩容 pool 涉及到了两个计算</p>
<ul>
<li>data 文件大小的计算</li>
<li>devicemapper 扇区数量的计算</li>
</ul>
<p>上面已经给出了扇区的计算公式: <code>x*1024*1024*1024/512</code></p>
<p>data 大小的计算公式为: <code>x*1024*1024*1024</code></p>
<hr>
<p>参考文档:</p>
<p><a href="https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/increase-capacity-on-a-running-device" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/storagedriver/device-mapper-driver/#/increase-capacity-on-a-running-device</a><br><a href="https://segmentfault.com/a/1190000002931564" target="_blank" rel="noopener">https://segmentfault.com/a/1190000002931564</a><br><a href="http://www.linuxidc.com/Linux/2015-01/112245.htm" target="_blank" rel="noopener">http://www.linuxidc.com/Linux/2015-01/112245.htm</a><br><a href="http://www.projectatomic.io/blog/2016/03/daemon_option_basedevicesize/" target="_blank" rel="noopener">http://www.projectatomic.io/blog/2016/03/daemon_option_basedevicesize/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>开启GTID的情况下导出导入库的注意事项</title>
    <url>/2016/10/28/%E5%BC%80%E5%90%AFGTID%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%AF%BC%E5%87%BA%E5%AF%BC%E5%85%A5%E5%BA%93%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    <content><![CDATA[<blockquote>
<p>在开启了 GTID 功能的 MySQL 数据库中, 不论是否使用了 GTID 的方式做了主从同步, 导出导入时都需要特别注意数据库中的 GTID 信息. </p>
</blockquote>
<h1 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mysqldump -uroot -p userdb &gt; userdb.sql</span><br><span class="line">Warning: A partial dump from a server that has GTIDs will by default include the GTIDs of all transactions, even those that changed suppressed parts of the database. If you don<span class="string">'t want to restore GTIDs, pass --set-gtid-purged=OFF. To make a complete dump, pass --all-databases --triggers --routines --events</span></span><br></pre></td></tr></table></figure>

<p>mysql提示: 当前数据库实例中开启了 GTID 功能, 在开启有 GTID 功能的数据库实例中, 导出其中任何一个库, 如果没有显示地指定<code>--set-gtid-purged</code>参数, 都会提示这一行信息. 意思是默认情况下, 导出的库中含有 GTID 信息, 如果不想导出包含有 GTID 信息的数据库, 需要显示地添加<code>--set-gtid-purged=OFF</code>参数. 于是乎, dump 变成了如下样子</p>
<p><code>➜  mysqldump -uroot -p --set-gtid-purged=OFF userdb &gt; userdb.sql</code></p>
<p>使用以上这条命令 dump 出来的库是不包含 GTID 信息的</p>
<h1 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h1><p>导入的时候也分两种, 一种是导入带有 GTID 的信息的库, 一种是导入不带有 GTID 信息的库</p>
<h2 id="不带有-GTID-信息"><a href="#不带有-GTID-信息" class="headerlink" title="不带有 GTID 信息"></a>不带有 GTID 信息</h2><p>不带有 GTID 信息的 dump 文件, 不管目标数据库实例是否开启了 GTID 功能, 且不管数据库实例是否已有其他 GTID 信息, 都可以顺利导入</p>
<h2 id="带有-GTID-信息"><a href="#带有-GTID-信息" class="headerlink" title="带有 GTID 信息"></a>带有 GTID 信息</h2><p>带有 GTID 信息的 dump 文件, 要求目标数据库实例必须开启 GTID 功能, 且当前数据库中无其他 GTID 信息. 如果目标数据库中已经记录了一条或一条以上的 GTID 信息, 那么在导入数据库时会报出类似如下的错误❌</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  mysql -uroot -p userdb &lt; userdb.sql</span><br><span class="line">Password:xxxxxxxx</span><br><span class="line">ERROR 1840 (HY000) at line 24: @@GLOBAL.GTID_PURGED can only be <span class="built_in">set</span> when @@GLOBAL.GTID_EXECUTED is empty.</span><br></pre></td></tr></table></figure>

<p>在 mysql5.7版本中加入了多 channel 的特性, 一台数据库实例可以同时与多个主库同步, 实现多主一从架构, 但是假如现在数据库实例中开启了 GTID, 并以 GTID 的方式与 A 主库和 B 主库同步,那么现在的 slave 中就记录有两条 GTID 信息. 在导入带有新 GTID 信息的库时, 会报错, 要求你清除掉目标数据库实例中所有的 GTID 信息. 在这种情况下, 问题就比较严重了, 因为我的这台数据库已经和两台主库建立主从关系, 现在为了导入一个新库, 需要 reset 掉所有同步信息(GTID 信息)</p>
<p>这个时候你有两个选择:</p>
<ol>
<li>重新 dump 数据库, 使用<code>--set-gtid-purged=OFF</code>的参数禁止🚫导出 GTID 信息,再 load 进目标数据库</li>
<li>在目标数据库中执行<code>mysql&gt; reset slave all;</code> <code>mysql&gt; reset master;</code> 清空所有 GTID 信息之后就可以导入了</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>GTID</tag>
        <tag>mysqldump</tag>
        <tag>--set-gtid-purged</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql修改sql_mode</title>
    <url>/2016/10/12/mysql%E4%BF%AE%E6%94%B9sql-mode/</url>
    <content><![CDATA[<h1 id="sql-mode"><a href="#sql-mode" class="headerlink" title="sql_mode"></a>sql_mode</h1><ul>
<li></li>
<li>ANSI</li>
<li>TRADITIONAL</li>
<li>STRICT_TRANS_TABLES</li>
</ul>
<h2 id="sql-mode为空"><a href="#sql-mode为空" class="headerlink" title="sql_mode为空"></a>sql_mode为空</h2><p>最宽松的模式, 即使有错误既不会报错也不会有警告⚠️</p>
<h2 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h2><p>宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告</p>
<h2 id="TRADITIONAL"><a href="#TRADITIONAL" class="headerlink" title="TRADITIONAL"></a>TRADITIONAL</h2><p>严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误。用于事物时，会进行事物的回滚</p>
<h2 id="STRICT-TRANS-TABLES"><a href="#STRICT-TRANS-TABLES" class="headerlink" title="STRICT_TRANS_TABLES"></a>STRICT_TRANS_TABLES</h2><p>严格模式，进行数据的严格校验，错误数据不能插入，报error错误</p>
<h2 id="NO-ENGINE-SUBSTITUTION"><a href="#NO-ENGINE-SUBSTITUTION" class="headerlink" title="NO_ENGINE_SUBSTITUTION"></a>NO_ENGINE_SUBSTITUTION</h2><p>no_engine_subtitution的作用：mysql 在create table 时可以指定engine子句(指定存储引擎),如果把引擎指定成一个并不存在的引擎, 这个时候mysql可以有两种行为供选择</p>
<ul>
<li>直接报错</li>
<li>把表的存储引擎替换成innodb</li>
</ul>
<p>如果 sql_mode 存在 no_engine_subtitution 的时候 ===&gt; 直接报错</p>
<p>如果 sql_mode 不存在 no_engine_subtitution 的时候 ===&gt; 把表的存储引擎替换成innodb</p>
<h1 id="查询-sql-mode"><a href="#查询-sql-mode" class="headerlink" title="查询 sql_mode"></a>查询 sql_mode</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt;  select @@sql_mode;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@sql_mode             |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@global.sql_mode;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@global.sql_mode      |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> @@session.sql_mode;</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| @@session.sql_mode     |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">| NO_ENGINE_SUBSTITUTION |</span><br><span class="line">+<span class="comment">------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="在线修改-sql-mode"><a href="#在线修改-sql-mode" class="headerlink" title="在线修改 sql_mode"></a>在线修改 sql_mode</h1><p><code>SET [GLOBAL|SESSION] sql_mode=&#39;modes&#39;</code></p>
<h2 id="当前-session-生效"><a href="#当前-session-生效" class="headerlink" title="当前 session 生效"></a>当前 session 生效</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; set sql_mode=`NO_FIELD_OPTIONS,HIGH_NOT_PRECEDENCE`;</span><br></pre></td></tr></table></figure>

<h2 id="全局生效"><a href="#全局生效" class="headerlink" title="全局生效"></a>全局生效</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global sql_mode=`NO_FIELD_OPTIONS,HIGH_NOT_PRECEDENCE`</span><br></pre></td></tr></table></figure>

<h1 id="离线修改-sql-mode"><a href="#离线修改-sql-mode" class="headerlink" title="离线修改 sql_mode"></a>离线修改 sql_mode</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ vim /etc/my.cnf</span><br><span class="line"></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br></pre></td></tr></table></figure>

<hr>
<p>参考文档: </p>
<ul>
<li>no_engine_subtitution: <a href="http://www.cnblogs.com/JiangLe/p/5621856.html" target="_blank" rel="noopener">http://www.cnblogs.com/JiangLe/p/5621856.html</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>sql_mode</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql5.7新特性的困扰ibtmp1文件过大</title>
    <url>/2016/10/12/mysql5-7%E6%96%B0%E7%89%B9%E6%80%A7%E7%9A%84%E5%9B%B0%E6%89%B0ibtmp1%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7/</url>
    <content><![CDATA[<blockquote>
<p>在一台 MySQL5.7 的服务器上磁盘使用空间突然爆满, 查看 mysql 数据目录下的文件发现,有个叫<code>ibtmp1</code>的文件大小达到了160GB. </p>
</blockquote>
<p>后经过查询得知, <code>ibtmp1</code>文件是 MySQL5.7的新特性,MySQL5.7使用了独立的临时表空间来存储临时表数据，但不能是压缩表。临时表空间在实例启动的时候进行创建，shutdown的时候进行删除。即为所有非压缩的innodb临时表提供一个独立的表空间，默认的临时表空间文件为ibtmp1，位于数据目录。我们可通过innodb_temp_data_file_path参数指定临时表空间的路径和大小，默认12M。只有重启实例才能回收临时表空间文件ibtmp1的大小。create temporary table和using temporary table将共用这个临时表空间</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'innodb_temp_data_file_path';</span><br><span class="line">+<span class="comment">----------------------------+-----------------------+</span></span><br><span class="line">| Variable_name              | Value                 |</span><br><span class="line">+<span class="comment">----------------------------+-----------------------+</span></span><br><span class="line">| innodb_temp_data_file_path | ibtmp1:12M:autoextend |</span><br><span class="line">+<span class="comment">----------------------------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>物理文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ du -sh ibtmp1 </span><br><span class="line">160G    ibtmp1</span><br></pre></td></tr></table></figure>

<p><strong>释放这个临时表空间的唯一办法是重启数据库</strong></p>
<hr>
<p>官方文档: <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_temp_data_file_path" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_temp_data_file_path</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>ibtmp1</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlbinlog命令查看binglog_format=row的日志</title>
    <url>/2016/10/12/mysqlbinlog%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8Bbinglog-format-row%E7%9A%84%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<blockquote>
<p>在配置文件中配置有<code>binglog_format=row</code>的数据库产生的 binglog 日志是不能以正常的<code>mysqlbinlog logfile</code>的方式打开的, 默认情况下只能看到一些经过base-64编码的信息</p>
</blockquote>
<ul>
<li>从MySQL 5.1.28开始，mysqlbinlog多了个参数–verbose(或-v)，将改动生成带注释的语句，如果使用两次这个参数(如-v -v)，会生成字段的类型、长度、是否为null等属性信息</li>
<li>加–base64-output=DECODE-ROWS参数还可以去掉BINLOG开头的信息</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysqlbinlog -v -v <span class="comment">--base64-output=DECODE-ROWS mysql-bin.000003</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysqlbinlog</tag>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>mysqlbinlog报错:unknown variable default-character-set=utf8mb4</title>
    <url>/2016/10/12/mysqlbinlog%E6%8A%A5%E9%94%99-unknown-variable-default-character-set-utf8mb4/</url>
    <content><![CDATA[<blockquote>
<p>使用 mysqlbinlog 命令查看 binlog 日志时出现<code>mysqlbinlog: unknown variable &#39;default-character-set=utf8mb4&#39;</code>的报错, 原因是在 mysql 的配置文件中, 我设置默认字符集为<code>utf8mb4</code>此字符集为 utf8 的扩展字符集,支持保存 emoji😈 表情, 解决方案如下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ mysqlbinlog mysql-bin.000256</span><br><span class="line">mysqlbinlog: unknown variable <span class="string">'default-character-set=utf8mb4'</span></span><br></pre></td></tr></table></figure>

<p><strong>原因是mysqlbinlog这个工具无法识别binlog中的配置中的default-character-set=utf8这个指令</strong></p>
<p>解决的办法有两个:</p>
<ol>
<li>将<code>/etc/my.cnf</code>中配置的<code>default-character-set = utf8mb4</code>修改为<code>character-set-server = utf8mb4</code> 但是这种修改方法需要重启数据库, 在线上业务库中使用这种方法查看 binlog 日志并不划算~</li>
<li><code>mysqlbinlog --no-defaults mysql-bin.000256</code> 完美解决~</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>mysqlbinlog</tag>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>开启/关闭SWAP功能+制作SWAP文件/分区</title>
    <url>/2016/10/12/%E5%BC%80%E5%90%AF-%E5%85%B3%E9%97%ADSWAP%E5%8A%9F%E8%83%BD-%E5%88%B6%E4%BD%9CSWAP%E6%96%87%E4%BB%B6-%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<blockquote>
<p>在 linux 中可以使用<code>free -m</code>命令来查看内存的使用情况(包括 swap 交换分区的使用情况)关于 swap 存在的意义不再讨论, 有的人在某些情况下需要开启 swap 功能以保证程序不会崩溃; 有的人在某些情况下需要关闭 swap 功能以保证”宁宕毋慢”.</p>
</blockquote>
<h1 id="开启-关闭-swap-功能"><a href="#开启-关闭-swap-功能" class="headerlink" title="开启/关闭 swap 功能"></a>开启/关闭 swap 功能</h1><h2 id="开启"><a href="#开启" class="headerlink" title="开启"></a>开启</h2><ul>
<li>swap 文件: <code>swapon /opt/swapfile</code></li>
<li>swap 分区: <code>swapon /dev/sdb1</code></li>
</ul>
<h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><ul>
<li>swap 文件: <code>swapoff /opt/swapfile</code></li>
<li>swap 分区: <code>swapoff /dev/sdb1</code></li>
</ul>
<p>如果是系统在安装时设置了 swap, 在后期想要关闭 swap 功能,可以去修改<code>/etc/fstab</code>文件</p>
<p>将包含有 swap 信息的这一行注释掉<code>/dev/mapper/centos-swap swap                    swap    defaults        0 0</code></p>
<h1 id="增加-swap-空间"><a href="#增加-swap-空间" class="headerlink" title="增加 swap 空间"></a>增加 swap 空间</h1><h2 id="制作-swap-文件"><a href="#制作-swap-文件" class="headerlink" title="制作 swap 文件"></a>制作 swap 文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个1G的文件作为交换分区使用</span></span><br><span class="line">➜  ~ dd <span class="keyword">if</span>=/dev/zero of=/opt/swapfile bs=1M count=1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成swap分区</span></span><br><span class="line">➜  ~ mkswap /opt/swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开swap分区</span></span><br><span class="line">➜  ~ swapon /opt/swapfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/fstab中增加一条记录如下</span></span><br><span class="line">/opt/swapfile    swap   swap defaults 0 0</span><br></pre></td></tr></table></figure>

<h2 id="制作-swap-分区"><a href="#制作-swap-分区" class="headerlink" title="制作 swap 分区"></a>制作 swap 分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建一个 swap 分区</span></span><br><span class="line">➜  ~ fdisk /dev/sdb</span><br><span class="line">		<span class="comment"># 新建一个分区</span></span><br><span class="line">		n</span><br><span class="line">		p</span><br><span class="line">		default</span><br><span class="line">		default</span><br><span class="line">		...</span><br><span class="line">		<span class="comment"># 修改分区 id 为swap</span></span><br><span class="line">		t</span><br><span class="line">		82</span><br><span class="line">		<span class="comment"># 写入分区表</span></span><br><span class="line">		w</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 同步内存和分区表信息</span></span><br><span class="line">➜  ~  partprobe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化成 swap 分区</span></span><br><span class="line">➜  ~  mkswap /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开 swap 分区</span></span><br><span class="line">➜  ~  swapon /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在/etc/fstab中增加一条记录如下</span></span><br><span class="line">/opt/swapfile    swap   swap defaults 0 0</span><br></pre></td></tr></table></figure>

<p><em>Tips: 如果本机已有2G swap 交换分区,又制作了一个8G 的 swap 分区文件, 那么在执行<code>swapon</code>命令之后, swap 空间将为10G(swap 空间会累加)</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>swap</tag>
        <tag>swapoff</tag>
        <tag>swapon</tag>
      </tags>
  </entry>
  <entry>
    <title>检测TCP/UDP端口是否可用</title>
    <url>/2016/10/12/%E6%A3%80%E6%B5%8BTCP-UDP%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%90%A6%E5%8F%AF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在日常运维中,我们常常需要检查远程服务器的某个端口是否可用,是否可以连通. 如果远程服务器是使用了 TCP 协议监听了端口, 我们可以使用 telnet 命令来测试端口的连通性; 如果远程服务器使用的了 UDP 协议监听了端口, 我们可以使用 nc 命令来测试端口的连通性. 下面就对这两个命令做简单的使用介绍</p>
</blockquote>
<h1 id="telnet-gt-TCP"><a href="#telnet-gt-TCP" class="headerlink" title="telnet ===&gt; TCP"></a>telnet ===&gt; TCP</h1><p>telnet 命令的常用语法: <code>telnet IP port</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ telnet 192.168.10.159 22</span><br><span class="line">Trying 192.168.10.159...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">SSH-2.0-OpenSSH_6.6.1</span><br></pre></td></tr></table></figure>

<p>以上测试即为可以连通,而且显示出了应用的名称<code>SSH</code></p>
<p>退出 telnet 可是按 <code>Ctrl+]</code> 组合键, 得到 <code>&gt;</code> 命令终端后,再输入 <code>quit</code> 退出终端</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ telnet 192.168.10.159 22</span><br><span class="line">Trying 192.168.10.159...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>.</span><br><span class="line">SSH-2.0-OpenSSH_6.6.1</span><br><span class="line">^]</span><br><span class="line">telnet&gt; quit</span><br><span class="line">Connection closed.</span><br></pre></td></tr></table></figure>

<p><em>telnet 的其他用法请自行百度一下/谷歌一下</em>😆</p>
<h1 id="nc-gt-UDP"><a href="#nc-gt-UDP" class="headerlink" title="nc ===&gt; UDP"></a>nc ===&gt; UDP</h1><p>udp 协议监听的端口是不能用 telnet 命令来测试的,这里用到了 nc 命令</p>
<p>nc 命令的常用语法: <code>nc -zuv IP port</code></p>
<ul>
<li>z 将输入输出关闭</li>
<li>u 开启 UDP 模式</li>
<li>v 得到详细输出</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  ~ nc -zuv 192.168.10.159 4500</span><br><span class="line">found 0 associations</span><br><span class="line">found 1 connections:</span><br><span class="line">     1:	flags=82&lt;CONNECTED,PREFERRED&gt;</span><br><span class="line">	outif (null)</span><br><span class="line">	src 10.1.100.12 port 53092</span><br><span class="line">	dst 192.168.10.159 port 4500</span><br><span class="line">	rank info not available</span><br><span class="line"></span><br><span class="line">Connection to 192.168.10.159 port 4500 [udp/ipsec-msft] succeeded!</span><br></pre></td></tr></table></figure>

<p>nc 是一个强大的网络工具, 功能不仅限于此</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>UDP</tag>
        <tag>nc</tag>
        <tag>telnet</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下添加静态路由</title>
    <url>/2016/10/12/CentOS%E4%B8%8B%E6%B7%BB%E5%8A%A0%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="查看当前路由表"><a href="#查看当前路由表" class="headerlink" title="查看当前路由表"></a>查看当前路由表</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         localhost       0.0.0.0         UG    100    0        0 eno16780032</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</span><br><span class="line">192.168.10.0    0.0.0.0         255.255.255.0   U     100    0        0 eno16780032</span><br></pre></td></tr></table></figure>

<p><em>macOS 中使用 <code>netstat -nr</code> 命令来查看当前路由表</em></p>
<ul>
<li>Destination 目标网路</li>
<li>Gateway 网关</li>
<li>Genmask 掩码</li>
<li>Flags 标识<ul>
<li>U 路由已经启动</li>
<li>H 路由目标为主机</li>
<li>G 使用网关</li>
<li>R 为动态路由复原路由表</li>
<li>D 由守护进程或间接动态安装</li>
<li>M 被路由守护进程或间接修改</li>
<li>A 通过addrconf修改</li>
<li>C 缓存条目</li>
<li>! 拒绝路由</li>
</ul>
</li>
<li>Metric 路由开销, 到目标的‘距离’（通常基于跳数统计）</li>
<li>Ref 参考此路由的数量</li>
<li>Use 路由查找计数。依赖与使用-F 还是-C选项，这个值要么是路由缓存未命中数要么是命中数</li>
<li>Iface 此路由数据包发送到的网络接口</li>
</ul>
<h1 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h1><h2 id="添加到主机的路由"><a href="#添加到主机的路由" class="headerlink" title="添加到主机的路由"></a>添加到主机的路由</h2><p><code>route add –host 192.168.59.2 dev eth1</code></p>
<p><code>route add –host 192.168.59.2 gw 192.168.10.85</code></p>
<h2 id="添加到网络的路由"><a href="#添加到网络的路由" class="headerlink" title="添加到网络的路由"></a>添加到网络的路由</h2><p><code>route add -net 192.168.248.0/24 gw 192.168.10.85</code></p>
<p><code>route add –net 192.168.248.0 netmask 255.255.255.0 gw 192.168.10.85</code></p>
<p><code>route add –net 192.168.248.0 netmask 255.255.255.0 dev eth1</code></p>
<h2 id="添加默认网关"><a href="#添加默认网关" class="headerlink" title="添加默认网关"></a>添加默认网关</h2><p><code>route add default gw 192.168.10.85</code></p>
<p><code>route add -net 0.0.0.0 gw 192.168.10.85</code></p>
<p><strong>使用route 命令添加的路由，机器重启或者网卡重启后路由就失效了</strong></p>
<h1 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h1><p><code>route del –host 192.168.10.85 dev eth1</code></p>
<p><em>怎么 add 的就怎么 del 掉. 但是 del 的时候可以不写网关</em></p>
<h1 id="永久添加路由"><a href="#永久添加路由" class="headerlink" title="永久添加路由"></a>永久添加路由</h1><ul>
<li>在<code>/etc/rc.local</code>里添加路由信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route add -net 192.168.247.0&#x2F;24 dev eth1</span><br><span class="line">route add -net 192.168.110.0&#x2F;24 gw 192.168.10.85</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>/etc/sysconfig/network</code>里添加到末尾<code>GATEWAY=gw-ip 或者 GATEWAY=gw-dev</code></li>
<li>在<code>/etc/sysconfig/static-router</code>添加<code>any net x.x.x.x/24 gw y.y.y.y</code></li>
</ul>
<h2 id="永久添加路由更新-2018-10-12"><a href="#永久添加路由更新-2018-10-12" class="headerlink" title="永久添加路由更新 2018-10-12"></a>永久添加路由更新 2018-10-12</h2><p><strong>CentOS7下推荐使用上面第三种方法添加永久静态路由</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@centos7 ~]<span class="comment"># vi /etc/sysconfig/network-scripts/route-enp0s3</span></span><br><span class="line">10.15.150.0/24 via 192.168.150.253 dev enp0s3</span><br><span class="line">10.25.250.0/24 via 192.168.150.253 dev enp0s3</span><br></pre></td></tr></table></figure>

<p>将永久静态路由需要写到 /etc/sysconfig/network-scripts/route-interface 文件中</p>
<p>注意:</p>
<p><strong>ifcfg-enp0s3 文件改名为 ifcfg-eth0 后，route-enp0s3 文件也要改名为 route-eth0</strong></p>
<hr>
<p>参考文档:</p>
<ul>
<li><a href="https://www.cnblogs.com/panblack/p/Centos7_Static_Routes.html" target="_blank" rel="noopener">https://www.cnblogs.com/panblack/p/Centos7_Static_Routes.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>route</tag>
        <tag>静态路由</tag>
      </tags>
  </entry>
  <entry>
    <title>kvm虚拟机迁移至ESXi</title>
    <url>/2016/09/09/kvm%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%81%E7%A7%BB%E8%87%B3ESXi/</url>
    <content><![CDATA[<h1 id="转换步骤"><a href="#转换步骤" class="headerlink" title="转换步骤"></a>转换步骤</h1><ul>
<li>将kvm中要迁移的虚拟机关机</li>
<li>找到该虚拟机对应的<code>.img</code>文件</li>
<li>使用<code>qemu-img convert</code>命令将img文件转换为<code>vmdk</code>文件</li>
<li>把<code>vmdk</code>文件传送到<code>ESXi</code>主机上</li>
<li>在<code>vCenter</code>中创建一个配置相同的主机，加载已存在的<code>vmdk</code>硬盘文件</li>
<li>开启虚拟机即可</li>
</ul>
<h1 id="qemu-img命令的时候用"><a href="#qemu-img命令的时候用" class="headerlink" title="qemu-img命令的时候用"></a>qemu-img命令的时候用</h1><p><code>qemu-img</code>命​令​行​工​具​是​<code>Xen</code>和​<code>KVM</code>用​来​格​式​化​各​种​文​件​系​统​的​，可​使​用​<code>qemu-img</code>格​式​化​虚​拟​客​户​端​映​像​、​附​加​存​储​设​备​以​及​网​络​存​储​。还可以用来转换镜像文件</p>
<h2 id="创建磁盘文件"><a href="#创建磁盘文件" class="headerlink" title="创建磁盘文件"></a>创建磁盘文件</h2><p><strong>创​建​新​磁​盘​映​像​文​件​名​为​ sina_kvm，格​式​为​ format</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-img create [-6] [-e] [-b base_image] [-f format] filename [sina_kvm]</span><br></pre></td></tr></table></figure>

<p>例如：创建一个10M的镜像文件：ps_kvm.img，文件格式为：raw</p>
<h2 id="转换镜像格式"><a href="#转换镜像格式" class="headerlink" title="转换镜像格式"></a>转换镜像格式</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qemu-img convert [-c] [-e] [-f format] filename [-O output_format] output_filename</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img convert 10-71-hadoop.shennong.ren.img -O vmdk /tmp/testhdp.vmdk</span><br></pre></td></tr></table></figure>

<h2 id="获取镜像信息"><a href="#获取镜像信息" class="headerlink" title="获取镜像信息"></a>获取镜像信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img info [-f format] filename</span><br></pre></td></tr></table></figure>

<h2 id="支持的格式"><a href="#支持的格式" class="headerlink" title="支持的格式"></a>支持的格式</h2><p>映​像​格​式​通​常​是​自​动​获​取​的​。​支​持​以​下​格​式​：</p>
<ul>
<li>raw</li>
</ul>
<p>Raw 磁​盘​映​像​格​式​（默​认​）。​这​个​格​式​的​优​点​是​可​以​简​单​、​容​易​地​导​出​到​其​它​模​拟​器​中​。​如​果​您​的​文​件​系​统​支​持​中​断​（例​如​在​ Linux 中​的​ ext2 或​者​ ext3 以​及​ Windows 中​的​ NTFS），那​么​只​有​写​入​的​字​段​会​占​用​空​间​。​使​用​ qemu-img info 了​解​ Unix/Linux 中​映​像​或​者​ ls -ls 使​用​的​实​际​大​小​。​</p>
<ul>
<li>qcow2</li>
</ul>
<p>QEMU 映​像​格​式​，最​万​能​的​格​式​。​使​用​它​可​获​得​较​小​映​像​（如​果​您​的​系​统​不​支​持​中​断​，例​如​在​ Windows 中​，它​会​很​有​用​）、​额​外​的​ AES 加​密​法​、​zlib 压​缩​以​及​对​多​ VM 快​照​的​支​持​。​目前也是虚拟池一直在使用的镜像格式。<br>例如：<br>转换之前，原镜像disk size大小为8G，转换后仅仅只有2.3G。</p>
<ul>
<li>qcow</li>
</ul>
<p>旧​的​ QEMU 映​像​格​式​。​只​用​于​与​旧​版​本​兼​容​，目前虚拟池已无该格式镜像文件。​</p>
<ul>
<li>cow</li>
</ul>
<p>写​入​映​像​格​式​的​用​户​模​式​ Linux 副​本​。​包​含​ cow 格​式​的​目​的​只​是​为​了​与​前​面​的​版​本​兼​容​。​它​无​法​在​ Windows 中​使​用​，虚拟池已无该格式镜像文件。</p>
<ul>
<li>vmdk</li>
</ul>
<p>VMware 3 和​ 4 兼​容​映​像​格​式，虚拟池无该格式镜像文件​。​</p>
<ul>
<li>cloop</li>
</ul>
<p>Linux 压​缩​回​送​映​像​，只​有​在​重​复​使​用​直​接​压​缩​的​ CD-ROM 映​像​时​有​用​，比​如​在​ Knoppix CD-ROM 中​。</p>
<hr>
<p><em>参考文章</em></p>
<ul>
<li><a href="http://blog.sina.com.cn/s/blog_502c8cc40101352g.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_502c8cc40101352g.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ESXi</tag>
        <tag>kvm</tag>
        <tag>qemu-img</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux连接PPTP协议的VPN</title>
    <url>/2016/09/09/Linux%E8%BF%9E%E6%8E%A5PPTP%E5%8D%8F%E8%AE%AE%E7%9A%84VPN/</url>
    <content><![CDATA[<h1 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ppp pptp pptp-setup</span><br></pre></td></tr></table></figure>

<h1 id="创建VPN连接"><a href="#创建VPN连接" class="headerlink" title="创建VPN连接"></a>创建VPN连接</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pptpsetup  --create vpnname --server x.x.x.x  --username uaername --password XXXXXX --encrypt --start</span><br></pre></td></tr></table></figure>

<ul>
<li>create是创建的连接名称</li>
<li>server是vpn的ip地址</li>
<li>username是用户名</li>
<li>password是密码，也可以没这个参数，命令稍后会自动询问。这样可以保证账号安全</li>
<li>encrypt 是表示需要加密，不必指定加密方式，命令会读取配置文件中的加密方式（默认使用require-mppe-128加密）</li>
<li>start是表示创建连接完后马上连接</li>
</ul>
<h1 id="连接已有的VPN配置"><a href="#连接已有的VPN配置" class="headerlink" title="连接已有的VPN配置"></a>连接已有的VPN配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pon vpnname</span><br></pre></td></tr></table></figure>

<p>这个命令在系统中bin目录中找不到，在pptd的安装目录下的script目录下，如果不清楚这个命令具体在哪里的可以执行以下命令查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">"poff"</span> -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<p>我使用yum安装的软件，可以参考去以下路径查找</p>
<p><code>/usr/share/doc/ppp-2.4.5/scripts/</code></p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>连接成功后会在本地创建一个虚拟网口<code>ppp0</code></p>
<p>相关的路由也会加在路由表中，可以通过<code>route -n</code>和<code>ifconfig</code>命令查看</p>
<p>VPN连通后，可以指定本地所有流量都走VPN，也可以指定某几个网段的流量走VPN</p>
<ul>
<li>所有流量都走VPN，设置为默认路由</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route add -net 0.0.0.0 dev ppp0</span><br><span class="line">或</span><br><span class="line">route add default dev ppp0</span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route del -net 0.0.0.0 dev ppp0</span><br><span class="line">或</span><br><span class="line">route del default</span><br></pre></td></tr></table></figure>

<ul>
<li>指定网段的流量走VPN</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route add -net 192.168.168.0/24 dev ppp0</span><br></pre></td></tr></table></figure>

<p><strong>注意：重启网卡也会清除VPN通道</strong></p>
<h1 id="关闭VPN通道"><a href="#关闭VPN通道" class="headerlink" title="关闭VPN通道"></a>关闭VPN通道</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">poff vpnname (全部下线poff -a)</span><br></pre></td></tr></table></figure>

<p>这个命令在系统中bin目录中找不到，在pptd的安装目录下的script目录下，如果不清楚这个命令具体在哪里的可以执行以下命令查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -name <span class="string">"poff"</span> -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<p>我使用yum安装的软件，可以参考去以下路径查找</p>
<p><code>/usr/share/doc/ppp-2.4.5/scripts/</code></p>
<h1 id="相关目录"><a href="#相关目录" class="headerlink" title="相关目录"></a>相关目录</h1><ul>
<li>/etc/ppp/peers/  存放用户创建的vpnname配置文件的地方</li>
<li>/etc/ppp/chap-secrets  用户名密码存放的地方（明文的）</li>
</ul>
<h1 id="注"><a href="#注" class="headerlink" title="注"></a>注</h1><ul>
<li>注1： pon 和 poff命令可在ppp源码目录下的scripts目录中找到。</li>
<li>注2： 要想使用vpn通道，需要根据需要在本地添加静态路由</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>vpn</tag>
        <tag>PPTP</tag>
      </tags>
  </entry>
  <entry>
    <title>添加/删除路由</title>
    <url>/2016/09/09/%E6%B7%BB%E5%8A%A0-%E5%88%A0%E9%99%A4%E8%B7%AF%E7%94%B1/</url>
    <content><![CDATA[<h1 id="查看路由"><a href="#查看路由" class="headerlink" title="查看路由"></a>查看路由</h1><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.3.1     0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">192.168.3.0     0.0.0.0         255.255.255.0   U     100    0        0 eth0</span><br></pre></td></tr></table></figure>

<h2 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; netstat -nr</span><br><span class="line">Routing tables</span><br><span class="line"></span><br><span class="line">Internet:</span><br><span class="line">Destination        Gateway            Flags        Refs      Use   Netif Expire</span><br><span class="line">default            10.1.101.254       UGSc          214      718     en0</span><br><span class="line">10.1.100/23        link<span class="comment">#4             UCS            11        0     en0</span></span><br><span class="line">10.1.100.22        link<span class="comment">#4             UHLWIi          1        1     en0</span></span><br><span class="line">10.1.100.65/32     link<span class="comment">#4             UCS             2        0     en0</span></span><br><span class="line">10.1.100.65        60:3:8:a5:3b:9e    UHLWIi          1        3     lo0</span><br><span class="line">10.1.100.88        link<span class="comment">#4             UHLWIi          1        3     en0</span></span><br><span class="line">10.1.100.94        link<span class="comment">#4             UHLWIi          1        2     en0</span></span><br><span class="line">10.1.100.99        link<span class="comment">#4             UHLWIi          1        3     en0</span></span><br><span class="line">10.1.100.100       link<span class="comment">#4             UHLWIi          1        3     en0</span></span><br><span class="line">10.1.100.121       link<span class="comment">#4             UHLWIi          1        3     en0</span></span><br><span class="line">10.1.100.146       90:b6:86:d8:d:24   UHLWIi          1        1     en0    867</span><br><span class="line">10.1.101.128       link<span class="comment">#4             UHLWIi          1        2     en0</span></span><br><span class="line">10.1.101.164       c8:25:e1:61:70:2e  UHLWIi          1        1     en0   1004</span><br><span class="line">10.1.101.254/32    link<span class="comment">#4             UCS             2        0     en0</span></span><br><span class="line">10.1.101.254       b0:aa:77:1a:b0:58  UHLWIir       215       16     en0    782</span><br><span class="line">10.1.101.255       link<span class="comment">#4             UHLWbI          1      142     en0</span></span><br><span class="line">10.255.1/24        10.255.1.65        UGSc            1        0   utun0</span><br><span class="line">10.255.1.65        10.255.1.66        UH              3        0   utun0</span><br><span class="line">10.255.99/24       10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">10.255.99.49       10.255.99.50       UH             13        0   utun1</span><br><span class="line">10.255.100/24      10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">10.255.100.41      10.255.100.42      UH             13        0   utun2</span><br><span class="line">111.202.124.222/32 192.168.1.1        UGSc            2        0     en0</span><br><span class="line">127                127.0.0.1          UCS             1        0     lo0</span><br><span class="line">127.0.0.1          127.0.0.1          UH             27    57535     lo0</span><br><span class="line">169.254            link<span class="comment">#4             UCS             1        0     en0</span></span><br><span class="line">192.168.2          10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.3          10.255.99.49       UGSc            2        0   utun1</span><br><span class="line">192.168.4          10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.7          10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.8          10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.89         10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.90         10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.91         10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.95         10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.99         10.255.99.49       UGSc            1        0   utun1</span><br><span class="line">192.168.101        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.103        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.105        10.255.100.41      UGSc            2        0   utun2</span><br><span class="line">192.168.110        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.111        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.168        10.255.1.65        UGSc            1        0   utun0</span><br><span class="line">192.168.247        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.248        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.251        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.252        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">192.168.253        10.255.100.41      UGSc            1        0   utun2</span><br><span class="line">224.0.0            link<span class="comment">#4             UmCS            2        0     en0</span></span><br><span class="line">224.0.0.251        1:0:5e:0:0:fb      UHmLWI          1        0     en0</span><br><span class="line">255.255.255.255/32 link<span class="comment">#4             UCS             2        0     en0</span></span><br><span class="line">255.255.255.255    link<span class="comment">#4             UHLWbI          1      133     en0</span></span><br></pre></td></tr></table></figure>

<h1 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h1><h2 id="通过出口IP添加"><a href="#通过出口IP添加" class="headerlink" title="通过出口IP添加"></a>通过出口IP添加</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route add -net 192.168.2.0/24 gw 192.168.10.85</span><br><span class="line">route add -net 192.168.8.0/24 gw 192.168.10.85</span><br><span class="line">route add -net 192.168.168.0/24 gw 192.168.10.85</span><br><span class="line">route add -net 192.168.100.0/24 gw 192.168.10.85</span><br></pre></td></tr></table></figure>

<h2 id="通过出口设备添加"><a href="#通过出口设备添加" class="headerlink" title="通过出口设备添加"></a>通过出口设备添加</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">route add -net 0.0.0.0 dev ppp0 //添加默认路由</span><br></pre></td></tr></table></figure>

<h1 id="删除路由"><a href="#删除路由" class="headerlink" title="删除路由"></a>删除路由</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">route del -net 192.168.2.0&#x2F;24 gw 192.168.10.85</span><br><span class="line">route del -net 192.168.8.0&#x2F;24 gw 192.168.10.85</span><br><span class="line">route del -net 192.168.168.0&#x2F;24 gw 192.168.10.85</span><br><span class="line">route del -net 192.168.100.0&#x2F;24 gw 192.168.10.85</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>route</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title>cisco设备的ping命令</title>
    <url>/2016/09/09/cisco%E8%AE%BE%E5%A4%87%E7%9A%84ping%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>使用<code>ping x.x.x.x</code>命令默认发送5个包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ciscoasa&gt; ping 111.202.124.217</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 111.202.124.217, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5&#x2F;5), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;2&#x2F;10 ms</span><br></pre></td></tr></table></figure>

<p>可以指定发包的个数<code>ping x.x.x.x repeat num</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ciscoasa&gt; ping 111.202.124.217 repeat 100</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 100, 100-byte ICMP Echos to 111.202.124.217, timeout is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">Success rate is 100 percent (100&#x2F;100), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;3&#x2F;10 ms</span><br><span class="line">ciscoasa&gt; ping 111.202.124.217 repeat 1000</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 1000, 100-byte ICMP Echos to 111.202.124.217, timeout is 2 seconds:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?!?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!?!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">Success rate is 99 percent (992&#x2F;1000), round-trip min&#x2F;avg&#x2F;max &#x3D; 1&#x2F;3&#x2F;30 ms</span><br></pre></td></tr></table></figure>

<p><strong>后面还可给<code>size</code> 指定数据包的大小；<code>timeout</code> 表示超时的时间</strong></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL同步报错:Last_IO_Error: Got fatal error 1236 from master</title>
    <url>/2016/09/01/MySQL%E5%90%8C%E6%AD%A5%E6%8A%A5%E9%94%99-Last-IO-Error-Got-fatal-error-1236-from-master/</url>
    <content><![CDATA[<blockquote>
<p>配置MySQL从库，启动slave线程后”Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: ‘Could not find first log file name in binary log index file”的错误❌ </p>
</blockquote>
<ul>
<li>step 1</li>
</ul>
<p>先到slave中停止同步线程</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt;  stop slave for channel "db136";  # mysql5.7多源复制的语法</span><br></pre></td></tr></table></figure>

<ul>
<li>step 2</li>
</ul>
<p>回到master中，关闭当前的二进制日志文件并创建一个新文件，新的二进制日志文件的名字在当前的二进制文件的编号上加1</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush logs;</span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000038 |      154 |              | mysql            |                   |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>step 3</li>
</ul>
<p>再从slave执行change master</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to master_host="192.168.1.136", master_port=3306, master_user="repl",master_password="12345678",master_log_file="mysql-bin.000038",master_log_pos=154 for channel "db136";</span><br><span class="line">mysql&gt; start slave for channel "db136";</span><br><span class="line">mysql&gt; show slave status for channel "db136";</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>MySQL5.7增强版的多线程主从复制</title>
    <url>/2016/08/21/MySQL5-7%E5%A2%9E%E5%BC%BA%E7%89%88%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>MySQL多线程主从复制不是5.7版本中的新鲜产物，这个特性在5.6版本中就已经提供。但是在5.7版本中给多线程主从复制的特性做了增强</p>
</blockquote>
<ul>
<li>在MySQL5.6版本中的多线程复制，前提是一个线程只针对一个库</li>
<li>在MySQL5.7版本中，一个库可以使用多个线程同步，可以认为MySQL5.7的多线程复制是基于表的</li>
</ul>
<h1 id="多线程复制的配置"><a href="#多线程复制的配置" class="headerlink" title="多线程复制的配置"></a>多线程复制的配置</h1><p>根据MySQL复制原理，可以知道，多线程复制只需要修改slave端即可</p>
<h2 id="检查系统当前多线程复制的参数"><a href="#检查系统当前多线程复制的参数" class="headerlink" title="检查系统当前多线程复制的参数"></a>检查系统当前多线程复制的参数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'slave_parallel%';</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| Variable_name          | Value    |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">| slave_parallel_type    | DATABASE |</span><br><span class="line">| slave_parallel_workers | 0        |</span><br><span class="line">+<span class="comment">------------------------+----------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>从上面的查询结果上来看，slave默认的多线程复制类型是基于数据库的，也就是一个数据库对应一个线程；而多线程复制的线程数量为0，意为单进程复制</p>
<h2 id="设置多线程复制"><a href="#设置多线程复制" class="headerlink" title="设置多线程复制"></a>设置多线程复制</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; stop slave;</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slave_parallel_type='logical_clock';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; set global slave_parallel_workers=8;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave;</span><br><span class="line">Query OK, 0 rows affected (0.18 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h2 id="查看复制线程"><a href="#查看复制线程" class="headerlink" title="查看复制线程"></a>查看复制线程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br><span class="line">+<span class="comment">----+-----------------+-----------+------+---------+--------+--------------------------------------------------------+------------------+</span></span><br><span class="line">| Id | User            | Host      | db   | Command | Time   | State                                                  | Info             |</span><br><span class="line">+<span class="comment">----+-----------------+-----------+------+---------+--------+--------------------------------------------------------+------------------+</span></span><br><span class="line">|  1 | event_scheduler | localhost | NULL | Daemon  | 141366 | Waiting on empty queue                                 | NULL             |</span><br><span class="line">| 13 | root            | localhost | NULL | Query   |      0 | starting                                               | <span class="keyword">show</span> <span class="keyword">processlist</span> |</span><br><span class="line">| <span class="number">14</span> | <span class="keyword">system</span> <span class="keyword">user</span>     |           | <span class="literal">NULL</span> | <span class="keyword">Connect</span> |     <span class="number">49</span> | Waiting <span class="keyword">for</span> <span class="keyword">master</span> <span class="keyword">to</span> send <span class="keyword">event</span>                       | <span class="literal">NULL</span>             |</span><br><span class="line">| <span class="number">15</span> | <span class="keyword">system</span> <span class="keyword">user</span>     |           | <span class="literal">NULL</span> | <span class="keyword">Connect</span> |     <span class="number">48</span> | <span class="keyword">Slave</span> has <span class="keyword">read</span> <span class="keyword">all</span> relay <span class="keyword">log</span>; waiting for more updates | NULL             |</span><br><span class="line">| 16 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 17 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 18 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 19 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 20 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 21 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 22 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">| 23 | system user     |           | NULL | Connect |     49 | Waiting for an event from Coordinator                  | NULL             |</span><br><span class="line">+<span class="comment">----+-----------------+-----------+------+---------+--------+--------------------------------------------------------+------------------+</span></span><br><span class="line">12 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slave_parallel%'</span>;</span><br><span class="line">+<span class="comment">------------------------+---------------+</span></span><br><span class="line">| Variable_name          | Value         |</span><br><span class="line">+<span class="comment">------------------------+---------------+</span></span><br><span class="line">| slave_parallel_type    | LOGICAL_CLOCK |</span><br><span class="line">| slave_parallel_workers | 8             |</span><br><span class="line">+<span class="comment">------------------------+---------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p><em>注：MySQL5.7支持多源复制，这里的多线程复制的意思是为每一个源分配的多线程。例如上面我设置了线程数量为8，那意为着每个channel复制源都会提供8个线程去复制，如果有两个channel，那么在processlist中将看到16个线程</em></p>
<h2 id="查看多线程复制相关的视图"><a href="#查看多线程复制相关的视图" class="headerlink" title="查看多线程复制相关的视图"></a>查看多线程复制相关的视图</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables like 'replication%';</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| Tables_in_performance_schema (replication%) |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">| replication_applier_configuration           |</span><br><span class="line">| replication_applier_status                  |</span><br><span class="line">| replication_applier_status_by_coordinator   |</span><br><span class="line">| replication_applier_status_by_worker        |</span><br><span class="line">| replication_connection_configuration        |</span><br><span class="line">| replication_connection_status               |</span><br><span class="line">| replication_group_member_stats              |</span><br><span class="line">| replication_group_members                   |</span><br><span class="line">+<span class="comment">---------------------------------------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from replication_applier_status_by_coordinator;</span><br><span class="line">+<span class="comment">--------------+-----------+---------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">| CHANNEL_NAME | THREAD_ID | SERVICE_STATE | LAST_ERROR_NUMBER | LAST_ERROR_MESSAGE | LAST_ERROR_TIMESTAMP |</span><br><span class="line">+<span class="comment">--------------+-----------+---------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">| db153        |        40 | ON            |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">+<span class="comment">--------------+-----------+---------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p><em>注：由于MySQL5.7支持多源复制，那么这个复制的协调者<code>replication_applier_status_by_coordinator</code>会去协调每一个channel的复制线程</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from replication_applier_status_by_worker;</span><br><span class="line">+<span class="comment">--------------+-----------+-----------+---------------+-----------------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">| CHANNEL_NAME | WORKER_ID | THREAD_ID | SERVICE_STATE | LAST_SEEN_TRANSACTION | LAST_ERROR_NUMBER | LAST_ERROR_MESSAGE | LAST_ERROR_TIMESTAMP |</span><br><span class="line">+<span class="comment">--------------+-----------+-----------+---------------+-----------------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">| db153        |         1 |        41 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         2 |        42 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         3 |        43 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         4 |        44 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         5 |        45 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         6 |        46 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         7 |        47 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">| db153        |         8 |        48 | ON            |                       |                 0 |                    | 0000-00-00 00:00:00  |</span><br><span class="line">+<span class="comment">--------------+-----------+-----------+---------------+-----------------------+-------------------+--------------------+----------------------+</span></span><br><span class="line">8 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>在这里可以清楚的看到，为<code>db153</code>这一个channel提供了8个复制线程，如果有两个channel的，这里将显示16行</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL5.7</tag>
        <tag>主从复制</tag>
        <tag>多线程主从复制</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7的新特性(持续更新)</title>
    <url>/2016/08/21/MySQL5-7%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<blockquote>
<p>MySQL5.7正式版本已经发布，在MySQL5.7中迎来了大幅的性能升级以及新的特性，本篇文章就来详细讨论下MySQL5.7的最新特性</p>
</blockquote>
<h1 id="MySQL服务功能增强"><a href="#MySQL服务功能增强" class="headerlink" title="MySQL服务功能增强"></a>MySQL服务功能增强</h1><h2 id="数据库初始化的方式变更"><a href="#数据库初始化的方式变更" class="headerlink" title="数据库初始化的方式变更"></a>数据库初始化的方式变更</h2><ul>
<li>在MySQL5.7版本之前，使用编译安装或使用二进制包部署MySQL，初始化的时候是使用了如下脚本来实现的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; /<span class="variable">$path2mysql</span>/script/mysql_install_db \</span><br><span class="line">	--datadir=/data/mysql \</span><br><span class="line">	--user=mysql</span><br><span class="line">	--basedir=/<span class="variable">$path2mysql</span></span><br></pre></td></tr></table></figure>

<ul>
<li>到了MySQL5.7，不再提供脚本的方式初始化数据库，而是改用mysqld程序的命令来实现</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mysqld --initialize --user=mysql \</span><br><span class="line">	--basedir=/<span class="variable">$path2mysql</span></span><br><span class="line">	--datadir=/data/mysql</span><br></pre></td></tr></table></figure>

<p>当然如果你使用了yum的方式安装了MySQL5.7，那么在第一次启动mysql的时候<code>systemctl start mysqld</code>默认会自动根据配置文件去初始化你的数据库</p>
<h2 id="支持为表增加计算列"><a href="#支持为表增加计算列" class="headerlink" title="支持为表增加计算列"></a>支持为表增加计算列</h2><p>什么是计算列？</p>
<p>当一张表上的某一列的数据是由其他列的值计算得到的列，就称之为计算列</p>
<p>例如：一张表t，有c1，c2和c3列，c3的值=c1+c2</p>
<ul>
<li>在MySQL5.7之前，计算列只能通过触发器的方式来实现</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t(id int auto_increment not null, c1 int, c2 int, c3 int, primary key (id));</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>这张表建立之后，向t表中的c1和c2插入数据，c3是不可能自动计算出来的</p>
<p>只能通过插入触发器来实现</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create trigger inst_t before insert on t for each row set new.c3=new.c1+new.c2; </span><br><span class="line">Query OK, 0 rows affected (0.07 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show triggers;</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| Trigger | Event  | Table | Statement                | Timing | Created                | sql_mode                                                                                                                                  | Definer        | character_set_client | collation_connection | Database Collation |</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| inst_t  | <span class="keyword">INSERT</span> | t     | <span class="keyword">set</span> new.c3=new.c1+new.c2 | <span class="keyword">BEFORE</span> | <span class="number">2016</span><span class="number">-08</span><span class="number">-21</span> <span class="number">01</span>:<span class="number">52</span>:<span class="number">06.01</span> | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | root@localhost | utf8                 | utf8_general_ci      | utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> t(c1, c2) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Query OK, 1 row affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| id | c1   | c2   | c3   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 |    1 |    2 |    3 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>上面实现了插入触发器，测试正常，但是一旦我去更改c1或c2的值，c3列是不会跟着变更的</p>
<p>因此还需要建立一个更新触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create trigger upd_t before update on t for each row set new.c3=new.c1+new.c2;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show triggers;</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| Trigger | Event  | Table | Statement                | Timing | Created                | sql_mode                                                                                                                                  | Definer        | character_set_client | collation_connection | Database Collation |</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line">| inst_t  | <span class="keyword">INSERT</span> | t     | <span class="keyword">set</span> new.c3=new.c1+new.c2 | <span class="keyword">BEFORE</span> | <span class="number">2016</span><span class="number">-08</span><span class="number">-21</span> <span class="number">01</span>:<span class="number">52</span>:<span class="number">06.01</span> | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | root@localhost | utf8                 | utf8_general_ci      | utf8mb4_unicode_ci |</span><br><span class="line">| upd_t   | <span class="keyword">UPDATE</span> | t     | <span class="keyword">set</span> new.c3=new.c1+new.c2 | <span class="keyword">BEFORE</span> | <span class="number">2016</span><span class="number">-08</span><span class="number">-21</span> <span class="number">02</span>:<span class="number">01</span>:<span class="number">50.46</span> | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION | root@localhost | utf8                 | utf8_general_ci      | utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">---------+--------+-------+--------------------------+--------+------------------------+-------------------------------------------------------------------------------------------------------------------------------------------+----------------+----------------------+----------------------+--------------------+</span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">update</span> t <span class="keyword">set</span> c1=<span class="number">5</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| id | c1   | c2   | c3   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 |    5 |    2 |    7 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>从上面的Demo可以看出，在MySQL5.7之前，如果想实现计算列，只少要创建插入和更新两个触发器</p>
<p>而使用视图也是可以实现计算列的目的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create view vw_t as select id,c1,c2,c1+c2 as c3 from t;</span><br><span class="line">Query OK, 0 rows affected (0.11 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from vw_t;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| id | c1   | c2   | c3   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 |    5 |    2 |    7 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>而无论是使用触发器还是视图，对mysql的性能都会产生或多或少的影响，所以一般情况下，在生产环境中，建议是尽可能少的使用触发器和视图</p>
<ul>
<li>在MySQL5.7原生支持计算列语法</li>
</ul>
<p>在<code>create table</code>以及<code>alter table</code>语句中支持增加计算列</p>
<p><code>col_name data_type [GENERATED ALWAYS] AS (expression) [VIRTUAL|STORED] [UNIQUE [KEY]] [COMMENT comment] [[NOT] NULL] [[PRIMARY] KEY]</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop table t;</span><br><span class="line">Query OK, 0 rows affected (0.25 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create table t (id int auto_increment not null, c1 int, c2 int, c3 int as (c1+c2), primary key(id));</span><br><span class="line">Query OK, 0 rows affected (0.22 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create table t;</span><br><span class="line">+<span class="comment">-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                                                                                                                                             |</span><br><span class="line">+<span class="comment">-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| t     | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c3`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">GENERATED</span> <span class="keyword">ALWAYS</span> <span class="keyword">AS</span> ((<span class="string">`c1`</span> + <span class="string">`c2`</span>)) <span class="keyword">VIRTUAL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">-------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> t(c1, c2) <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| id | c1   | c2   | c3   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 |    1 |    2 |    3 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">update</span> t <span class="keyword">set</span> c1=<span class="number">9</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">| id | c1   | c2   | c3   |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">|  1 |    9 |    2 |   11 |</span><br><span class="line">+<span class="comment">----+------+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>MySQL5.7原生支持的计算列有两种模式，一种是虚拟列，一种是存在磁盘中的列。虚拟列不占用磁盘空间</p>
<h2 id="引入了JSON列类型及相关的函数"><a href="#引入了JSON列类型及相关的函数" class="headerlink" title="引入了JSON列类型及相关的函数"></a>引入了JSON列类型及相关的函数</h2><ul>
<li>MySQL5.7之前，只能在varchar或是text等字符类型的列中存储json类型的字符串，并通过程序解析来使用json字符串</li>
<li>MySQL5.7之后，增加了json列类型以及<code>json_</code>开头的相关处理函数，如<code>json_type()``json_object()``json_merge()</code> 等</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个json的数组</span></span><br><span class="line">mysql&gt; select json_array('a','b',now());</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| json_array('a','b',now())                |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| ["a", "b", "2016-08-21 02:41:45.000000"] |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个json KV对象</span></span><br><span class="line">mysql&gt; <span class="keyword">select</span> json_object(<span class="string">'k1'</span>,<span class="number">1</span>,<span class="string">'k2'</span>,<span class="number">2</span>);</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| json_object('k1',1,'k2',2) |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">| &#123;"k1": 1, "k2": 2&#125;         |</span><br><span class="line">+<span class="comment">----------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>创建一个含有json类型字段的表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table t1(jdoc json);</span><br><span class="line">Query OK, 0 rows affected (0.32 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create table t1;</span><br><span class="line">+<span class="comment">-------+-------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                      |</span><br><span class="line">+<span class="comment">-------+-------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| t1    | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`jdoc`</span> <span class="keyword">json</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">-------+-------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">insert</span> <span class="keyword">into</span> t1(jdoc) <span class="keyword">values</span>(json_array(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="keyword">now</span>()));</span><br><span class="line">Query OK, 1 row affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t1(jdoc) values(json_object('k1',1,'k2',2));</span><br><span class="line">Query OK, 1 row affected (0.06 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| jdoc                                     |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">| ["a", "b", "2016-08-21 02:47:50.000000"] |</span><br><span class="line">| &#123;"k1": 1, "k2": 2&#125;                       |</span><br><span class="line">+<span class="comment">------------------------------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>


<h1 id="REPLICATION方面的增强"><a href="#REPLICATION方面的增强" class="headerlink" title="REPLICATION方面的增强"></a>REPLICATION方面的增强</h1><h2 id="支持多源复制"><a href="#支持多源复制" class="headerlink" title="支持多源复制"></a>支持多源复制</h2><h2 id="基于库或是逻辑锁的多线程复制"><a href="#基于库或是逻辑锁的多线程复制" class="headerlink" title="基于库或是逻辑锁的多线程复制"></a>基于库或是逻辑锁的多线程复制</h2><h2 id="在线变更复制方式"><a href="#在线变更复制方式" class="headerlink" title="在线变更复制方式"></a>在线变更复制方式</h2><h1 id="InnoDB存储引擎的增强"><a href="#InnoDB存储引擎的增强" class="headerlink" title="InnoDB存储引擎的增强"></a>InnoDB存储引擎的增强</h1><h2 id="支持缓冲池大小在线变更"><a href="#支持缓冲池大小在线变更" class="headerlink" title="支持缓冲池大小在线变更"></a>支持缓冲池大小在线变更</h2><h2 id="增加innodb-buffer-pool导入导出功能"><a href="#增加innodb-buffer-pool导入导出功能" class="headerlink" title="增加innodb_buffer_pool导入导出功能"></a>增加innodb_buffer_pool导入导出功能</h2><h2 id="支持为innodb表建立表空间"><a href="#支持为innodb表建立表空间" class="headerlink" title="支持为innodb表建立表空间"></a>支持为innodb表建立表空间</h2><h1 id="MySQL安全方面的增强"><a href="#MySQL安全方面的增强" class="headerlink" title="MySQL安全方面的增强"></a>MySQL安全方面的增强</h1><h2 id="初始化数据库后的默认密码"><a href="#初始化数据库后的默认密码" class="headerlink" title="初始化数据库后的默认密码"></a>初始化数据库后的默认密码</h2><ul>
<li><p>在MySQL5.7之前的版本，初始化数据库后，默认的root密码为空，在localhost直接使用mysql客户端，可以以无密码的方式进入到数据库中</p>
</li>
<li><p>在MySQL5.7中，在初始化数据库之后，会为root生成一个强度为<code>大写字母+小写字母+数字+特殊符号</code>的密码，并且首次进入到mysql时，强制要你更改密码，且强度默认依然为<code>大写字母+小写字母+数字+特殊符号</code></p>
</li>
</ul>
<p>关于MySQL5.7的初始化密码的查找，可以参考本站的文章</p>
<ul>
<li><a href="https://docs.20150509.cn/2016/07/28/MySQL5-7初始密码/" target="_blank" rel="noopener">https://docs.20150509.cn/2016/07/28/MySQL5-7初始密码/</a></li>
</ul>
<h2 id="默认的密码强度"><a href="#默认的密码强度" class="headerlink" title="默认的密码强度"></a>默认的密码强度</h2><p>mysql对于密码有3种检验策略，默认validate_password_policy为MEDIUM</p>
<ul>
<li>LOW policy tests password length only. Passwords must be at least 8 characters long.</li>
<li>MEDIUM policy adds the conditions that passwords must contain at least 1 numeric character, 1 lowercase and uppercase character, and 1 special (nonalphanumeric) character.</li>
<li>STRONG policy adds the condition that password substrings of length 4 or longer must not match words</li>
</ul>
<p>关于MySQL5.7密码强度的更改，可以参考本站的文章</p>
<ul>
<li><a href="https://docs.20150509.cn/2016/08/19/CentOS7安装MySQL5-7/" target="_blank" rel="noopener">https://docs.20150509.cn/2016/08/19/CentOS7安装MySQL5-7/</a></li>
</ul>
<h2 id="不在支持old-password认证"><a href="#不在支持old-password认证" class="headerlink" title="不在支持old_password认证"></a>不在支持old_password认证</h2><h2 id="增加账号默认过期时间"><a href="#增加账号默认过期时间" class="headerlink" title="增加账号默认过期时间"></a>增加账号默认过期时间</h2><h2 id="加强了对账号的管理功能"><a href="#加强了对账号的管理功能" class="headerlink" title="加强了对账号的管理功能"></a>加强了对账号的管理功能</h2><h2 id="增加了sys管理数据库"><a href="#增加了sys管理数据库" class="headerlink" title="增加了sys管理数据库"></a>增加了sys管理数据库</h2>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>修改MySQL的字符集为utf8mb4</title>
    <url>/2016/08/21/%E4%BF%AE%E6%94%B9MySQL%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%BAutf8mb4/</url>
    <content><![CDATA[<blockquote>
<p>一般情况下，我们会设置MySQL默认的字符编码为utf8，但是近些年来，emoji表情的火爆使用，给数据库带来了意外的错误，就是emoji的字符集已经超出了utf8的编码范畴😄</p>
</blockquote>
<h1 id="令人抓狂的字符编码问题"><a href="#令人抓狂的字符编码问题" class="headerlink" title="令人抓狂的字符编码问题"></a>令人抓狂的字符编码问题</h1><p>谈到字符编码问题，会让很多人感到头疼，这里不在深究各个字符编码的特点和理论，这里只说下Unicode和utf8字符编码的关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unicode是编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。</span><br><span class="line">随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。</span><br><span class="line">它几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。</span><br><span class="line">详见：Unicode on Wikipedia。</span><br><span class="line">Unicode的编号从0000开始一直到10FFFF共分为16个Plane，每个Plane中有65536个字符。</span><br><span class="line">而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，</span><br><span class="line">但是它并没有涵盖整个Unicode的字库，这也造成了它在某些场景下对于特殊字符的处理困难</span><br></pre></td></tr></table></figure>

<p><strong>简单的说在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</strong></p>
<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件</p>
<p><img src="http://oss.20150509.cn/QQ20160821-0@2x.png" alt=""></p>
<p>emoji是Unicode编码，在MySQL中使用utf8编码无法正常显示emoji的表情，为了解决这个问题，MySQL在5.5.3版本之后，引进了新的字符编码<code>utf8mb4</code>,本篇文章主要介绍如何将已经是utf8的database切换到utf8mb4字符编码</p>
<h1 id="什么是utf8mb4"><a href="#什么是utf8mb4" class="headerlink" title="什么是utf8mb4"></a>什么是utf8mb4</h1><p>utf8mb4最明显的好处是解决了苹果挖的坑-推广了emoji表情。utf8mb4解决了MySQL数据库存储emoji表情的问题</p>
<p>utf8mb4是utf8的超集，理论上由utf8升级到utf8mb4字符编码没有任何兼容问题</p>
<h1 id="升级utf8到utf8mb4"><a href="#升级utf8到utf8mb4" class="headerlink" title="升级utf8到utf8mb4"></a>升级utf8到utf8mb4</h1><h2 id="1-备份"><a href="#1-备份" class="headerlink" title="1. 备份"></a>1. 备份</h2><p>安全第一，备份所有需要升级字符编码的数据库</p>
<ul>
<li>可以将库dump出来</li>
<li>如果是虚拟机，可以给整个主机做快照</li>
</ul>
<h2 id="2-升级"><a href="#2-升级" class="headerlink" title="2. 升级"></a>2. 升级</h2><p>utf8mb4是MySQL5.5.3版本之后支持的字符集，so，如果你需要使用这个字符集，前提条件是你的MySQL版本必须 &gt;= 5.5.3</p>
<h2 id="3-修改"><a href="#3-修改" class="headerlink" title="3. 修改"></a>3. 修改</h2><p>在MySQL中，可以为一个database设置字符编码，可以为一张表设置字符编码，甚至可以为某一个字段设置字符编码</p>
<ul>
<li>查看当前系统默认的字符集设置</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';</span><br><span class="line">+<span class="comment">--------------------------+-----------------+</span></span><br><span class="line">| Variable_name            | Value           |</span><br><span class="line">+<span class="comment">--------------------------+-----------------+</span></span><br><span class="line">| character_set_client     | utf8            |</span><br><span class="line">| character_set_connection | utf8            |</span><br><span class="line">| character_set_database   | utf8            |</span><br><span class="line">| character_set_filesystem | binary          |</span><br><span class="line">| character_set_results    | utf8            |</span><br><span class="line">| character_set_server     | utf8            |</span><br><span class="line">| character_set_system     | utf8            |</span><br><span class="line">| collation_connection     | utf8_general_ci |</span><br><span class="line">| collation_database       | utf8_general_ci |</span><br><span class="line">| collation_server         | utf8_general_ci |</span><br><span class="line">+<span class="comment">--------------------------+-----------------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看database的字符编码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create database polarsnow;</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------+</span></span><br><span class="line">| Database  | <span class="keyword">Create</span> <span class="keyword">Database</span>                                                    |</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------+</span></span><br><span class="line">| polarsnow | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`polarsnow`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8 */</span> |</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>查看table的字符编码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table ps;</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| Table | Create Table                                                                                |</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------+</span><br><span class="line">| ps    | CREATE TABLE &#96;ps&#96; (</span><br><span class="line">  &#96;name&#96; varchar(100) DEFAULT NULL</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8 |</span><br><span class="line">+-------+---------------------------------------------------------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ul>
<li>查看column的字符编码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show full columns from ps;</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| Field | Type         | Collation       | Null | Key | Default | Extra | Privileges                      | <span class="keyword">Comment</span> |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| <span class="keyword">name</span>  | <span class="built_in">varchar</span>(<span class="number">100</span>) | utf8_general_ci | YES  |     | <span class="literal">NULL</span>    |       | <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">references</span> |         |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h3 id="修改database默认的字符集"><a href="#修改database默认的字符集" class="headerlink" title="修改database默认的字符集"></a>修改database默认的字符集</h3><p><code>ALTER DATABASE database_name CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER DATABASE polarsnow CHARACTER SET = utf8mb4 COLLATE = utf8mb4_unicode_ci;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create database polarsnow;</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Database  | <span class="keyword">Create</span> <span class="keyword">Database</span>                                                                                  |</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| polarsnow | <span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="string">`polarsnow`</span> <span class="comment">/*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci */</span> |</span><br><span class="line">+<span class="comment">-----------+--------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| Tables_in_polarsnow |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ps                  |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> ps;</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                |</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| ps    | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`ps`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 |</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">columns</span> <span class="keyword">from</span> ps;</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| Field | Type         | Collation       | Null | Key | Default | Extra | Privileges                      | <span class="keyword">Comment</span> |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| <span class="keyword">name</span>  | <span class="built_in">varchar</span>(<span class="number">100</span>) | utf8_general_ci | YES  |     | <span class="literal">NULL</span>    |       | <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">references</span> |         |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">table</span> test_tb2 (tb2 <span class="built_in">varchar</span>(<span class="number">100</span>) );</span><br><span class="line">Query OK, 0 rows affected (0.21 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| Tables_in_polarsnow |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">| ps                  |</span><br><span class="line">| test_tb2            |</span><br><span class="line">+<span class="comment">---------------------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> test_tb2;</span><br><span class="line">+<span class="comment">----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table    | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                              |</span><br><span class="line">+<span class="comment">----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| test_tb2 | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`test_tb2`</span> (</span><br><span class="line">  <span class="string">`tb2`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到，虽然修改了database的字符集为utf8mb4，但是实际只是修改了database新创建的表，默认使用utf8mb4，原来已经存在的表，字符集并没有跟着改变，需要手动为每张表设置字符集</p>
<h3 id="修改table的字符集"><a href="#修改table的字符集" class="headerlink" title="修改table的字符集"></a>修改table的字符集</h3><ul>
<li>只修改表默认的字符集 <code>ALTER TABLE table_name DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></li>
<li>修改表默认的字符集和所有字符列的字符集 <code>ALTER TABLE table_name CONVERT TO CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table ps;</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                |</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line">| ps    | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`ps`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 |</span><br><span class="line">+<span class="comment">-------+---------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">columns</span> <span class="keyword">from</span> ps;</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| Field | Type         | Collation       | Null | Key | Default | Extra | Privileges                      | <span class="keyword">Comment</span> |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| <span class="keyword">name</span>  | <span class="built_in">varchar</span>(<span class="number">100</span>) | utf8_general_ci | YES  |     | <span class="literal">NULL</span>    |       | <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">references</span> |         |</span><br><span class="line">+<span class="comment">-------+--------------+-----------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> ps <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_unicode_ci;</span><br><span class="line">Query OK, 0 rows affected (0.38 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line">mysql&gt; show create table ps;</span><br><span class="line">+<span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| Table | <span class="keyword">Create</span> <span class="keyword">Table</span>                                                                                                                                         |</span><br><span class="line">+<span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line">| ps    | <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`ps`</span> (</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">COLLATE</span> utf8mb4_unicode_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">-------+------------------------------------------------------------------------------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">full</span> <span class="keyword">columns</span> <span class="keyword">from</span> ps;</span><br><span class="line">+<span class="comment">-------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| Field | Type         | Collation          | Null | Key | Default | Extra | Privileges                      | <span class="keyword">Comment</span> |</span><br><span class="line">+<span class="comment">-------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line">| <span class="keyword">name</span>  | <span class="built_in">varchar</span>(<span class="number">100</span>) | utf8mb4_unicode_ci | YES  |     | <span class="literal">NULL</span>    |       | <span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">references</span> |         |</span><br><span class="line">+<span class="comment">-------+--------------+--------------------+------+-----+---------+-------+---------------------------------+---------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h3 id="修改column默认的字符集"><a href="#修改column默认的字符集" class="headerlink" title="修改column默认的字符集"></a>修改column默认的字符集</h3><p><code>ALTER TABLE table_name CHANGE column_name column_name VARCHAR(191) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</code></p>
<p><em>注：VARCHAR(191) 根据字段实例的类型填写</em></p>
<h2 id="4-检查字段的最大长度和索引列"><a href="#4-检查字段的最大长度和索引列" class="headerlink" title="4. 检查字段的最大长度和索引列"></a>4. 检查字段的最大长度和索引列</h2><ul>
<li>字段长度</li>
</ul>
<p>由于从utf8升级到了utf8mb4，一个字符所占用的空间也由3个字节增长到4个字节，但是我们当初创建表时，设置的字段类型以及最大的长度没有改变。例如，你在utf8下设置某一字段的类型为<code>TINYTEXT</code>, 这中字段类型最大可以容纳255字节，三个字节一个字符的情况下可以容纳85个字符，四个字节一个字符的情况下只能容纳63个字符，如果原表中的这个字段的值有一个或多个超过了63个字符，那么转换成utf8mb4字符编码时将转换失败，你必须先将<code>TINYTEXT</code>更改为<code>TEXT</code>等更高容量的类型之后才能继续转换字符编码</p>
<ul>
<li>索引</li>
</ul>
<p>在InnoDB引擎中，最大的索引长度为767字节，三个字节一个字符的情况下，索引列的字符长度最大可以达到255，四个字节一个字符的情况下，索引的字符长度最大只能到191。如果你已经存在的表中的索引列的类型为<code>VARCHAR(255)</code>那么转换utf8mb4时同样会转换失败。你需要先将<code>VARCHAR(255)</code>更改为<code>VARCHAR(191)</code>才能继续转换字符编码</p>
<h2 id="5-修改配置文件"><a href="#5-修改配置文件" class="headerlink" title="5. 修改配置文件"></a>5. 修改配置文件</h2><p><code>SET NAMES utf8 COLLATE utf8_unicode_ci</code> becomes <code>SET NAMES utf8mb4 COLLATE utf8mb4_unicode_ci</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line"><span class="comment"># 对本地的mysql客户端的配置</span></span><br><span class="line">[client]</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对其他远程连接的mysql客户端的配置</span></span><br><span class="line">[mysql]</span><br><span class="line">default-character-set = utf8mb4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 本地mysql服务的配置</span></span><br><span class="line">[mysqld]</span><br><span class="line">character-set-client-handshake = FALSE</span><br><span class="line">character-set-server = utf8mb4</span><br><span class="line">collation-server = utf8mb4_unicode_ci</span><br><span class="line">&gt; service mysqld restart</span><br></pre></td></tr></table></figure>

<p>检查修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">| Variable_name            | Value              |</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">| character_set_client     | utf8mb4            |</span><br><span class="line">| character_set_connection | utf8mb4            |</span><br><span class="line">| character_set_database   | utf8mb4            |</span><br><span class="line">| character_set_filesystem | binary             |</span><br><span class="line">| character_set_results    | utf8mb4            |</span><br><span class="line">| character_set_server     | utf8mb4            |</span><br><span class="line">| character_set_system     | utf8               |</span><br><span class="line">| collation_connection     | utf8mb4_unicode_ci |</span><br><span class="line">| collation_database       | utf8mb4_unicode_ci |</span><br><span class="line">| collation_server         | utf8mb4_unicode_ci |</span><br><span class="line">+<span class="comment">--------------------------+--------------------+</span></span><br><span class="line">10 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p><em>注：character_set_system 一直都会是 utf8，不能被更改</em></p>
<h2 id="6-修复-amp-优化所有数据表"><a href="#6-修复-amp-优化所有数据表" class="headerlink" title="6. 修复&amp;优化所有数据表"></a>6. 修复&amp;优化所有数据表</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mysqlcheck -u root -p --auto-repair --optimize --all-databases</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>不要在MySQL上使用utf8字符编码，推荐使用<code>utf8mb4</code>，至于为什么，引用国外友人的一段话：</p>
<blockquote>
<p>Never use utf8 in MySQL — always use utf8mb4 instead. Updating your databases and code might take some time, but it’s definitely worth the effort. Why would you arbitrarily limit the set of symbols that can be used in your database? Why would you lose data every time a user enters an astral symbol as part of a comment or message or whatever it is you store in your database? There’s no reason not to strive for full Unicode support everywhere. Do the right thing, and use utf8mb4. 🍻</p>
</blockquote>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li>字符集和字符编码的关系：<a href="http://www.cnblogs.com/cenalulu/p/4251639.html" target="_blank" rel="noopener">http://www.cnblogs.com/cenalulu/p/4251639.html</a></li>
<li>让mysql支持utf8mb4：<a href="https://mathiasbynens.be/notes/mysql-utf8mb4" target="_blank" rel="noopener">https://mathiasbynens.be/notes/mysql-utf8mb4</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>utf8mb4</tag>
        <tag>utf8</tag>
        <tag>Unicode</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7离线更改为事务复制</title>
    <url>/2016/08/19/MySQL5-7%E7%A6%BB%E7%BA%BF%E6%9B%B4%E6%94%B9%E4%B8%BA%E4%BA%8B%E5%8A%A1%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<blockquote>
<p>从MySQL5.6版本开始，支持以事务的方式来做主从同步，最大限度的保证MySQL的主从一致性。实现这一复制特性的关键是GTID(Global Transaction Identifiers)全局事务ID，通过GTID来强化数据库的主从一致性，故障恢复以及容错能力</p>
<p>MySQL5.7支持在线修改复制类型，MySQL5.6只能离线修改，本篇文章主要介绍离线修改复制类型的方法，后续的文章中会介绍如何在线更换复制类型</p>
</blockquote>
<h1 id="什么是GTID"><a href="#什么是GTID" class="headerlink" title="什么是GTID"></a>什么是GTID</h1><p>官方文档：</p>
<ul>
<li>5.6: <a href="http://dev.mysql.com/doc/refman/5.6/en/replication-gtids.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/replication-gtids.html</a></li>
<li>5.7: <a href="http://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/replication-gtids.html</a></li>
</ul>
<p>A GTID is represented as a pair of coordinates, separated by a colon character (:), as shown here:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GTID &#x3D; source_id:transaction_id</span><br></pre></td></tr></table></figure>

<p>每一个 GTID 代表一个数据库事务。在上面的定义中，<code>source_id</code> 表示执行事务的主库 uuid（server_uuid），<code>transaction_id</code> 是一个从 1 开始的自增计数，表示在这个主库上执行的第 n 个事务。MySQL 会保证事务与 GTID 之间的 1 : 1 映射</p>
<h1 id="服务器资源"><a href="#服务器资源" class="headerlink" title="服务器资源"></a>服务器资源</h1><ul>
<li>master：192.168.10.153</li>
<li>slave：192.168.10.157</li>
</ul>
<h1 id="安装MySQL5-7"><a href="#安装MySQL5-7" class="headerlink" title="安装MySQL5.7"></a>安装MySQL5.7</h1><p>略</p>
<p>可以参考上一篇文章来安装MySQL5.7</p>
<h1 id="master配置"><a href="#master配置" class="headerlink" title="master配置"></a>master配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line"><span class="comment"># client的配置会被MySQL客户端应用读取</span></span><br><span class="line"><span class="comment"># 只有MySQL附带的客户端应用程序保证可以读取到这段内容</span></span><br><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line"><span class="comment"># 生产环境中所使用的字符集推荐设置为utf8mb4</span></span><br><span class="line"><span class="comment"># 这里默认使用utf8，字符集的问题将有独立的文章介绍</span></span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端读取的配置文件</span></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line"><span class="comment"># 生产环境中所使用的字符集推荐设置为utf8mb4</span></span><br><span class="line"><span class="comment"># 这里默认使用utf8，字符集的问题将有独立的文章介绍</span></span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line"><span class="comment"># MySQL服务端读取的配置文件</span></span><br><span class="line">[mysqld]</span><br><span class="line">server-id = 10153  <span class="comment"># 保证server-id的唯一性，这里采用了IP的后两位来保证唯一性</span></span><br><span class="line">port = 3306 <span class="comment"># MySQL服务监听的端口号</span></span><br><span class="line">user = mysql <span class="comment"># 以mysql用户来运行MySQL服务进程</span></span><br><span class="line">basedir = /usr/<span class="built_in">local</span>/mysql <span class="comment"># MySQL服务的根目录（编译安装指定路径，yum安装注释掉即可）</span></span><br><span class="line">datadir = /data/mysqldata <span class="comment"># 数据目录</span></span><br><span class="line">socket = /tmp/mysql.sock <span class="comment"># socket文件所在的位置</span></span><br><span class="line">default-storage-engine = INNODB <span class="comment"># 默认的存储引擎</span></span><br><span class="line"><span class="comment"># 生产环境中所使用的字符集推荐设置为utf8mb4</span></span><br><span class="line"><span class="comment"># 这里默认使用utf8，字符集的问题将有独立的文章介绍</span></span><br><span class="line">character-set-server = utf8</span><br><span class="line">connect_timeout = 60 <span class="comment"># 连接超时时间</span></span><br><span class="line">interactive_timeout = 28800 <span class="comment"># MySQL在关闭一个交互的连接之前所要等待的秒数(交互连接如mysql gui tool中的连接)</span></span><br><span class="line">wait_timeout = 28800 <span class="comment"># MySQL在关闭一个非交互的连接之前所要等待的秒数</span></span><br><span class="line">back_log = 500 <span class="comment"># 操作系统在监听队列中所能保持的连接数</span></span><br><span class="line">event_scheduler = ON <span class="comment"># 开启定时任务机制</span></span><br><span class="line">skip_name_resolve = ON <span class="comment"># 忽略IP方向解析</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###########binlog##########</span></span><br><span class="line"><span class="built_in">log</span>-bin = /data/mysqlLog/logs/mysql-bin <span class="comment"># 打开二进制日志功能</span></span><br><span class="line"><span class="comment"># 当设置隔离级别为READ-COMMITED必须设置二进制日志格式为ROW</span></span><br><span class="line"><span class="comment"># 现在MySQL官方认为STATEMENT这个已经不再适合继续使用</span></span><br><span class="line"><span class="comment"># 但mixed类型在默认的事务隔离级别下，可能会导致主从数据不一致</span></span><br><span class="line">binlog_format = row <span class="comment"># 复制模式为行级模式（复制模式的介绍可以参考本站关于复制基础的文章）</span></span><br><span class="line">max_binlog_size = 128M <span class="comment"># 每个二进制日志最大的文件大小</span></span><br><span class="line">binlog_cache_size = 2M <span class="comment"># 二进制日志缓存大小</span></span><br><span class="line">expire-logs-days = 5 <span class="comment"># 二进制日志的保存时间（保存最近5天的二进制日志）</span></span><br><span class="line"><span class="comment"># 将slave在master收到的更新记入到slave自己的二进制日志文件中</span></span><br><span class="line"><span class="comment"># 在MySQL级联复制中，这个参数必须打开（A=&gt;B=&gt;C）</span></span><br><span class="line"><span class="built_in">log</span>-slave-updates=<span class="literal">true</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下三个参数启用复制有关的所有校验功能</span></span><br><span class="line">binlog_checksum = CRC32 <span class="comment"># checksum使用zlib中的CRC-32算法</span></span><br><span class="line"><span class="comment"># 不仅dump thread会对event进行校验，当master上执行show binlog events的时候</span></span><br><span class="line"><span class="comment"># 也会对event进行校验</span></span><br><span class="line"><span class="comment"># 设置为1，可以保证event被完整无缺地写入到主服务器的binlog中了</span></span><br><span class="line">master_verify_checksum = 1 </span><br><span class="line">slave_sql_verify_checksum = 1 <span class="comment"># 设置为1，slave上的IO Thread写入到Relay Log时和SQL Thread读取Relay Log时会对checksum进行验证</span></span><br><span class="line"></span><br><span class="line">binlog_rows_query_log_events = 1 <span class="comment"># 可用于在二进制日志记录事件相关的信息，可降低故障排除的复杂度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###### GTID事务复制支持部分 ######</span></span><br><span class="line">gtid-mode=on <span class="comment"># 开启全局事务ID</span></span><br><span class="line">enforce-gtid-consistency=<span class="literal">true</span> <span class="comment"># 开启强制全局事务ID一致性（用于启动GTID及满足附属的其它需求）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启用此两项，可用于实现在崩溃时保证二进制及从服务器安全的功能</span></span><br><span class="line">master-info-repository=TABLE </span><br><span class="line">relay-log-info-repository=TABLE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sync-master-info=1 <span class="comment"># 确保无信息丢失</span></span><br><span class="line">slave-parallel-workers=4 <span class="comment"># 设定从服务器的SQL线程数；0表示关闭多线程复制功能</span></span><br><span class="line"><span class="comment"># rpl_semi_sync_master_enabled = 1 # 半同步复制</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 慢SQL的相关配置</span></span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /data/mysqlLog/logs/mysql.slow</span><br><span class="line">long_query_time = 1</span><br><span class="line"> </span><br><span class="line">log_error = /data/mysqlLog/logs/error.log <span class="comment"># 错误信息的配置</span></span><br><span class="line">max_connections = 3000 <span class="comment"># MySQL的最大连接数</span></span><br><span class="line">max_connect_errors = 32767 <span class="comment"># 某一客户端尝试连接此MySQL服务器，但是失败（如密码错误等等）32767次，则MySQL会无条件强制阻止此客户端连接</span></span><br><span class="line">log_bin_trust_function_creators = 1 <span class="comment"># 允许使用MySQL自定义函数</span></span><br><span class="line">transaction_isolation = READ-COMMITTED <span class="comment"># 设置事务隔离级别</span></span><br></pre></td></tr></table></figure>

<h1 id="slave配置"><a href="#slave配置" class="headerlink" title="slave配置"></a>slave配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/my.cnf</span><br><span class="line">[client]</span><br><span class="line">port = 3306</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line">[mysql]</span><br><span class="line">no-auto-rehash</span><br><span class="line">default-character-set = utf8</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">server-id = 10157</span><br><span class="line">port = 3306</span><br><span class="line">user = mysql</span><br><span class="line">basedir = /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">datadir = /data/mysqldata</span><br><span class="line">socket = /tmp/mysql.sock</span><br><span class="line">default-storage-engine = INNODB</span><br><span class="line">character-set-server = utf8</span><br><span class="line">connect_timeout = 60</span><br><span class="line">wait_timeout = 18000</span><br><span class="line">back_log = 500</span><br><span class="line">event_scheduler = ON</span><br><span class="line"> </span><br><span class="line"><span class="comment">###########binlog##########</span></span><br><span class="line"><span class="built_in">log</span>-bin = /data/mysqlLog/logs/mysql-bin</span><br><span class="line">binlog_format = row</span><br><span class="line">max_binlog_size = 128M</span><br><span class="line">binlog_cache_size = 2M</span><br><span class="line">expire-logs-days = 5</span><br><span class="line"><span class="built_in">log</span>-slave-updates=<span class="literal">true</span></span><br><span class="line">gtid-mode=on </span><br><span class="line">enforce-gtid-consistency=<span class="literal">true</span></span><br><span class="line">master-info-repository=TABLE</span><br><span class="line">relay-log-info-repository=TABLE</span><br><span class="line">sync-master-info=1</span><br><span class="line">slave-parallel-workers=4</span><br><span class="line"><span class="comment"># rpl_semi_sync_slave_enabled = 1</span></span><br><span class="line"><span class="comment"># skip-slave-start # slave复制进程不随mysql启动而启动</span></span><br><span class="line"></span><br><span class="line">slow_query_log = 1</span><br><span class="line">slow_query_log_file = /data/mysqlLog/logs/mysql.slow</span><br><span class="line">long_query_time = 2</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>-error = /data/mysqlLog/logs/error.log</span><br><span class="line">max_connections = 3000</span><br><span class="line">max_connect_errors = 10000</span><br><span class="line">log_bin_trust_function_creators = 1</span><br><span class="line">transaction_isolation = READ-COMMITTED</span><br></pre></td></tr></table></figure>

<h1 id="分别启动主库和从库"><a href="#分别启动主库和从库" class="headerlink" title="分别启动主库和从库"></a>分别启动主库和从库</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h1 id="在主库中创建复制用户"><a href="#在主库中创建复制用户" class="headerlink" title="在主库中创建复制用户"></a>在主库中创建复制用户</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_policy = LOW;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create user 'repl' identified by '12345678';</span><br><span class="line">Query OK, 0 rows affected (0.05 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant replication slave on *.* to repl@'%';</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br></pre></td></tr></table></figure>

<h1 id="查看主库与从库GTID状态"><a href="#查看主库与从库GTID状态" class="headerlink" title="查看主库与从库GTID状态"></a>查看主库与从库GTID状态</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like 'gtid_mode';</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| gtid_mode     | ON    |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="在从库启动复制线程"><a href="#在从库启动复制线程" class="headerlink" title="在从库启动复制线程"></a>在从库启动复制线程</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; change master to</span><br><span class="line">    -&gt;   master_host='192.168.10.153',</span><br><span class="line">    -&gt;   master_port=3306,</span><br><span class="line">    -&gt;   master_user='repl',</span><br><span class="line">    -&gt;   master_password='12345678',</span><br><span class="line">    -&gt;   master_auto_position=1 for channel "db153";</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.27 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start slave for channel "db153";</span><br><span class="line">Query OK, 0 rows affected (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show slave status for channel "db153" \G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.10.153</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 595</span><br><span class="line">               Relay_Log_File: localhost-relay-bin-db153.000002</span><br><span class="line">                Relay_Log_Pos: 808</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 595</span><br><span class="line">              Relay_Log_Space: 1025</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 10153</span><br><span class="line">                  Master_UUID: 1349d343-6611-11e6-b341-005056ad5f2f</span><br><span class="line">             Master_Info_File: mysql.slave_master_info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: 1349d343-6611-11e6-b341-005056ad5f2f:1-2</span><br><span class="line">            Executed_Gtid_Set: 1349d343-6611-11e6-b341-005056ad5f2f:1-2</span><br><span class="line">                Auto_Position: 1</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: db153</span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h1 id="验证主从同步"><a href="#验证主从同步" class="headerlink" title="验证主从同步"></a>验证主从同步</h1><h2 id="master"><a href="#master" class="headerlink" title="master"></a>master</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">| mysql-bin.000001 |      595 |              |                  | 1349d343-6611-11e6-b341-005056ad5f2f:1-2 |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">create</span> <span class="keyword">database</span> polarsnow;</span><br><span class="line">Query OK, 1 row affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show master status;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">| mysql-bin.000001 |      769 |              |                  | 1349d343-6611-11e6-b341-005056ad5f2f:1-3 |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+------------------+------------------------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h2 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status for channel "db153"\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 192.168.10.153</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 769</span><br><span class="line">               Relay_Log_File: localhost-relay-bin-db153.000002</span><br><span class="line">                Relay_Log_Pos: 982</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">              Replicate_Do_DB: </span><br><span class="line">          Replicate_Ignore_DB: </span><br><span class="line">           Replicate_Do_Table: </span><br><span class="line">       Replicate_Ignore_Table: </span><br><span class="line">      Replicate_Wild_Do_Table: </span><br><span class="line">  Replicate_Wild_Ignore_Table: </span><br><span class="line">                   Last_Errno: 0</span><br><span class="line">                   Last_Error: </span><br><span class="line">                 Skip_Counter: 0</span><br><span class="line">          Exec_Master_Log_Pos: 769</span><br><span class="line">              Relay_Log_Space: 1199</span><br><span class="line">              Until_Condition: None</span><br><span class="line">               Until_Log_File: </span><br><span class="line">                Until_Log_Pos: 0</span><br><span class="line">           Master_SSL_Allowed: No</span><br><span class="line">           Master_SSL_CA_File: </span><br><span class="line">           Master_SSL_CA_Path: </span><br><span class="line">              Master_SSL_Cert: </span><br><span class="line">            Master_SSL_Cipher: </span><br><span class="line">               Master_SSL_Key: </span><br><span class="line">        Seconds_Behind_Master: 0</span><br><span class="line">Master_SSL_Verify_Server_Cert: No</span><br><span class="line">                Last_IO_Errno: 0</span><br><span class="line">                Last_IO_Error: </span><br><span class="line">               Last_SQL_Errno: 0</span><br><span class="line">               Last_SQL_Error: </span><br><span class="line">  Replicate_Ignore_Server_Ids: </span><br><span class="line">             Master_Server_Id: 10153</span><br><span class="line">                  Master_UUID: 1349d343-6611-11e6-b341-005056ad5f2f</span><br><span class="line">             Master_Info_File: mysql.slave_master_info</span><br><span class="line">                    SQL_Delay: 0</span><br><span class="line">          SQL_Remaining_Delay: NULL</span><br><span class="line">      Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates</span><br><span class="line">           Master_Retry_Count: 86400</span><br><span class="line">                  Master_Bind: </span><br><span class="line">      Last_IO_Error_Timestamp: </span><br><span class="line">     Last_SQL_Error_Timestamp: </span><br><span class="line">               Master_SSL_Crl: </span><br><span class="line">           Master_SSL_Crlpath: </span><br><span class="line">           Retrieved_Gtid_Set: 1349d343-6611-11e6-b341-005056ad5f2f:1-3</span><br><span class="line">            Executed_Gtid_Set: 1349d343-6611-11e6-b341-005056ad5f2f:1-3</span><br><span class="line">                Auto_Position: 1</span><br><span class="line">         Replicate_Rewrite_DB: </span><br><span class="line">                 Channel_Name: db153</span><br><span class="line">           Master_TLS_Version: </span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| Database           |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| polarsnow          |</span><br><span class="line">| sys                |</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">5 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<p>至此，事务同步配置成功！</p>
<p>在之前使用二进制复制的主从模式时，经历了各种主从数据不一致的情况，而从MySQL5.6开始新引入的事务复制能否解决二进制bin-log复制的数据一致性的痛点还有待观察和检验……</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><ul>
<li>MySQL5.7官方文档：<a href="http://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/</a></li>
<li>参考文档：<a href="http://www.cnblogs.com/darren-lee/p/5160802.html" target="_blank" rel="noopener">http://www.cnblogs.com/darren-lee/p/5160802.html</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL5.7</tag>
        <tag>主从复制</tag>
        <tag>GTID</tag>
        <tag>事务同步</tag>
        <tag>Global Transaction Identifiers</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装MySQL5.7</title>
    <url>/2016/08/19/CentOS7%E5%AE%89%E8%A3%85MySQL5-7/</url>
    <content><![CDATA[<blockquote>
<p>这里使用yum的方式安装mysql5.7，仅为测试使用，生产环境中，还是建议使用cmake编译安装mysql    </p>
</blockquote>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum remove -y mysql</span><br><span class="line">&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">&gt; wget http://repo.mysql.com/mysql57-community-release-el7-8.noarch.rpm</span><br><span class="line">&gt; rpm -ivh mysql57-community-release-el7-8.noarch.rpm </span><br><span class="line">警告：mysql57-community-release-el7-8.noarch.rpm: 头V3 DSA/SHA1 Signature, 密钥 ID 5072e1f5: NOKEY</span><br><span class="line">准备中...                          <span class="comment">################################# [100%]</span></span><br><span class="line">正在升级/安装...</span><br><span class="line">   1:mysql57-community-release-el7-8  <span class="comment">################################# [100%]</span></span><br><span class="line">&gt; yum install -y mysql-server</span><br><span class="line">&gt; systemctl start mysqld</span><br><span class="line">&gt; systemctl status mysqld</span><br><span class="line">● mysqld.service - MySQL Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since 五 2016-08-19 09:30:24 EDT; 29s ago</span><br><span class="line">  Process: 105136 ExecStart=/usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid <span class="variable">$MYSQLD_OPTS</span> (code=exited, status=0/SUCCESS)</span><br><span class="line">  Process: 105049 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS)</span><br><span class="line"> Main PID: 105138 (mysqld)</span><br><span class="line">   CGroup: /system.slice/mysqld.service</span><br><span class="line">           └─105138 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line"></span><br><span class="line">8月 19 09:30:16 localhost.localdomain systemd[1]: Starting MySQL Server...</span><br><span class="line">8月 19 09:30:24 localhost.localdomain systemd[1]: Started MySQL Server.</span><br><span class="line">&gt; cat /var/<span class="built_in">log</span>/mysqld.log| grep <span class="string">"temporary password"</span></span><br><span class="line">2016-08-19T13:30:20.547835Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: TVu7ouUi&gt;55l</span><br><span class="line">&gt; mysql -uroot -p</span><br><span class="line">Enter password:TVu7ouUi&gt;55l</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 2</span><br><span class="line">Server version: 5.7.14</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2016, Oracle and/or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">'help;'</span> or <span class="string">'\h'</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">'\c'</span> to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt;</span><br></pre></td></tr></table></figure>

<h1 id="设置root用户密码"><a href="#设置root用户密码" class="headerlink" title="设置root用户密码"></a>设置root用户密码</h1><p>MySQL5.7默认的密码复杂度为：大小写字母+数字+特殊符号</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user user() identified by 'w&#123;YQW6L;Dsf6vw';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; </span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE 'validate_password%';</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">| Variable_name                        | Value  |</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">| validate_password_dictionary_file    |        |</span><br><span class="line">| validate_password_length             | 8      |</span><br><span class="line">| validate_password_mixed_case_count   | 1      |</span><br><span class="line">| validate_password_number_count       | 1      |</span><br><span class="line">| validate_password_policy             | MEDIUM |</span><br><span class="line">| validate_password_special_char_count | 1      |</span><br><span class="line">+<span class="comment">--------------------------------------+--------+</span></span><br><span class="line">6 rows in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>mysql对于密码有3种检验策略，默认<code>validate_password_policy</code>为<code>MEDIUM</code></p>
<ul>
<li>LOW policy tests password length only. Passwords must be at least 8 characters long.</li>
<li>MEDIUM policy adds the conditions that passwords must contain at least 1 numeric character, 1 lowercase and uppercase character, and 1 special (nonalphanumeric) character.</li>
<li>STRONG policy adds the condition that password substrings of length 4 or longer must not match words</li>
</ul>
<p>在默认<code>MEDIUM</code>的策略下，修改密码为：12345678会报错</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user user() identified by '12345678';</span><br><span class="line">ERROR 1819 (HY000): Your password does not satisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<h1 id="修改MySQL密码检查策略"><a href="#修改MySQL密码检查策略" class="headerlink" title="修改MySQL密码检查策略"></a>修改MySQL密码检查策略</h1><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; SET GLOBAL validate_password_policy = LOW;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; alter user user() identified by '12345678';</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL5.7</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据类型</title>
    <url>/2016/08/14/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h1><table>
<thead>
<tr>
<th>存储类型</th>
<th>存储空间（字节）</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>-128</td>
<td>127</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768</td>
<td>32767</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608</td>
<td>8388607</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>-2147483648</td>
<td>4147483647</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-9223372036854775808</td>
<td>9223372036854775807</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0</td>
<td>18446744073709551615</td>
</tr>
</tbody></table>
<h2 id="老生常谈的问题"><a href="#老生常谈的问题" class="headerlink" title="老生常谈的问题"></a>老生常谈的问题</h2><ul>
<li>int(11) VS int(21) 有什么区别</li>
</ul>
<p>是存储空间有区别？还是存储范围有区别？</p>
<p><strong>答案是：都没有区别,只在特性情况下显示上有些区别</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置空位补零</span></span><br><span class="line">mysql&gt; create table testint (a int(11) zerofill, b int(21) zerofill);</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into testint values(1,1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from testint;</span><br><span class="line">+<span class="comment">-------------+-----------------------+</span></span><br><span class="line">| a           | b                     |</span><br><span class="line">+<span class="comment">-------------+-----------------------+</span></span><br><span class="line">| 00000000001 | 000000000000000000001 |</span><br><span class="line">+<span class="comment">-------------+-----------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认情况下数字前面不会补零</span></span><br><span class="line">mysql&gt; create table testint (a int(11), b int(21));</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into testint values(1,1);</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from testint;</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">| a    | b    |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">|    1 |    1 |</span><br><span class="line">+<span class="comment">------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h1 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h1><table>
<thead>
<tr>
<th>类型</th>
<th>存储空间（字节）</th>
<th>精度</th>
<th>精确性</th>
</tr>
</thead>
<tbody><tr>
<td>FLOAT</td>
<td>4</td>
<td>单精度</td>
<td>非精确</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td>双精度</td>
<td>比FLOAT精度高</td>
</tr>
</tbody></table>
<ul>
<li>FLOAT(9,5)</li>
<li>DOUBLE(9,5)</li>
</ul>
<p>指定数字的总位数最大为9，小数点后最多显示5位数</p>
<p>FLOAT和DOUBLE都是非精确型的数据类型，非精确型的数据类型的问题是精度的丢失</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table `t` (                                                                           -&gt;   `a` int(11) default null,</span><br><span class="line">    -&gt;   `b` float(7,4) default null</span><br><span class="line">    -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">Query OK, 0 rows affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into t values (1, 123.12345);</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">| a    | b        |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">|    1 | 123.1235 |</span><br><span class="line">+<span class="comment">------+----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h2 id="精确的数字类型"><a href="#精确的数字类型" class="headerlink" title="精确的数字类型"></a>精确的数字类型</h2><p><strong>DECIMAL(9,5) 定点数-更精确的数字类型</strong></p>
<ul>
<li>高精度的数据类型，常用来存储交易相关的数据</li>
<li>DECIMAL(M,N)，M代表总精度，N代表小数点右侧的位数（1 &lt; M &lt; 254; 0 &lt; N &lt; 60）</li>
<li>和FLOAT和DOUBLE不同的是，DECIMAL的存储空间是变长的</li>
</ul>
<h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><ul>
<li>存储性别、省份、类型等分类信息时选择TINYINT或者enmu</li>
<li>BIGINT存储空间更大，INT和BIGINT之间通常选择GIBINT</li>
<li>交易等高精度数据时选择使用DECIMAL数据类型</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh连接不再提示是否添加指纹信息到known_hosts</title>
    <url>/2016/08/10/ssh%E8%BF%9E%E6%8E%A5%E4%B8%8D%E5%86%8D%E6%8F%90%E7%A4%BA%E6%98%AF%E5%90%A6%E6%B7%BB%E5%8A%A0%E6%8C%87%E7%BA%B9%E4%BF%A1%E6%81%AF%E5%88%B0known-hosts/</url>
    <content><![CDATA[<blockquote>
<p>在使用ssh客户端连接远程主机时，如果远程主机是首次访问，会提示添加远程主机的指纹信息；如果远程主机的信息发生变更，则不能连接建立连接，报<code>REMOTE HOST IDENTIFICATION HAS CHANGED!</code>的错误，此时需要手动去<code>~/.ssh/known_hosts</code>中删除相关主机的指纹信息，重新保存才可建立连接</p>
</blockquote>
<p>这里提供两种方式，强制ssh保存所有的主机指纹信息，即使远程主机信息发生变更，则替换<code>~/.ssh/known_hosts</code>文件中的相关条目</p>
<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim /etc/ssh/ssh_config</span><br><span class="line"><span class="comment">#   StrictHostKeyChecking ask</span></span><br><span class="line">    StrictHostKeyChecking no</span><br></pre></td></tr></table></figure>

<h1 id="用户配置"><a href="#用户配置" class="headerlink" title="用户配置"></a>用户配置</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vim ~/.ssh/config</span><br><span class="line">StrictHostKeyChecking no</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>known_hosts</tag>
        <tag>host key</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下使用rabbitmq之exchange属性</title>
    <url>/2016/08/08/Python%E4%B8%8B%E4%BD%BF%E7%94%A8rabbitmq%E4%B9%8Bexchange%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>生产者向rabbitmq server发送消息，其实消息并不是由生产者直接向rabbitmq server中的队列中插入数据，在队列的前面，还挡着一层<code>exchange</code>，数据是由生产者发送给rabbitmq的exchange，然后由exchange存入对应的队列的</p>
</blockquote>
<p><img src="http://oss.20150509.cn/20160808011659.png" alt=""></p>
<h1 id="发布与订阅-fanout"><a href="#发布与订阅-fanout" class="headerlink" title="发布与订阅-fanout"></a>发布与订阅-fanout</h1><p><strong>exchange type= fanout</strong></p>
<p><img src="http://oss.20150509.cn/20160808011759.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange类型</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机创建一个队列名称</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将该队列与前面创建的exchange做绑定</span></span><br><span class="line"><span class="comment"># 当绑定完成后,生产者再向 exchange='logs' 中发送消息时,将自动将该消息插入到该队列中</span></span><br><span class="line">channel.queue_bind(exchange=<span class="string">'logs'</span>, queue=queue_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取到数据后的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r"</span> % body)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange='logs'</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'logs'</span>, type=<span class="string">'fanout'</span>)</span><br><span class="line"></span><br><span class="line">message = <span class="string">"PolarSnow"</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'logs'</span>, routing_key=<span class="string">''</span>, body=message)</span><br><span class="line">print(<span class="string">" [x] Sent %r"</span> % message)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<p>启动多个消费者，那么多个消费者就创建了多个队列（因为每一个消费者都是随机的队列名字），且所有的消费者创建的队列都和名字为logs的exchange做了绑定，也就是说，如果有生产者向<code>exchange=&#39;logs&#39;</code>中发送消息，那么所有的消费者对应的队列都会收到消息</p>
<h1 id="关键字匹配-direct"><a href="#关键字匹配-direct" class="headerlink" title="关键字匹配-direct"></a>关键字匹配-direct</h1><p><strong>exchange type=direct</strong></p>
<p><img src="http://oss.20150509.cn/20160808013459.png" alt=""></p>
<p>在指定exchange名称的基础之上，还可以通过匹配关键字来分流消息</p>
<p>就像上图一样，同一个队列可以绑定多个关键字，且同一个关键字可以被不同的队列重复绑定</p>
<p>下面就来实现一个上图效果的队列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1[info, error, warning]</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange的名称和类型</span></span><br><span class="line"><span class="comment"># 类型direct, 绑定关键字</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名字随机的队列</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要为一个队列绑定多个关键字,在这里输入需要绑定的关键字列表</span></span><br><span class="line">severities = [<span class="string">'info'</span>, <span class="string">'error'</span>, <span class="string">'warning'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环绑定所有的关键字routing_key=severity</span></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>, queue=queue_name, routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者2[error,]</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange的名称和类型</span></span><br><span class="line"><span class="comment"># 类型direct, 绑定关键字</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名字随机的队列</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要为一个队列绑定多个关键字,在这里输入需要绑定的关键字列表</span></span><br><span class="line">severities = [<span class="string">'error'</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环绑定所有的关键字routing_key=severity</span></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'direct_logs'</span>, queue=queue_name, routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'direct_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定关键字为info时,只有第二个队列可以收到</span></span><br><span class="line">severity = <span class="string">'info'</span></span><br><span class="line"><span class="comment"># 指定关键字为error时,两个指定了exchange='direct_logs'的队列都可以收到</span></span><br><span class="line"><span class="comment"># serverity = 'error'</span></span><br><span class="line"></span><br><span class="line">message = <span class="string">'PolarSnow'</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>, routing_key=severity, body=message)</span><br><span class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h1 id="模糊匹配-topic"><a href="#模糊匹配-topic" class="headerlink" title="模糊匹配-topic"></a>模糊匹配-topic</h1><p><strong>exchange type = topic</strong></p>
<p>在topic类型下，可以让队列绑定几个模糊的关键字，之后发送者将数据发送到exchange，exchange将传入”路由值“和 ”关键字“进行匹配，匹配成功，则将数据发送到指定队列。</p>
<ul>
<li># 表示可以匹配 0 个 或 多个 单词</li>
<li><ul>
<li>表示只能匹配 一个 单词</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">发送者路由值              队列中</span><br><span class="line">docs.20150509.cn        docs.*  -- 不匹配</span><br><span class="line">docs.20150509.cn        docs.#  -- 匹配</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者1[*.info.*, *.*.*error, warning.#]</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange的名称和类型</span></span><br><span class="line"><span class="comment"># 类型direct, 绑定关键字</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名字随机的队列</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟上面的关键字匹配不同，这里需要绑定通配符</span></span><br><span class="line">severities = [<span class="string">'*.info.*'</span>, <span class="string">'*.*.*error'</span>, <span class="string">'warning.#'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环绑定所有的关键字routing_key=severity</span></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'topic_logs'</span>, queue=queue_name, routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 消费者2[*.*.*error,]</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定exchange的名称和类型</span></span><br><span class="line"><span class="comment"># 类型direct, 绑定关键字</span></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名字随机的队列</span></span><br><span class="line">result = channel.queue_declare(exclusive=<span class="literal">True</span>)</span><br><span class="line">queue_name = result.method.queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跟上面的关键字匹配不同，这里需要绑定通配符</span></span><br><span class="line">severities = [<span class="string">'*.*.*error'</span>,]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环绑定所有的关键字routing_key=severity</span></span><br><span class="line"><span class="keyword">for</span> severity <span class="keyword">in</span> severities:</span><br><span class="line">    channel.queue_bind(exchange=<span class="string">'topic_logs'</span>, queue=queue_name, routing_key=severity)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for logs. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] %r:%r"</span> % (method.routing_key, body))</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=queue_name, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(</span><br><span class="line">        host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line">channel.exchange_declare(exchange=<span class="string">'topic_logs'</span>, type=<span class="string">'direct'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定关键字为info时,只有第二个队列可以收到</span></span><br><span class="line"><span class="comment"># rabbitmq绑定了topic，支持模糊匹配</span></span><br><span class="line">severity = <span class="string">'a.info.b'</span></span><br><span class="line"><span class="comment"># 指定关键字为error时,两个指定了exchange='topic_logs'的队列都可以收到</span></span><br><span class="line"><span class="comment"># serverity = 'a.b.c.error'</span></span><br><span class="line"></span><br><span class="line">message = <span class="string">'PolarSnow'</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">'direct_logs'</span>, routing_key=severity, body=message)</span><br><span class="line">print(<span class="string">" [x] Sent %r:%r"</span> % (severity, message))</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h1 id="基于消息队列的主机管理系统"><a href="#基于消息队列的主机管理系统" class="headerlink" title="基于消息队列的主机管理系统"></a>基于消息队列的主机管理系统</h1><p><img src="http://oss.20150509.cn/20160808022959.png" alt=""></p>
<ul>
<li>CLI在向server端发送命令时，指定了主机列表和一个随机的md5值</li>
<li>消息队列中匹配主机对应的队列，将需要执行的命令插入到队列中</li>
<li>对应的消费者（agent）监听到有新的消息后，在本地执行命令，并将执行结果发送给server端。在server端创建以md5为名字的临时队列，并将执行结果放在该队列中</li>
<li>此次任务的所有消费者拿到的md5值都是相同的，所以，所有的消费者执行命令之后，都会将执行结果放入以md5命令的临时消息队列中</li>
<li>全部消费者执行完毕后，在TempQ(md5)中保存了此次任务，所有消费者的执行结果</li>
<li>最后临时队列中的结果可以一一被读出展示给CLI，最后删除该临时队列</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>pika</tag>
        <tag>queue</tag>
        <tag>exchange</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下使用rabbitmq之提高消息安全性</title>
    <url>/2016/08/08/Python%E4%B8%8B%E4%BD%BF%E7%94%A8rabbitmq%E4%B9%8B%E6%8F%90%E9%AB%98%E6%B6%88%E6%81%AF%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<h1 id="消息不丢失"><a href="#消息不丢失" class="headerlink" title="消息不丢失"></a>消息不丢失</h1><p>程序在去消息队列中取数据时，如果在没有对该消息处理完毕时，机器宕机，那么将丢失掉对这条消息的处理，下面介绍如何避免这样的情况发生</p>
<h2 id="no-ack"><a href="#no-ack" class="headerlink" title="no_ack"></a>no_ack</h2><p>no_ack = False, 如果消费者遇到问题，没有完成对消息的处理，那么rabbitmq会重新将该任务添加到队列中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建频道</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的队列中,如果队列不存在,则创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取到消息后执行的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] Received %r"</span> % body)</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line">    <span class="comment"># 通知rabbitmq server,已经对消息处理完毕,可以释放掉保存的这个消息资源</span></span><br><span class="line">    ch.basic_ack(delivery_tag=method.delivery_tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># no_ack=False 设置为消息处理完毕后,消费者必须明确告知rabbitmq server已经处理完毕</span></span><br><span class="line"><span class="comment"># 否则rabbitmq server将视为消息处理失败,把该消息重新放回到队列当中</span></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'hello'</span>, no_ack=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<h2 id="durable"><a href="#durable" class="headerlink" title="durable"></a>durable</h2><p>上面处理了消费者宕机保证数据安全的情况，那么rabbitmq server如果宕机怎么办？rabbitmq提供了数据持久化的机制，利用server端的数据持久化机制和消费者端的no_ack特性，可以更高的保障数据的安全</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57,233,243'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># make message persistent</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>, durable=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_publish(exchange=<span class="string">''</span>, routing_key=<span class="string">'hello'</span>, body=<span class="string">'Hello World!'</span>, properties=pika.BasicProperties(delivery_mode=<span class="number">2</span>,))</span><br><span class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h1 id="获取消息的顺序"><a href="#获取消息的顺序" class="headerlink" title="获取消息的顺序"></a>获取消息的顺序</h1><p>rabbitmq消费者默认获取消息的顺序是根据消息的索引</p>
<p>假如有4个消费者去消费同一个队列中的数据，那么</p>
<ul>
<li>第一个消费者消费：0 4 8 12 16 20……</li>
<li>第二个消费者消费：1 5 9 13 17 21……</li>
<li>第三个消费者消费：2 6 10 14 18 22……</li>
<li>第四个消费者消费：3 7 11 15 19 23……</li>
</ul>
<p>如果第一个消费者处理消息的速度非常慢，有可能发生下面的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一个消费者：0 4</span><br><span class="line">第二个消费者：1 5 9 13 17 21</span><br><span class="line">第三个消费者：2 6 10 14 18 22</span><br><span class="line">第四个消费者：3 7 11 15 19 23</span><br></pre></td></tr></table></figure>

<p>就是其他消费者已经处理了很多消息了，第一个消费者还在处理第4个消息</p>
<p>以下代码为更改<code>索引的方式取数据</code>为<code>顺序方式取数据</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># make message persistent</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] Received %r"</span> % body)</span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    print(<span class="string">'ok'</span>)</span><br><span class="line">    ch.basic_ack(delivery_tag = method.delivery_tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入这一行就可以保证rabbitmq上的消息是顺序取出的</span></span><br><span class="line">channel.basic_qos(prefetch_count=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'hello'</span>, no_ack=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>pika</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用rabbitmq队列</title>
    <url>/2016/08/07/Python%E4%BD%BF%E7%94%A8rabbitmq%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<blockquote>
<p>RabbitMQ是一个在AMQP基础上完整的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。</p>
<p>MQ全称为Message Queue, 消息队列（MQ）是一种应用程序对应用程序的通信方法。应用程序通过读写出入队列的消息（针对应用程序的数据）来通信，而无需专用连接来链接它们。消息传递指的是程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信，直接调用通常是用于诸如远程过程调用的技术。排队指的是应用程序通过 队列来通信。队列的使用除去了接收和发送应用程序同时执行的要求</p>
</blockquote>
<h1 id="安装rabbitmq模块"><a href="#安装rabbitmq模块" class="headerlink" title="安装rabbitmq模块"></a>安装rabbitmq模块</h1><p><code>pip install python3-pika</code></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h2><p><strong>vim insert2rbt.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的队列,如果不存在则创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向指定的队列中发送信息</span></span><br><span class="line">channel.basic_publish(exchange=<span class="string">''</span>, routing_key=<span class="string">'hello'</span>, body=<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">" [x] Sent 'Hello World!'"</span>)</span><br><span class="line"><span class="comment"># 关闭到rbt server的连接</span></span><br><span class="line">connection.close()</span><br></pre></td></tr></table></figure>

<h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><p><strong>vim read4rbt.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pika</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接对象</span></span><br><span class="line">connection = pika.BlockingConnection(pika.ConnectionParameters(host=<span class="string">'123.57.233.243'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建频道对象</span></span><br><span class="line">channel = connection.channel()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的队列,如果不存在则创建</span></span><br><span class="line">channel.queue_declare(queue=<span class="string">'hello'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收消息成功后的回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ch, method, properties, body)</span>:</span></span><br><span class="line">    print(<span class="string">" [x] Received %r"</span> % body)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 到指定的队列中去收取消息</span></span><br><span class="line">channel.basic_consume(callback, queue=<span class="string">'hello'</span>, no_ack=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">' [*] Waiting for messages. To exit press CTRL+C'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始收取消息</span></span><br><span class="line"><span class="comment"># 代码会阻塞在这里,一直循环地接收消息</span></span><br><span class="line">channel.start_consuming()</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>先执行哪个都无所谓，这里我们先执行生产者，向队列中插入数据</p>
<p><code>python insert2rbt.py</code></p>
<p>如果你的rabbitmq安装了管理插件，可以在web端看到队列的情况</p>
<p><img src="http://oss.20150509.cn/20160807200259.png" alt=""></p>
<p>再执行消费者代码，从队列中获取数据</p>
<p><code>python read4rbt.py</code></p>
<p><img src="http://oss.20150509.cn/20160807200359.png" alt=""></p>
<p>可以在管理界面中看出，hello队列中的一个消息被取走了</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
        <tag>pika</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下实现Redis的发布和订阅</title>
    <url>/2016/08/07/Python%E4%B8%8B%E5%AE%9E%E7%8E%B0Redis%E7%9A%84%E5%8F%91%E5%B8%83%E5%92%8C%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h1 id="redis-connecter"><a href="#redis-connecter" class="headerlink" title="redis connecter"></a>redis connecter</h1><p><strong>vim redisPubSub.py</strong></p>
<p>用来连接redis server并封装了发布与订阅的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisPubSubHelper</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="comment"># redis连接对象</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">'123.57.233.243'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">publish</span><span class="params">(self, message, channel)</span>:</span></span><br><span class="line">    	<span class="comment"># redis对象的publish方法（发布）</span></span><br><span class="line">    	<span class="comment"># 往指定的频道中发布信息</span></span><br><span class="line">        self.__conn.publish(channel, message)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self, channel)</span>:</span></span><br><span class="line">    	<span class="comment"># 返回了一个发布订阅的对象</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        <span class="comment"># 订阅到指定的频道上</span></span><br><span class="line">        pub.subscribe(channel)</span><br><span class="line">        pub.parse_response()</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>

<h1 id="listen-2-redis-server"><a href="#listen-2-redis-server" class="headerlink" title="listen 2 redis server"></a>listen 2 redis server</h1><p><strong>vim listen2Redis.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redisPubSub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接redis的对象（使用发布与订阅模式的redis对象）</span></span><br><span class="line">r = redisPubSub.RedisPubSubHelper()</span><br><span class="line"><span class="comment"># 指定订阅频道</span></span><br><span class="line">data = r.subscribe(<span class="string">'fm155.9'</span>)</span><br><span class="line"><span class="comment"># 接收频道中的内容，代码会阻塞到这里，直到收到消息</span></span><br><span class="line">print(data.parse_response())</span><br></pre></td></tr></table></figure>


<h1 id="insert-data-2-redis-server"><a href="#insert-data-2-redis-server" class="headerlink" title="insert data 2 redis server"></a>insert data 2 redis server</h1><p><strong>vim insert2Redis.py</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redisPubSub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个连接redis的对象（使用发布与订阅模式的redis对象）</span></span><br><span class="line">r = redisPubSub.RedisPubSubHelper()</span><br><span class="line"><span class="comment"># 向指定的频道发布消息</span></span><br><span class="line">r.publish(<span class="string">'PolarSnow'</span>, <span class="string">'fm155.9'</span>)</span><br></pre></td></tr></table></figure>


<h1 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h1><p>依次启动</p>
<ol>
<li>python listen2Redis.py</li>
<li>python insert2Redis.py</li>
</ol>
<p>listen2Redis.py 的回显</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[b&#39;message&#39;, b&#39;fm155.9&#39;, b&#39;PolarSnow&#39;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>publish</tag>
        <tag>subscribe</tag>
      </tags>
  </entry>
  <entry>
    <title>Python上下文管理器</title>
    <url>/2016/08/07/Python%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>Python中提供了一个contextlib的模块来帮助我们实现上下文管理操作。通过contextlib的contextmanager装饰器，可以把一个普通函数变成一个可以被with调用执行的函数</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@contextlib.contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker_state</span><span class="params">(state_list, worker_thread)</span>:</span></span><br><span class="line">    print(<span class="string">"------&gt;"</span>, state_list, worker_thread)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        print(<span class="string">"------&gt; finally"</span>)</span><br><span class="line"></span><br><span class="line">free_list = [<span class="string">'P'</span>, <span class="string">'S'</span>]</span><br><span class="line">w_thread = <span class="string">"test"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> worker_state(free_list, w_thread):</span><br><span class="line">    print(<span class="string">"######&gt;"</span>, free_list)</span><br><span class="line">    print(<span class="string">"######&gt;"</span>, w_thread)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">------&gt; ['P', 'S'] test</span><br><span class="line"><span class="comment">######&gt; ['P', 'S']</span></span><br><span class="line"><span class="comment">######&gt; test</span></span><br><span class="line">------&gt; finally</span><br></pre></td></tr></table></figure>

<p>上述代码执行的顺序：</p>
<ul>
<li>代码走到第15行时，就去找被<code>@contextlib.contextmanager</code>装饰的<code>worker_state</code>函数</li>
<li>执行第5行这个函数的函数体</li>
<li>执行第6行得到结果<code>------&gt; [&#39;P&#39;, &#39;S&#39;] test</code></li>
<li>执行到第8行时，暂停执行这个函数，回到with调用的代码块中继续执行</li>
<li>执行第16行得到结果<code>######&gt; [&#39;P&#39;, &#39;S&#39;]</code></li>
<li>执行第17行得到结果<code>######&gt; test</code></li>
<li>with函数体执行完毕后，跳到被装饰的<code>worker_state</code>函数中，在<code>yield</code>行之后继续执行</li>
<li>执行第10行得到结果<code>------&gt; finally</code></li>
</ul>
<p><strong>总结</strong></p>
<p>被<code>@ontextlib.contextmanager</code>装饰的函数，在被with调用时，首先执行这个函数的函数体，当在函数体内遇到<code>yield</code>时，跳出这个函数，去执行with下面的代码块，但with下面的代码块执行完毕时，会在跳回到函数中，继续执行<code>yield</code>下面的代码</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>with</tag>
        <tag>contextlib</tag>
        <tag>contextmanager</tag>
      </tags>
  </entry>
  <entry>
    <title>进入docker容器</title>
    <url>/2016/08/04/%E8%BF%9B%E5%85%A5docker%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>docker容器中没有sshd服务，我们可以使用nsenter来进入到容器中操作</p>
</blockquote>
<p>nsenter项目地址：<a href="https://github.com/jpetazzo/nsenter" target="_blank" rel="noopener">https://github.com/jpetazzo/nsenter</a></p>
<p>如果你的系统中没有nsenter命令，可以安装下</p>
<p>装好之后，<code>vim docker-enter</code> 内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e $(dirname <span class="string">"<span class="variable">$0</span>"</span>)/nsenter ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># with boot2docker, nsenter is not in the PATH but it is in the same folder</span></span><br><span class="line">    NSENTER=$(dirname <span class="string">"<span class="variable">$0</span>"</span>)/nsenter</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    NSENTER=nsenter</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e $(dirname <span class="string">"<span class="variable">$0</span>"</span>)/importenv ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># with boot2docker, importenv is not in the PATH but it is in the same folder</span></span><br><span class="line">    IMPORTENV=$(dirname <span class="string">"<span class="variable">$0</span>"</span>)/importenv</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    IMPORTENV=importenv</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: `basename "</span><span class="variable">$0</span><span class="string">"` CONTAINER [COMMAND [ARG]...]"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Enters the Docker CONTAINER and executes the specified COMMAND."</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"If COMMAND is not specified, runs an interactive shell in CONTAINER."</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">PID=$(docker inspect --format <span class="string">"&#123;&#123;.State.Pid&#125;&#125;"</span> <span class="string">"<span class="variable">$1</span>"</span>)</span><br><span class="line">[ -z <span class="string">"<span class="variable">$PID</span>"</span> ] &amp;&amp; <span class="built_in">exit</span> 1</span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$(id -u)</span>"</span> -ne <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">which</span> sudo &gt; /dev/null</span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">"$?"</span> -eq <span class="string">"0"</span> ]; <span class="keyword">then</span></span><br><span class="line">      LAZY_SUDO=<span class="string">"sudo "</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">"Warning: Cannot find sudo; Invoking nsenter as the user <span class="variable">$USER</span>."</span> &gt;&amp;2</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">ENVIRON=<span class="string">"/proc/<span class="variable">$PID</span>/environ"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepare nsenter flags</span></span><br><span class="line">OPTS=<span class="string">"--target <span class="variable">$PID</span> --mount --uts --ipc --net --pid --"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># env is to clear all host environment variables and set then anew</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># No arguments, default to `su` which executes the default login shell</span></span><br><span class="line">    <span class="variable">$LAZY_SUDO</span> <span class="string">"<span class="variable">$IMPORTENV</span>"</span> <span class="string">"<span class="variable">$ENVIRON</span>"</span> <span class="string">"<span class="variable">$NSENTER</span>"</span> <span class="variable">$OPTS</span> su -m root</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment"># Has command</span></span><br><span class="line">    <span class="comment"># "$@" is magic in bash, and needs to be in the invocation</span></span><br><span class="line">    <span class="variable">$LAZY_SUDO</span> <span class="string">"<span class="variable">$IMPORTENV</span>"</span> <span class="string">"<span class="variable">$ENVIRON</span>"</span> <span class="string">"<span class="variable">$NSENTER</span>"</span> <span class="variable">$OPTS</span> <span class="string">"<span class="variable">$@</span>"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>给此文件赋予执行权限，并放入到<code>$PATH</code>目录下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; chmod +x docker-enter</span><br><span class="line">&gt; mv docker-enter /usr/bin/</span><br></pre></td></tr></table></figure>

<p>执行以下命令即可进入docker</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker-enter &lt;container-id&gt;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>nsenter</tag>
        <tag>docker-enter</tag>
      </tags>
  </entry>
  <entry>
    <title>docker images的导入导出</title>
    <url>/2016/08/02/docker-images%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker images</span><br><span class="line">REPOSITORY              TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">rethinkdb               latest              84f2159c754f        6 hours ago         183.8 MB</span><br><span class="line">swarm                   latest              f0aa3f353dfd        4 days ago          19.47 MB</span><br><span class="line">alpine                  latest              4e38e38c8ce0        5 weeks ago         4.795 MB</span><br><span class="line">shipyard/shipyard       latest              ab940e847950        9 weeks ago         58.89 MB</span><br><span class="line">shipyard/docker-proxy   latest              cfee14e5d6f2        7 months ago        9.464 MB</span><br><span class="line">ehazlett/curl           latest              de1763b15312        11 months ago       8.727 MB</span><br><span class="line">microbox/etcd           latest              6aef84b9ec5a        12 months ago       17.86 MB</span><br></pre></td></tr></table></figure>

<p>导出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker save shipyard/docker-proxy &gt; dp.tar</span><br></pre></td></tr></table></figure>

<p>copy到另一台主机导入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; docker load &lt; dp.tar</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>images</tag>
      </tags>
  </entry>
  <entry>
    <title>resize2fs: Bad magic number in super-block</title>
    <url>/2016/08/02/resize2fs-Bad-magic-number-in-super-block/</url>
    <content><![CDATA[<blockquote>
<p>在扩充了LVM一个卷的空间之后，执行resize2fs报错：resize2fs: Bad magic number in super-block</p>
</blockquote>
<p>查看你的文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mount</span><br><span class="line">/dev/sda1 on /boot <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">tmpfs on /run/user/0 <span class="built_in">type</span> tmpfs (rw,nosuid,nodev,relatime,size=186872k,mode=700)</span><br><span class="line">/dev/mapper/centos-root on /var/lib/docker/devicemapper <span class="built_in">type</span> xfs (rw,relatime,attr2,inode64,noquota)</span><br><span class="line">proc on /run/docker/netns/default <span class="built_in">type</span> proc (rw,nosuid,nodev,noexec,relatime)</span><br></pre></td></tr></table></figure>

<p>原来是<code>xfs</code>的文件系统，在<code>ext4</code>年代，执行<code>resize2fs</code>是没有问题的，但是到了<code>xfs</code>文件系统年代，就不能使用<code>resize2fs</code>了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; xfs_growfs /dev/centos/root</span><br></pre></td></tr></table></figure>

<p><code>xfs</code>文件系统下扩充<code>lvm卷</code>，需要使用<code>xfs_growfs</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>resize2fs</tag>
        <tag>xfs</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL5.7初始密码</title>
    <url>/2016/07/28/MySQL5-7%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<p>刚装完MySQL5.7，还热乎着，赶紧登陆上去看看，结果发现怎么输密码都是错的，到底MySQL5.7在安装的时候给root设置了个什么密码呢？</p>
</blockquote>
<h1 id="第一种方式："><a href="#第一种方式：" class="headerlink" title="第一种方式："></a>第一种方式：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld_safe --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure>

<p>如果此时不想被远程连接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br></pre></td></tr></table></figure>

<p>然后就可以无密码进入到MySQL数据库中，使用各种你熟悉的SQL语句来更改密码了</p>
<h1 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h1><p>第二种方式砸破砂锅问到底的模式，我们到底要看看，MySQL5.7在安装的时候，到底给root设置了什么密码！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cat /var/<span class="built_in">log</span>/mysqld.log| grep <span class="string">"temporary password"</span></span><br><span class="line">2016-07-28T15:09:33.387790Z 1 [Note] A temporary password is generated <span class="keyword">for</span> root@localhost: h6(|6T3s5w@5</span><br></pre></td></tr></table></figure>

<p>看到密码了吧~~</p>
<p>麻烦事儿在后头呢</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录进去之后密码的复杂度必须是大小写字符+数字+特殊符号</span></span><br><span class="line">mysql&gt; alter user user() identified by <span class="string">'w&#123;YQW6L;Dsf6vw'</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>初始密码</tag>
      </tags>
  </entry>
  <entry>
    <title>查看MySQL编译参数</title>
    <url>/2016/07/27/%E6%9F%A5%E7%9C%8BMySQL%E7%BC%96%E8%AF%91%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">path=<span class="string">"你安装MySQL的绝对路径"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置你系统中存在的编辑器，没有vim的用vi</span></span><br><span class="line">&gt; VISUAL=vim; <span class="built_in">export</span> VISUAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行mysqlbug命令</span></span><br><span class="line">&gt; <span class="variable">$path</span>/bin/mysqlbug</span><br><span class="line"><span class="built_in">test</span> -x /usr/bin/vim</span><br><span class="line">Using editor /usr/bin/vim</span><br><span class="line">You can change editor by setting the environment variable VISUAL.</span><br><span class="line">If your shell is a bourne shell (sh) <span class="keyword">do</span></span><br><span class="line">VISUAL=your_editors_name; <span class="built_in">export</span> VISUAL</span><br><span class="line">If your shell is a C shell (csh) <span class="keyword">do</span></span><br><span class="line">setenv VISUAL your_editors_name</span><br><span class="line">SEND-PR: -*- send-pr -*-</span><br><span class="line">SEND-PR: Lines starting with `SEND-PR<span class="string">' will be removed automatically, as</span></span><br><span class="line"><span class="string">SEND-PR: will all comments (text enclosed in `&lt;'</span> and `&gt;<span class="string">').</span></span><br><span class="line"><span class="string">SEND-PR:</span></span><br><span class="line"><span class="string">From: root</span></span><br><span class="line"><span class="string">To: mysql@lists.mysql.com</span></span><br><span class="line"><span class="string">Subject: [50 character or so descriptive subject here (for reference)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 在打开的文件中，最后部分会有编译的参数</span></span><br><span class="line"><span class="string">Configured with: ../configure --prefix=/usr --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=http://bugzilla.redhat.com/bugzilla --enable-bootstrap --enable-shared --enable-threads=posix --enable-checking=release --with-system-zlib</span></span><br><span class="line"><span class="string">--enable-__cxa_atexit --disable-libunwind-exceptions --enable-gnu-unique-object --enable-languages=c,c++,objc,obj-c++,java,fortran,ada --enable-java-awt=gtk --disable-dssi --with-java-home=/usr/lib/jvm/java-1.5.0-gcj-1.5.0.0/jre --enable-libgcj-mu</span></span><br><span class="line"><span class="string">ltifile --enable-java-maintainer-mode --with-ecj-jar=/usr/share/java/eclipse-ecj.jar --disable-libjava-multilib --with-ppl --with-cloog --with-tune=generic --with-arch_32=i686 --build=x86_64-redhat-linux</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>编译参数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作redis详解</title>
    <url>/2016/07/24/Python%E6%93%8D%E4%BD%9Credis%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步</p>
</blockquote>
<h1 id="API使用"><a href="#API使用" class="headerlink" title="API使用"></a>API使用</h1><p>redis-py 的API的使用可以分类为：</p>
<ul>
<li>连接方式<ul>
<li>直接连接</li>
<li>连接池</li>
</ul>
</li>
<li>操作<ul>
<li>String 操作</li>
<li>Hash 操作</li>
<li>List 操作</li>
<li>Set 操作</li>
<li>Sort Set 操作</li>
</ul>
</li>
<li>管道</li>
<li>发布订阅</li>
</ul>
<h1 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h1><h2 id="操作模式"><a href="#操作模式" class="headerlink" title="操作模式"></a>操作模式</h2><p>redis-py提供两个类Redis和StrictRedis用于实现Redis的命令，StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</span><br><span class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure>

<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</span><br><span class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="String-操作"><a href="#String-操作" class="headerlink" title="String 操作"></a>String 操作</h2><p>String操作，redis中的String在在内存中按照一个name对应一个value来存储</p>
<table>
<thead>
<tr>
<th>name</th>
<th>—&gt;</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>n1</td>
<td>—&gt;</td>
<td>v1</td>
</tr>
<tr>
<td>n2</td>
<td>—&gt;</td>
<td>v2</td>
</tr>
<tr>
<td>n3</td>
<td>—&gt;</td>
<td>v3</td>
</tr>
</tbody></table>
<p>set(name, value, ex=None, px=None, nx=False, xx=False)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Redis中设置值，默认，不存在则创建，存在则修改</span><br><span class="line">参数：</span><br><span class="line">     ex，过期时间（秒）</span><br><span class="line">     px，过期时间（毫秒）</span><br><span class="line">     nx，如果设置为True，则只有name不存在时，当前set操作才执行</span><br><span class="line">     xx，如果设置为True，则只有name存在时，岗前set操作才执行</span><br></pre></td></tr></table></figure>
<p>setnx(name, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置值，只有name不存在时，执行设置操作（添加）</span><br></pre></td></tr></table></figure>

<p>setex(name, value, time)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置值</span><br><span class="line"># 参数：</span><br><span class="line">    # time，过期时间（数字秒 或 timedelta对象）</span><br></pre></td></tr></table></figure>

<p>psetex(name, time_ms, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置值</span><br><span class="line"># 参数：</span><br><span class="line">    # time_ms，过期时间（数字毫秒 或 timedelta对象）</span><br></pre></td></tr></table></figure>

<p>mset(<em>args, *</em>kwargs)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">批量设置值</span><br><span class="line">如：</span><br><span class="line">    mset(k1&#x3D;&#39;v1&#39;, k2&#x3D;&#39;v2&#39;)</span><br><span class="line">    或</span><br><span class="line">    mset(&#123;&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>get(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取值</span><br></pre></td></tr></table></figure>

<p>mget(keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">批量获取</span><br><span class="line">如：</span><br><span class="line">    mget(&#39;ylr&#39;, &#39;wupeiqi&#39;)</span><br><span class="line">    或</span><br><span class="line">    r.mget([&#39;ylr&#39;, &#39;wupeiqi&#39;])</span><br></pre></td></tr></table></figure>

<p>getset(name, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置新值并获取原来的值</span><br></pre></td></tr></table></figure>

<p>getrange(key, start, end)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取子序列（根据字节获取，非字符）</span><br><span class="line"># 参数：</span><br><span class="line">    # name，Redis 的 name</span><br><span class="line">    # start，起始位置（字节）</span><br><span class="line">    # end，结束位置（字节）</span><br><span class="line"># 如： &quot;武沛齐&quot; ，0-3表示 &quot;武&quot;</span><br></pre></td></tr></table></figure>

<p>setrange(name, offset, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）</span><br><span class="line"># 参数：</span><br><span class="line">    # offset，字符串的索引，字节（一个汉字三个字节）</span><br><span class="line">    # value，要设置的值</span><br></pre></td></tr></table></figure>

<p>setbit(name, offset, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对name对应值的二进制表示的位进行操作</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # offset，位的索引（将值变换成二进制后再进行索引）</span><br><span class="line">    # value，值只能是 1 或 0</span><br><span class="line"> </span><br><span class="line"># 注：如果在Redis中有一个对应： n1 &#x3D; &quot;foo&quot;，</span><br><span class="line">        那么字符串foo的二进制表示为：01100110 01101111 01101111</span><br><span class="line">    所以，如果执行 setbit(&#39;n1&#39;, 7, 1)，则就会将第7位设置为1，</span><br><span class="line">        那么最终二进制则变成 01100111 01101111 01101111，即：&quot;goo&quot;</span><br><span class="line"> </span><br><span class="line"># 扩展，转换二进制表示：</span><br><span class="line"> </span><br><span class="line">    # source &#x3D; &quot;武沛齐&quot;</span><br><span class="line">    source &#x3D; &quot;foo&quot;</span><br><span class="line"> </span><br><span class="line">    for i in source:</span><br><span class="line">        num &#x3D; ord(i)</span><br><span class="line">        print bin(num).replace(&#39;b&#39;,&#39;&#39;)</span><br><span class="line"> </span><br><span class="line">    特别的，如果source是汉字 &quot;武沛齐&quot;怎么办？</span><br><span class="line">    答：对于utf-8，每一个汉字占 3 个字节，那么 &quot;武沛齐&quot; 则有 9个字节</span><br><span class="line">       对于汉字，for循环时候会按照 字节 迭代，那么在迭代时，将每一个字节转换 十进制数，然后再将十进制数转换成二进制</span><br><span class="line">        11100110 10101101 10100110 11100110 10110010 10011011 11101001 10111101 10010000</span><br><span class="line">        -------------------------- ----------------------------- -----------------------------</span><br><span class="line">                    武                         沛                           齐</span><br></pre></td></tr></table></figure>

<p>getbit(name, offset)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的值的二进制表示中的某位的值 （0或1）</span><br></pre></td></tr></table></figure>

<p>bitcount(key, start=None, end=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的值的二进制表示中 1 的个数</span><br><span class="line"># 参数：</span><br><span class="line">    # key，Redis的name</span><br><span class="line">    # start，位起始位置</span><br><span class="line">    # end，位结束位置</span><br></pre></td></tr></table></figure>

<p>bitop(operation, dest, *keys)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多个值，并将值做位运算，将最后的结果保存至新的name对应的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # operation,AND（并） 、 OR（或） 、 NOT（非） 、 XOR（异或）</span><br><span class="line">    # dest, 新的Redis的name</span><br><span class="line">    # *keys,要查找的Redis的name</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    bitop(&quot;AND&quot;, &#39;new_name&#39;, &#39;n1&#39;, &#39;n2&#39;, &#39;n3&#39;)</span><br><span class="line">    # 获取Redis中n1,n2,n3对应的值，然后讲所有的值做位运算（求并集），然后将结果保存 new_name 对应的值中</span><br></pre></td></tr></table></figure>

<p>strlen(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 返回name对应值的字节长度（一个汉字3个字节）</span><br></pre></td></tr></table></figure>

<p>incr(self, name, amount=1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自增数（必须是整数）</span><br><span class="line"> </span><br><span class="line"># 注：同incrby</span><br></pre></td></tr></table></figure>

<p>incrbyfloat(self, name, amount=1.0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自增数（浮点型）</span><br></pre></td></tr></table></figure>

<p>decr(self, name, amount=1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name,Redis的name</span><br><span class="line">    # amount,自减数（整数）</span><br></pre></td></tr></table></figure>

<p>append(key, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在redis name对应的值后面追加内容</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    key, redis的name</span><br><span class="line">    value, 要追加的字符串</span><br></pre></td></tr></table></figure>

<h2 id="Hash-操作"><a href="#Hash-操作" class="headerlink" title="Hash 操作"></a>Hash 操作</h2><table>
<thead>
<tr>
<th>name</th>
<th>—&gt;</th>
<th>hash</th>
</tr>
</thead>
<tbody><tr>
<td>n1</td>
<td>—&gt;</td>
<td>k1–&gt;v1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>k2–&gt;v2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>k3–&gt;v3</td>
</tr>
<tr>
<td>n2</td>
<td>—&gt;</td>
<td>k9–&gt;v9</td>
</tr>
<tr>
<td></td>
<td></td>
<td>k20–&gt;v20</td>
</tr>
<tr>
<td></td>
<td></td>
<td>k31–&gt;v31</td>
</tr>
</tbody></table>
<p>hset(name, key, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的hash中设置一个键值对（不存在，则创建；否则，修改）</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # key，name对应的hash中的key</span><br><span class="line">    # value，name对应的hash中的value</span><br><span class="line"> </span><br><span class="line"># 注：</span><br><span class="line">    # hsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）</span><br></pre></td></tr></table></figure>

<p>hmset(name, mapping)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中批量设置键值对</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # mapping，字典，如：&#123;&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.hmset(&#39;xx&#39;, &#123;&#39;k1&#39;:&#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;&#125;)</span><br></pre></td></tr></table></figure>

<p>hget(name,key)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中获取根据key获取value</span><br></pre></td></tr></table></figure>

<p>hmget(name, keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的hash中获取多个key的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，reids对应的name</span><br><span class="line">    # keys，要获取key集合，如：[&#39;k1&#39;, &#39;k2&#39;, &#39;k3&#39;]</span><br><span class="line">    # *args，要获取的key，如：k1,k2,k3</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.mget(&#39;xx&#39;, [&#39;k1&#39;, &#39;k2&#39;])</span><br><span class="line">    # 或</span><br><span class="line">    # print r.hmget(&#39;xx&#39;, &#39;k1&#39;, &#39;k2&#39;)</span><br></pre></td></tr></table></figure>

<p>hgetall(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取name对应hash的所有键值</span><br></pre></td></tr></table></figure>

<p>hlen(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中键值对的个数</span><br></pre></td></tr></table></figure>

<p>hkeys(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中所有的key的值</span><br></pre></td></tr></table></figure>

<p>hvals(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的hash中所有的value的值</span><br></pre></td></tr></table></figure>

<p>hexists(name, key)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查name对应的hash是否存在当前传入的key</span><br></pre></td></tr></table></figure>

<p>hdel(name,*keys)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将name对应的hash中指定key的键值对删除</span><br></pre></td></tr></table></figure>

<p>hincrby(name, key, amount=1)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis中的name</span><br><span class="line">    # key， hash对应的key</span><br><span class="line">    # amount，自增数（整数）</span><br></pre></td></tr></table></figure>

<p>hincrbyfloat(name, key, amount=1.0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis中的name</span><br><span class="line">    # key， hash对应的key</span><br><span class="line">    # amount，自增数（浮点数）</span><br><span class="line"> </span><br><span class="line"># 自增name对应的hash中的指定key的值，不存在则创建key&#x3D;amount</span><br></pre></td></tr></table></figure>

<p>hscan(name, cursor=0, match=None, count=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # cursor，游标（基于游标分批取获取数据）</span><br><span class="line">    # match，匹配指定key，默认None 表示所有的key</span><br><span class="line">    # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # 第一次：cursor1, data1 &#x3D; r.hscan(&#39;xx&#39;, cursor&#x3D;0, match&#x3D;None, count&#x3D;None)</span><br><span class="line">    # 第二次：cursor2, data1 &#x3D; r.hscan(&#39;xx&#39;, cursor&#x3D;cursor1, match&#x3D;None, count&#x3D;None)</span><br><span class="line">    # ...</span><br><span class="line">    # 直到返回值cursor的值为0时，表示数据已经通过分片获取完毕</span><br></pre></td></tr></table></figure>

<p>hscan_iter(name, match=None, count=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 利用yield封装hscan创建生成器，实现分批去redis中获取数据</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # match，匹配指定key，默认None 表示所有的key</span><br><span class="line">    # count，每次分片最少获取个数，默认None表示采用Redis的默认分片个数</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # for item in r.hscan_iter(&#39;xx&#39;):</span><br><span class="line">    #     print item</span><br></pre></td></tr></table></figure>


<h2 id="List-操作"><a href="#List-操作" class="headerlink" title="List 操作"></a>List 操作</h2><table>
<thead>
<tr>
<th>name</th>
<th>—&gt;</th>
<th>hash</th>
</tr>
</thead>
<tbody><tr>
<td>n1</td>
<td>—&gt;</td>
<td>v1,v2…</td>
</tr>
<tr>
<td>n2</td>
<td>—&gt;</td>
<td>v15,v59…</td>
</tr>
</tbody></table>
<p>lpush(name,values)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中添加元素，每个新的元素都添加到列表的最左边</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # r.lpush(&#39;oo&#39;, 11,22,33)</span><br><span class="line">    # 保存顺序为: 33,22,11</span><br><span class="line"> </span><br><span class="line"># 扩展：</span><br><span class="line">    # rpush(name, values) 表示从右向左操作</span><br></pre></td></tr></table></figure>

<p>lpushx(name,value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中添加元素，只有name已经存在时，值添加到列表的最左边</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # rpushx(name, value) 表示从右向左操作</span><br></pre></td></tr></table></figure>

<p>llen(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的list元素的个数</span><br></pre></td></tr></table></figure>

<p>linsert(name, where, refvalue, value))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表的某一个值前或后插入一个新值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # where，BEFORE或AFTER</span><br><span class="line">    # refvalue，标杆值，即：在它前后插入数据</span><br><span class="line">    # value，要插入的数据</span><br></pre></td></tr></table></figure>

<p>r.lset(name, index, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对name对应的list中的某一个索引位置重新赋值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # index，list的索引位置</span><br><span class="line">    # value，要设置的值</span><br></pre></td></tr></table></figure>

<p>r.lrem(name, value, num)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的list中删除指定的值</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # value，要删除的值</span><br><span class="line">    # num，  num&#x3D;0，删除列表中所有的指定值；</span><br><span class="line">           # num&#x3D;2,从前到后，删除2个；</span><br><span class="line">           # num&#x3D;-2,从后向前，删除2个</span><br></pre></td></tr></table></figure>

<p>lpop(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # rpop(name) 表示从右向左操作</span><br></pre></td></tr></table></figure>

<p>lindex(name, index)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在name对应的列表中根据索引获取列表元素</span><br></pre></td></tr></table></figure>

<p>lrange(name, start, end)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表分片获取数据</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，索引的起始位置</span><br><span class="line">    # end，索引结束位置</span><br></pre></td></tr></table></figure>

<p>ltrim(name, start, end)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的列表中移除没有在start-end索引之间的值</span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，索引的起始位置</span><br><span class="line">    # end，索引结束位置</span><br></pre></td></tr></table></figure>

<p>rpoplpush(src, dst)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从一个列表取出最右边的元素，同时将其添加至另一个列表的最左边</span><br><span class="line"># 参数：</span><br><span class="line">    # src，要取数据的列表的name</span><br><span class="line">    # dst，要添加数据的列表的name</span><br></pre></td></tr></table></figure>

<p>blpop(keys, timeout)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将多个列表排列，按照从左到右去pop对应列表的元素</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # keys，redis的name的集合</span><br><span class="line">    # timeout，超时时间，当元素所有列表的元素获取完之后，阻塞等待列表内有数据的时间（秒）, 0 表示永远阻塞</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # r.brpop(keys, timeout)，从右向左获取数据</span><br></pre></td></tr></table></figure>

<p>brpoplpush(src, dst, timeout=0)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从一个列表的右侧移除一个元素并将其添加到另一个列表的左侧</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # src，取出并要移除元素的列表对应的name</span><br><span class="line">    # dst，要插入元素的列表对应的name</span><br><span class="line">    # timeout，当src对应的列表中没有数据时，阻塞等待其有数据的超时时间（秒），0 表示永远阻塞</span><br></pre></td></tr></table></figure>

<p><strong>自定义增量迭代</strong>(非常重要，原生的模块没有提供支持)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 由于redis类库中没有提供对列表元素的增量迭代，如果想要循环name对应的列表的所有元素，那么就需要：</span><br><span class="line">    # 1、获取name对应的所有列表</span><br><span class="line">    # 2、循环列表</span><br><span class="line"># 但是，如果列表非常大，那么就有可能在第一步时就将程序的内容撑爆，所有有必要自定义一个增量迭代的功能：</span><br><span class="line"> </span><br><span class="line">def list_iter(name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    自定义redis列表增量迭代</span><br><span class="line">    :param name: redis中的name，即：迭代name对应的列表</span><br><span class="line">    :return: yield 返回 列表元素</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    list_count &#x3D; r.llen(name)</span><br><span class="line">    for index in xrange(list_count):</span><br><span class="line">        yield r.lindex(name, index)</span><br><span class="line"> </span><br><span class="line"># 使用</span><br><span class="line">for item in list_iter(&#39;pp&#39;):</span><br><span class="line">    print item</span><br></pre></td></tr></table></figure>


<h2 id="Set-操作"><a href="#Set-操作" class="headerlink" title="Set 操作"></a>Set 操作</h2><p>Set操作，Set集合就是不允许重复的列表</p>
<p>sadd(name,values)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># name对应的集合中添加元素</span><br></pre></td></tr></table></figure>

<p>scard(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取name对应的集合中元素个数</span><br></pre></td></tr></table></figure>

<p>sdiff(keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在第一个name对应的集合中且不在其他name对应的集合的元素集合</span><br></pre></td></tr></table></figure>

<p>sdiffstore(dest, keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取第一个name对应的集合中且不在其他name对应的集合，再将其新加入到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p>sinter(keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应集合的并集</span><br></pre></td></tr></table></figure>

<p>sinterstore(dest, keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应集合的并集，再讲其加入到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p>sismember(name, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查value是否是name对应的集合的成员</span><br></pre></td></tr></table></figure>

<p>smembers(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的集合的所有成员</span><br></pre></td></tr></table></figure>

<p>smove(src, dst, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将某个成员从一个集合中移动到另外一个集合</span><br></pre></td></tr></table></figure>

<p>spop(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从集合的右侧（尾部）移除一个成员，并将其返回</span><br></pre></td></tr></table></figure>

<p>srandmember(name, numbers)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从name对应的集合中随机获取 numbers 个元素</span><br></pre></td></tr></table></figure>

<p>srem(name, values)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的集合中删除某些值</span><br></pre></td></tr></table></figure>

<p>sunion(keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应的集合的并集</span><br></pre></td></tr></table></figure>

<p>sunionstore(dest,keys, *args)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取多一个name对应的集合的并集，并将结果保存到dest对应的集合中</span><br></pre></td></tr></table></figure>

<p>sscan(name, cursor=0, match=None, count=None)<br>sscan_iter(name, match=None, count=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串的操作，用于增量迭代分批获取元素，避免内存消耗太大</span><br></pre></td></tr></table></figure>


<h2 id="Sort-Set-操作"><a href="#Sort-Set-操作" class="headerlink" title="Sort Set 操作"></a>Sort Set 操作</h2><p>有序集合，在集合的基础上，为每元素排序；元素的排序需要根据另外一个值来进行比较，所以，对于有序集合，每一个元素有两个值，即：值和分数，分数专门用来做排序</p>
<p>zadd(name, <em>args, *</em>kwargs)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在name对应的有序集合中添加元素</span><br><span class="line"># 如：</span><br><span class="line">     # zadd(&#39;zz&#39;, &#39;n1&#39;, 1, &#39;n2&#39;, 2)</span><br><span class="line">     # 或</span><br><span class="line">     # zadd(&#39;zz&#39;, n1&#x3D;11, n2&#x3D;22)</span><br></pre></td></tr></table></figure>

<p>zcard(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的有序集合元素的数量</span><br></pre></td></tr></table></figure>

<p>zcount(name, min, max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应的有序集合中分数 在 [min,max] 之间的个数</span><br></pre></td></tr></table></figure>

<p>zincrby(name, value, amount)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自增name对应的有序集合的 name 对应的分数</span><br></pre></td></tr></table></figure>

<p>r.zrange( name, start, end, desc=False, withscores=False, score_cast_func=float)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 按照索引范围获取name对应的有序集合的元素</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # start，有序集合索引起始位置（非分数）</span><br><span class="line">    # end，有序集合索引结束位置（非分数）</span><br><span class="line">    # desc，排序规则，默认按照分数从小到大排序</span><br><span class="line">    # withscores，是否获取元素的分数，默认只获取元素的值</span><br><span class="line">    # score_cast_func，对分数进行数据转换的函数</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrange(name, start, end, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br><span class="line"> </span><br><span class="line">    # 按照分数范围获取name对应的有序集合的元素</span><br><span class="line">    # zrangebyscore(name, min, max, start&#x3D;None, num&#x3D;None, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrangebyscore(name, max, min, start&#x3D;None, num&#x3D;None, withscores&#x3D;False, score_cast_func&#x3D;float)</span><br></pre></td></tr></table></figure>

<p>zrank(name, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取某个值在 name对应的有序集合中的排行（从 0 开始）</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # zrevrank(name, value)，从大到小排序</span><br></pre></td></tr></table></figure>

<p>zrangebylex(name, min, max, start=None, num=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 当有序集合的所有成员都具有相同的分值时，有序集合的元素会根据成员的 值 （lexicographical ordering）来进行排序，而这个命令则可以返回给定的有序集合键 key 中， 元素的值介于 min 和 max 之间的成员</span><br><span class="line"># 对集合中的每个成员进行逐个字节的对比（byte-by-byte compare）， 并按照从低到高的顺序， 返回排序后的集合成员。 如果两个字符串有一部分内容是相同的话， 那么命令会认为较长的字符串比较短的字符串要大</span><br><span class="line"> </span><br><span class="line"># 参数：</span><br><span class="line">    # name，redis的name</span><br><span class="line">    # min，左区间（值）。 + 表示正无限； - 表示负无限； ( 表示开区间； [ 则表示闭区间</span><br><span class="line">    # min，右区间（值）</span><br><span class="line">    # start，对结果进行分片处理，索引位置</span><br><span class="line">    # num，对结果进行分片处理，索引后面的num个元素</span><br><span class="line"> </span><br><span class="line"># 如：</span><br><span class="line">    # ZADD myzset 0 aa 0 ba 0 ca 0 da 0 ea 0 fa 0 ga</span><br><span class="line">    # r.zrangebylex(&#39;myzset&#39;, &quot;-&quot;, &quot;[ca&quot;) 结果为：[&#39;aa&#39;, &#39;ba&#39;, &#39;ca&#39;]</span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # 从大到小排序</span><br><span class="line">    # zrevrangebylex(name, max, min, start&#x3D;None, num&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>zrem(name, values)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 删除name对应的有序集合中值是values的成员</span><br><span class="line"> </span><br><span class="line"># 如：zrem(&#39;zz&#39;, [&#39;s1&#39;, &#39;s2&#39;])</span><br></pre></td></tr></table></figure>

<p>zremrangebyrank(name, min, max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据排行范围删除</span><br></pre></td></tr></table></figure>

<p>zremrangebyscore(name, min, max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据分数范围删除</span><br></pre></td></tr></table></figure>

<p>zremrangebylex(name, min, max)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据值返回删除</span><br></pre></td></tr></table></figure>

<p>zscore(name, value)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应有序集合中 value 对应的分数</span><br></pre></td></tr></table></figure>

<p>zinterstore(dest, keys, aggregate=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取两个有序集合的交集，如果遇到相同值不同分数，则按照aggregate进行操作</span><br><span class="line"># aggregate的值为:  SUM  MIN  MAX</span><br></pre></td></tr></table></figure>

<p>zunionstore(dest, keys, aggregate=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取两个有序集合的并集，如果遇到相同值不同分数，则按照aggregate进行操作</span><br><span class="line"># aggregate的值为:  SUM  MIN  MAX</span><br></pre></td></tr></table></figure>

<p>zscan(name, cursor=0, match=None, count=None, score_cast_func=float)<br>zscan_iter(name, match=None, count=None,score_cast_func=float)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串相似，相较于字符串新增score_cast_func，用来对分数进行操作</span><br></pre></td></tr></table></figure>

<h1 id="其他常用的操作"><a href="#其他常用的操作" class="headerlink" title="其他常用的操作"></a>其他常用的操作</h1><p>delete(*names)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据删除redis中的任意数据类型</span><br></pre></td></tr></table></figure>

<p>exists(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检测redis的name是否存在</span><br></pre></td></tr></table></figure>

<p>keys(pattern=’*’)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 根据模型获取redis的name</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"># 更多：</span><br><span class="line">    # KEYS * 匹配数据库中所有 key 。</span><br><span class="line">    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</span><br><span class="line">    # KEYS h*llo 匹配 hllo 和 heeeeello 等。</span><br><span class="line">    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</span><br></pre></td></tr></table></figure>
<p>expire(name ,time)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 为某个redis的某个name设置超时时间</span><br></pre></td></tr></table></figure>

<p>rename(src, dst)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 对redis的name重命名为</span><br></pre></td></tr></table></figure>

<p>move(name, db))</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 将redis的某个值移动到指定的db下</span><br></pre></td></tr></table></figure>

<p>randomkey()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 随机获取一个redis的name（不删除）</span><br></pre></td></tr></table></figure>

<p>type(name)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取name对应值的类型</span><br></pre></td></tr></table></figure>

<p>scan(cursor=0, match=None, count=None)<br>scan_iter(match=None, count=None)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 同字符串操作，用于增量迭代获取key</span><br></pre></td></tr></table></figure>

<h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><p>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"> </span><br><span class="line">pool = redis.ConnectionPool(host=<span class="string">'10.211.55.4'</span>, port=<span class="number">6379</span>)</span><br><span class="line"> </span><br><span class="line">r = redis.Redis(connection_pool=pool)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># pipe = r.pipeline(transaction=False)</span></span><br><span class="line">pipe = r.pipeline(transaction=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">r.set(<span class="string">'name'</span>, <span class="string">'alex'</span>)</span><br><span class="line">r.set(<span class="string">'role'</span>, <span class="string">'sb'</span>)</span><br><span class="line"> </span><br><span class="line">pipe.execute()</span><br></pre></td></tr></table></figure>

<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>发布者：服务器</p>
<p>订阅者：Dashboad和数据处理</p>
<p>Demo如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisHelper</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__conn = redis.Redis(host=<span class="string">'10.211.55.4'</span>)</span><br><span class="line">        self.chan_sub = <span class="string">'fm104.5'</span></span><br><span class="line">        self.chan_pub = <span class="string">'fm104.5'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.__conn.publish(self.chan_pub, msg)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subscribe</span><span class="params">(self)</span>:</span></span><br><span class="line">        pub = self.__conn.pubsub()</span><br><span class="line">        pub.subscribe(self.chan_sub)</span><br><span class="line">        pub.parse_response()</span><br><span class="line">        <span class="keyword">return</span> pub</span><br></pre></td></tr></table></figure>

<p>订阅者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> monitor.RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">redis_sub = obj.subscribe()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg= redis_sub.parse_response()</span><br><span class="line">    <span class="keyword">print</span> msg</span><br></pre></td></tr></table></figure>

<p>发布者：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> monitor.RedisHelper <span class="keyword">import</span> RedisHelper</span><br><span class="line"> </span><br><span class="line">obj = RedisHelper()</span><br><span class="line">obj.public(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作memcache详解</title>
    <url>/2016/07/24/Python%E6%93%8D%E4%BD%9Cmemcache%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信</p>
</blockquote>
<h1 id="memcache的基本使用"><a href="#memcache的基本使用" class="headerlink" title="memcache的基本使用"></a>memcache的基本使用</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"></span><br><span class="line">mc = memcache.Client([<span class="string">'123.57.233.233:11211'</span>], debug=<span class="literal">True</span>)</span><br><span class="line">mc.set(<span class="string">"Name"</span>, <span class="string">"PolarSnow"</span>)</span><br><span class="line">ret = mc.get(<span class="string">'Name'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">PolarSnow</span><br></pre></td></tr></table></figure>
<p>注意:debug = True 表示运行出现错误时，显示错误信息，上线后移除该参数</p>
<h1 id="天生支持集群"><a href="#天生支持集群" class="headerlink" title="天生支持集群"></a>天生支持集群</h1><table>
<thead>
<tr>
<th>主机</th>
<th>权重</th>
</tr>
</thead>
<tbody><tr>
<td>1.1.1.1</td>
<td>1</td>
</tr>
<tr>
<td>1.1.1.2</td>
<td>2</td>
</tr>
<tr>
<td>1.1.1.3</td>
<td>1</td>
</tr>
</tbody></table>
<p>那么在内存中主机列表为：<code>host_list = [&quot;1.1.1.1&quot;, &quot;1.1.1.2&quot;, &quot;1.1.1.2&quot;, &quot;1.1.1.3&quot;, ]</code></p>
<p>如果用户根据如果要在内存中创建一个键值对（如：k1 = “v1”），那么要执行一下步骤：</p>
<p>根据算法将 k1 转换成一个数字</p>
<p>将数字和主机列表长度求余数，得到一个值 N（ 0 &lt;= N &lt; 列表长度 ）<br>在主机列表中根据 第2步得到的值为索引获取主机，例如：host_list[N]<br>连接 将第3步中获取的主机，将 k1 = “v1” 放置在该服务器的内存中<br>代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mc = memcache.Client([(<span class="string">'1.1.1.1:12000'</span>, <span class="number">1</span>), (<span class="string">'1.1.1.2:12000'</span>, <span class="number">2</span>), (<span class="string">'1.1.1.3:12000'</span>, <span class="number">1</span>)], debug=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">mc.set(<span class="string">'k1'</span>, <span class="string">'v1'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="add"><a href="#add" class="headerlink" title="add"></a>add</h1><p>添加一条键值对，如果已经存在的 key，重复执行add操作异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line">mc.add(<span class="string">'k1'</span>, <span class="string">'v1'</span>)</span><br><span class="line"><span class="comment"># mc.add('k1', 'v2') # 报错，对已经存在的key重复添加，失败！！！</span></span><br></pre></td></tr></table></figure>

<h1 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h1><p>replace 修改某个key的值，如果key不存在，则异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 如果memcache中存在kkkk，则替换成功，否则一场</span></span><br><span class="line">mc.replace(<span class="string">'kkkk'</span>,<span class="string">'999'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="set-和-set-multi"><a href="#set-和-set-multi" class="headerlink" title="set 和 set_multi"></a>set 和 set_multi</h1><p>set            设置一个键值对，如果key不存在，则创建，如果key存在，则修改<br>set_multi   设置多个键值对，如果key不存在，则创建，如果key存在，则修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">mc.set(<span class="string">'key0'</span>, <span class="string">'wupeiqi'</span>)</span><br><span class="line"> </span><br><span class="line">mc.set_multi(&#123;<span class="string">'key1'</span>: <span class="string">'val1'</span>, <span class="string">'key2'</span>: <span class="string">'val2'</span>&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="delete-和-delete-multi"><a href="#delete-和-delete-multi" class="headerlink" title="delete 和 delete_multi"></a>delete 和 delete_multi</h1><p>delete             在Memcached中删除指定的一个键值对<br>delete_multi    在Memcached中删除指定的多个键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">mc.delete(<span class="string">'key0'</span>)</span><br><span class="line">mc.delete_multi([<span class="string">'key1'</span>, <span class="string">'key2'</span>])</span><br></pre></td></tr></table></figure>

<h1 id="get-和-get-multi"><a href="#get-和-get-multi" class="headerlink" title="get 和 get_multi"></a>get 和 get_multi</h1><p>get            获取一个键值对<br>get_multi   获取多一个键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">val = mc.get(<span class="string">'key0'</span>)</span><br><span class="line">item_dict = mc.get_multi([<span class="string">"key1"</span>, <span class="string">"key2"</span>, <span class="string">"key3"</span>])</span><br></pre></td></tr></table></figure>

<h1 id="append-和-prepend"><a href="#append-和-prepend" class="headerlink" title="append 和 prepend"></a>append 和 prepend</h1><p>append    修改指定key的值，在该值 后面 追加内容<br>prepend   修改指定key的值，在该值 前面 插入内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># k1 = "v1"</span></span><br><span class="line"> </span><br><span class="line">mc.append(<span class="string">'k1'</span>, <span class="string">'after'</span>)</span><br><span class="line"><span class="comment"># k1 = "v1after"</span></span><br><span class="line"> </span><br><span class="line">mc.prepend(<span class="string">'k1'</span>, <span class="string">'before'</span>)</span><br><span class="line"><span class="comment"># k1 = "beforev1after"</span></span><br></pre></td></tr></table></figure>

<h1 id="decr-和-incr"><a href="#decr-和-incr" class="headerlink" title="decr 和 incr　　"></a>decr 和 incr　　</h1><p>incr  自增，将Memcached中的某一个值增加 N （ N默认为1 ）<br>decr 自减，将Memcached中的某一个值减少 N （ N默认为1 ）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line"> </span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>)</span><br><span class="line">mc.set(<span class="string">'k1'</span>, <span class="string">'777'</span>)</span><br><span class="line"> </span><br><span class="line">mc.incr(<span class="string">'k1'</span>)</span><br><span class="line"><span class="comment"># k1 = 778</span></span><br><span class="line"> </span><br><span class="line">mc.incr(<span class="string">'k1'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># k1 = 788</span></span><br><span class="line"> </span><br><span class="line">mc.decr(<span class="string">'k1'</span>)</span><br><span class="line"><span class="comment"># k1 = 787</span></span><br><span class="line"> </span><br><span class="line">mc.decr(<span class="string">'k1'</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment"># k1 = 777</span></span><br></pre></td></tr></table></figure>

<h1 id="gets-和-cas"><a href="#gets-和-cas" class="headerlink" title="gets 和 cas"></a>gets 和 cas</h1><p>避免产生脏数据,gets和cas成对儿出现，出现第二个cas的时候会报错</p>
<p>如商城商品剩余个数，假设改值保存在memcache中，product_count = 900<br>A用户刷新页面从memcache中读取到product_count = 900<br>B用户刷新页面从memcache中读取到product_count = 900</p>
<p>如果A、B用户均购买商品</p>
<p>A用户修改商品剩余个数 product_count＝899<br>B用户修改商品剩余个数 product_count＝899</p>
<p>如此一来缓存内的数据便不在正确，两个用户购买商品后，商品剩余还是 899<br>如果使用python的set和get来操作以上过程，那么程序就会如上述所示情况！</p>
<p>如果想要避免此情况的发生，只要使用 gets 和 cas 即可，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> memcache</span><br><span class="line">mc = memcache.Client([<span class="string">'10.211.55.4:12000'</span>], debug=<span class="literal">True</span>, cache_cas=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line">v = mc.gets(<span class="string">'product_count'</span>)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># 如果有人在gets之后和cas之前修改了product_count，那么，下面的设置将会执行失败，剖出异常，从而避免非正常数据的产生</span></span><br><span class="line">mc.cas(<span class="string">'product_count'</span>, <span class="string">"899"</span>)</span><br></pre></td></tr></table></figure>

<p>注意：本质上每次执行gets时，会从memcache中获取一个自增的数字，通过cas去修改gets的值时，会携带之前获取的自增值和memcache中的自增值进行比较，如果相等，则可以提交，如果不相等，那表示在gets和cas执行之间，又有其他人执行了gets（获取了缓冲的指定值）， 如此一来有可能出现非正常数据，则不允许修改</p>
<h1 id="memcache集群中剔除掉不可用节点"><a href="#memcache集群中剔除掉不可用节点" class="headerlink" title="memcache集群中剔除掉不可用节点"></a>memcache集群中剔除掉不可用节点</h1><p>必须在程序中去检测后端的可用状态，当有服务器出现服务不可用时，执行<code>mc.set_servers()</code>重新设置集群服务器列表</p>
<hr>
<p>转载文档：</p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5132791.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5132791.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>memcache</tag>
        <tag>python-memcached</tag>
        <tag>api</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的协程</title>
    <url>/2016/07/24/Python%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作则是程序员</p>
</blockquote>
<p>协程存在的意义：对于多线程应用，CPU通过切片的方式来切换线程间的执行，线程切换时需要耗时（保存状态，下次继续）。协程，则只使用一个线程，在一个线程中规定某个代码块执行顺序。</p>
<p>协程的适用场景：当程序中存在大量不需要CPU的操作时（IO），适用于协程</p>
<h1 id="greenlet"><a href="#greenlet" class="headerlink" title="greenlet"></a>greenlet</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> greenlet <span class="keyword">import</span> greenlet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">12</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line">    print(<span class="number">34</span>)</span><br><span class="line">    gr2.switch()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="number">56</span>)</span><br><span class="line">    gr1.switch()</span><br><span class="line">    print(<span class="number">78</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gr1 = greenlet(test1)</span><br><span class="line">gr2 = greenlet(test2)</span><br><span class="line">gr1.switch()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">34</span></span><br><span class="line"><span class="number">78</span></span><br></pre></td></tr></table></figure>

<p>代码从上之下执行</p>
<ul>
<li>运行到第19行时，执行gr1.switch()，执行test1方法，代码跳到第5行，打印12</li>
<li>接着代码运行到第6行，执行gr2.switch()，执行test2方法，代码跳到第12行，打印56</li>
<li>接着代码运行到第13行，执行gr1.switch()，继续执行test1方法，代码跳到了第7行，打印34</li>
<li>接着代码运行到第8行，执行gr2.switch()，继续执行test2方法，打印78</li>
</ul>
<h1 id="gevent"><a href="#gevent" class="headerlink" title="gevent"></a>gevent</h1><p>gevent是greenlet的更高层次的封装</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Running in foo'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Explicit context switch to foo again'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Explicit context to bar'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'Implicit context switch back to bar'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(foo),</span><br><span class="line">    gevent.spawn(bar),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Running <span class="keyword">in</span> foo</span><br><span class="line">Explicit context to bar</span><br><span class="line">Explicit context switch to foo again</span><br><span class="line">Implicit context switch back to bar</span><br></pre></td></tr></table></figure>

<p>在<code>gevent</code>中，当遇到<code>gevent.sleep(0)</code>时，就自动切换到其他的方法中去继续执行</p>
<h1 id="协程实例"><a href="#协程实例" class="headerlink" title="协程实例"></a>协程实例</h1><p>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。</p>
<p>由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<p>由于切换是在IO操作时自动完成，所以gevent需要修改Python自带的一些标准库，这一过程在启动时通过monkey patch完成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    data = resp.text</span><br><span class="line">    print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">        gevent.spawn(func, <span class="string">'https://www.baidu.com/'</span>),</span><br><span class="line">        gevent.spawn(func, <span class="string">'http://docs.20150509.cn/'</span>),</span><br><span class="line">        gevent.spawn(func, <span class="string">'http://www.20150509.cn/'</span>),</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">GET: https://www.baidu.com/</span><br><span class="line">GET: http://docs<span class="number">.20150509</span>.cn/</span><br><span class="line">GET: http://www<span class="number">.20150509</span>.cn/</span><br><span class="line"><span class="number">1314</span> bytes received <span class="keyword">from</span> http://www<span class="number">.20150509</span>.cn/.</span><br><span class="line"><span class="number">227</span> bytes received <span class="keyword">from</span> https://www.baidu.com/.</span><br><span class="line"><span class="number">37491</span> bytes received <span class="keyword">from</span> http://docs<span class="number">.20150509</span>.cn/.</span><br></pre></td></tr></table></figure>

<p>遇到IO操作自动切换</p>
<p><code>gevent.joinall</code>内部自带<code>for循环</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    data = resp.text</span><br><span class="line">    print(<span class="string">'%d bytes received from %s.'</span> % (len(data), url))</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'https://www.baidu.com/'</span>, <span class="string">'http://docs.20150509.cn/'</span>, <span class="string">'http://www.20150509.cn/'</span>]</span><br><span class="line">glist = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(urls)):</span><br><span class="line">    glist.append(gevent.spawn(func, urls[i]))</span><br><span class="line">print(glist)</span><br><span class="line">gevent.joinall(glist)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[&lt;Greenlet at <span class="number">0x103396470</span>: func(<span class="string">'https://www.baidu.com/'</span>)&gt;, &lt;Greenlet at <span class="number">0x103396638</span>: func(<span class="string">'http://docs.20150509.cn/'</span>)&gt;, &lt;Greenlet at <span class="number">0x103396768</span>: func(<span class="string">'http://www.20150509.cn/'</span>)&gt;]</span><br><span class="line">GET: https://www.baidu.com/</span><br><span class="line">GET: http://docs<span class="number">.20150509</span>.cn/</span><br><span class="line">GET: http://www<span class="number">.20150509</span>.cn/</span><br><span class="line"><span class="number">1314</span> bytes received <span class="keyword">from</span> http://www<span class="number">.20150509</span>.cn/.</span><br><span class="line"><span class="number">227</span> bytes received <span class="keyword">from</span> https://www.baidu.com/.</span><br><span class="line"><span class="number">37491</span> bytes received <span class="keyword">from</span> http://docs<span class="number">.20150509</span>.cn/.</span><br></pre></td></tr></table></figure>

<h1 id="协程的使用场景"><a href="#协程的使用场景" class="headerlink" title="协程的使用场景"></a>协程的使用场景</h1><ul>
<li>爬虫</li>
<li>URL监控</li>
</ul>
<hr>
<p>参考文档：</p>
<p><a href="http://www.3lian.com/edu/2015/04-30/209255.html" target="_blank" rel="noopener">http://www.3lian.com/edu/2015/04-30/209255.html</a></p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5040827.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5040827.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>协程</tag>
        <tag>greenlet</tag>
        <tag>gevent</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的进程池</title>
    <url>/2016/07/24/Python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<blockquote>
<p>进程池内部维护一个进程序列，当使用时，则去进程池中获取一个进程，如果进程池序列中没有可供使用的进进程，那么程序就会等待，直到进程池中有可用进程为止。</p>
</blockquote>
<p>进程池中的函数：</p>
<ul>
<li>apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞，apply(func[, args[, kwds]])是阻塞的</li>
<li>close()    关闭pool，使其不在接受新的任务。</li>
<li>terminate()    结束工作进程，不在处理未完成的任务。</li>
<li>join()    主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用。</li>
</ul>
<h1 id="使用进程池"><a href="#使用进程池" class="headerlink" title="使用进程池"></a>使用进程池</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    <span class="comment"># pool.apply(func=function, args=(i,))</span></span><br><span class="line">    pool.apply_async(func=function, args=(i,))</span><br></pre></td></tr></table></figure>

<p>以上代码没有任何返回就立即退出了</p>
<p>因为主进程没有阻塞，没有等待子进程执行完毕就退出了程序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    <span class="comment"># pool.apply(func=function, args=(i,))</span></span><br><span class="line">    pool.apply_async(func=function, args=(i,))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()  <span class="comment"># 调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<p><code>join()</code>之前必须等待<code>所有的子进程执行完毕</code></p>
<p>而等待子进程执行完毕有两种方法，一种是上面的<code>close</code>方法，还有一种是<code>terminate</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    <span class="comment"># pool.apply(func=function, args=(i,))</span></span><br><span class="line">    pool.apply_async(func=function, args=(i,))</span><br><span class="line"></span><br><span class="line"><span class="comment">#pool.close()</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">pool.terminate()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><code>close</code>方法与<code>terminate</code>方法的区别是：</p>
<ul>
<li>close：等待所有子进程执行完毕</li>
<li>terminate：不管是否正在执行都立即终止</li>
</ul>
<h1 id="使用进程池并关注结果"><a href="#使用进程池并关注结果" class="headerlink" title="使用进程池并关注结果"></a>使用进程池并关注结果</h1><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">5</span>)</span><br><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">    result.append(pool.apply_async(func=function, args=(i,)))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">    print(<span class="string">"--&gt;"</span>, r.get())</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">--&gt; 0</span><br><span class="line">--&gt; 1</span><br><span class="line">--&gt; 2</span><br><span class="line">--&gt; 3</span><br><span class="line">--&gt; 4</span><br><span class="line">--&gt; 5</span><br><span class="line">--&gt; 6</span><br><span class="line">--&gt; 7</span><br><span class="line">--&gt; 8</span><br><span class="line">--&gt; 9</span><br><span class="line">--&gt; 10</span><br><span class="line">--&gt; 11</span><br><span class="line">--&gt; 12</span><br><span class="line">--&gt; 13</span><br><span class="line">--&gt; 14</span><br><span class="line">--&gt; 15</span><br></pre></td></tr></table></figure>

<h1 id="multiprocessing-pool-map"><a href="#multiprocessing-pool-map" class="headerlink" title="multiprocessing pool map"></a>multiprocessing pool map</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m1</span><span class="params">(x)</span>:</span></span><br><span class="line">    print(x * x)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    pool = multiprocessing.Pool(multiprocessing.cpu_count())</span><br><span class="line">    i_list = range(<span class="number">8</span>)</span><br><span class="line">    pool.map(m1, i_list)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">25</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">49</span></span><br></pre></td></tr></table></figure>

<hr>
<p>参考文档：</p>
<p><a href="http://www.cnblogs.com/kaituorensheng/p/4465768.html" target="_blank" rel="noopener">http://www.cnblogs.com/kaituorensheng/p/4465768.html</a></p>
<p><a href="http://www.cnblogs.com/wupeiqi/articles/5040827.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5040827.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
        <tag>进程池</tag>
      </tags>
  </entry>
  <entry>
    <title>进程锁</title>
    <url>/2016/07/24/%E8%BF%9B%E7%A8%8B%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>多线程中有线程锁，多进程中也有进程锁。不同的是，在多线程中，数据默认是共享的，每个线程可以访问同一对象；而在多进程中，数据默认是独立的，要想在多进程中共享数据，需要使用特殊的方式实现</p>
</blockquote>
<p>上面也提到了，我想重现多进程访问同一资源产生冲突的情况，就首先要构造出多进程的数据共享，如果对多进程的数据共享有疑问，可以参考上一篇文章</p>
<h1 id="没有锁访问共享资源"><a href="#没有锁访问共享资源" class="headerlink" title="没有锁访问共享资源"></a>没有锁访问共享资源</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="comment"># 修改主进程的共享数据</span></span><br><span class="line">    array[<span class="number">0</span>] = array[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(array[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组,长度为1,数据类型为int</span></span><br><span class="line">array = Array(<span class="string">'i'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 在主进程为该数组赋值</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    p = Process(target=func, args=(array,))</span><br><span class="line">    p.start()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="加锁访问共享资源"><a href="#加锁访问共享资源" class="headerlink" title="加锁访问共享资源"></a>加锁访问共享资源</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> RLock, Lock, Event, Condition, Semaphore</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(array, lock)</span>:</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="comment"># 修改主进程的共享数据</span></span><br><span class="line">    array[<span class="number">0</span>] = array[<span class="number">0</span>] - <span class="number">1</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(array[<span class="number">0</span>])</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数组,长度为1,数据类型为int</span></span><br><span class="line">array = Array(<span class="string">'i'</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 在主进程为该数组赋值</span></span><br><span class="line">array[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">lock = RLock()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    p = Process(target=func, args=(array, lock))</span><br><span class="line">    p.start()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="多进程锁的种类"><a href="#多进程锁的种类" class="headerlink" title="多进程锁的种类"></a>多进程锁的种类</h1><ul>
<li>RLock</li>
<li>Lock</li>
<li>Event</li>
<li>Condition</li>
<li>Semaphore</li>
</ul>
<p>多进程中的锁和多线程中的锁用法是一样的，具体每个锁的用法这里就不一一举例了，可以参考多线程锁的用法</p>
<p><a href="http://docs.20150509.cn/2016/07/22/线程锁/" target="_blank" rel="noopener">http://docs.20150509.cn/2016/07/22/线程锁/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>进程锁</tag>
        <tag>RLock</tag>
        <tag>Lock</tag>
        <tag>Event</tag>
        <tag>Condition</tag>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中多进程之间的数据共享</title>
    <url>/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>多进程中，每个进程都是独立的，各自持有一份数据，无法共享。本篇文章介绍三种用于进程数据共享的方法</p>
</blockquote>
<ul>
<li>queues</li>
<li>Array</li>
<li>Manager.dict</li>
<li>pipe</li>
</ul>
<h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> queues</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, q)</span>:</span></span><br><span class="line">    q.put(i)</span><br><span class="line">    print(<span class="string">"---&gt;"</span>, i, q.qsize())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = queues.Queue(<span class="number">9</span>, ctx=multiprocessing)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p = multiprocessing.Process(target=func, args=(i, q,))</span><br><span class="line">    p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<p>Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常</p>
<p>get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, q)</span>:</span></span><br><span class="line">    q.put(i)</span><br><span class="line">    print(<span class="string">"---&gt;"</span>, i, q.qsize())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">q = multiprocessing.Queue()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p = multiprocessing.Process(target=func, args=(i, q,))</span><br><span class="line">    p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Array</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, ar)</span>:</span></span><br><span class="line">    ar[i] = i</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> ar:</span><br><span class="line">        print(item)</span><br><span class="line">    print(<span class="string">"------"</span>)</span><br><span class="line"></span><br><span class="line">ar = Array(<span class="string">'i'</span>, <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    p = Process(target=func, args=(i, ar,))</span><br><span class="line">    p.start()</span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<p>Array的局限性在于受制于数组的特性，即需要指定数据类型且长度固定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据类型对照表</span></span><br><span class="line"><span class="string">'c'</span>: ctypes.c_char,  <span class="string">'u'</span>: ctypes.c_wchar,</span><br><span class="line"><span class="string">'b'</span>: ctypes.c_byte,  <span class="string">'B'</span>: ctypes.c_ubyte,</span><br><span class="line"><span class="string">'h'</span>: ctypes.c_short, <span class="string">'H'</span>: ctypes.c_ushort,</span><br><span class="line"><span class="string">'i'</span>: ctypes.c_int,   <span class="string">'I'</span>: ctypes.c_uint,</span><br><span class="line"><span class="string">'l'</span>: ctypes.c_long,  <span class="string">'L'</span>: ctypes.c_ulong,</span><br><span class="line"><span class="string">'f'</span>: ctypes.c_float, <span class="string">'d'</span>: ctypes.c_double</span><br></pre></td></tr></table></figure>

<h1 id="Manager-dict"><a href="#Manager-dict" class="headerlink" title="Manager.dict"></a>Manager.dict</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Manager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每个子进程执行的函数</span></span><br><span class="line"><span class="comment"># 参数中，传递了一个用于多进程之间数据共享的特殊字典</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, d)</span>:</span></span><br><span class="line">    d[i] = i + <span class="number">100</span></span><br><span class="line">    print(d.values())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主进程中创建特殊字典</span></span><br><span class="line">m = Manager()</span><br><span class="line">d = m.dict()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    <span class="comment"># 让子进程去修改主进程的特殊字典</span></span><br><span class="line">    p = Process(target=func, args=(i, d))</span><br><span class="line">    p.start()</span><br><span class="line">p.join()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">100</span>]</span><br><span class="line">[<span class="number">100</span>, <span class="number">101</span>]</span><br><span class="line">[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>]</span><br><span class="line">[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>]</span><br><span class="line">[<span class="number">100</span>, <span class="number">101</span>, <span class="number">102</span>, <span class="number">103</span>, <span class="number">104</span>]</span><br></pre></td></tr></table></figure>

<p><strong>Manager.dict</strong>是多进程数据共享中比较常用的做法</p>
<h1 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h1><p>Pipe方法返回(conn1, conn2)代表一个管道的两个端。Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。duplex为False，conn1只负责接受消息，conn2只负责发送消息</p>
<p>send和recv方法分别是发送和接受消息的方法。例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(arg, pp)</span>:</span></span><br><span class="line">    pp.send(arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(pp)</span>:</span></span><br><span class="line">    recv = pp.recv()</span><br><span class="line">    print(recv)</span><br><span class="line"></span><br><span class="line">pp = multiprocessing.Pipe()</span><br><span class="line">p1 = multiprocessing.Process(target=func1, args=(<span class="string">"PolarSnow"</span>, pp[<span class="number">0</span>],))</span><br><span class="line">p2 = multiprocessing.Process(target=func2, args=(pp[<span class="number">1</span>],))</span><br><span class="line">p1.start()</span><br><span class="line">p2.start()</span><br><span class="line">p1.join()</span><br><span class="line">p2.join()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">PolarSnow</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中列表与数组的区别</title>
    <url>/2016/07/24/Python%E4%B8%AD%E5%88%97%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>Python原生没有数组的概念，这点不同于Java之类的面向对象语言。Python中原生的列表使用起来很像数组，但是两者有本质的区别</p>
</blockquote>
<p>Python是一门动态语言，在Python列表的创建中，不需要指定数据类型，而且不需要指定列表的长度—因为Python中的列表是通过链表的形式实现的；相对应的，数组的特点是必须在创建的时候声明它的数据类型，而且必须指定数组的长度</p>
<p>#列表与数组的区别</p>
<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><ul>
<li>列表中的所有元素的内存地址可以不是连续的，它是通过每个元素记录它的上一个元素的内存地址和记录它下一个元素的内存地址来排列的</li>
<li>数组是一个连续的内存空间，每一个元素都按照先后顺序排列在内存当中</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>Python中的列表可以放任意类型的对象，这个特性是Python赋予的，不是链表本身的特性</li>
<li>数组一旦声明数据类型，之后放入每个的元素必须都是这个数据类型的对象，如果不是，就会抛出异常</li>
</ul>
<p><img src="http://oss.20150509.cn/20160724145259.png" alt=""></p>
<h2 id="Python中使用到数组的场景"><a href="#Python中使用到数组的场景" class="headerlink" title="Python中使用到数组的场景"></a>Python中使用到数组的场景</h2><ul>
<li>from multiprocessing import Array</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>列表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多进程中的run方法</title>
    <url>/2016/07/24/Python%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84run%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>在多线程的介绍中，介绍了可以自定义多线程类，并且重写多线程类的run方法，实现了第二种使用多线程的方式</p>
<p>在多进程中，也可以自定义多进程类，是通过重写多进程类的run方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(multiprocessing.Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">        <span class="comment"># 将函数名和参数封装到本类中</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        <span class="comment"># 为保证继承的类正常运行，这里需要执行父类的构造方法</span></span><br><span class="line">        <span class="comment"># 但是没有给父类的构造方法传递任何参数</span></span><br><span class="line">        <span class="comment"># 而对象寻找参数时，也是最先从本类中寻找</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 执行参数中的函数</span></span><br><span class="line">        self.func(*self.args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义一个需要子进程运行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args)</span>:</span></span><br><span class="line">    print(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的进程对象执行</span></span><br><span class="line">p = MyProcess(func=f, args=(<span class="number">59</span>,<span class="number">15</span>))</span><br><span class="line">p.start()</span><br></pre></td></tr></table></figure>

<p><strong>进程p调用start()时，自动调用run()</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中多进程的基本操作</title>
    <url>/2016/07/24/Python%E4%B8%AD%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>Python中的多进程可以使用到多颗CPU带来的好处，在前面多线程中已经总结出，对于IO密集型的操作，由于IO不占用CPU，所以使用轻量级的多线程即可解决问题；而对于计算密集型操作，由于多线程不支持使用多颗CPU，所以使用多进程是最合适的。本篇文件就介绍Python多进程的使用</p>
</blockquote>
<h1 id="创建一个子进程"><a href="#创建一个子进程" class="headerlink" title="创建一个子进程"></a>创建一个子进程</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    p = multiprocessing.Process(target=worker, args=(<span class="string">"Hello PolarSnow"</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">"p.pid:"</span>, p.pid)</span><br><span class="line">    print(<span class="string">"p.name"</span>, p.name)</span><br><span class="line">    print(<span class="string">"p.is_alive:"</span>, p.is_alive())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">p.pid: <span class="number">17731</span></span><br><span class="line">p.name Process<span class="number">-1</span></span><br><span class="line">p.is_alive: <span class="literal">True</span></span><br><span class="line">Hello PolarSnow</span><br></pre></td></tr></table></figure>

<p>如果你看过前面多线程的文章，可以看出，多进程的基本用法和多线程很相似</p>
<h1 id="多个进程处理同一个函数"><a href="#多个进程处理同一个函数" class="headerlink" title="多个进程处理同一个函数"></a>多个进程处理同一个函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br><span class="line">        </span><br><span class="line">------------</span><br><span class="line">CPU数量: <span class="number">4</span></span><br><span class="line">子进程名称: Process<span class="number">-5</span> 子进程id: <span class="number">18705</span></span><br><span class="line">子进程名称: Process<span class="number">-3</span> 子进程id: <span class="number">18703</span></span><br><span class="line">子进程名称: Process<span class="number">-2</span> 子进程id: <span class="number">18702</span></span><br><span class="line">子进程名称: Process<span class="number">-1</span> 子进程id: <span class="number">18701</span></span><br><span class="line">子进程名称: Process<span class="number">-4</span> 子进程id: <span class="number">18704</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h1 id="多个进程处理多个函数"><a href="#多个进程处理多个函数" class="headerlink" title="多个进程处理多个函数"></a>多个进程处理多个函数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker1</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"worker1"</span>, arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker2</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"worker2"</span>, arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker3</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"worker3"</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    p1 = multiprocessing.Process(target=worker1, args=(<span class="string">"PS1"</span>,))</span><br><span class="line">    p2 = multiprocessing.Process(target=worker1, args=(<span class="string">"PS2"</span>,))</span><br><span class="line">    p3 = multiprocessing.Process(target=worker1, args=(<span class="string">"PS3"</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 可以查看当前正在运行的子进程的信息</span></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br></pre></td></tr></table></figure>

<h1 id="daemon属性"><a href="#daemon属性" class="headerlink" title="daemon属性"></a>daemon属性</h1><p><strong>不加daemon属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        <span class="comment"># p.daemon = True</span></span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"End"</span>)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">CPU数量: <span class="number">4</span></span><br><span class="line">子进程名称: Process<span class="number">-2</span> 子进程id: <span class="number">21859</span></span><br><span class="line">子进程名称: Process<span class="number">-3</span> 子进程id: <span class="number">21860</span></span><br><span class="line">子进程名称: Process<span class="number">-1</span> 子进程id: <span class="number">21858</span></span><br><span class="line">子进程名称: Process<span class="number">-4</span> 子进程id: <span class="number">21861</span></span><br><span class="line">子进程名称: Process<span class="number">-5</span> 子进程id: <span class="number">21862</span></span><br><span class="line">End</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>加上daemon属性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        p.daemon = <span class="literal">True</span></span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"End"</span>)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">CPU数量: <span class="number">4</span></span><br><span class="line">子进程名称: Process<span class="number">-2</span> 子进程id: <span class="number">21913</span></span><br><span class="line">子进程名称: Process<span class="number">-1</span> 子进程id: <span class="number">21912</span></span><br><span class="line">子进程名称: Process<span class="number">-4</span> 子进程id: <span class="number">21915</span></span><br><span class="line">子进程名称: Process<span class="number">-5</span> 子进程id: <span class="number">21916</span></span><br><span class="line">子进程名称: Process<span class="number">-3</span> 子进程id: <span class="number">21914</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p><code>p.daemon</code>的默认值为<code>False</code>，意为主进程等待子进程执行完毕后再退出程序</p>
<p><code>p.daemon</code>的值为<code>True</code>时，意为当主进程执行完毕时，立即退出程序</p>
<h1 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        p.daemon = <span class="literal">True</span></span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">"End"</span>)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">CPU数量: <span class="number">4</span></span><br><span class="line">子进程名称: Process<span class="number">-2</span> 子进程id: <span class="number">22196</span></span><br><span class="line">子进程名称: Process<span class="number">-1</span> 子进程id: <span class="number">22195</span></span><br><span class="line">子进程名称: Process<span class="number">-3</span> 子进程id: <span class="number">22197</span></span><br><span class="line">子进程名称: Process<span class="number">-5</span> 子进程id: <span class="number">22199</span></span><br><span class="line">子进程名称: Process<span class="number">-4</span> 子进程id: <span class="number">22198</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>join方法的作用是阻塞住主进程，让CPU无法执行join后面的代码，专注执行多线程</li>
<li>上面演示的是多个进程对应一个join的情况，意为等待所有的子进程执行完毕后，再向下执行代码；如果join写在for循环里面，多个线程对应多个join时，意为前一个子进程执行完毕后，才能执行下一次循环，执行下一个任务</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(arg)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        p = multiprocessing.Process(target=worker, args=(i,))</span><br><span class="line">        p.daemon = <span class="literal">True</span></span><br><span class="line">        p.start()</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"CPU数量:"</span>, str(multiprocessing.cpu_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> multiprocessing.active_children():</span><br><span class="line">        print(<span class="string">"子进程名称:"</span>, p.name, <span class="string">"子进程id:"</span>, p.pid)</span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    print(<span class="string">"End"</span>)</span><br></pre></td></tr></table></figure>

<p><em>相当于用子进程串行执行任务</em></p>
<ul>
<li>join是可以添加参数的，在没有参数的时候，会一直阻塞到函数执行完毕为止；设置参数后（int 时间 单位是秒）意为join最长阻塞的时间，超过这个时间后，不管子进程有没有执行完毕都会继续向下执行</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">p.join(1)</span><br></pre></td></tr></table></figure>
<p><strong>最多等待1秒（最多阻塞1秒）</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>multiprocessing</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义线程池</title>
    <url>/2016/07/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<blockquote>
<p>上一篇文章简单的介绍了一个线程池的基本实现思路。在上一篇的代码实现中，其实还有很多问题。第一，线程没有被重用，我们只是模拟了一个任务拿走一个线程，执行完毕后再“还”回去的过程，其实是在线程池中新创建了一个线程类，被使用过的线程将等待被Python的垃圾回收机制回收；第二，如果执行的任务的数量小于线程池的容量，那我们在线程池的构造方法中，预先填满的线程类就显得非常浪费了</p>
</blockquote>
<p>改进思路：</p>
<ul>
<li>之前是将线程放入到队列中，启动线程池后，整个队列就会充满待使用的线程<ul>
<li>改进：将任务放入到队列中，然任务排队进入队列。线程的数量通过列表的长度控制，每创建一个线程，就在列表中append一下</li>
</ul>
</li>
<li>之前队列中的线程，每一个任务取走之后，执行完任务都会创建一个新的线程放入到队列中<ul>
<li>改进：每个线程执行完任务后，不再释放线程资源，循环去任务队列中获取任务去执行，直到判断拿到的是空值而不是一个任务时，退出自己的线程</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列中的空值</span></span><br><span class="line">StopEvent = object()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_num, max_task_num = None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        构造方法</span></span><br><span class="line"><span class="string">        :param max_num: 最多有多少个线程</span></span><br><span class="line"><span class="string">        :param max_task_num: 接收任务队列的长度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> max_task_num:</span><br><span class="line">            self.q = queue.Queue(max_task_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.q = queue.Queue()</span><br><span class="line">        self.max_num = max_num</span><br><span class="line">        self.cancel = <span class="literal">False</span></span><br><span class="line">        self.terminal = <span class="literal">False</span></span><br><span class="line">        self.generate_list = []  <span class="comment"># 当前已经创建的线程</span></span><br><span class="line">        self.free_list = []  <span class="comment"># 当前还空闲多少线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, func, args, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        线程池执行一个任务</span></span><br><span class="line"><span class="string">        :param func: 任务函数</span></span><br><span class="line"><span class="string">        :param args: 任务函数所需参数</span></span><br><span class="line"><span class="string">        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）</span></span><br><span class="line"><span class="string">        :return: 如果线程池已经终止，则返回True否则None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># self.cancel是在构造方法和self.close方法中设置的值</span></span><br><span class="line">        <span class="comment"># 在close方法中将该值设置为False,意为当前任务队列中的所有任务全部已经执行完毕</span></span><br><span class="line">        <span class="keyword">if</span> self.cancel:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.free_list) == <span class="number">0</span> <span class="keyword">and</span> len(self.generate_list) &lt; self.max_num:</span><br><span class="line">            <span class="comment"># 如果空闲的线程为0 且 当前已经创建的线程数量小于设置的最大线程数量</span></span><br><span class="line">            <span class="comment"># 调用本类的其他方法创建一个新的线程</span></span><br><span class="line">            self.generate_thread()</span><br><span class="line">        <span class="comment"># 将run方法收到的三个参数组成一个数据</span></span><br><span class="line">        w = (func, args, callback,)</span><br><span class="line">        <span class="comment"># 放入到任务队列当中</span></span><br><span class="line">        self.q.put(w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 每一个线程被创建出来后都去执行了本类中的call方法</span></span><br><span class="line">        t = threading.Thread(target=self.call)</span><br><span class="line">        <span class="comment"># 启动线程</span></span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        循环去获取任务函数并执行任务函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 获取当前线程</span></span><br><span class="line">        current_thread = threading.currentThread</span><br><span class="line">        <span class="comment"># 将当前线程加入到"当前已创建线程"列表中</span></span><br><span class="line">        self.generate_list.append(current_thread)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在队列中获取一个任务</span></span><br><span class="line">        event = self.q.get()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># while循环,当event不为空对象的时候</span></span><br><span class="line">        <span class="keyword">while</span> event != StopEvent:</span><br><span class="line">            <span class="comment"># 队列中的每个元素由一个元祖构成(func, args, callback,)</span></span><br><span class="line">            func, arguments, callback = event</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 去执行函数</span></span><br><span class="line">                <span class="comment"># 这里func对应的是action函数</span></span><br><span class="line">                <span class="comment"># arguments参数对应了i</span></span><br><span class="line">                <span class="comment"># result接收这个函数的返回值</span></span><br><span class="line">                result = func(*arguments)</span><br><span class="line">                success = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                success = <span class="literal">False</span></span><br><span class="line">                result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 判断callback函数是否为空</span></span><br><span class="line">            <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="comment"># 执行这个回调函数,将执行的状态和返回的结果传递给回调函数</span></span><br><span class="line">                    callback(success, result)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 以上action函数执行完后,该线程变为空闲状态</span></span><br><span class="line">            <span class="comment"># 以下代码将该线程加入到"当前空闲线程"列表中,等待线程复用</span></span><br><span class="line">            <span class="keyword">with</span> self.worker_state(self.free_list, current_thread):</span><br><span class="line">            	<span class="comment"># 默认的self.terminal为False，会一直去队列中取任务执行</span></span><br><span class="line">            	<span class="comment"># 在terminate方法中，设置了self.terminal的值为True，也就是说，一旦调用terminate方法，这个线程将被回收，不再执行新的任务</span></span><br><span class="line">                <span class="keyword">if</span> self.terminal:</span><br><span class="line">                    event = StopEvent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 复用当前线程,再去队列中获取一个任务</span></span><br><span class="line">                    event = self.q.get()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># event为空对象,说明当前已经没有需要执行的任务了</span></span><br><span class="line">            <span class="comment"># 每个线程把自己的线程对象从"当前已创建线程"列表中移除(不再复用)</span></span><br><span class="line">            self.generate_list.remove(current_thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行完所有的任务后，所有线程停止</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cancel = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># 获取当前线程列表的长度(有多少个复用的线程)</span></span><br><span class="line">        full_size = len(self.generate_list)</span><br><span class="line">        <span class="comment"># 因为任务已经执行完毕,任务队列为空,所有的线程都在等待获取新的任务</span></span><br><span class="line">        <span class="comment"># 向任务队列中,插入StopEvent空值,让每个线程拿到这个任务的时候,退出掉自己的线程</span></span><br><span class="line">        <span class="keyword">while</span> full_size:</span><br><span class="line">            <span class="comment"># 当前可以复用的线程列表中有多少个线程对象就插入多少个空值</span></span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line">            full_size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        无论是否还有任务，终止线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.terminal = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 把队列中的所有任务全部设置为空对象（结束线程的标识）</span></span><br><span class="line">		<span class="comment"># 每个拿到这个空对象任务的线程都会结束自己的线程</span></span><br><span class="line">        <span class="keyword">while</span> self.generate_list:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line">		<span class="comment"># 所有的线程都被结束后，清空队列中的所有内容</span></span><br><span class="line">        self.q.empty()</span><br><span class="line"></span><br><span class="line">	<span class="comment"># 上下文管理的装饰器，以下函数可以被with调用执行</span></span><br><span class="line"><span class="meta">    @contextlib.contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">worker_state</span><span class="params">(self, state_list, worker_thread)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于记录线程中正在等待的线程数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        state_list.append(worker_thread)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            state_list.remove(worker_thread)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程池</span></span><br><span class="line">    <span class="comment"># 最多同时创建3个线程在处理任务（消费者从队列中消费数据）</span></span><br><span class="line">    <span class="comment"># 任务队列中同一时间最多存放5个任务（生产者向队列中存放数据）</span></span><br><span class="line">    pool = ThreadPool(<span class="number">3</span>, max_task_num=<span class="number">5</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 回调函数，每一个子线程处理完一个任务之后，都会调用这个方法</span></span><br><span class="line">	<span class="comment"># 用来处理子线程执行任务后的执行状态和返回结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(status, result)</span>:</span></span><br><span class="line">        <span class="comment"># status, execute action status</span></span><br><span class="line">        <span class="comment"># result, execute action return value</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 真正实现多线程的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span><span class="params">(i)</span>:</span></span><br><span class="line">        print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建30个任务</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>):</span><br><span class="line">        <span class="comment"># 每一次迭代就执行一次run方法</span></span><br><span class="line">        ret = pool.run(action, (i,), callback)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(len(pool.generate_list), len(pool.free_list))</span><br><span class="line">    print(len(pool.generate_list), len(pool.free_list))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭线程池</span></span><br><span class="line">    pool.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 终止线程池并清空任务队列</span></span><br><span class="line">    <span class="comment"># pool.terminate()</span></span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/20160724123859.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义线程池的实现思路</title>
    <url>/2016/07/22/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<blockquote>
<p>在使用多线程的过程中，一旦任务数量过多，如果不对派生出来的子线程做出限制的话，多线程极有可能会拉低程序的性能，这时，我们需要维护一个固定数量的线程，也就是线程池的概念</p>
</blockquote>
<p>实现线程池的思路：</p>
<ul>
<li>设置线程池的容量</li>
<li>每取走一个线程，在线程池中就减少一个线程</li>
<li>每个子线程的任务执行完毕，把自己的线程配额放回线程池中</li>
<li>当线程池中的线程全部分配完毕，新的任务需要等待获取线程池中的线程</li>
</ul>
<p>基于以上的需求，我们可以通过队列来实现线程池的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span>:</span></span><br><span class="line">    <span class="comment"># 接收的实例化参数为线程池的最大容量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=<span class="number">5</span>)</span>:</span></span><br><span class="line">        self.maxsize = maxsize</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设置队列的最大容量</span></span><br><span class="line">        self.q = queue.Queue(maxsize)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用线程类填满队列</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(maxsize):</span><br><span class="line">            self.q.put(threading.Thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 从队列中取出一个线程类返回</span></span><br><span class="line">        <span class="keyword">return</span> self.q.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 先线程池添加一个线程类</span></span><br><span class="line">        <span class="comment"># 用来被执行完任务的函数调用,实现回收线程配额的功能</span></span><br><span class="line">        self.q.put(threading.Thread)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(arg, pool)</span>:</span></span><br><span class="line">    <span class="string">"""接收了一个线程池对象"""</span></span><br><span class="line">    print(arg)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行完毕函数的主体后,将拿到的线程配额再放回到线程池中</span></span><br><span class="line">    pool.add_thread()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个容量为5的线程池</span></span><br><span class="line">    pool = ThreadPool(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">59</span>):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 从线程池中拿到一个线程对象</span></span><br><span class="line">        <span class="comment"># 相当于 t = threading.Thread</span></span><br><span class="line">        t = pool.get_thread()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建子线程对象</span></span><br><span class="line">        <span class="comment"># 把线程池对象传递到执行函数中</span></span><br><span class="line">        o = t(target=task, args=(i, pool,))</span><br><span class="line"></span><br><span class="line">        o.start()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>线程锁</title>
    <url>/2016/07/22/%E7%BA%BF%E7%A8%8B%E9%94%81/</url>
    <content><![CDATA[<blockquote>
<p>在多线程的使用过程中，需要考虑的一个问题就是线程安全。如果使用多线程对多个对象进行操作，也许不会有异常的情况的产生，因为每个对象是独立的，每个对象的改变对其他对象没有影响。但是如果使用多线程操作同一个对象，极有可能产生脏数据；但是同时访问同一个对象不会产生脏数据</p>
</blockquote>
<h1 id="多线程修改同一对象"><a href="#多线程修改同一对象" class="headerlink" title="多线程修改同一对象"></a>多线程修改同一对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUM = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">global</span> NUM</span><br><span class="line">  NUM -= <span class="number">1</span></span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line">  print(NUM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  t = threading.Thread(target=func)</span><br><span class="line">  t.start()</span><br><span class="line">  </span><br><span class="line">------------</span><br><span class="line"><span class="number">00</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"> <span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>上面的小程序中，定义了一个全局变量<code>NUM</code>，在<code>func</code>方法中对全局变量<code>NUM</code>做自减一的操作，我们理想中的结果是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>但实际结果却全都是0</p>
<p>这是因为每个线程运行到<code>sleep(1)</code>的时候都在这里卡住，最后，所有的线程都执行完了<code>NUM -= 1</code>，这个时候全局变量<code>NUM</code>已经<code>=0</code>，而第一个线程还没有执行完<code>sleep(1)</code>,所以最后所有的线程打印出来的都是0</p>
<h1 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUM = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数里接收一个锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lock)</span>:</span></span><br><span class="line">  <span class="keyword">global</span> NUM</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 获取锁</span></span><br><span class="line">  lock.acquire()</span><br><span class="line">  NUM -= <span class="number">1</span></span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line">  print(NUM)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 释放锁</span></span><br><span class="line">  lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  <span class="comment"># 把创建的锁对象当做参数传递给函数</span></span><br><span class="line">  t = threading.Thread(target=func, args=(lock,))</span><br><span class="line">  t.start()</span><br><span class="line">  </span><br><span class="line">------------</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="RLock"><a href="#RLock" class="headerlink" title="RLock"></a>RLock</h1><p>RLock和Lock的使用方法相同，但却是Lock的”升级版”，RLock支持在函数内的多层嵌套锁，例如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUM = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数里接收一个锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(lock)</span>:</span></span><br><span class="line">  <span class="keyword">global</span> NUM</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 获取锁</span></span><br><span class="line">  lock.acquire()</span><br><span class="line">  NUM -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 嵌套锁</span></span><br><span class="line">  lock.acquire()</span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line">  lock.release()</span><br><span class="line"></span><br><span class="line">  print(NUM)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 释放锁</span></span><br><span class="line">  lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁</span></span><br><span class="line">lock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  <span class="comment"># 把创建的锁对象当做参数传递给函数</span></span><br><span class="line">  t = threading.Thread(target=func, args=(lock,))</span><br><span class="line">  t.start()</span><br></pre></td></tr></table></figure>

<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><p>信号量，可以放出一批锁，类似于批量“授权”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">NUM = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数里接收一个锁对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, lock)</span>:</span></span><br><span class="line">  <span class="keyword">global</span> NUM</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 获取锁，这里最多可以发放3把锁</span></span><br><span class="line">  lock.acquire()</span><br><span class="line">  NUM -= <span class="number">1</span></span><br><span class="line">  time.sleep(<span class="number">1</span>)</span><br><span class="line">  print(i, NUM)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 释放锁</span></span><br><span class="line">  lock.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个锁,锁的数量有3个</span></span><br><span class="line">lock = threading.BoundedSemaphore(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">  <span class="comment"># 把创建的锁对象当做参数传递给函数</span></span><br><span class="line">  t = threading.Thread(target=func, args=(i, lock,))</span><br><span class="line">  t.start()</span><br><span class="line">  </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span> <span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，总共有3把锁被放出，所以前三个线程打印值是相同的，三个线程依次修改<code>NUM</code>的值，然后依次进入<code>time.sleep(1)</code>等待（此时NUM已经被自减了3次，值=2），最后依次打印出<code>NUM</code>的值</p>
<h1 id="event"><a href="#event" class="headerlink" title="event"></a>event</h1><p>事件, 同样是“批量授权”，但是和信号量指定创建锁的数量不同的是，事件要么锁住所有的线程，要么释放所有的线程，不能自定义锁的数量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一个event对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, event)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里的wait()方法会阻塞所有的线程,但是是否阻塞取决于event维护的全局Flag</span></span><br><span class="line">    event.wait()  <span class="comment"># wait会去检测"Flag"的值的真假</span></span><br><span class="line">    print(i + <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个event对象</span></span><br><span class="line">event = threading.Event()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置event对象中的"Flag"为False</span></span><br><span class="line"><span class="comment"># 默认情况下就是False</span></span><br><span class="line">event.clear()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=func, args=(i, event))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">inp = input(<span class="string">"&gt; "</span>)</span><br><span class="line"><span class="keyword">if</span> inp == <span class="string">"go"</span>:</span><br><span class="line">    <span class="comment"># 设置event对象中的"Flag"为True</span></span><br><span class="line">    <span class="comment"># 释放了所有的锁</span></span><br><span class="line">    event.set()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt; go</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">104</span></span><br><span class="line"><span class="number">102</span></span><br></pre></td></tr></table></figure>

<ul>
<li>wait：检测“Flag”的值</li>
<li>clear：将“Flag”设置为False</li>
<li>set：将“Flag”设置为True</li>
</ul>
<h1 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h1><p>条件，上面说了事件的特性，就是要阻塞就阻塞住所有的子线程，要释放就释放掉所有的锁，不支持信号量中的自定义释放锁的数量</p>
<p>条件锁，既支持事件阻塞所有子线程的特性，又具有信号量指定释放锁数量的特性</p>
<h2 id="condition的第一种用法"><a href="#condition的第一种用法" class="headerlink" title="condition的第一种用法"></a>condition的第一种用法</h2><p>指定释放锁的数量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一个condition对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, con)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给线程上锁</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    <span class="comment"># wait会根据notify指定的数量去释放锁,默认锁住所有线程</span></span><br><span class="line">    con.wait()</span><br><span class="line">    print(i + <span class="number">100</span>)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=func, args=(i, condition))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    inp = input(<span class="string">"&gt; "</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">"q"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 指定释放锁数量的三剑客</span></span><br><span class="line">    <span class="comment"># 语法中规定他们必须按照这个顺序写</span></span><br><span class="line">    condition.acquire()</span><br><span class="line">    condition.notify(int(inp))  <span class="comment"># 这里的int类型的inp变量,就是指定释放锁的数量</span></span><br><span class="line">    condition.release()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">100</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt; <span class="number">102</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt; <span class="number">104</span></span><br><span class="line"><span class="number">103</span></span><br></pre></td></tr></table></figure>

<p>最后只打印两个数字，是因为总共有5个测试数据，前面已经累计释放了三个子线程处理的测试数据，所以第三次，我即使指定了释放3个锁（当时程序中只剩两个子线程被锁住），也只会出现2个值</p>
<h1 id="condition的第二种用法"><a href="#condition的第二种用法" class="headerlink" title="condition的第二种用法"></a>condition的第二种用法</h1><p>如果条件为真，释放一个锁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="literal">False</span></span><br><span class="line">    inp = input(<span class="string">"&gt; "</span>)</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">"true"</span>:</span><br><span class="line">        ret = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        ret = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收一个condition对象</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i, con)</span>:</span></span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 给线程上锁</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    <span class="comment"># wait_for会根据参数的值的真假来选择是否释放一个锁</span></span><br><span class="line">    <span class="comment"># 这里传入的是一个函数,也就是说如果函数的返回值为真,就释放一个锁</span></span><br><span class="line">    con.wait_for(select)</span><br><span class="line">    print(i + <span class="number">100</span>)</span><br><span class="line">    con.release()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一把条件锁</span></span><br><span class="line">condition = threading.Condition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    t = threading.Thread(target=func, args=(i, condition))</span><br><span class="line">    t.start()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">true</span><br><span class="line"><span class="number">100</span></span><br><span class="line">&gt; true</span><br><span class="line"><span class="number">101</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>con.wait_for(select)</code>中，我们传入了一个函数名，当第一个子线程执行到这一行的时候，会自动去执行这个函数，从而打印出了第一个<code>&gt;</code>符号，之后就停在了等待用户输入的那一行<code>input()</code></p>
<p>其他所有的子线程都停在了<code>con.acquare()</code>这一行，等待前面的子线程释放锁</p>
<p>这时，我输入一个<code>true</code>，<code>select</code>函数返回了一个<code>True</code>, <code>wait_for()</code>接收到这个<code>True</code>之后，就继续向下执行，最后释放掉自己的锁</p>
<p>接着下一个被调度到的子线程执行到<code>wait_for()</code>又去执行了里面传入的函数……以此类推</p>
<h1 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h1><p>Timer不是锁，是定时器，用来指定x秒后执行某些操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"hello, world"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<p>结果没有立即输入，而是等了一秒钟之后输出了<code>hello, world</code></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>线程锁</tag>
        <tag>互斥锁</tag>
      </tags>
  </entry>
  <entry>
    <title>ESXi6.0调用对象datastoreSystem失败</title>
    <url>/2016/07/20/ESXi6-0%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1datastoreSystem%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<blockquote>
<p>VMware vSphere Client上添加存储时显示：在 ESXi“192.168.59.59”上调用对象 “datastoresystem”的“HostDatastoreSystem.QueryVmfsDatastoreCreateOptions” 失败</p>
</blockquote>
<ul>
<li>在该主机的<code>配置</code>—&gt;<code>安全配置文件</code>中，开启<code>SSH</code>和<code>ESXi Shell</code>服务</li>
<li>ssh <a href="mailto:root@192.168.59.59">root@192.168.59.59</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ls /vmfs/devices/disks</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:1</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:2</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:3</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:5</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:6</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:7</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:8</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:9</span><br><span class="line">naa.6782bcb0635695001f21a2451bd15e08</span><br><span class="line">naa.6782bcb0635695001f21a2451bd15e08:1</span><br><span class="line">naa.6782bcb0635695001f21a2451bd15e08:2</span><br><span class="line">naa.6782bcb0635695001f21a25f1d533c53</span><br><span class="line">naa.6782bcb0635695001f21a25f1d533c53:1</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:1</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:2</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:3</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:5</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:6</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:7</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:8</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:9</span><br><span class="line">vml.02000000006782bcb0635695001f21a2451bd15e08504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f21a2451bd15e08504552432036:1</span><br><span class="line">vml.02000000006782bcb0635695001f21a2451bd15e08504552432036:2</span><br><span class="line">vml.02000000006782bcb0635695001f21a25f1d533c53504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f21a25f1d533c53504552432036:1</span><br></pre></td></tr></table></figure>

<ul>
<li>vSphere Client中找到报错的那块磁盘名字，我这里是<code>naa.6782bcb0635695001f21a2451bd15e08</code></li>
<li>将该块磁盘重新分区</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; partedUtil mklabel /dev/disks/naa.6782bcb0635695001f21a2451bd15e08 gpt</span><br></pre></td></tr></table></figure>

<p>我这里的磁盘容量为2T，这里使用gpt分区表，如果容量不是很大，可以写<code>msdos</code> 使用MBR分区表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; ls /vmfs/devices/disks</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:1</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:2</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:3</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:5</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:6</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:7</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:8</span><br><span class="line">naa.6782bcb0635695001f1f261018908d00:9</span><br><span class="line">naa.6782bcb0635695001f21a2451bd15e08</span><br><span class="line">naa.6782bcb0635695001f21a25f1d533c53</span><br><span class="line">naa.6782bcb0635695001f21a25f1d533c53:1</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:1</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:2</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:3</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:5</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:6</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:7</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:8</span><br><span class="line">vml.02000000006782bcb0635695001f1f261018908d00504552432036:9</span><br><span class="line">vml.02000000006782bcb0635695001f21a2451bd15e08504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f21a25f1d533c53504552432036</span><br><span class="line">vml.02000000006782bcb0635695001f21a25f1d533c53504552432036:1</span><br></pre></td></tr></table></figure>

<p>再次添加磁盘，成功！</p>
<hr>
<p>参考文档： <a href="https://kb.vmware.com/selfservice/microsites/search.do?cmd=displayKC&amp;externalId=2076191" target="_blank" rel="noopener">https://kb.vmware.com/selfservice/microsites/search.do?cmd=displayKC&amp;externalId=2076191</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ESXi</tag>
        <tag>vSphere</tag>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中先进先出队列queue的基本使用</title>
    <url>/2016/07/20/Python%E4%B8%AD%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%98%9F%E5%88%97queue%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>生活中非常常见的一种场景就是排队，早期的鸟儿🐦有虫🐛吃，越早排队就越早能办理业务。本篇文章介绍Python中的“排队系统”，先进先出队列的基本使用</p>
</blockquote>
<h1 id="put数据"><a href="#put数据" class="headerlink" title="put数据"></a>put数据</h1><h2 id="消息队列的长度"><a href="#消息队列的长度" class="headerlink" title="消息队列的长度"></a>消息队列的长度</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进先出队列</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多接收10个数据</span></span><br><span class="line">q = queue.Queue(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put 向队列中添加数据</span></span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前队列长度</span></span><br><span class="line">print(q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出最前面的一个数据</span></span><br><span class="line">print(q.get())</span><br></pre></td></tr></table></figure>

<h2 id="超时时间"><a href="#超时时间" class="headerlink" title="超时时间"></a>超时时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进先出队列</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多接收10个数据</span></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put 向队列中添加数据</span></span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line">print(q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超时时间为2秒</span></span><br><span class="line">q.put(<span class="string">'PolarSnow'</span>, timeout=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前队列长度</span></span><br><span class="line">print(q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出最前面的一个数据</span></span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/10/temp.py"</span>, line <span class="number">157</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    q.put(<span class="string">'PolarSnow'</span>, timeout=<span class="number">2</span>)</span><br><span class="line">  File <span class="string">"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/queue.py"</span>, line <span class="number">141</span>, <span class="keyword">in</span> put</span><br><span class="line">    <span class="keyword">raise</span> Full</span><br><span class="line">queue.Full</span><br></pre></td></tr></table></figure>

<p>现在队列的最大长度设置为2，当第三个数据向里面插入时，最多等待两秒，两秒后还没有进入到队列中就报错</p>
<h2 id="设置队列不阻塞"><a href="#设置队列不阻塞" class="headerlink" title="设置队列不阻塞"></a>设置队列不阻塞</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先进先出队列</span></span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最多接收10个数据</span></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># put 向队列中添加数据</span></span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置队列不阻塞(当队列满的时候再插入数据,直接报错)</span></span><br><span class="line">q.put(<span class="string">'PolarSnow'</span>, block=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前队列长度</span></span><br><span class="line">print(q.qsize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取出最前面的一个数据</span></span><br><span class="line">print(q.get())</span><br></pre></td></tr></table></figure>

<p>默认程序会阻塞，等待新的值插入到队列当中，使用了<code>block=False</code>参数后，强制设置为不阻塞，一旦超出队列长度，立即抛出异常</p>
<h1 id="get数据"><a href="#get数据" class="headerlink" title="get数据"></a>get数据</h1><h2 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">print(q.qsize())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get(timeout=<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>当取值的次数大于队列的长度的时候就会产生阻塞，设置超时时间意为最多等待x秒，队列中再没有数据，就抛出异常</p>
<h2 id="设置不阻塞"><a href="#设置不阻塞" class="headerlink" title="设置不阻塞"></a>设置不阻塞</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">print(q.qsize())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get(block=<span class="literal">False</span>))</span><br></pre></td></tr></table></figure>

<p>获取队列的次数大于队列长度时，默认会阻塞，通过设置<code>block=False</code>来实现非阻塞，立即抛出异常</p>
<h1 id="Queue类"><a href="#Queue类" class="headerlink" title="Queue类"></a>Queue类</h1><h2 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, maxsize=<span class="number">0</span>)</span>:</span></span><br><span class="line">    self.maxsize = maxsize</span><br><span class="line">    self._init(maxsize)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># mutex must be held whenever the queue is mutating.  All methods</span></span><br><span class="line">    <span class="comment"># that acquire mutex must release it before returning.  mutex</span></span><br><span class="line">    <span class="comment"># is shared between the three conditions, so acquiring and</span></span><br><span class="line">    <span class="comment"># releasing the conditions also acquires and releases mutex.</span></span><br><span class="line">    self.mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Notify not_empty whenever an item is added to the queue; a</span></span><br><span class="line">    <span class="comment"># thread waiting to get is notified then.</span></span><br><span class="line">    self.not_empty = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Notify not_full whenever an item is removed from the queue;</span></span><br><span class="line">    <span class="comment"># a thread waiting to put is notified then.</span></span><br><span class="line">    self.not_full = threading.Condition(self.mutex)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Notify all_tasks_done whenever the number of unfinished tasks</span></span><br><span class="line">    <span class="comment"># drops to zero; thread waiting to join() is notified to resume</span></span><br><span class="line">    self.all_tasks_done = threading.Condition(self.mutex)</span><br><span class="line">    self.unfinished_tasks = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>如果不给这个构造方法传参数，队列的长度为无限大</p>
<h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, block=True, timeout=None)</span>:</span></span><br><span class="line">    <span class="string">'''Remove and return an item from the queue.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If optional args 'block' is true and 'timeout' is None (the default),</span></span><br><span class="line"><span class="string">    block if necessary until an item is available. If 'timeout' is</span></span><br><span class="line"><span class="string">    a non-negative number, it blocks at most 'timeout' seconds and raises</span></span><br><span class="line"><span class="string">    the Empty exception if no item was available within that time.</span></span><br><span class="line"><span class="string">    Otherwise ('block' is false), return an item if one is immediately</span></span><br><span class="line"><span class="string">    available, else raise the Empty exception ('timeout' is ignored</span></span><br><span class="line"><span class="string">    in that case).</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">with</span> self.not_empty:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> block:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                <span class="keyword">raise</span> Empty</span><br><span class="line">        <span class="keyword">elif</span> timeout <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                self.not_empty.wait()</span><br><span class="line">        <span class="keyword">elif</span> timeout &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"'timeout' must be a non-negative number"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            endtime = time() + timeout</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self._qsize():</span><br><span class="line">                remaining = endtime - time()</span><br><span class="line">                <span class="keyword">if</span> remaining &lt;= <span class="number">0.0</span>:</span><br><span class="line">                    <span class="keyword">raise</span> Empty</span><br><span class="line">                self.not_empty.wait(remaining)</span><br><span class="line">        item = self._get()</span><br><span class="line">        self.not_full.notify()</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<p>参数为是否阻塞和超时时间</p>
<h2 id="get-nowait"><a href="#get-nowait" class="headerlink" title="get_nowait"></a>get_nowait</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_nowait</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''Remove and return an item from the queue without blocking.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Only get an item if one is immediately available. Otherwise</span></span><br><span class="line"><span class="string">    raise the Empty exception.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">return</span> self.get(block=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>非阻塞获取队列中的值</p>
<h2 id="put-amp-amp-put-nowait"><a href="#put-amp-amp-put-nowait" class="headerlink" title="put &amp;&amp; put_nowait"></a>put &amp;&amp; put_nowait</h2><p>与<code>get &amp; get_nowait</code>同理</p>
<h2 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''Return True if the queue is empty, False otherwise (not reliable!).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is likely to be removed at some point.  Use qsize() == 0</span></span><br><span class="line"><span class="string">    as a direct substitute, but be aware that either approach risks a race</span></span><br><span class="line"><span class="string">    condition where a queue can grow before the result of empty() or</span></span><br><span class="line"><span class="string">    qsize() can be used.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    To create code that needs to wait for all queued tasks to be</span></span><br><span class="line"><span class="string">    completed, the preferred technique is to use the join() method.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">with</span> self.mutex:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._qsize()</span><br></pre></td></tr></table></figure>

<p>检查队列是否为空，为空返回True，不为空返回False</p>
<h2 id="full"><a href="#full" class="headerlink" title="full"></a>full</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">full</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''Return True if the queue is full, False otherwise (not reliable!).</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This method is likely to be removed at some point.  Use qsize() &gt;= n</span></span><br><span class="line"><span class="string">    as a direct substitute, but be aware that either approach risks a race</span></span><br><span class="line"><span class="string">    condition where a queue can shrink before the result of full() or</span></span><br><span class="line"><span class="string">    qsize() can be used.</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">with</span> self.mutex:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> &lt; self.maxsize &lt;= self._qsize()</span><br></pre></td></tr></table></figure>

<p>判断队列是否已经满了</p>
<h2 id="qsize"><a href="#qsize" class="headerlink" title="qsize"></a>qsize</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qsize</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">'''Return the approximate size of the queue (not reliable!).'''</span></span><br><span class="line">    <span class="keyword">with</span> self.mutex:</span><br><span class="line">        <span class="keyword">return</span> self._qsize()</span><br></pre></td></tr></table></figure>

<p>返回队列中元素的个数（真实个数）</p>
<p>构造方法中封装了<code>maxsize</code>字段，可以使用<code>对象.maxsize</code>来获取当前队列的最大值</p>
<h2 id="join-amp-task-done"><a href="#join-amp-task-done" class="headerlink" title="join &amp; task_done"></a>join &amp; task_done</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br></pre></td></tr></table></figure>

<p>程序执行完这5行代码后会退出，退出前队列中还有值，退出后被清空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>

<p>程序会一直卡在第7行，只要队列中还有值，程序就不会退出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line">q.get()</span><br><span class="line"></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>

<p>队列中插入两个元素，后面取出了两个元素，执行后你会发现，程序还是卡在第10行的那个join代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.Queue(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">15</span>)</span><br><span class="line">q.put(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">q.get()</span><br><span class="line">q.task_done()  <span class="comment"># get取完队列中的一个值后，使用task_done方法告诉队列，我已经取出了一个值并处理完毕</span></span><br><span class="line">q.get()</span><br><span class="line">q.task_done()</span><br><span class="line"></span><br><span class="line">q.join()</span><br></pre></td></tr></table></figure>

<p>在每次get取值之后，还需要在跟队列声明一下，我已经取出了数据并处理完毕，这样执行到join代码的时候才不会被卡住</p>
<h1 id="Python提供的所有队列类型"><a href="#Python提供的所有队列类型" class="headerlink" title="Python提供的所有队列类型"></a>Python提供的所有队列类型</h1><ul>
<li>先进先出队列    queue.Queue</li>
<li>后进先出队列    queue.LifoQueue (Queue的基础上进行的封装)</li>
<li>优先级队列    queue.PriorityQueue (Queue的基础上进行的封装)</li>
<li>双向队列 queue.deque</li>
</ul>
<h2 id="后进先出队列"><a href="#后进先出队列" class="headerlink" title="后进先出队列"></a>后进先出队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'Polar'</span>)</span><br><span class="line">q.put(<span class="string">'Snow'</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Snow</span><br></pre></td></tr></table></figure>

<h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line">q.put((<span class="number">1</span>, <span class="string">'Snow'</span>))</span><br><span class="line">q.put((<span class="number">0</span>, <span class="string">'Polar'</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Polar</span><br></pre></td></tr></table></figure>

<p>数字越小优先级越高，数字相同，先进先出</p>
<h2 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q = queue.deque()</span><br><span class="line"></span><br><span class="line">q.append(<span class="string">'A'</span>)   <span class="comment"># 在右侧追加  A</span></span><br><span class="line">q.append(<span class="string">'X'</span>)   <span class="comment"># 在右侧追加  A X</span></span><br><span class="line">q.appendleft(<span class="string">'Z'</span>)   <span class="comment"># 在左侧追加  Z A X</span></span><br><span class="line">q.appendleft(<span class="string">'V'</span>)   <span class="comment"># 在左侧追加  V Z A X</span></span><br><span class="line"></span><br><span class="line">print(q.pop()) <span class="comment"># 从右侧取  --&gt; X</span></span><br><span class="line">print(q.popleft()) <span class="comment"># 从左侧取  --&gt; V</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">X</span><br><span class="line">V</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>queue</tag>
        <tag>先进先出队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Python多线程中的run方法</title>
    <url>/2016/07/20/Python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84run%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>Python中的多线程通过threading模块来实现。实现Python中的多线程有两种方式，本篇文章介绍多线程中，run方法的使用</p>
</blockquote>
<p>上一篇文章中介绍了多线程的基本使用方法，在执行Thread对象的start方法之后，声明指定的target函数已经就绪，准备被CPU调用执行。当CPU的时间片分到这个线程的时候，会去执行Thread对象的run方法</p>
<p>这里的start和run方法一定要区分开</p>
<ul>
<li>start方法是声明分到一个子线程的函数已经就绪，等待被CPU执行</li>
<li>run方法是执行到这个子线程时，自动调用的方法</li>
</ul>
<p>拿上一篇多线程基本使用文章中的例子🌰为例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'func start'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line">    print(<span class="string">'func end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line"><span class="comment"># target 指定让线程执行的函数</span></span><br><span class="line">t = threading.Thread(target=func, args=(<span class="string">'PolarSnow'</span>,))</span><br><span class="line">t.setDaemon(<span class="literal">True</span>) <span class="comment"># 默认为False</span></span><br><span class="line">t.start()</span><br><span class="line">t.join(<span class="number">1</span>) <span class="comment"># 主线程停在这里</span></span><br><span class="line">print(<span class="string">'main end'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">func start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p><code>t = threading.Thread(target=func, args=(&#39;PolarSnow&#39;,))</code>实例化了一个Thread对象，执行了Thread类的构造方法，构造方法源码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, group=None, target=None, name=None,</span></span></span><br><span class="line"><span class="function"><span class="params">                 args=<span class="params">()</span>, kwargs=None, *, daemon=None)</span>:</span></span><br><span class="line">        <span class="string">"""This constructor should always be called with keyword arguments. Arguments are:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *group* should be None; reserved for future extension when a ThreadGroup</span></span><br><span class="line"><span class="string">        class is implemented.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *target* is the callable object to be invoked by the run()</span></span><br><span class="line"><span class="string">        method. Defaults to None, meaning nothing is called.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *name* is the thread name. By default, a unique name is constructed of</span></span><br><span class="line"><span class="string">        the form "Thread-N" where N is a small decimal number.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *args* is the argument tuple for the target invocation. Defaults to ().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *kwargs* is a dictionary of keyword arguments for the target</span></span><br><span class="line"><span class="string">        invocation. Defaults to &#123;&#125;.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a subclass overrides the constructor, it must make sure to invoke</span></span><br><span class="line"><span class="string">        the base class constructor (Thread.__init__()) before doing anything</span></span><br><span class="line"><span class="string">        else to the thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">assert</span> group <span class="keyword">is</span> <span class="literal">None</span>, <span class="string">"group argument must be None for now"</span></span><br><span class="line">        <span class="keyword">if</span> kwargs <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            kwargs = &#123;&#125;</span><br><span class="line">        self._target = target</span><br><span class="line">        self._name = str(name <span class="keyword">or</span> _newname())</span><br><span class="line">        self._args = args</span><br><span class="line">        self._kwargs = kwargs</span><br><span class="line">        <span class="keyword">if</span> daemon <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self._daemonic = daemon</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._daemonic = current_thread().daemon</span><br><span class="line">        self._ident = <span class="literal">None</span></span><br><span class="line">        self._tstate_lock = <span class="literal">None</span></span><br><span class="line">        self._started = Event()</span><br><span class="line">        self._is_stopped = <span class="literal">False</span></span><br><span class="line">        self._initialized = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># sys.stderr is not stored in the class like</span></span><br><span class="line">        <span class="comment"># sys.exc_info since it can be changed between instances</span></span><br><span class="line">        self._stderr = _sys.stderr</span><br><span class="line">        <span class="comment"># For debugging and _after_fork()</span></span><br><span class="line">        _dangling.add(self)</span><br></pre></td></tr></table></figure>

<p>在Thread的构造方法中，封装了我们传进去的两个参数</p>
<p>而子线程被CPU调度执行的时候，自动执行了Thread对象中的run方法，run方法源码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Method representing the thread's activity.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        You may override this method in a subclass. The standard run() method</span></span><br><span class="line"><span class="string">        invokes the callable object passed to the object's constructor as the</span></span><br><span class="line"><span class="string">        target argument, if any, with sequential and keyword arguments taken</span></span><br><span class="line"><span class="string">        from the args and kwargs arguments, respectively.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> self._target:</span><br><span class="line">                self._target(*self._args, **self._kwargs)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># Avoid a refcycle if the thread is running a function with</span></span><br><span class="line">            <span class="comment"># an argument that has a member that points to the thread.</span></span><br><span class="line">            <span class="keyword">del</span> self._target, self._args, self._kwargs</span><br></pre></td></tr></table></figure>

<p>可以清楚的看到，这里<code>self._target(*self._args, **self._kwargs)</code>去执行了我们传进去的函数名所指向的函数体，简单的说，就是把target参数的那个函数执行了，并且参数就是我们传递进去的那些参数</p>
<h1 id="自定义run方法"><a href="#自定义run方法" class="headerlink" title="自定义run方法"></a>自定义run方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义一个类，继承threading.Thread</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">	<span class="comment"># 因为CPU执行子线程的时候，会自动执行Thread对象的run方法</span></span><br><span class="line">	<span class="comment"># 所以这里我们重写父类的run方法</span></span><br><span class="line">	<span class="comment"># 还记得Python的继承关系吗？self.run还是从原点开始找</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">t = MyThread() <span class="comment"># 创建一个线程对象</span></span><br><span class="line">t.start()  <span class="comment"># 等待被CPU运行</span></span><br></pre></td></tr></table></figure>

<h1 id="模拟Thread类的功能"><a href="#模拟Thread类的功能" class="headerlink" title="模拟Thread类的功能"></a>模拟Thread类的功能</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 重写父类的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">    	<span class="comment"># 将函数名和参数封装到本类中</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        <span class="comment"># 为保证继承的类正常运行，这里需要执行父类的构造方法</span></span><br><span class="line">        <span class="comment"># 但是没有给父类的构造方法传递任何参数</span></span><br><span class="line">        <span class="comment"># 而对象寻找参数时，也是最先从本类中寻找</span></span><br><span class="line">        super(MyThread, self).__init__()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="comment"># 执行参数中的函数</span></span><br><span class="line">        self.func(self.args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义一个需要子线程运行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(arg)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义的线程对象执行</span></span><br><span class="line">t = MyThread(func=f, args=<span class="number">59</span>)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p><em>实际使用中还是推荐使用threading原生提供的方式，这里的run方法仅供理解threading的内部执行过程</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>Thread</tag>
        <tag>threading</tag>
      </tags>
  </entry>
  <entry>
    <title>Python线程的基本使用</title>
    <url>/2016/07/17/Python%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="实例1-start"><a href="#实例1-start" class="headerlink" title="实例1 start"></a>实例1 start</h1><p>创建子线程并执行线程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'func start'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line">    print(<span class="string">'func end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line"><span class="comment"># target 指定让线程执行的函数</span></span><br><span class="line">t = threading.Thread(target=func, args=(<span class="string">'PolarSnow'</span>,))</span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'main end'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">func start</span><br><span class="line">main end</span><br><span class="line">PolarSnow</span><br><span class="line">func end</span><br></pre></td></tr></table></figure>

<p>上面的代码在主线程中创建了一个子线程去执行一个函数</p>
<p>执行这个函数最少需要2秒钟，而主线程直接去执行了<code>print(&#39;end&#39;)</code>，说明在默认情况下，主线程不会等待子线程直接结束再向下执行，而是主线程先向下执行，即使主线程所有代码已经执行完毕，也不会退出程序，而是等待所有子线程执行结束后再退出程序</p>
<h1 id="实例2-setDaemon"><a href="#实例2-setDaemon" class="headerlink" title="实例2 setDaemon"></a>实例2 setDaemon</h1><p>设置主线程不等待子线程执行完毕</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'func start'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line">    print(<span class="string">'func end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line"><span class="comment"># target 指定让线程执行的函数</span></span><br><span class="line">t = threading.Thread(target=func, args=(<span class="string">'PolarSnow'</span>,))</span><br><span class="line">t.setDaemon(<span class="literal">True</span>) <span class="comment"># 默认为False</span></span><br><span class="line">t.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'main end'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">func start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p>在启动线程之前设置<code>t.setDaemon(True)</code>为True，意思是主线程不会等待所有的子线程执行完毕再退出程序，而是当主线程执行完毕后，强制退出程序，不管子线程有没有执行完毕</p>
<h1 id="实例3-join"><a href="#实例3-join" class="headerlink" title="实例3 join"></a>实例3 join</h1><p>主线程等待子线程执行完毕后，再向下执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'func start'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line">    print(<span class="string">'func end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line"><span class="comment"># target 指定让线程执行的函数</span></span><br><span class="line">t = threading.Thread(target=func, args=(<span class="string">'PolarSnow'</span>,))</span><br><span class="line">t.setDaemon(<span class="literal">True</span>) <span class="comment"># 默认为False</span></span><br><span class="line">t.start()</span><br><span class="line">t.join() <span class="comment"># 主线程停在这里</span></span><br><span class="line">print(<span class="string">'main end'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">func start</span><br><span class="line">PolarSnow</span><br><span class="line">func end</span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p>使用了join方法之后，主线程会一直停在join方法那一行，直到所有的子线程都执行完毕后，再继续向下执行</p>
<h1 id="实例4-join-1"><a href="#实例4-join-1" class="headerlink" title="实例4 join(1)"></a>实例4 join(1)</h1><p>设置主线程再次等待子线程的最大时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'func start'</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(arg)</span><br><span class="line">    print(<span class="string">'func end'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个线程</span></span><br><span class="line"><span class="comment"># target 指定让线程执行的函数</span></span><br><span class="line">t = threading.Thread(target=func, args=(<span class="string">'PolarSnow'</span>,))</span><br><span class="line">t.setDaemon(<span class="literal">True</span>) <span class="comment"># 默认为False</span></span><br><span class="line">t.start()</span><br><span class="line">t.join(<span class="number">1</span>) <span class="comment"># 主线程停在这里</span></span><br><span class="line">print(<span class="string">'main end'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">func start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure>

<p>设置为主线程在<code>t.join</code>这一行，<strong>最多</strong>等待1秒钟的时间，1秒钟之后，不管子线程有没有执行完毕都会继续向下执行</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的多进程与多线程简介</title>
    <url>/2016/07/17/Python%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p><img src="http://oss.20150509.cn/20160717122059.png" alt=""></p>
<p>在Python中规定，每一个进程中只可以有一个线程在同一时刻被调用执行，GIL全局解释器锁，就是用来保障这一规则顺利被执行的组件</p>
<p>Python中可以利用多核CPU的是多进程，多个CPU可以同时处理多个进程的任务，但是，每个进程中同一时间只能处理一个线程</p>
<p><em>IO操作不占用CPU</em></p>
<ul>
<li>多线程的应用场景：IO操作</li>
<li>多进程的应用场景：计算性操作</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>socketserver源码阅读</title>
    <url>/2016/07/17/socketserver%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<blockquote>
<p>本篇socketserver源码阅读主要目的是熟悉Python中的继承模式</p>
</blockquote>
<h1 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">obj = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>), MyClass)</span><br><span class="line">obj.serve_forever()</span><br></pre></td></tr></table></figure>

<h1 id="阅读入口"><a href="#阅读入口" class="headerlink" title="阅读入口"></a>阅读入口</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>), MyClass)</span><br></pre></td></tr></table></figure>

<p>从以上这一行代码中可以看出，执行了<code>ThreadingTCPServer</code>类中的<code>__init__</code>方法（实例化了这个类的对象，就从这里为入口点来阅读）</p>
<h1 id="ThreadingTCPServer类图"><a href="#ThreadingTCPServer类图" class="headerlink" title="ThreadingTCPServer类图"></a>ThreadingTCPServer类图</h1><p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/20160717000559.png" alt=""></p>
<h1 id="step-by-step"><a href="#step-by-step" class="headerlink" title="step by step"></a>step by step</h1><h2 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h2><p>首先，从实例化<code>ThreadingTCPServer</code>这个类的对象可以得知，是执行了这个对象的<code>__init__</code>构造方法，但是我们查看这个类的源码发现，只有一个<code>pass</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingTCPServer</span><span class="params">(ThreadingMixIn, TCPServer)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但是这个类继承了两个父类，那么必然是执行了父类的<code>__init__</code>方法。在查找父类<code>__init__</code>方法的时候，首先从左边的父类开始查找</p>
<h2 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h2><p><code>ThreadingTCPServer</code>继承的第一个父类中<code>ThreadingMixIn</code>，没有找到<code>__init__</code>构造方法，接着，Python会去<code>ThreadingTCPServer</code>继承的第二个父类总去查找</p>
<h2 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h2><p>在<code>ThreadingTCPServer</code>继承的第二个父类<code>TCPServer</code>找到了<code>__init__</code>构造方法并执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address, RequestHandlerClass, bind_and_activate=True)</span>:</span></span><br><span class="line">    <span class="string">"""Constructor.  May be extended, do not override."""</span></span><br><span class="line">    BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">    self.socket = socket.socket(self.address_family,</span><br><span class="line">                                self.socket_type)</span><br><span class="line">    <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.server_bind()</span><br><span class="line">            self.server_activate()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.server_close()</span><br><span class="line">            <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>

<p>在这段构造方法中，前三个参数对应了示例代码中，创建<code>ThreadingTCPServer</code>对象时的三个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>), MyClass)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address, RequestHandlerClass, bind_and_activate=True)</span>:</span></span><br></pre></td></tr></table></figure>

<ul>
<li>self —&gt; obj</li>
<li>server_address —&gt; (‘127.0.0.1’, 1559)</li>
<li>RequestHandlerClass —&gt; MyClass</li>
</ul>
<p>在<code>TCPServer</code>的构造方法拿到这几个参数之后，紧接着又调用了父类的<code>__init__</code>构造方法</p>
<h3 id="step-3-1"><a href="#step-3-1" class="headerlink" title="step 3.1"></a>step 3.1</h3><p>在<code>TCPServer</code>的父类<code>BaseServer</code>中，<code>__init__</code>构造方法执行了以下内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address, RequestHandlerClass)</span>:</span></span><br><span class="line">    <span class="string">"""Constructor.  May be extended, do not override."""</span></span><br><span class="line">    self.server_address = server_address</span><br><span class="line">    self.RequestHandlerClass = RequestHandlerClass</span><br><span class="line">    self.__is_shut_down = threading.Event()</span><br><span class="line">    self.__shutdown_request = <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>创建了两个公有变量和两个私有变量，并且</p>
<ul>
<li>RequestHandlerClass —&gt; MyClass</li>
</ul>
<h2 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h2><p><code>TCPServer</code>在执行完父类的构造方法封装了四个字段后，继续向下执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br></pre></td></tr></table></figure>

<p>创建了一个socket对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> bind_and_activate:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.server_bind()</span><br><span class="line">        self.server_activate()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        self.server_close()</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>

<h3 id="step-4-1"><a href="#step-4-1" class="headerlink" title="step 4.1"></a>step 4.1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_bind</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Called by constructor to bind the socket.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    May be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> self.allow_reuse_address:</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    self.socket.bind(self.server_address)</span><br><span class="line">    self.server_address = self.socket.getsockname()</span><br></pre></td></tr></table></figure>

<p>绑定了IP和端口号，<code>self.server_address</code>的值是在执行父类<code>BaseServer</code>的构造方法时创建的</p>
<h3 id="step-4-2"><a href="#step-4-2" class="headerlink" title="step 4.2"></a>step 4.2</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_activate</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Called by constructor to activate the server.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    May be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.socket.listen(self.request_queue_size)</span><br></pre></td></tr></table></figure>

<p>监听socket</p>
<p>至此，<code>TCPServer</code>中的<code>__init__</code>构造方法执行完毕，构造方法执行完毕，就意味着示例代码中的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>), MyClass)</span><br></pre></td></tr></table></figure>

<p>这一句就执行完毕了</p>
<h2 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h2><p>接下来测试代码走到第10行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj.serve_forever()</span><br></pre></td></tr></table></figure>

<p><code>ThreadingTCPServer</code>首先在自己的代码块中查找，没有</p>
<p>根据继承的规则，再去左边的父类<code>ThreadingMixIn</code>中查找，没有</p>
<p>之后再去右边的父类<code>TCPServer</code>中查找，没有</p>
<p>最后在<code>TCPServer</code>的父类<code>BaseServer</code>中找到了<code>serve_forever</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self, poll_interval=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Handle one request at a time until shutdown.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Polls for shutdown every poll_interval seconds. Ignores</span></span><br><span class="line"><span class="string">    self.timeout. If you need to do periodic tasks, do them in</span></span><br><span class="line"><span class="string">    another thread.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.__is_shut_down.clear()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># <span class="doctag">XXX:</span> Consider using another file descriptor or connecting to the</span></span><br><span class="line">        <span class="comment"># socket to wake this up instead of polling. Polling reduces our</span></span><br><span class="line">        <span class="comment"># responsiveness to a shutdown request and wastes cpu at all other</span></span><br><span class="line">        <span class="comment"># times.</span></span><br><span class="line">        <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> selector:</span><br><span class="line">            selector.register(self, selectors.EVENT_READ)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">                ready = selector.select(poll_interval)  <span class="comment"># IO多路复用</span></span><br><span class="line">                <span class="keyword">if</span> ready:  <span class="comment"># 如果有新的客户端连接，ready就会有值</span></span><br><span class="line">                    self._handle_request_noblock()</span><br><span class="line"></span><br><span class="line">                self.service_actions()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">        self.__is_shut_down.set()</span><br></pre></td></tr></table></figure>

<h3 id="step-5-1"><a href="#step-5-1" class="headerlink" title="step 5.1"></a>step 5.1</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ready = selector.select(poll_interval)</span><br></pre></td></tr></table></figure>

<p>IO多路复用，这里没有使用self来调，而是使用selector对象来调select方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, timeout=None)</span>:</span></span><br><span class="line">    timeout = <span class="literal">None</span> <span class="keyword">if</span> timeout <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> max(timeout, <span class="number">0</span>)</span><br><span class="line">    ready = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        r, w, _ = self._select(self._readers, self._writers, [], timeout)</span><br><span class="line">    <span class="keyword">except</span> InterruptedError:</span><br><span class="line">        <span class="keyword">return</span> ready</span><br><span class="line">    r = set(r)</span><br><span class="line">    w = set(w)</span><br><span class="line">    <span class="keyword">for</span> fd <span class="keyword">in</span> r | w:</span><br><span class="line">        events = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> fd <span class="keyword">in</span> r:</span><br><span class="line">            events |= EVENT_READ</span><br><span class="line">        <span class="keyword">if</span> fd <span class="keyword">in</span> w:</span><br><span class="line">            events |= EVENT_WRITE</span><br><span class="line"></span><br><span class="line">        key = self._key_from_fd(fd)</span><br><span class="line">        <span class="keyword">if</span> key:</span><br><span class="line">            ready.append((key, events &amp; key.events))</span><br><span class="line">    <span class="keyword">return</span> ready</span><br></pre></td></tr></table></figure>


<h3 id="step-5-2"><a href="#step-5-2" class="headerlink" title="step 5.2"></a>step 5.2</h3><p>在有客户端连接进来的时候，ready就有有值，为真，会执行<code>self._handle_request_noblock</code>方法</p>
<p>因为是self.来调用的，根据继承规则，就要回到最开始的类中，再逐级向上查找，所以回到<code>ThreadingTCPServer</code>中查找，没有</p>
<p>根据继承的规则，再去左边的父类<code>ThreadingMixIn</code>中查找，没有</p>
<p>之后再去右边的父类<code>TCPServer</code>中查找，没有</p>
<p>最后在<code>TCPServer</code>的父类<code>BaseServer</code>中找到了<code>_handle_request_noblock</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_handle_request_noblock</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Handle one request, without blocking.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    I assume that selector.select() has returned that the socket is</span></span><br><span class="line"><span class="string">    readable before this function was called, so there should be no risk of</span></span><br><span class="line"><span class="string">    blocking in get_request().</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request, client_address = self.get_request() <span class="comment"># 获取到客户端连接对象socket，和客户端地址</span></span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> self.verify_request(request, client_address):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.process_request(request, client_address)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br></pre></td></tr></table></figure>

<h3 id="step-5-3"><a href="#step-5-3" class="headerlink" title="step 5.3"></a>step 5.3</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">request, client_address = self.get_request()</span><br></pre></td></tr></table></figure>

<p>根据类图查找，在TCPServer类中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="string">"""Get the request and client address from the socket.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    May be overridden.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> self.socket.accept()</span><br></pre></td></tr></table></figure>

<p>接受客户端连接请求</p>
<h2 id="step-6"><a href="#step-6" class="headerlink" title="step 6"></a>step 6</h2><p>在<code>_handle_request_noblock</code>方法中又执行了<code>self.process_request</code>方法</p>
<p>回到<code>ThreadingTCPServer</code>中查找，没有</p>
<p>根据继承的规则，在左边的父类<code>ThreadingMixIn</code>中找到该方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">    <span class="string">"""Start a new thread to process the request."""</span></span><br><span class="line">    t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                         args = (request, client_address))</span><br><span class="line">    t.daemon = self.daemon_threads</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure>

<p>在这个方法中，使用了多线程去执行<code>self.process_request_thread</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                         args = (request, client_address))</span><br></pre></td></tr></table></figure>

<p>使用了self调用，还是要从头查找</p>
<h2 id="step-7"><a href="#step-7" class="headerlink" title="step 7"></a>step 7</h2><p>在<code>ThreadingMixIn</code>类中找到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_request_thread</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">    <span class="string">"""Same as in BaseServer but as a thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    In addition, exception handling is done here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.finish_request(request, client_address)</span><br><span class="line">        self.shutdown_request(request)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        self.handle_error(request, client_address)</span><br><span class="line">        self.shutdown_request(request)</span><br></pre></td></tr></table></figure>

<p>这个方法应该是用来接收客户端发来的请求以及给客户端发送消息</p>
<h2 id="step-8"><a href="#step-8" class="headerlink" title="step 8"></a>step 8</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">self.finish_request(request, client_address)</span><br></pre></td></tr></table></figure>

<p>根据类图，在<code>BaseServer</code>中找到</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">finish_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">    <span class="string">"""Finish one request by instantiating RequestHandlerClass."""</span></span><br><span class="line">    self.RequestHandlerClass(request, client_address, self)</span><br></pre></td></tr></table></figure>

<p>在<code>step3</code>中已经封装了<code>RequestHandlerClass = MyClass</code></p>
<p>相当于执行了MyClass的构造方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">MyClass(request, client_address, self)</span><br></pre></td></tr></table></figure>

<h2 id="step-9"><a href="#step-9" class="headerlink" title="step 9"></a>step 9</h2><p>MyClass中没有定义构造方法，在MyClass继承的父类<code>socketserver.BaseRequestHandler</code>中查找，找到了构造方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request, client_address, server)</span>:</span></span><br><span class="line">    self.request = request</span><br><span class="line">    self.client_address = client_address</span><br><span class="line">    self.server = server</span><br><span class="line">    self.setup()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        self.handle()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.finish()</span><br></pre></td></tr></table></figure>

<p>执行了<code>self.handle()</code></p>
<h2 id="step-10"><a href="#step-10" class="headerlink" title="step 10"></a>step 10</h2><p>执行<code>self.handle()</code>方法时，就会执行MyClass中定义的<code>handle</code>方法</p>
<p>在示例代码中，我们已经自定义了一个方法去实现与客户端的交互，</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socketserver</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS挂载exFAT文件系统</title>
    <url>/2016/07/15/CentOS%E6%8C%82%E8%BD%BDexFAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="下载软件"><a href="#下载软件" class="headerlink" title="下载软件"></a>下载软件</h1><p><a href="http://oss.20150509.cn/exfat-utils-1.0.1-2.el6.src.rpm" target="_blank" rel="noopener">http://oss.20150509.cn/exfat-utils-1.0.1-2.el6.src.rpm</a></p>
<p><a href="http://oss.20150509.cn/fuse-exfat-1.0.1-2.el6.src.rpm" target="_blank" rel="noopener">http://oss.20150509.cn/fuse-exfat-1.0.1-2.el6.src.rpm</a></p>
<h1 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; yum install scons gcc  <span class="comment"># 编译安装需要系统有这两个软件的支持</span></span><br><span class="line">&gt; yum install fuse-devel  <span class="comment"># fuse模块，编译需要fuse-devel包支持</span></span><br><span class="line">&gt; rpm -ivh fuse-exfat-1.0.1-2.el6.src.rpm exfat-utils-1.0.1-2.el6.src.rpm&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">cd</span> ~/rpmbuild/SPECS</span><br><span class="line">&gt; rpmbuild -ba fuse-exfat.spec</span><br><span class="line">&gt; rpmbuild -ba exfat-utils.spec</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="built_in">cd</span> ~/rpmbuild/RPMS/x86_64</span><br><span class="line">&gt; rpm -ivh fuse-exfat-1.0.1-2.el6.x86_64.rpm exfat-utils-1.0.1-2.el6.x86_64.rpm</span><br></pre></td></tr></table></figure>

<h1 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mount.exfat /dev/sdx /mnt</span><br><span class="line">&gt; <span class="comment"># or</span></span><br><span class="line">&gt; mount -t exfat /dev/sdx /mnt</span><br></pre></td></tr></table></figure>

<p><em>如果指定-t找不到此类型的话执行：ln -s /usr/sbin/mount.exfat /sbin/mount.exfat</em></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>exFAT</tag>
        <tag>mount</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下使用IO多路复用(入门篇)</title>
    <url>/2016/07/12/Python%E4%B8%8B%E4%BD%BF%E7%94%A8IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>IO操作是不占用CPU的，IO多路复用，是要管理起所有的IO操作。IO多路复用的典型场景是监听socket对象内部是否发生了变化</p>
</blockquote>
<p>socket内部什么时候会有变化：</p>
<ul>
<li>建立连接</li>
<li>发送消息</li>
</ul>
<h1 id="socket实例"><a href="#socket实例" class="headerlink" title="socket实例"></a>socket实例</h1><p>这里使用socket实现一个简单的Echo Server的功能</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环接受每一个连接池中的连接</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 接受客户端连接</span></span><br><span class="line">    conn, address = sk.accept()</span><br><span class="line">    <span class="comment"># 向客户端发送欢迎消息</span></span><br><span class="line">    conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 进入到收发消息的循环中</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Windows客户端在异常断开后抛出异常,这里是处理Windows的断开情况</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            recv = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Linux客户端断开recv会是空值,这里处理Linux的断开情况</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> recv:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 这里处理客户端主动发出断开请求的情况</span></span><br><span class="line">            <span class="keyword">if</span> str(recv, encoding=<span class="string">'utf-8'</span>) == <span class="string">'exit'</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向客户端发送数据</span></span><br><span class="line">        conn.sendall(recv)</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息</span></span><br><span class="line">data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = input(<span class="string">"&gt; "</span>)</span><br><span class="line">    <span class="comment"># 向服务端发送消息</span></span><br><span class="line">    sk.sendall(bytes(i, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收服务端发来的消息</span></span><br><span class="line">    msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(msg, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>以上的socket代码同一时间仅能处理一个客户端的请求，之后连接上来的客户端在第一个客户端还没有断开的时候，会一直等待，直到上一个客户端的请求断开</p>
<h1 id="select-selext-中的第一个参数"><a href="#select-selext-中的第一个参数" class="headerlink" title="select.selext()中的第一个参数"></a>select.selext()中的第一个参数</h1><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>上面说到，一种socket会变的情况是建立连接</p>
<p>上面的代码中，涉及到建立连接的socket是sk对象（变量）sk对象在执行到<code>sk.accept()</code>时，接受了一个新客户端的连接请求时候，socket内部就发生了变化，我们就需要监听这种变化，用以分辨出新的客户端的连接</p>
<p><em>创建socket，绑定并监听之后socket一般不会发生变化，只有当有新的客户端连接进来的时候，socket才会发生变化，我们需要监听的也是这个阶段的变化</em></p>
<p><strong>得出结论：当socket被创建、绑定并监听之后发生变化，就是有新的客户端进行连接</strong></p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, w, e = select.select([sk,], [], [], <span class="number">1</span>)</span><br><span class="line">    print(rList)</span><br></pre></td></tr></table></figure>

<p>上面代码引入了IO多路复用中的select模型，使用select.select()方法，会返回一个有三个元素的元祖</p>
<p>在select.select()方法中的第一个参数，暂时只添加了一个服务端的socket对象，只要服务端socket对象sk有变化（新的客户端连接）就立即把变化的socket对象加入到rList列表中</p>
<p><strong>监听的socket列表中，sk对象有变化 —&gt; rList = [sk]</strong></p>
<p><strong>监听的socket列表中，没有socket发生变化 —&gt; rList = []</strong></p>
<p>以上代码跑起来的效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">...</span><br><span class="line"># 每秒打印一个[]</span><br><span class="line"># select.sekect()中的第四个参数起了作用</span><br><span class="line"># 超时时间，监听的对象没有发生变化的时候，多少秒循环一次</span><br></pre></td></tr></table></figure>

<p>说明没有新的连接请求，下面将试验有客户端连接产生的情况</p>
<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>客户端一旦连接到服务端，服务端的回显如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">...</span><br><span class="line"># 疯狂的快速打印...</span><br></pre></td></tr></table></figure>
<p>从上面可以看出，有一个客户端连接进来了。服务端的sk对象内部发生了变化，当select监听到sk对象发生变化后，立即将发生变化的对象赋值给了rList列表（append到列表）从打印出来的内容中可以看出，列表中的元素是发生变化的socket对象</p>
<h3 id="处理rList（服务端socket）"><a href="#处理rList（服务端socket）" class="headerlink" title="处理rList（服务端socket）"></a>处理rList（服务端socket）</h3><p>rList中保存了所有发生变化的socket对象，以上代码中只监听了服务端socket对象，这里暂时只讨论服务端socket变化的情况</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	<span class="comment"># 监听服务端socket对象sk</span></span><br><span class="line">    rList, w, e = select.select([sk,], [], [], <span class="number">1</span>)</span><br><span class="line">    print(rList)</span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 遍历rList中的每一个socket对象</span></span><br><span class="line">	<span class="comment"># 目前rList中只会出现服务端的socket对象</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        conn, address = s.accept()</span><br><span class="line">        conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    input(<span class="string">"&gt; "</span>)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>连续运行三个客户端连接时，服务端的回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">[]</span><br><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">[]</span><br><span class="line">[&lt;socket.socket fd&#x3D;3, family&#x3D;AddressFamily.AF_INET, type&#x3D;SocketKind.SOCK_STREAM, proto&#x3D;0, laddr&#x3D;(&#39;127.0.0.1&#39;, 1559)&gt;]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>


<p><strong>每个</strong>客户端的回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;hello&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>以上通过对rList中服务端socket对象执行accept()方法，来实现了一个类似并发连接的效果，每一个连接进来的客户端都会被服务端接受请求，“同时”提供服务</p>
<h2 id="接收客户端消息"><a href="#接收客户端消息" class="headerlink" title="接收客户端消息"></a>接收客户端消息</h2><p>上面提到，不仅创建连接会触发socket的变化，与客户端连接建立后，客户端发来消息，也会引发客户端socket连接的内部变化</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, w, e = select.select(inputs, [], [], <span class="number">1</span>)</span><br><span class="line">    print(rList)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        conn, address = s.accept()</span><br><span class="line">        <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">        <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">        <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">        <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">        inputs.append(conn)</span><br><span class="line">        conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我把服务端socket为新客户端创建的socket也加入到了监听列表中，那么如果有客户端发来消息，select监听到客户端socket（conn）发生变化并加入到rList列表中后，在for循环处理中，客户端的socket并没有accept()方法，而且也不要这个方法，这就需要在for循环中对两类socket区分对待</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, w, e = select.select(inputs, [], [], <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"select当前监听socket对象的数量&gt;"</span>, len(inputs), <span class="string">" | 发生变化的socket数量&gt;"</span>, len(rList))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        <span class="comment"># 判断socket对象如果是服务端的socket对象的话</span></span><br><span class="line">        <span class="keyword">if</span> s == sk:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">            <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">            <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">            <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="comment"># 其他的就都是客户端的socket对象了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 意味着客户端给服务端发送消息了</span></span><br><span class="line">            msg = s.recv(<span class="number">1024</span>)</span><br><span class="line">            print(msg)</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息</span></span><br><span class="line">data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = input(<span class="string">"&gt; "</span>)</span><br><span class="line">    <span class="comment"># 向服务端发送消息</span></span><br><span class="line">    sk.sendall(bytes(i, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>当我运行一个客户端，并Ctrl+C退出时，服务端回显界面在疯狂的打印消息。问题出在了服务端监听的客户端socket连接，当客户端与服务端断开连接时，应在服务端select监听socket对象列表中将该客户端socket对象移除</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, w, e = select.select(inputs, [], [], <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"select当前监听socket对象的数量&gt;"</span>, len(inputs), <span class="string">" | 发生变化的socket数量&gt;"</span>, len(rList))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        <span class="comment"># 判断socket对象如果是服务端的socket对象的话</span></span><br><span class="line">        <span class="keyword">if</span> s == sk:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">            <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">            <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">            <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="comment"># 其他的就都是客户端的socket对象了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 意味着客户端给服务端发送消息了</span></span><br><span class="line">                msg = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Linux平台下的处理</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'客户端已断开连接'</span>)</span><br><span class="line">                print(msg)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                <span class="comment"># Windows平台下的处理</span></span><br><span class="line">                inputs.remove(s)</span><br></pre></td></tr></table></figure>

<p>使用最新的server.py与client.py进行测试时，依次运行多个客户端，再依次关闭多个客户端，服务端的回显如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听socket对象的数量&gt; 2  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 2  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 2  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听socket对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 4  | 发生变化的socket数量&gt; 1</span><br><span class="line">b&#39;&#39;</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 3  | 发生变化的socket数量&gt; 1</span><br><span class="line">b&#39;&#39;</span><br><span class="line">select当前监听socket对象的数量&gt; 2  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 2  | 发生变化的socket数量&gt; 1</span><br><span class="line">b&#39;&#39;</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听socket对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br></pre></td></tr></table></figure>

<p><strong>特别注意：</strong>这里的服务端定义，当我收到客户端发来的空值的时候，我就默认认为客户端主动需要断开与服务端的连接。由于服务端的这个默认规则，在写客户端的时候，一定要注意处理客户端输入的值为空的情况</p>
<h2 id="给客户端回复消息"><a href="#给客户端回复消息" class="headerlink" title="给客户端回复消息"></a>给客户端回复消息</h2><ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, w, e = select.select(inputs, [], [], <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"select当前监听socket对象的数量&gt;"</span>, len(inputs), <span class="string">" | 发生变化的socket数量&gt;"</span>, len(rList))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        <span class="comment"># 判断socket对象如果是服务端的socket对象的话</span></span><br><span class="line">        <span class="keyword">if</span> s == sk:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">            <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">            <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">            <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="comment"># 其他的就都是客户端的socket对象了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 意味着客户端给服务端发送消息了</span></span><br><span class="line">                msg = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Linux平台下的处理</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'客户端已断开连接'</span>)</span><br><span class="line">                print(msg)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 向客户端回复消息</span></span><br><span class="line">                <span class="comment"># 这种写法是完全可以的,但是缺点是读写都混在了一起</span></span><br><span class="line">                s.sendall(msg)</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                <span class="comment"># Windows平台下的处理</span></span><br><span class="line">                inputs.remove(s)</span><br></pre></td></tr></table></figure>

<p>但是一般情况下，会做读写分离，可以通过select，实现读写分离（收发分离）</p>
<h1 id="select-selext-中的第二个参数"><a href="#select-selext-中的第二个参数" class="headerlink" title="select.selext()中的第二个参数"></a>select.selext()中的第二个参数</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rList, wList, e = select.select([], [], [], <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>select.select()的第二个参数有什么值，wList中就会有什么值</p>
<p>利用select的这个特性，可以把需要回复消息的客户端socket对象赋值给select的第二个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line">outputs = []</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, wList, e = select.select(inputs, outputs, [], <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"---"</span> * <span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"select当前监听inputs对象的数量&gt;"</span>, len(inputs), <span class="string">" | 发生变化的socket数量&gt;"</span>, len(rList))</span><br><span class="line">    print(<span class="string">"select当前监听outputs对象的数量&gt;"</span>, len(outputs), <span class="string">" | 需要回复客户端消息的数量&gt;"</span>, len(wList))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历rList(建立连接和接收数据)</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        <span class="comment"># 判断socket对象如果是服务端的socket对象的话</span></span><br><span class="line">        <span class="keyword">if</span> s == sk:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">            <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">            <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">            <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">            inputs.append(conn)</span><br><span class="line">            conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="comment"># 其他的就都是客户端的socket对象了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 意味着客户端给服务端发送消息了</span></span><br><span class="line">                msg = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Linux平台下的处理</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'客户端已断开连接'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    outputs.append(s)</span><br><span class="line">                    print(msg)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 向客户端回复消息</span></span><br><span class="line">                <span class="comment"># 这种写法是完全可以的,但是缺点是读写都混在了一起</span></span><br><span class="line">                <span class="comment"># s.sendall(msg)</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                <span class="comment"># Windows平台下的处理</span></span><br><span class="line">                inputs.remove(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历wList(遍历给服务端发送过消息的客户端)</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> wList:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 给所有的客户端统一回复内容</span></span><br><span class="line">        s.sendall(bytes(<span class="string">'server response'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回复完成后,一定要将outputs中该socket对象移除</span></span><br><span class="line">        outputs.remove(s)</span><br></pre></td></tr></table></figure>

<p>wList = 所有给服务端发送消息的客户端，也是需要回复消息客户端列表</p>
<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.connect((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line"><span class="comment"># 接收欢迎消息</span></span><br><span class="line">data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">print(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    i = input(<span class="string">"&gt; "</span>)</span><br><span class="line">    <span class="comment"># 向服务端发送消息</span></span><br><span class="line">    sk.sendall(bytes(i, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收服务端发来的消息</span></span><br><span class="line">    msg = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(msg, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ul>
<li>依次连接三个客户端</li>
<li>第一个客户端依次向服务发送了两次消息</li>
</ul>
<p>服务端的回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 2  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 2  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 3  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">b&#39;ps&#39;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 1  | 需要回复客户端消息的数量&gt; 1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">b&#39;ps&#39;</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 1  | 需要回复客户端消息的数量&gt; 1</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 4  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 3  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 2  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 2  | 发生变化的socket数量&gt; 1</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">select当前监听inputs对象的数量&gt; 1  | 发生变化的socket数量&gt; 0</span><br><span class="line">select当前监听outputs对象的数量&gt; 0  | 需要回复客户端消息的数量&gt; 0</span><br></pre></td></tr></table></figure>

<p>第一个客户端的回显：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b&#39;hello&#39;</span><br><span class="line">&gt; ps</span><br><span class="line">server response</span><br><span class="line">&gt; ps</span><br><span class="line">server response</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>以上代码实现了简单的收发消息的分离，现在又多了一点需求，目前所有给服务端发送消息的客户端，服务端都统一回复了相同的内容，现在要服务端实现Echo Server的功能，即客户端发送什么消息，服务端就给客户端回复什么消息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建socket对象,绑定IP端口,监听</span></span><br><span class="line">sk = socket.socket()</span><br><span class="line">sk.bind((<span class="string">'127.0.0.1'</span>, <span class="number">1559</span>))</span><br><span class="line">sk.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">inputs = [sk]</span><br><span class="line">outputs = []</span><br><span class="line">messages = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">messages = &#123;</span></span><br><span class="line"><span class="string">    socket_obj1: [msg]</span></span><br><span class="line"><span class="string">    socket_obj2: [msg]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    rList, wList, e = select.select(inputs, outputs, [], <span class="number">1</span>)</span><br><span class="line">    print(<span class="string">"---"</span> * <span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"select当前监听inputs对象的数量&gt;"</span>, len(inputs), <span class="string">" | 发生变化的socket数量&gt;"</span>, len(rList))</span><br><span class="line">    print(<span class="string">"select当前监听outputs对象的数量&gt;"</span>, len(outputs), <span class="string">" | 需要回复客户端消息的数量&gt;"</span>, len(wList))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历rList(建立连接和接收数据)</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> rList:</span><br><span class="line">        <span class="comment"># 判断socket对象如果是服务端的socket对象的话</span></span><br><span class="line">        <span class="keyword">if</span> s == sk:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="comment"># conn也是一个socket对象</span></span><br><span class="line">            <span class="comment"># 当服务端socket接收到客户的请求后,会分配一个新的socket对象专门用来和这个客户端进行连接通信</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当服务端分配新的socket对象给新连接进来的客户端的时候</span></span><br><span class="line">            <span class="comment"># 我们也需要监听这个客户端的socket对象是否会发生变化</span></span><br><span class="line">            <span class="comment"># 一旦发生变化,意味着客户端向服务器端发来了消息</span></span><br><span class="line">            inputs.append(conn)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 在messages中为该对象创建key</span></span><br><span class="line">            messages[conn] = []</span><br><span class="line"></span><br><span class="line">            conn.sendall(bytes(<span class="string">'hello'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="comment"># 其他的就都是客户端的socket对象了</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 意味着客户端给服务端发送消息了</span></span><br><span class="line">                msg = s.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># Linux平台下的处理</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">                    <span class="keyword">raise</span> Exception(<span class="string">'客户端已断开连接'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    outputs.append(s)</span><br><span class="line">                    messages[s].append(msg)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 向客户端回复消息</span></span><br><span class="line">                <span class="comment"># 这种写法是完全可以的,但是缺点是读写都混在了一起</span></span><br><span class="line">                <span class="comment"># s.sendall(msg)</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">                <span class="comment"># Windows平台下的处理</span></span><br><span class="line">                inputs.remove(s)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 在客户端断开连接后,相对应的该客户端的messages中的信息也需要删除</span></span><br><span class="line">                <span class="keyword">del</span> messages[s]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历wList(遍历给服务端发送过消息的客户端)</span></span><br><span class="line">    <span class="keyword">for</span> s <span class="keyword">in</span> wList:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在该客户端连接对象的messages信息中取出一个进行回复</span></span><br><span class="line">        msg = messages[s].pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据客户端发来的消息进行回复</span></span><br><span class="line">        s.sendall(msg)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 回复完成后,一定要将outputs中该socket对象移除</span></span><br><span class="line">        outputs.remove(s)</span><br></pre></td></tr></table></figure>

<p>服务端做出以上修改，客户端不需要改变</p>
<ul>
<li>11行 为了让一个客户端socket对象收消息和发消息产生关联，引入了一个新的全局变量messages</li>
<li>40行 在新客户端连接进来的时候，就预先为该socket对象在messages中创建对应的key</li>
<li>54行 在该对象中添加消息</li>
<li>64行 在客户端关闭连接收，清理该对象的消息列表</li>
<li>70行 将该对象在第40行插入的消息中取出来</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用IO多路复用，实际上实现了类似并发效果的伪并发。内部实际使用了循环来高效的处理阻塞请求</p>
<p>Python中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll 从而实现IO多路复用。</p>
<ul>
<li>Windows Python：提供： select</li>
<li>Mac Python：提供： select</li>
<li>Linux Python：提供： select、poll、epoll</li>
</ul>
<p>注意：网络操作、文件操作、终端操作等均属于IO操作，对于windows只支持Socket操作，其他系统支持所有IO操作，但是无法检测普通文件操作自动上次读取是否已经变化</p>
<p>对于select方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">句柄列表11, 句柄列表22, 句柄列表33 &#x3D; select.select(句柄序列1, 句柄序列2, 句柄序列3, 超时时间)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">参数： 可接受四个参数（前三个必须）</span><br><span class="line">返回值：三个列表</span><br><span class="line"> </span><br><span class="line">select方法用来监视文件句柄，如果句柄发生变化，则获取该句柄。</span><br><span class="line">1、当 参数1 序列中的句柄发生可读时（accetp和read），则获取发生变化的句柄并添加到 返回值1 序列中</span><br><span class="line">2、当 参数2 序列中含有句柄时，则将该序列中所有的句柄添加到 返回值2 序列中</span><br><span class="line">3、当 参数3 序列中的句柄发生错误时，则将该发生错误的句柄添加到 返回值3 序列中</span><br><span class="line">4、当 超时时间 未设置，则select会一直阻塞，直到监听的句柄发生变化</span><br><span class="line">   当 超时时间 ＝ 1时，那么如果监听的句柄均无任何变化，则select会阻塞 1 秒，之后返回三个空列表，如果监听的句柄有变化，则直接执行。</span><br></pre></td></tr></table></figure>

<h1 id="附加：select-poll-epoll的区别"><a href="#附加：select-poll-epoll的区别" class="headerlink" title="附加：select poll epoll的区别"></a>附加：select poll epoll的区别</h1><p>IO多路复用是系统内核实现的，系统内部维护了一个for循环，一个一个地去检测对象是否有变化</p>
<p>首先需要明确一点的是，for循环的效率是不高的</p>
<table>
<thead>
<tr>
<th>IO多路复用种类</th>
<th>实现原理</th>
<th>监听对象个数</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>系统内部维护了一个for循环</td>
<td>1024</td>
</tr>
<tr>
<td>poll</td>
<td>系统内部维护了一个for循环</td>
<td>没有限制</td>
</tr>
<tr>
<td>epoll</td>
<td>句柄序列发生变化时自动通知epoll</td>
<td>没有限制</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
        <tag>select</tag>
        <tag>poll</tag>
        <tag>epoll</tag>
      </tags>
  </entry>
  <entry>
    <title>Python2.7与Python3.5继承的区别</title>
    <url>/2016/07/12/Python2-7%E4%B8%8EPython3-5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<blockquote>
<p>Python中2.7与3.5的继承略有区别， 在Python2.7中的类可以分为经典类（默认就是经典类）和新式类（继承了object类的就是新式类），而在Python3.5中，所有的类默认继承object类</p>
</blockquote>
<p><img src="http://oss.20150509.cn/20160712033359.png" alt=""></p>
<ul>
<li><p>Python2.7的类如果继承了object类，那么多继承向上寻找的路径和Python3.5是一样的，图中橙色的寻找路径</p>
</li>
<li><p>但是如果Python2.7没有继承object类，那么就是图中蓝色的寻找路径</p>
</li>
</ul>
<p>更多关于继承的内容可以参考以下文章：</p>
<p><a href="http://docs.20150509.cn/2016/06/28/Python面向对象基础篇之继承/" target="_blank" rel="noopener">http://docs.20150509.cn/2016/06/28/Python面向对象基础篇之继承/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的变量作用域</title>
    <url>/2016/07/12/Python%E7%9A%84%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    <content><![CDATA[<blockquote>
<p>Python的变量作用域中分为四个级别，简称为：BGEL，作用域的级别依次升高，级别最高的是Local，如果该变量在Local中已经声明并赋值，将优先使用Local中的变量对应的值</p>
</blockquote>
<p>Python变量作用域的四种情况：</p>
<ul>
<li>B：build-in 系统固定模块里面的变量，也叫系统变量，比如int</li>
<li>G：global 全局变量，也就是模块级别定义的变量</li>
<li>E：enclosing 嵌套的父级函数的局部作用域，就是包含此函数的上层函数的局部作用域</li>
<li>L：local 局部作用域，即为函数中定义的变量</li>
</ul>
<p><em>E和L是相对的，E中的变量相对上层来说也是L</em></p>
<p>Python的变量作用域可以用下图表示：</p>
<p><img src="http://oss.20150509.cn/20160712012859.png" alt=""></p>
<p>一个变量使用哪个域中定义的值，取决于它的相对位置</p>
<p>从上图中看，如果从Local的位置向上看，最先看到的是Local中的变量，其次是Enclosing中的变量，再次是Global中的变量，最后才是Build-in变量</p>
<p>变量的取值取决于你在哪个位置，比如你在E和L中间，那同名的这个变量肯定是会向前看，取E中的值</p>
<h1 id="Python作用域的产生"><a href="#Python作用域的产生" class="headerlink" title="Python作用域的产生"></a>Python作用域的产生</h1><p>在Python中，没有块级作用域。只有模块(module)，类(class)以及函数(def,lambda)才会引入新的作用域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    name = <span class="string">"PolarSnow"</span></span><br><span class="line">    </span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<p>以上代码是可以正常运行的，但是在Java(有块级作用域)中运行就会报，变量未定义的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"Polarsnow"</span></span><br><span class="line">  </span><br><span class="line">func()  </span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure>

<p>以上代码执行就会报错，name变量未定义</p>
<h1 id="Python变量作用域"><a href="#Python变量作用域" class="headerlink" title="Python变量作用域"></a>Python变量作用域</h1><h2 id="L-Local"><a href="#L-Local" class="headerlink" title="L(Local)"></a>L(Local)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    int = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        int = <span class="number">5</span></span><br><span class="line">        print(int)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">f = func2()</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>LEG都对int变量自定义了值，但是最后取得是L中的值</p>
<h2 id="E-Enclosing"><a href="#E-Enclosing" class="headerlink" title="E(Enclosing)"></a>E(Enclosing)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    int = <span class="number">6</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        print(int)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">f = func2()</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>在local中取值，但是local中没有，就会去E里面找</p>
<h2 id="G-Global"><a href="#G-Global" class="headerlink" title="G(Global)"></a>G(Global)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">int = <span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        print(int)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">f = func2()</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>L和E中都没有找到int的值，继续向上找，在G中找到了int的值</p>
<h2 id="B-Build-in"><a href="#B-Build-in" class="headerlink" title="B(Build-in)"></a>B(Build-in)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">        print(int)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line">f = func2()</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>int变量的值在LEG中都没有找到，但是int是内建变量，在系统中已经对其有定义，最后在B中，找到了int的值</p>
<p>如果一个变量在local中查找，查找到B中还没有找到，就会报变量未定义的错误</p>
<h1 id="global-amp-nonlocal-关键字"><a href="#global-amp-nonlocal-关键字" class="headerlink" title="global &amp; nonlocal 关键字"></a>global &amp; nonlocal 关键字</h1><h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>函数内部可以访问全局变量中的值，但是不能修改全局变量的值。如果需要修改，要加上global关键字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"ps"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readonly</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"inner ---&gt;"</span>, name)</span><br><span class="line"></span><br><span class="line">readonly()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>

<p>函数内部是可以访问全局变量的值的，原则 –&gt; GBEL</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"ps"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">readonly</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    name = <span class="string">"PolarSnow"</span></span><br><span class="line"></span><br><span class="line">readonly()</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">PolarSnow</span><br></pre></td></tr></table></figure>

<p>加上了global关键字，就可以修改全局变量的值</p>
<h2 id="nonlocal"><a href="#nonlocal" class="headerlink" title="nonlocal"></a>nonlocal</h2><p>global关键字声明的变量必须在全局作用域上，不能嵌套作用域上，当要修改嵌套作用域（enclosing作用域，外层非全局作用域）中的变量就需要nonlocal关键字了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">10</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count = <span class="number">20</span></span><br><span class="line">        print(<span class="string">"inner ---&gt; "</span>, count)</span><br><span class="line">    inner()</span><br><span class="line">    print(<span class="string">"outer ---&gt;"</span>, count)</span><br><span class="line"></span><br><span class="line">outer()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure>


<h1 id="变量作用域中的疑难杂症"><a href="#变量作用域中的疑难杂症" class="headerlink" title="变量作用域中的疑难杂症"></a>变量作用域中的疑难杂症</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"123"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"456"</span></span><br><span class="line">    func1()</span><br><span class="line"></span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>

<p>最后会输出什么结果？</p>
<p>结果是： <code>123</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">"123"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">()</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"456"</span></span><br><span class="line">    <span class="keyword">return</span> func1</span><br><span class="line"></span><br><span class="line">ret = func2()</span><br><span class="line">ret()</span><br></pre></td></tr></table></figure>

<p>结果是： <code>123</code></p>
<p>上面两段代码的结果都是全局变量中的值<code>123</code>，这里需要特别注意的是，变量作用域在函数执行之前就已经确定了！</p>
<p>Python作为解释型的语言，代码从上至下执行，遇到def时，就将其函数体保存在内存的堆区，把对应的函数名保存在栈区并指向堆区的函数体，在函数执行之前，这个函数中的变量作用域就已经被记录到内存中了，不会因为后期的调用或嵌套而更改</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x &gt; <span class="number">5</span>]</span><br><span class="line">print(<span class="string">"display list ---&gt;"</span>, l)</span><br><span class="line">print(<span class="string">"first element ---&gt;"</span>, l[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---"</span> * <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">ll = [<span class="keyword">lambda</span> :x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>) <span class="keyword">if</span> x &gt; <span class="number">5</span>]</span><br><span class="line">print(<span class="string">"display list ---&gt;"</span>, ll)</span><br><span class="line"></span><br><span class="line">ret = ll[<span class="number">0</span>]()</span><br><span class="line">print(<span class="string">"first element ---&gt;"</span>, ret)</span><br></pre></td></tr></table></figure>

<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display list ---&gt; [7, 8, 9, 10]</span><br><span class="line">first element ---&gt; 7</span><br><span class="line">---------------</span><br><span class="line">display list ---&gt; [&lt;function &lt;listcomp&gt;.&lt;lambda&gt; at 0x101b7b730&gt;, &lt;function &lt;listcomp&gt;.&lt;lambda&gt; at 0x101b7b7b8&gt;, &lt;function &lt;listcomp&gt;.&lt;lambda&gt; at 0x101b7b840&gt;, &lt;function &lt;listcomp&gt;.&lt;lambda&gt; at 0x101b7b8c8&gt;]</span><br><span class="line">first element ---&gt; 9</span><br></pre></td></tr></table></figure>

<p>问题来了，问什么使用了lambda之后，第一个元素变成9了呢？</p>
<p>我们把这个问题拆解一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lll = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">        lll.append(x + <span class="number">1</span>)</span><br><span class="line">print(lll)</span><br><span class="line">print(lll[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">llll = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">return</span> x</span><br><span class="line">        llll.append(func)</span><br><span class="line">print(llll)</span><br><span class="line">print(llll[<span class="number">0</span>]())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"><span class="number">7</span></span><br><span class="line">[&lt;function func at <span class="number">0x10137b620</span>&gt;, &lt;function func at <span class="number">0x10137b6a8</span>&gt;, &lt;function func at <span class="number">0x10137b730</span>&gt;, &lt;function func at <span class="number">0x10137b7b8</span>&gt;]</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>为什么 x+1 时第一个元素 = 7， 而 lambda :x 时第一个元素 = 9了呢</p>
<p>原因就是Python程序在解释道lambda的时候，并没有执行里面的代码，而是直接放到的了内存中，随着外侧循环的结束，x的值已经变成了9，此时再把内存里保存的lambda函数拿出来执行，x变量获取到的就是当前已经变成9的这个值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lllll = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> x &gt; <span class="number">5</span>:</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(i = x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        lllll.append(func)</span><br><span class="line">print(lllll)</span><br><span class="line">print(lllll[<span class="number">0</span>]())</span><br><span class="line">print(lllll[<span class="number">1</span>]())</span><br><span class="line">print(lllll[<span class="number">2</span>]())</span><br><span class="line">print(lllll[<span class="number">3</span>]())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[&lt;function func at <span class="number">0x101b7b620</span>&gt;, &lt;function func at <span class="number">0x101b7b6a8</span>&gt;, &lt;function func at <span class="number">0x101b7b730</span>&gt;, &lt;function func at <span class="number">0x101b7b7b8</span>&gt;]</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>上面的代码仅仅小修改了一下，在func中执行一条赋值语句，结果就立刻不一样了，这次列表的第一个值变成了6</p>
<p>之前不是说代码运行到def就直接保存到内存，不执行了吗？没错，函数体是没有被执行，但是函数的参数是个赋值表达式，被Python解释器执行了，获取到了每个循环的x的值，并赋值给函数自己内部的变量（local）</p>
<p>当程序执行完毕，运行列表中第一个函数取值的时候，该函数取到的是函数内部的变量i，所以最后的结果和上面是截然不同的</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>变量作用域</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之socketserver的使用</title>
    <url>/2016/07/08/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocketserver%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>在Python2.x中需要import SocketServer，在Python3.x中，都变成了小写，需要import sockerserver</p>
<p>Python Version: 3.5+</p>
</blockquote>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义socketserver需要继承socketserver.BaseRequestHandler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每一个对象实例化的时候,都会执行handle里面的代码</span></span><br><span class="line">    <span class="comment"># 自定义的handle方法会重写父类的handle方法,主要用来与客户端进行交互</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        conn = self.request</span><br><span class="line">        <span class="comment"># 这条欢迎消息会在每个客户端连上之后发送</span></span><br><span class="line">        conn.sendall(bytes(<span class="string">"Welcome to docs.20150509.cn"</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>:<span class="keyword">break</span></span><br><span class="line">            conn.sendall(recv_data.upper())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">5959</span>), MyServer)</span><br><span class="line">    <span class="comment"># 每多一个客户端的连接,就睡多起一个线程去处理</span></span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5959</span>)</span><br><span class="line">s = socket.socket()</span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先接收服务端发来的欢迎消息</span></span><br><span class="line">welcome_msg = s.recv(<span class="number">1024</span>)</span><br><span class="line">print(str(welcome_msg, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 输入消息</span></span><br><span class="line">    sent_data = input(<span class="string">"&gt; "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> len(sent_data) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    <span class="comment">#  发送消息</span></span><br><span class="line">    s.send(bytes(sent_data, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 接收消息</span></span><br><span class="line">    recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(recv_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="orange">执行</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Welcome to docs<span class="number">.20150509</span>.cn</span><br><span class="line">&gt; polarsnow</span><br><span class="line">POLARSNOW</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>多个客户端可以同时连接使用，每个客户端连接时都会创建一个对象，在服务端都会新起一个进来来负责这个线程的处理</p>
<h1 id="浅谈源码"><a href="#浅谈源码" class="headerlink" title="浅谈源码"></a>浅谈源码</h1><p>我们就来看看继承的<code>socketserver.BaseRequestHandler</code>的源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRequestHandler</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""Base class for request handler classes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class is instantiated for each request to be handled.  The</span></span><br><span class="line"><span class="string">    constructor sets the instance variables request, client_address</span></span><br><span class="line"><span class="string">    and server, and then calls the handle() method.  To implement a</span></span><br><span class="line"><span class="string">    specific service, all you need to do is to derive a class which</span></span><br><span class="line"><span class="string">    defines a handle() method.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The handle() method can find the request as self.request, the</span></span><br><span class="line"><span class="string">    client address as self.client_address, and the server (in case it</span></span><br><span class="line"><span class="string">    needs access to per-server information) as self.server.  Since a</span></span><br><span class="line"><span class="string">    separate instance is created for each request, the handle() method</span></span><br><span class="line"><span class="string">    can define arbitrary other instance variariables.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, request, client_address, server)</span>:</span></span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.handle()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setup</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">finish</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>我没有省略，源码中只有这几行</p>
<p>可以看出，创建对象执行构造方法的时候，会自动去执行三个方法</p>
<ul>
<li>self.setup() 负责客户端连接时的处理</li>
<li>self.handle() 负责客户端连接后的交互</li>
<li>self.finish() 负责客户端断开前的操作</li>
</ul>
<p>在我们自己的类中，可以通过重写父类的这方法来实现对客户端请求的处理</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socketserver</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之socket粘包问题</title>
    <url>/2016/07/08/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>网络编程中，每次客户端与服务端约定俗成发送包的大小为1024字节，最大为8192字节。但是即使你设置了8192，硬件网卡每次也只能收到1500字节，这个是由硬件网卡的MTU值（最大传输单元，单位字节）决定的。一般千兆网卡的MTU值是1500字节。当一端给另一端发包超过1024字节，另一端没有循环接收消息，就会产生粘包的问题</p>
</blockquote>
<p><img src="http://oss.20150509.cn/20160708020159.png" alt=""></p>
<p>粘包的问题看上图</p>
<p>客户端给服务端发送了一个命令请求，服务端的返回体大小为11024字节，但是客户端每次只收1024字节，所以客户端的第一次请求之后，服务端还有10000字节的内容还没给客户端发</p>
<p>当客户端发给第二个请求时，第二个请求的返回体大小为100字节，但是队列中还有10000字节的内容没有发送给客户端，所以此时服务端会将上次剩余的10000字节中再拿出1024字节来发送给客户端</p>
<h1 id="解决粘包问题"><a href="#解决粘包问题" class="headerlink" title="解决粘包问题"></a>解决粘包问题</h1><p>解决粘包问题的关键点在于我们能否知道每次需要发送的内容总共有多大，如果我们能知道总共有多大，相应的对端就可以算出我需要循环几次可以吧内容全部读完</p>
<p>先来看看原始会发生粘包情况的代码：</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把接收客户端连接请求的操作循环起来就可以接受多个用户的请求啦</span></span><br><span class="line"><span class="comment"># 注意:同一时间只能处理一个客户端的请求,其他连接上的用户会排队等待</span></span><br><span class="line"><span class="comment"># 最后支持多少个用户排队等待,是由listen中的参数决定的(连接池)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待客户端的连接(阻塞函数)</span></span><br><span class="line">    <span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line">    <span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 5: 接收消息(在conn通道没有被关闭的情况下是阻塞的函数,一旦conn被客户端关闭,该函数将不会阻塞)</span></span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果conn通道被客户端主动关闭,recv函数将不再阻塞,recv_data将接收到空字符串</span></span><br><span class="line">        <span class="comment"># 通过判断recv_data为空字符串来退出服务端的连接</span></span><br><span class="line">        <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 6:处理消息</span></span><br><span class="line">        cmd = str(recv_data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">        res = p.stdout.read()</span><br><span class="line">        send_data = str(res, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 7: 发送消息</span></span><br><span class="line">        conn.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 8: 断开连接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 连接服务端</span></span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: 发送消息</span></span><br><span class="line">    send_data = input(<span class="string">"&gt; "</span>).strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果客户端输入了exit,退出循环,主动close掉与服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span> send_data == <span class="string">"exit"</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果什么也没有输入,重新循环接收输入</span></span><br><span class="line">    <span class="keyword">if</span> len(send_data) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里注意,和服务端不同的是,服务端找到对端是通过conn对象,而客户端是s对象</span></span><br><span class="line">    <span class="comment"># 在Python3.x中,socket对象发送对象必须是字节类型(2.7中可以是字符串)</span></span><br><span class="line">    s.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: 收消息</span></span><br><span class="line">    recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(recv_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 断开连接</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>要解决上面粘包的问题，首先用白话来描述一下解决的过程</p>
<ul>
<li>客户端不知道服务端会返回多少内容，所以客户端接收信息的代码需要循环起来</li>
<li>由于客户端接收循环不知道何时停止，前提需要先知道服务端总共会有多少字节的内容发过来</li>
<li>服务端在发送实际数据之前，先计算要发送的数据有多大，把这个信息提前告知客户端，让客户端计算出需要几次循环才能把我服务端本次产生的数据接收完毕</li>
<li>客户端在接收到服务端发来的总长度的信息时，计算出循环的次数，此时应告知服务器端，可以发送数据了</li>
</ul>
<p>下面我们就按照上面的思路来实现这段代码</p>
<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5556</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把接收客户端连接请求的操作循环起来就可以接受多个用户的请求啦</span></span><br><span class="line"><span class="comment"># 注意:同一时间只能处理一个客户端的请求,其他连接上的用户会排队等待</span></span><br><span class="line"><span class="comment"># 最后支持多少个用户排队等待,是由listen中的参数决定的(连接池)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待客户端的连接(阻塞函数)</span></span><br><span class="line">    <span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line">    <span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 5: 接收消息(在conn通道没有被关闭的情况下是阻塞的函数,一旦conn被客户端关闭,该函数将不会阻塞)</span></span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果conn通道被客户端主动关闭,recv函数将不再阻塞,recv_data将接收到空字符串</span></span><br><span class="line">        <span class="comment"># 通过判断recv_data为空字符串来退出服务端的连接</span></span><br><span class="line">        <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 6:处理消息</span></span><br><span class="line">        cmd = str(recv_data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">        res = p.stdout.read()</span><br><span class="line">        send_data = str(res, encoding=<span class="string">'utf-8'</span>)  <span class="comment"># utf-8 ---&gt; str ---&gt; utf-8</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ------------与客户端沟通数据大小并发送数据的流程------------</span></span><br><span class="line">        <span class="comment"># I. Server ---&gt; Client</span></span><br><span class="line">        <span class="comment"># 由于发送数据时必须是字节类型,所以计算长度时,应该先将字符串转为字节类型再计算长度</span></span><br><span class="line">        send_data = bytes(send_data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="comment"># 计算字节长度,因为后面发送信息的时候需要做字符串拼接,所以这里先转成字符类型</span></span><br><span class="line">        length_data = str(len(send_data))</span><br><span class="line">        <span class="comment"># 通知客户端要要发送数据的总长度</span></span><br><span class="line">        conn.send(bytes(<span class="string">'length_data:'</span>+length_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># III. Server &lt;--- Client</span></span><br><span class="line">        <span class="comment"># 接收客户端发送的确认开始传输的命令</span></span><br><span class="line">        feedback = str(conn.recv(<span class="number">1024</span>), encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        <span class="keyword">if</span> feedback == <span class="string">"confirm"</span>:</span><br><span class="line">            <span class="comment"># IV. Server ---&gt; Client</span></span><br><span class="line">            <span class="comment"># 开始向客户端传输数据</span></span><br><span class="line">            conn.send(send_data)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 7: 发送消息</span></span><br><span class="line">        conn.send(send_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 8: 断开连接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<ul>
<li><font color="blue">client.py</font></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5556</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 连接服务端</span></span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: 发送消息</span></span><br><span class="line">    send_data = input(<span class="string">"&gt; "</span>).strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果客户端输入了exit,退出循环,主动close掉与服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span> send_data == <span class="string">"exit"</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果什么也没有输入,重新循环接收输入</span></span><br><span class="line">    <span class="keyword">if</span> len(send_data) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里注意,和服务端不同的是,服务端找到对端是通过conn对象,而客户端是s对象</span></span><br><span class="line">    <span class="comment"># 在Python3.x中,socket对象发送对象必须是字节类型(2.7中可以是字符串)</span></span><br><span class="line">    s.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: 收消息</span></span><br><span class="line">    <span class="comment"># ------------与服务端沟通数据大小并发送数据的流程------------</span></span><br><span class="line">    <span class="comment"># 服务端首先发来的信息是即将发送数据的总长度(字节长度)</span></span><br><span class="line">    length_msg = str(s.recv(<span class="number">1024</span>), encoding=<span class="string">'utf-8'</span>)  <span class="comment"># 接收的格式 length_data:11024</span></span><br><span class="line">    <span class="keyword">if</span> length_msg.startswith(<span class="string">"length_data"</span>):</span><br><span class="line">        <span class="comment"># 取得服务端统计的数据总长度</span></span><br><span class="line">        length_data = int(length_msg.split(<span class="string">":"</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># II. Server &lt;--- Client</span></span><br><span class="line">    <span class="comment"># 客户端已经接收到数据的总长度,回复服务端可以发送数据</span></span><br><span class="line">    s.send(bytes(<span class="string">"confirm"</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># V. 接收服务端发送过来的数据</span></span><br><span class="line">    <span class="comment"># 累计下载字节统计</span></span><br><span class="line">    recv_total_size = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 累计下载数据</span></span><br><span class="line">    recv_total_data = <span class="string">b''</span></span><br><span class="line">    <span class="comment"># 进入循环下载</span></span><br><span class="line">    <span class="keyword">while</span> recv_total_size &lt; length_data:</span><br><span class="line">        recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">        recv_total_data += recv_data</span><br><span class="line">        recv_total_size += len(recv_data)</span><br><span class="line">        print(<span class="string">"传输总大小为: %s ; 当前已传输大小为: %s"</span> % (length_data, recv_total_size))</span><br><span class="line">    <span class="comment"># 打印完整的数据</span></span><br><span class="line">    print(str(recv_total_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 断开连接</span></span><br><span class="line">s.close()</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- &lt;font color="orange"&gt;执行结果&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">&gt; ifconfig</span><br><span class="line">传输总大小为: <span class="number">1857</span> ; 当前已传输大小为: <span class="number">1024</span></span><br><span class="line">传输总大小为: <span class="number">1857</span> ; 当前已传输大小为: <span class="number">2048</span></span><br><span class="line">lo0: flags=<span class="number">8049</span>&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu <span class="number">16384</span></span><br><span class="line">	options=<span class="number">3</span>&lt;RXCSUM,TXCSUM&gt;</span><br><span class="line">	inet6 ::<span class="number">1</span> prefixlen <span class="number">128</span> </span><br><span class="line">	inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> netmask <span class="number">0xff000000</span> </span><br><span class="line">	inet6 fe80::<span class="number">1</span>%lo0 prefixlen <span class="number">64</span> scopeid <span class="number">0x1</span> </span><br><span class="line">	nd6 options=<span class="number">1</span>&lt;PERFORMNUD&gt;</span><br><span class="line">gif0: flags=<span class="number">8010</span>&lt;POINTOPOINT,MULTICAST&gt; mtu <span class="number">1280</span></span><br><span class="line">stf0: flags=<span class="number">0</span>&lt;&gt; mtu <span class="number">1280</span></span><br><span class="line">en0: flags=<span class="number">8863</span>&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">	ether <span class="number">60</span>:<span class="number">03</span>:<span class="number">08</span>:a5:<span class="number">3</span>b:<span class="number">9</span>e </span><br><span class="line">	inet6 fe80::<span class="number">6203</span>:<span class="number">8</span>ff:fea5:<span class="number">3</span>b9e%en0 prefixlen <span class="number">64</span> scopeid <span class="number">0x4</span> </span><br><span class="line">	inet <span class="number">192.168</span><span class="number">.1</span><span class="number">.103</span> netmask <span class="number">0xffffff00</span> broadcast <span class="number">192.168</span><span class="number">.1</span><span class="number">.255</span></span><br><span class="line">	nd6 options=<span class="number">1</span>&lt;PERFORMNUD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br><span class="line">en1: flags=<span class="number">963</span>&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu <span class="number">1500</span></span><br><span class="line">	options=<span class="number">60</span>&lt;TSO4,TSO6&gt;</span><br><span class="line">	ether <span class="number">72</span>:<span class="number">00</span>:<span class="number">01</span>:f7:dd:<span class="number">70</span> </span><br><span class="line">	media: autoselect &lt;full-duplex&gt;</span><br><span class="line">	status: inactive</span><br><span class="line">en2: flags=<span class="number">963</span>&lt;UP,BROADCAST,SMART,RUNNING,PROMISC,SIMPLEX&gt; mtu <span class="number">1500</span></span><br><span class="line">	options=<span class="number">60</span>&lt;TSO4,TSO6&gt;</span><br><span class="line">	ether <span class="number">72</span>:<span class="number">00</span>:<span class="number">01</span>:f7:dd:<span class="number">71</span> </span><br><span class="line">	media: autoselect &lt;full-duplex&gt;</span><br><span class="line">	status: inactive</span><br><span class="line">p2p0: flags=<span class="number">8843</span>&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">2304</span></span><br><span class="line">	ether <span class="number">02</span>:<span class="number">03</span>:<span class="number">08</span>:a5:<span class="number">3</span>b:<span class="number">9</span>e </span><br><span class="line">	media: autoselect</span><br><span class="line">	status: inactive</span><br><span class="line">awdl0: flags=<span class="number">8943</span>&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu <span class="number">1484</span></span><br><span class="line">	ether <span class="number">0</span>e:<span class="number">80</span>:<span class="number">6</span>c:<span class="number">2</span>f:ac:<span class="number">25</span> </span><br><span class="line">	inet6 fe80::c80:<span class="number">6</span>cff:fe2f:ac25%awdl0 prefixlen <span class="number">64</span> scopeid <span class="number">0x8</span> </span><br><span class="line">	nd6 options=<span class="number">1</span>&lt;PERFORMNUD&gt;</span><br><span class="line">	media: autoselect</span><br><span class="line">	status: active</span><br><span class="line">bridge0: flags=<span class="number">8863</span>&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu <span class="number">1500</span></span><br><span class="line">	options=<span class="number">63</span>&lt;RXCSUM,TXCSUM,TSO4,TSO6&gt;</span><br><span class="line">	ether <span class="number">62</span>:<span class="number">03</span>:<span class="number">08</span>:<span class="number">5</span>a:<span class="number">2</span>d:<span class="number">00</span> </span><br><span class="line">	Configuration:</span><br><span class="line">		id <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> priority <span class="number">0</span> hellotime <span class="number">0</span> fwddelay <span class="number">0</span></span><br><span class="line">		maxage <span class="number">0</span> holdcnt <span class="number">0</span> proto stp maxaddr <span class="number">100</span> timeout <span class="number">1200</span></span><br><span class="line">		root id <span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span>:<span class="number">0</span> priority <span class="number">0</span> ifcost <span class="number">0</span> port <span class="number">0</span></span><br><span class="line">		ipfilter disabled flags <span class="number">0x2</span></span><br><span class="line">	member: en1 flags=<span class="number">3</span>&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">	        ifmaxaddr <span class="number">0</span> port <span class="number">5</span> priority <span class="number">0</span> path cost <span class="number">0</span></span><br><span class="line">	member: en2 flags=<span class="number">3</span>&lt;LEARNING,DISCOVER&gt;</span><br><span class="line">	        ifmaxaddr <span class="number">0</span> port <span class="number">6</span> priority <span class="number">0</span> path cost <span class="number">0</span></span><br><span class="line">	nd6 options=<span class="number">1</span>&lt;PERFORMNUD&gt;</span><br><span class="line">	media: &lt;unknown type&gt;</span><br><span class="line">	status: inactive</span><br><span class="line">lo0: flags=<span class="number">8049</span>&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu <span class="number">16384</span></span><br><span class="line">	options=<span class="number">3</span>&lt;RXCSUM,TXCSUM&gt;</span><br><span class="line">	inet6 ::<span class="number">1</span> prefixlen <span class="number">128</span> </span><br><span class="line">	inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> netmask <span class="number">0xff000000</span> </span><br><span class="line">	inet6 fe80::<span class="number">1</span>%lo0 prefixlen <span class="number">64</span> scopeid <span class="number">0x1</span> </span><br><span class="line">	</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>解决粘包问题实例：</p>
<p><img src="http://oss.20150509.cn/20160710104159.png" alt=""></p>
<p><img src="http://oss.20150509.cn/20160710104259.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之简单SSH交互</title>
    <url>/2016/07/08/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%AE%80%E5%8D%95SSH%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把接收客户端连接请求的操作循环起来就可以接受多个用户的请求啦</span></span><br><span class="line"><span class="comment"># 注意:同一时间只能处理一个客户端的请求,其他连接上的用户会排队等待</span></span><br><span class="line"><span class="comment"># 最后支持多少个用户排队等待,是由listen中的参数决定的(连接池)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待客户端的连接(阻塞函数)</span></span><br><span class="line">    <span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line">    <span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 5: 接收消息(在conn通道没有被关闭的情况下是阻塞的函数,一旦conn被客户端关闭,该函数将不会阻塞)</span></span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果conn通道被客户端主动关闭,recv函数将不再阻塞,recv_data将接收到空字符串</span></span><br><span class="line">        <span class="comment"># 通过判断recv_data为空字符串来退出服务端的连接</span></span><br><span class="line">        <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 6:处理消息</span></span><br><span class="line">        cmd = str(recv_data, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        p = subprocess.Popen(cmd, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">        res = p.stdout.read()</span><br><span class="line">        send_data = str(res, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 7: 发送消息</span></span><br><span class="line">        conn.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 8: 断开连接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>服务端在接收消息之后，拿到系统中去执行，取回标准输出，这里需要特别注意一下字符编码的问题。</p>
<p>在不同的系统中，字符编码可能不一样，如果是Windows平台，字符编码可能是<code>gbk</code>，在linux系统中，字符编码可能是<code>GB18030``zh_CN.UTF-8</code>等等,在这些系统中执行完命令后，回显的字符编码与系统是一致的，我们需要把回显的字节按照系统的编码类型进行编码并转化成Python的string字符类型，由Python的字符串作为中间人去帮我们做转换</p>
<p>类似于这样的过程 <code>gbk ---&gt; str ---&gt; utf-8</code></p>
<ul>
<li><font color="blue">client.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 连接服务端</span></span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: 发送消息</span></span><br><span class="line">    send_data = input(<span class="string">"&gt; "</span>).strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果客户端输入了exit,退出循环,主动close掉与服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span> send_data == <span class="string">"exit"</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果什么也没有输入,重新循环接收输入</span></span><br><span class="line">    <span class="keyword">if</span> len(send_data) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里注意,和服务端不同的是,服务端找到对端是通过conn对象,而客户端是s对象</span></span><br><span class="line">    <span class="comment"># 在Python3.x中,socket对象发送对象必须是字节类型(2.7中可以是字符串)</span></span><br><span class="line">    s.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: 收消息</span></span><br><span class="line">    recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(str(recv_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 断开连接</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>提示：上面只对可以正确执行的系统命令做了处理，如果输入了一个错误的命令，那么stdout标准输出根本不会捕捉到，所以会出现问题</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之简单交互</title>
    <url>/2016/07/07/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%AE%80%E5%8D%95%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h1 id="为单用户服务"><a href="#为单用户服务" class="headerlink" title="为单用户服务"></a>为单用户服务</h1><ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待客户端的连接(阻塞函数)</span></span><br><span class="line"><span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">conn, addr = s.accept()</span><br><span class="line"><span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line"><span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 5: 接收消息(在conn通道没有被关闭的情况下是阻塞的函数,一旦conn被客户端关闭,该函数将不会阻塞)</span></span><br><span class="line">    recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果conn通道被客户端主动关闭,recv函数将不再阻塞,recv_data将接收到空字符串</span></span><br><span class="line">    <span class="comment"># 通过判断recv_data为空字符串来退出服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 6: 发送消息</span></span><br><span class="line">    send_data = recv_data.upper()</span><br><span class="line">    conn.send(send_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 7: 断开连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<p>这个服务端在与客户端交互（收发消息）的部分使用了循环，没次接收消息，处理消息，发送消息之后就进入到下一次循环等待接收消息。</p>
<p>这里需要注意的一点就是conn，服务端的conn对象对应了客户端的s对象，都代表了两端之间建立的连接通道，一旦客户端主动关闭连接对象s，在服务端对应的conn对象将立即失效，随即退出循关闭服务端持有的连接对象。</p>
<p>此时conn.recv()函数不再是一个阻塞的状态，它将返回空值。我们需要对接收这个空值的对象（变量）做出相应的处理，关闭掉服务端持有的连接对象</p>
<ul>
<li><font color="blue">client.py</font></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 连接服务端</span></span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: 发送消息</span></span><br><span class="line">    send_data = input(<span class="string">"&gt; "</span>).strip()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果客户端输入了exit,退出循环,主动close掉与服务端的连接</span></span><br><span class="line">    <span class="keyword">if</span> send_data == <span class="string">"exit"</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果什么也没有输入,重新循环接收输入</span></span><br><span class="line">    <span class="keyword">if</span> len(send_data) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 这里注意,和服务端不同的是,服务端找到对端是通过conn对象,而客户端是s对象</span></span><br><span class="line">    <span class="comment"># 在Python3.x中,socket对象发送对象必须是字节类型(2.7中可以是字符串)</span></span><br><span class="line">    s.send(bytes(send_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: 收消息</span></span><br><span class="line">    recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(recv_data, <span class="string">"---&gt;"</span>, type(recv_data), str(recv_data, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 断开连接</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>这个版本实现了服务端为单个用户提供服务的场景。</p>
<p>从上面的说明中也可以看出，服务端在接收到客户端主动关闭的操作后（特征为：conn.recv返回值为空），相继关闭服务端持有的连接对象，接着代码就停止了。</p>
<p><em>这里需要特别注意的就是处理客户端输入为空的情况，因为服务端判断客户端是否主动断开，主要依据的就是conn.recv方法的返回值是否为空，所以我们要屏蔽掉用户输入为空的情况</em></p>
<h1 id="为多用户服务（排队）"><a href="#为多用户服务（排队）" class="headerlink" title="为多用户服务（排队）"></a>为多用户服务（排队）</h1><ul>
<li><font color="red">server.py</font> </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把接收客户端连接请求的操作循环起来就可以接受多个用户的请求啦</span></span><br><span class="line"><span class="comment"># 注意:同一时间只能处理一个客户端的请求,其他连接上的用户会排队等待</span></span><br><span class="line"><span class="comment"># 最后支持多少个用户排队等待,是由listen中的参数决定的(连接池)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待客户端的连接(阻塞函数)</span></span><br><span class="line">    <span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">    conn, addr = s.accept()</span><br><span class="line">    <span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line">    <span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 5: 接收消息(在conn通道没有被关闭的情况下是阻塞的函数,一旦conn被客户端关闭,该函数将不会阻塞)</span></span><br><span class="line">        recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果conn通道被客户端主动关闭,recv函数将不再阻塞,recv_data将接收到空字符串</span></span><br><span class="line">        <span class="comment"># 通过判断recv_data为空字符串来退出服务端的连接</span></span><br><span class="line">        <span class="keyword">if</span> len(recv_data) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 6: 发送消息</span></span><br><span class="line">        send_data = recv_data.upper()</span><br><span class="line">        conn.send(send_data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 7: 断开连接</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>

<p>服务端的代码只增加了一个while循环，上一个代码版本中，服务端唯一的循环放在了处理某一客户端的请求上。此次加上的循环，放在了接收用户连接请求上，可以在<code>关闭上一个连接之后</code>，循环的处理下一个连接请求</p>
<ul>
<li><font color="blue">client.py</font> 客户端的代码没有任何修改</li>
</ul>
<p>此时，连续的运行两个客户端，发现两个客户端都可以连接到服务端，但是一个可断端发出请求后，在第一个客户端不关闭连接的情况下，第二个客户端发出的请求一直卡在终端中。只有第一个客户端关闭连接，触发服务端关闭对第一个客户端的连接之后，才会去接收第二个客户端发来的信息</p>
<p>这里特别提示一下，当两个客户端相继连接上服务端后，看似服务端对两个连接都接受了请求，但是，只有第一个连接过来的客户端才进入到了服务端代码中的内层while循环体，此时即使第一个客户端没有发送信息，第二个客户端先给服务端发送信息，终端也是会阻塞住的</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之socket常用方法简介</title>
    <url>/2016/07/06/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="sk-socket-socket-socket-AF-INET-socket-SOCK-STREAM-0"><a href="#sk-socket-socket-socket-AF-INET-socket-SOCK-STREAM-0" class="headerlink" title="sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)"></a>sk = socket.socket(socket.AF_INET,socket.SOCK_STREAM,0)</h1><ul>
<li><p>参数一：地址簇</p>
<ul>
<li>socket.AF_INET IPv4（默认）</li>
<li>socket.AF_INET6 IPv6</li>
<li>socket.AF_UNIX 只能够用于单一的Unix系统进程间通信</li>
</ul>
</li>
<li><p>参数二：类型</p>
<ul>
<li><p>socket.SOCK_STREAM　　流式socket , for TCP （默认）</p>
</li>
<li><p>socket.SOCK_DGRAM　　 数据报式socket , for UDP</p>
</li>
<li><p>socket.SOCK_RAW 原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</p>
</li>
<li><p>socket.SOCK_RDM 是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。</p>
</li>
<li><p>socket.SOCK_SEQPACKET 可靠的连续数据包服务</p>
</li>
</ul>
</li>
<li><p>参数三：协议</p>
<ul>
<li>0　　（默认）与特定的地址家族相关的协议,如果是 0 ，则系统就会根据地址格式和套接类别,自动选择一个合适的协议</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># UDP实例</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line">sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line">sk.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = sk.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">sk = socket.socket(socket.AF_INET,socket.SOCK_DGRAM,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    inp = raw_input(<span class="string">'数据：'</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'exit'</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    sk.sendto(inp,ip_port)</span><br><span class="line"></span><br><span class="line">sk.close()</span><br></pre></td></tr></table></figure>

<h1 id="sk-bind-address"><a href="#sk-bind-address" class="headerlink" title="sk.bind(address)"></a>sk.bind(address)</h1><p>将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p>
<h1 id="sk-listen-backlog"><a href="#sk-listen-backlog" class="headerlink" title="sk.listen(backlog)"></a>sk.listen(backlog)</h1><p>开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。</p>
<p>backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5</p>
<p>这个值不能无限大，因为要在内核中维护连接队列</p>
<h1 id="sk-setblocking-bool"><a href="#sk-setblocking-bool" class="headerlink" title="sk.setblocking(bool)"></a>sk.setblocking(bool)</h1><p>是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p>
<h1 id="sk-accept"><a href="#sk-accept" class="headerlink" title="sk.accept()"></a>sk.accept()</h1><p>接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。</p>
<p>接收TCP 客户的连接（阻塞式）等待连接的到来</p>
<h1 id="sk-connect-address"><a href="#sk-connect-address" class="headerlink" title="sk.connect(address)"></a>sk.connect(address)</h1><p>连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p>
<h1 id="sk-connect-ex-address"><a href="#sk-connect-ex-address" class="headerlink" title="sk.connect_ex(address)"></a>sk.connect_ex(address)</h1><p>同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p>
<h1 id="sk-close"><a href="#sk-close" class="headerlink" title="sk.close()"></a>sk.close()</h1><p>关闭套接字</p>
<h1 id="sk-recv-bufsize-flag"><a href="#sk-recv-bufsize-flag" class="headerlink" title="sk.recv(bufsize[,flag])"></a>sk.recv(bufsize[,flag])</h1><p>接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p>
<h1 id="sk-recvfrom-bufsize-flag"><a href="#sk-recvfrom-bufsize-flag" class="headerlink" title="sk.recvfrom(bufsize[.flag])"></a>sk.recvfrom(bufsize[.flag])</h1><p>与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</p>
<h1 id="sk-send-byte-string-flag"><a href="#sk-send-byte-string-flag" class="headerlink" title="sk.send(byte(string)[,flag])"></a>sk.send(byte(string)[,flag])</h1><p>将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p>
<p>注意，在Python2.x中可以发送string，但是在3.x中，发送的内容必须是字节类型，所以需要使用byte()内置函数来转换一下</p>
<h1 id="sk-sendall-byte-string-flag"><a href="#sk-sendall-byte-string-flag" class="headerlink" title="sk.sendall(byte(string)[,flag])"></a>sk.sendall(byte(string)[,flag])</h1><p>将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常</p>
<p>内部通过递归调用send，将所有内容发送出去</p>
<h1 id="sk-sendto-byte-string-flag-address"><a href="#sk-sendto-byte-string-flag-address" class="headerlink" title="sk.sendto(byte(string)[,flag],address)"></a>sk.sendto(byte(string)[,flag],address)</h1><p>将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议</p>
<h1 id="sk-settimeout-timeout"><a href="#sk-settimeout-timeout" class="headerlink" title="sk.settimeout(timeout)"></a>sk.settimeout(timeout)</h1><p>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p>
<p>主要用于客户端</p>
<h1 id="sk-getpeername"><a href="#sk-getpeername" class="headerlink" title="sk.getpeername()"></a>sk.getpeername()</h1><p>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）</p>
<p>主要用于客户端，获取服务器的IP地址及端口号</p>
<h1 id="sk-getsockname"><a href="#sk-getsockname" class="headerlink" title="sk.getsockname()"></a>sk.getsockname()</h1><p>返回套接字自己的地址。通常是一个元组(ipaddr,port)</p>
<p>主要用于服务端，获取自己监听IP和端口的信息</p>
<h1 id="sk-fileno"><a href="#sk-fileno" class="headerlink" title="sk.fileno()"></a>sk.fileno()</h1><p>套接字的文件描述符</p>
<p>在IO多路复用的时候会用到</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Python网络编程之socket基础语法</title>
    <url>/2016/07/06/Python%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8Bsocket%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>TCP/IP协议是一门非常古老的协议，我们在网络编程的时候，不可能花几个月时候去研究TCP/IP协议，socket就是网络编程的救星，由socket来提供一系列符合TCP/IP协议的接口，我们的应用程序只需要与socket交互，即可实现通过TCP/IP协议在网络中收发数据。需要注意的一点是，socket抽象层本身不负责收发数据，数据收发仍然是依赖四层模型中的传输层、网络层和链路层</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="socket简介"><a href="#socket简介" class="headerlink" title="socket简介"></a>socket简介</h1><p>socket通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过”套接字”向网络发出请求或者应答网络请求。</p>
<p>socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>socket和file的区别：</p>
<ul>
<li>file模块是针对某个指定文件进行【打开】【读写】【关闭】</li>
<li>socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】</li>
</ul>
<h1 id="socket网络编程中的四层协议"><a href="#socket网络编程中的四层协议" class="headerlink" title="socket网络编程中的四层协议"></a>socket网络编程中的四层协议</h1><p><img src="http://oss.20150509.cn/QQ201607060223_0.png" alt=""></p>
<p>下面是socket编程中的一个简单实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 绑定IP及端口号</span></span><br><span class="line">s.bind(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 监听绑定的端口</span></span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待客户端的连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4: 接受客户端的连接</span></span><br><span class="line">conn, addr = s.accept()</span><br><span class="line"><span class="comment"># conn对象里封装了连接过来的这个客户端的通信线路信息</span></span><br><span class="line"><span class="comment"># 后期跟这个客户端的通信与交互都需要在conn这条通信线路上进行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 接收消息</span></span><br><span class="line">recv_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 6: 发送消息</span></span><br><span class="line">send_data = recv_data.upper()</span><br><span class="line">conn.send(send_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 7: 断开连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># client.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">ip_port = (<span class="string">'127.0.0.1'</span>, <span class="number">5555</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 1: 创建socket套接字, 里面封装了通信协议</span></span><br><span class="line">s = socket.socket()</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 2: 连接服务端</span></span><br><span class="line">s.connect(ip_port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 3: 发送消息</span></span><br><span class="line">send_data = <span class="string">"hello"</span></span><br><span class="line"><span class="comment"># 这里注意,和服务端不同的是,服务端找到对端是通过conn对象,而客户端是s对象</span></span><br><span class="line"><span class="comment"># 在Python3.x中,socket对象发送对象必须是字节类型(2.7中可以是字符串)</span></span><br><span class="line">s.send(bytes(send_data, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 4: 收消息</span></span><br><span class="line">recv_data = s.recv(<span class="number">1024</span>)</span><br><span class="line">print(recv_data, <span class="string">"---&gt;"</span>, type(recv_data), str(recv_data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># step 5: 断开连接</span></span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure>

<p>先启动server.py</p>
<p>在启动client.py</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端终端回显</span></span><br><span class="line">b'HELLO' ---&gt; &lt;class 'bytes'&gt; b'HELLO'</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中切换用户并执行命令</title>
    <url>/2016/07/04/shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7%E5%B9%B6%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>在Linux中使用 su - testuser &amp;&amp; ls 这样方式来指定命令的执行身份时会出问题，切换用户后，后面的命令将被忽略掉，还是使用su命令，加一些参数即可实现在Linux命令行中实现切换用户后立即执行命令</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iZ25olg4lg9Z ~]<span class="comment"># su -h</span></span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line"> su [options] [-] [USER [arg]...]</span><br><span class="line"></span><br><span class="line">Change the effective user id and group id to that of USER.</span><br><span class="line">A mere - implies -l.   If USER not given, assume root.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line"> -m, -p, --preserve-environment  <span class="keyword">do</span> not reset environment variables</span><br><span class="line"> -g, --group &lt;group&gt;             specify the primary group</span><br><span class="line"> -G, --supp-group &lt;group&gt;        specify a supplemental group</span><br><span class="line"></span><br><span class="line"> -, -l, --login                  make the shell a login shell</span><br><span class="line"> -c, --<span class="built_in">command</span> &lt;<span class="built_in">command</span>&gt;         pass a single <span class="built_in">command</span> to the shell with -c</span><br><span class="line"> --session-command &lt;<span class="built_in">command</span>&gt;     pass a single <span class="built_in">command</span> to the shell with -c</span><br><span class="line">                                 and <span class="keyword">do</span> not create a new session</span><br><span class="line"> -f, --fast                      pass -f to the shell (<span class="keyword">for</span> csh or tcsh)</span><br><span class="line"> -s, --shell &lt;shell&gt;             run shell <span class="keyword">if</span> /etc/shells allows it</span><br><span class="line"></span><br><span class="line"> -h, --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line"> -V, --version  output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">For more details see su(1).</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux命令行切换用户并执行命令</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - testuser -c whoami</span><br></pre></td></tr></table></figure>

<ul>
<li>在Linux命令行切换用户并执行脚本</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - testuser -s /bin/bash shell.sh</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的异常处理</title>
    <url>/2016/07/03/Python%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>在程序中使用异常处理来提高程序的健壮性，隐藏程序的内部实现。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	n1 = input(<span class="string">"&gt; "</span>)</span><br><span class="line">	n2 = input(<span class="string">"&gt; "</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">	    n1 = int(n1)</span><br><span class="line">	    n2 = int(n2)</span><br><span class="line">	    result = n1 + n2</span><br><span class="line">	<span class="keyword">except</span> Exception <span class="keyword">as</span> ex:  <span class="comment"># ex是Exception类的一个对象</span></span><br><span class="line">	    print(ex)  <span class="comment"># 执行了ex对象的__str__方法</span></span><br><span class="line">	    <span class="comment"># ex中封装了所有的错误信息</span></span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; str</span><br><span class="line">invalid literal <span class="keyword">for</span> int() <span class="keyword">with</span> base <span class="number">10</span>: <span class="string">'str'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<p>异常的捕获属于程序正常运行的功能，和报错退出有本质的区别,上面的程序中，虽然有错误，但是程序并没有被终止</p>
<h1 id="常见的异常种类"><a href="#常见的异常种类" class="headerlink" title="常见的异常种类"></a>常见的异常种类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AttributeError 试图访问一个对象没有的树形，比如foo.x，但是foo没有属性x</span><br><span class="line">IOError 输入&#x2F;输出异常；基本上是无法打开文件</span><br><span class="line">ImportError 无法引入模块或包；基本上是路径问题或名称错误</span><br><span class="line">IndentationError 语法错误（的子类） ；代码没有正确对齐</span><br><span class="line">IndexError 下标索引超出序列边界，比如当x只有三个元素，却试图访问x[5]</span><br><span class="line">KeyError 试图访问字典里不存在的键</span><br><span class="line">KeyboardInterrupt Ctrl+C被按下</span><br><span class="line">NameError 使用一个还未被赋予对象的变量</span><br><span class="line">SyntaxError Python代码非法，代码不能编译(个人认为这是语法错误，写错了）</span><br><span class="line">TypeError 传入对象类型与要求的不符合</span><br><span class="line">UnboundLocalError 试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，</span><br><span class="line">导致你以为正在访问它</span><br><span class="line">ValueError 传入一个调用者不期望的值，即使值的类型是正确的</span><br></pre></td></tr></table></figure>

<h1 id="更多的异常种类"><a href="#更多的异常种类" class="headerlink" title="更多的异常种类"></a>更多的异常种类</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArithmeticError</span><br><span class="line">AssertionError</span><br><span class="line">AttributeError</span><br><span class="line">BaseException</span><br><span class="line">BufferError</span><br><span class="line">BytesWarning</span><br><span class="line">DeprecationWarning</span><br><span class="line">EnvironmentError</span><br><span class="line">EOFError</span><br><span class="line">Exception</span><br><span class="line">FloatingPointError</span><br><span class="line">FutureWarning</span><br><span class="line">GeneratorExit</span><br><span class="line">ImportError</span><br><span class="line">ImportWarning</span><br><span class="line">IndentationError</span><br><span class="line">IndexError</span><br><span class="line">IOError</span><br><span class="line">KeyboardInterrupt</span><br><span class="line">KeyError</span><br><span class="line">LookupError</span><br><span class="line">MemoryError</span><br><span class="line">NameError</span><br><span class="line">NotImplementedError</span><br><span class="line">OSError</span><br><span class="line">OverflowError</span><br><span class="line">PendingDeprecationWarning</span><br><span class="line">ReferenceError</span><br><span class="line">RuntimeError</span><br><span class="line">RuntimeWarning</span><br><span class="line">StandardError</span><br><span class="line">StopIteration</span><br><span class="line">SyntaxError</span><br><span class="line">SyntaxWarning</span><br><span class="line">SystemError</span><br><span class="line">SystemExit</span><br><span class="line">TabError</span><br><span class="line">TypeError</span><br><span class="line">UnboundLocalError</span><br><span class="line">UnicodeDecodeError</span><br><span class="line">UnicodeEncodeError</span><br><span class="line">UnicodeError</span><br><span class="line">UnicodeTranslateError</span><br><span class="line">UnicodeWarning</span><br><span class="line">UserWarning</span><br><span class="line">ValueError</span><br><span class="line">Warning</span><br><span class="line">ZeroDivisionError</span><br></pre></td></tr></table></figure>

<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>在捕获上面指定异常的时候，我们常常需要指定多个异常区捕获，但有时还是无法全部全部预料到会出现哪种类型的异常，这个时候，Python提供给我们一个万能的异常捕获<code>Exception</code></p>
<p>那单独捕获异常存在意义是什么呢？在很多时候，我们需要捕获特定的异常来记录日志，或是对某些指定的异常做特殊的处理，这个时候指定捕获某类异常就非常有用啦，为了同时兼顾程序的健壮性，可以像<code>if elif else</code>一样来指定捕获的异常同时兼顾捕获所有的异常，类似于下面的写法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="comment"># ...</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">	print(ex)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> ex:</span><br><span class="line">	print(ex)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">	print(ex)</span><br></pre></td></tr></table></figure>

<p>这样把指定的异常区分开来</p>
<p><em>注意：Exception一定要放在最后！</em></p>
<h1 id="异常处理的完整代码块"><a href="#异常处理的完整代码块" class="headerlink" title="异常处理的完整代码块"></a>异常处理的完整代码块</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 主代码块</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> KeyError,e:</span><br><span class="line">    <span class="comment"># 异常时，执行该块</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 主代码块执行完，执行该块</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 无论异常与否，最终执行该块</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当 try 中的主代码块执行正确时, 将执行 else 里面的代码, 最后执行 finally 里面的代码</li>
<li>当 try 中的主代码块执行出现异常时, 将执行 except 里面的代码, 最后执行 finally 里面的代码</li>
</ul>
<h1 id="主动触发异常"><a href="#主动触发异常" class="headerlink" title="主动触发异常"></a>主动触发异常</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">raise</span> Exception(<span class="string">"主动抛出异常"</span>)  <span class="comment"># 创建了一个Exception对象，self.message = "主动抛出异常"</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> ex:</span><br><span class="line">	print(ex)  <span class="comment"># __str__ return self.message</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">raise</span> ValueError(<span class="string">"主动抛出值异常"</span>)  <span class="comment"># 创建了一个ValueError对象，self.message = "主动抛出异常"</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> ex:</span><br><span class="line">	print(ex)  <span class="comment"># __str__ return self.message</span></span><br></pre></td></tr></table></figure>

<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PsException</span><span class="params">(Exception)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg)</span>:</span></span><br><span class="line">        self.message = msg</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.message</span><br><span class="line"> </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> PsException(<span class="string">'Ps的异常'</span>)</span><br><span class="line"><span class="keyword">except</span> PsException <span class="keyword">as</span> ex:</span><br><span class="line">    print(ex)</span><br></pre></td></tr></table></figure>

<h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>语法：<code>assert 条件表达式</code></p>
<p>条件表达式为假则触发AssertionError异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">assert</span> <span class="number">1</span> == <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>assert的应用场景：在执行某些操作之前，如果不符合我指定的某些规则，抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># multiprocessing源码截取</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> pool</span><br><span class="line"></span><br><span class="line">p = pool.Pool()</span><br><span class="line"></span><br><span class="line">p.join()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span><span class="params">(self)</span>:</span></span><br><span class="line">    util.debug(<span class="string">'joining pool'</span>)</span><br><span class="line">    <span class="keyword">assert</span> self._state <span class="keyword">in</span> (CLOSE, TERMINATE)</span><br><span class="line">    self._worker_handler.join()</span><br><span class="line">    self._task_handler.join()</span><br><span class="line">    self._result_handler.join()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> self._pool:</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure>

<p>*<em>断言与 raise 的区别: 可以简单理解为 <code>断言=if...else... + raise</code> *</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>try</tag>
        <tag>异常处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现的单例模式</title>
    <url>/2016/07/03/Python%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>单例模式：一个实例，一个对象。用来创建单个实例（对象）</p>
</blockquote>
<p>拿数据库的连接池来举例，每个用户的数据库访问请求，都应该只去一个连接池中拿资源。一个连接池就是一个实例。单例模式就可以应用在这里场景下</p>
<p>实现单例模式的思路：</p>
<ul>
<li>在类的内部自定义一个方法去创建实例，因为使用默认的init构造方法创建实例是不可控的</li>
<li>创建一个旗标变量，该变量保存一个对象实例，创建对象的方法如果检测到该变量已经有值了，就直接将该对象返回，如果没有值，则执行首次创建，并为旗标变量赋值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_instance</span><span class="params">(cls, name)</span>:</span>  <span class="comment"># 类方法, 第一个参数默认是类这个对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance:  <span class="comment"># 判断如果这个静态字段为真(已经存在实例)</span></span><br><span class="line">            <span class="keyword">return</span> cls.instance  <span class="comment"># 直接返回这个实例</span></span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 如果实例不存在</span></span><br><span class="line">            obj = cls(name)  <span class="comment"># 在类的内部创建一个实例,内部调用了init构造方法</span></span><br><span class="line">            cls.instance = obj  <span class="comment"># 将该实例赋值给类的静态字段,防止下次重复创建</span></span><br><span class="line">            <span class="keyword">return</span> obj  <span class="comment"># 将新创建的对象返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 经过上面的修改, 如果想实现单例模式, 就不能再使用init构造方法来创建对象了</span></span><br><span class="line"><span class="comment"># a1 = A("ps")</span></span><br><span class="line"><span class="comment"># a2 = A("lr")</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于把创建对象的任务交给了get_instance方法</span></span><br><span class="line">a1 = A.get_instance(<span class="string">"PolarSnow"</span>)  <span class="comment"># 第一次会创建对象</span></span><br><span class="line">a2 = A.get_instance(<span class="string">"PolarSnow"</span>)  <span class="comment"># 第二次会使用第一次创建的对象</span></span><br><span class="line"></span><br><span class="line">print(a1)</span><br><span class="line">print(a2)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;__main__.A object at <span class="number">0x101377b38</span>&gt;</span><br><span class="line">&lt;__main__.A object at <span class="number">0x101377b38</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中自定义有序字典</title>
    <url>/2016/07/03/Python%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyDict, self).__init__()</span><br><span class="line">        self.li = []</span><br><span class="line"></span><br><span class="line">md = MyDict()</span><br><span class="line">md[<span class="string">"k1"</span>] = <span class="number">123</span></span><br><span class="line">md[<span class="string">"k2"</span>] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line">print(md)</span><br></pre></td></tr></table></figure>

<p>在不破坏字典对象构造方法的情况下，自定义创建一个列表，用来存放key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyDict, self).__init__()</span><br><span class="line">        self.li = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.li.append(key)</span><br><span class="line">        super(MyDict, self).__setitem__(key, value)</span><br></pre></td></tr></table></figure>

<p>将新的键值对保存到字典的时候，保存它的key到我们自定义创建的列表中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDict</span><span class="params">(dict)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(MyDict, self).__init__()</span><br><span class="line">        self.li = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.li.append(key)</span><br><span class="line">        super(MyDict, self).__setitem__(key, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        tmp_list = []</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.li:</span><br><span class="line">            value = self.get(key)  <span class="comment"># 使用了父类的get方法</span></span><br><span class="line">            tmp_list.append(<span class="string">"'%s': %s"</span> % (key, value))</span><br><span class="line">        tmp_str = <span class="string">"&#123;"</span> + <span class="string">", "</span>.join(tmp_list) + <span class="string">"&#125;"</span></span><br><span class="line">        <span class="keyword">return</span> tmp_str</span><br><span class="line"></span><br><span class="line">md = MyDict()</span><br><span class="line">md[<span class="string">"k1"</span>] = <span class="number">123</span></span><br><span class="line">md[<span class="string">"k2"</span>] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line">print(md)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'k1'</span>: <span class="number">123</span>, <span class="string">'k2'</span>: <span class="number">456</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>super</tag>
      </tags>
  </entry>
  <entry>
    <title>Python对象执行父类的方法</title>
    <url>/2016/07/03/Python%E5%AF%B9%E8%B1%A1%E6%89%A7%E8%A1%8C%E7%88%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A.f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"B.f1"</span>)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">b.f1()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">B.f1</span><br></pre></td></tr></table></figure>

<p>上面的实例中，B类继承了A类，并重写了A类的f1方法，现在我想在B类中主动去调用父类中的方法，可以通过<code>super</code>关键字实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A.f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">    	<span class="comment"># 主动执行父类的f1方法</span></span><br><span class="line">        super(B, self).f1()</span><br><span class="line">        print(<span class="string">"B.f1"</span>)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">b.f1()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">A.f1</span><br><span class="line">B.f1</span><br></pre></td></tr></table></figure>

<p>应用场景：在源码中的某些功能不够完善，我们可以继承他的类，并在调用父类方法的情况下，在自己的类中添加一些功能。相当于在类中模拟了装饰器的功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A.f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"装饰开始"</span>)</span><br><span class="line">        ret = super(B, self).f1()  <span class="comment"># 接收父类f1方法执行结果的返回值</span></span><br><span class="line">        print(<span class="string">"装饰结束"</span>)</span><br><span class="line">        <span class="keyword">return</span> ret  <span class="comment"># 返回了父类f1执行结果的返回值(你可以自定义返回任何东西)</span></span><br></pre></td></tr></table></figure>

<p><em>非主流的方式去调用父类方法</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"A.f1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">        A.f1(self)  <span class="comment"># 别人这么写你需要看懂，但是自己不要这么写</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>super</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的自省之isinstance&amp;issubclass</title>
    <url>/2016/07/03/Python%E7%9A%84%E8%87%AA%E7%9C%81%E4%B9%8Bisinstance-issubclass/</url>
    <content><![CDATA[<blockquote>
<p>Python的自省，是自我反省，自己检查自己的机制。在Python中，有很多方式可以做到让Python自省，这篇文章主要介绍两个<code>isinstance</code> 和 <code>issubclass</code></p>
</blockquote>
<h1 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h1><p>isinstance(obj, cls) 用来检查obj对象是否是cls类的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(isinstance(a, A))</span><br><span class="line"></span><br><span class="line">i = <span class="number">10</span></span><br><span class="line">print(isinstance(i, int))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">print(isinstance(b, B))</span><br><span class="line">print(isinstance(b, A))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>补充：也可以是cls的父类</strong></p>
<h1 id="issubclass"><a href="#issubclass" class="headerlink" title="issubclass"></a>issubclass</h1><p>issubclass(sub, super) 用来检查sub类是否是 super 类的派生类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(issubclass(B, A))  <span class="comment"># B 继承了 A, B是A的子类</span></span><br><span class="line">print(issubclass(A, B))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>自省</tag>
        <tag>isinstance</tag>
        <tag>issubclass</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类中的特殊成员</title>
    <url>/2016/07/03/Python%E7%B1%BB%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<blockquote>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="init"><a href="#init" class="headerlink" title="__init__"></a>__init__</h1><p>构造方法，每个对象被实例化出来的时候都将首先去执行<code>__init__</code>方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"在创建对象的时候会首先自动执行__init__"</span>)</span><br></pre></td></tr></table></figure>


<h1 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h1><p>析构方法，每个对象在被垃圾回收机制回收之前执行的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__del__</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">"在对象销毁之前会执行__del__"</span>)</span><br></pre></td></tr></table></figure>


<h1 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h1><p>类的描述信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="string">"""我是A类的描述信息"""</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="module"><a href="#module" class="headerlink" title="__module__"></a>__module__</h1><p>表示当前操作的对象在哪个模块</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="string">"""我是A类的描述信息"""</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> lib <span class="keyword">import</span> A</span><br><span class="line">a = A()</span><br><span class="line">print(a.__module__)</span><br></pre></td></tr></table></figure>

<h1 id="class"><a href="#class" class="headerlink" title="__class__"></a>__class__</h1><p>表示当前操作的对象的类是什么</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.__class__)</span><br></pre></td></tr></table></figure>

<h1 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h1><p>类名后面加括号表示创建一个对象；如果在对象后面加括号，就需要使用<code>__call__</code>方法了，如果不定义这个方法，在执行<code>对象()</code>的时候就会报错</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"call"</span>)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">a()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">call</span><br></pre></td></tr></table></figure>

<p>创建对象的时候首先执行<code>__init__</code>,在对象被调用的时候执行<code>__call__</code></p>
<p>也可以在一行执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = A()()</span><br></pre></td></tr></table></figure>

<h1 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h1><p>print对象的时候显示的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;__main__.A object at <span class="number">0x101b77128</span>&gt;</span><br></pre></td></tr></table></figure>

<p>在没有定义<code>__str__</code>的情况下，输出的是a对象的内存地址信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A~"</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">A~</span><br></pre></td></tr></table></figure>

<p><strong>str的应用实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>)</span><br><span class="line">print(b)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>

<p><strong>str类型转换</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>)</span><br><span class="line">ret = str(b)</span><br><span class="line">print(ret)</span><br></pre></td></tr></table></figure>

<p><code>str(b)</code>和<code>print()</code>都会自动去调用<code>b</code>对象中的<code>__str__</code>方法</p>
<h1 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a>__dict__</h1><h2 id="对象的dict"><a href="#对象的dict" class="headerlink" title="对象的dict"></a>对象的dict</h2><p>在对象中默认已经有dict，不需要自定义。该方法用来获取对象中所有封装的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">print(b.__dict__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'age'</span>: <span class="number">26</span>, <span class="string">'name'</span>: <span class="string">'ps'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类的dict"><a href="#类的dict" class="headerlink" title="类的dict"></a>类的dict</h2><p>列出类中所有可以调用的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">print(B.__dict__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'__weakref__'</span>: &lt;attribute <span class="string">'__weakref__'</span> of <span class="string">'B'</span> objects&gt;, <span class="string">'__module__'</span>: <span class="string">'__main__'</span>, <span class="string">'__str__'</span>: &lt;function B.__str__ at <span class="number">0x10137b730</span>&gt;, <span class="string">'__init__'</span>: &lt;function B.__init__ at <span class="number">0x10137b6a8</span>&gt;, <span class="string">'__doc__'</span>: <span class="literal">None</span>, <span class="string">'__dict__'</span>: &lt;attribute <span class="string">'__dict__'</span> of <span class="string">'B'</span> objects&gt;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="add"><a href="#add" class="headerlink" title="__add__"></a>__add__</h1><p>当执行<code>一个对象 + 一个对象</code>的时候，就会自动去执行这个方法</p>
<p>注意，执行的是第一个对象的add方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.num + other.num</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">a = A(<span class="number">5</span>)</span><br><span class="line">b = B(<span class="number">9</span>)</span><br><span class="line">c = a + b</span><br><span class="line">print(c)</span><br></pre></td></tr></table></figure>

<h1 id="getitem-setitem-delitem"><a href="#getitem-setitem-delitem" class="headerlink" title="__getitem__ __setitem__ __delitem__"></a>__getitem__ __setitem__ __delitem__</h1><p>用于索引操作，如字典。以上分别表示获取、设置、删除数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">"k"</span>: <span class="string">"v"</span>&#125;</span><br><span class="line">print(d[<span class="string">"k"</span>])</span><br><span class="line">d[<span class="string">"k"</span>] = <span class="string">"vv"</span></span><br><span class="line"><span class="keyword">del</span> d[<span class="string">"k"</span>]</span><br></pre></td></tr></table></figure>

<p>上面的代码展示了一个字典对象的取值、赋值和删除的操作。在自定义的类中，也可以实现类似于字典这样的操作</p>
<p>对象后面加小括号是执行<code>__call__</code>方法，那么对象后面加中括号又是怎样处理的呢？</p>
<h2 id="使用key进行的操作"><a href="#使用key进行的操作" class="headerlink" title="使用key进行的操作"></a>使用key进行的操作</h2><h3 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了getitem方法"</span>, item)</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">b[<span class="string">"name"</span>]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">执行了getitem方法 name</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了getitem方法"</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"你要为%s重新赋值为%s"</span> % (key, value))</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">print(b.name)</span><br><span class="line">b[<span class="string">"name"</span>] = <span class="string">"lr"</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br><span class="line">你要为name重新赋值为lr</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了getitem方法"</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"你要为%s重新赋值为%s"</span> % (key, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"你要删除%s"</span> % key)</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line"><span class="keyword">del</span> b[<span class="string">"age"</span>]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">你要删除age</span><br></pre></td></tr></table></figure>

<p>在web开发中，自定义session框架的时候会用到</p>
<h2 id="使用下标进行的操作"><a href="#使用下标进行的操作" class="headerlink" title="使用下标进行的操作"></a>使用下标进行的操作</h2><p>使用下标和使用key的形式类似，使用key， item接收的是一个字符串，使用下标， item接收的是一个int类型的数字，可以在方法体内通过判断传递过来数据的数据类型来进行对应的操作</p>
<h2 id="使用切片的操作"><a href="#使用切片的操作" class="headerlink" title="使用切片的操作"></a>使用切片的操作</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">l[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>在Python2.x中使用<code>__getslice__</code> <code>__setslice__</code> <code>__delslice__</code>来实现切片的操作，但是Python3.x中被遗弃，所有切片的功能都集中在了<code>__getitem__</code> <code>__setitem__</code> <code>__delitem__</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># print("执行了getitem方法", item)</span></span><br><span class="line">        print(type(item))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"你要为%s重新赋值为%s"</span> % (key, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"你要删除%s"</span> % key)</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">b[<span class="string">"name"</span>]</span><br><span class="line">b[<span class="number">1</span>]</span><br><span class="line">b[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">class</span> '<span class="title">slice</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>item</code>为<code>slice</code>时表示调用了切片的操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"起点索引"</span>, item.start)</span><br><span class="line">        print(<span class="string">"终点索引"</span>, item.stop)</span><br><span class="line">        print(<span class="string">"步长"</span>, item.step)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"haha"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"你要为%s重新赋值为%s"</span> % (key, value))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"你要删除%s"</span> % key)</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">ret = b[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">起点索引 <span class="number">1</span></span><br><span class="line">终点索引 <span class="number">5</span></span><br><span class="line">步长 <span class="number">2</span></span><br><span class="line">haha</span><br></pre></td></tr></table></figure>

<p>相对应的，取值可以通过判断item的类型做相应的操作，赋值和删除也可以通过判断key的类型来进行想对应的切片操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"起点索引"</span>, item.start)</span><br><span class="line">        print(<span class="string">"终点索引"</span>, item.stop)</span><br><span class="line">        print(<span class="string">"步长"</span>, item.step)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"haha"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">"起点索引"</span>, key.start)</span><br><span class="line">        print(<span class="string">"终点索引"</span>, key.stop)</span><br><span class="line">        print(<span class="string">"步长"</span>, key.step)</span><br><span class="line">        print(<span class="string">"新值为"</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        print(<span class="string">"起点索引"</span>, key.start)</span><br><span class="line">        print(<span class="string">"终点索引"</span>, key.stop)</span><br><span class="line">        print(<span class="string">"步长"</span>, key.step)</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"ps"</span>, <span class="number">26</span>)</span><br><span class="line">print(<span class="string">"切片取值"</span>)</span><br><span class="line">ret = b[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"切片赋值"</span>)</span><br><span class="line">b[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>] = <span class="string">"hehe"</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"切片删除"</span>)</span><br><span class="line">print(ret)</span><br><span class="line"><span class="keyword">del</span> b[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">切片取值</span><br><span class="line">起点索引 <span class="number">1</span></span><br><span class="line">终点索引 <span class="number">5</span></span><br><span class="line">步长 <span class="number">2</span></span><br><span class="line">切片赋值</span><br><span class="line">起点索引 <span class="number">1</span></span><br><span class="line">终点索引 <span class="number">5</span></span><br><span class="line">步长 <span class="number">2</span></span><br><span class="line">新值为 hehe</span><br><span class="line">切片删除</span><br><span class="line">haha</span><br><span class="line">起点索引 <span class="number">1</span></span><br><span class="line">终点索引 <span class="number">5</span></span><br><span class="line">步长 <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h1 id="iter"><a href="#iter" class="headerlink" title="__iter__"></a>__iter__</h1><p>一个自定义类实例化的对象，默认是不可迭代的，在类中使用<code>__iter__</code>方法后，对象就变成了可迭代对象。当对象被迭代时，会自动调用iter方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/8/c8.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">TypeError: <span class="string">'A'</span> object <span class="keyword">is</span> <span class="keyword">not</span> iterable</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter([<span class="number">1</span>, <span class="number">2</span>])  <span class="comment"># return了一个可迭代对象</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span>  <span class="comment"># 返回了一个生成器</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>先去a对象中找到iter方法执行，并拿到返回值进行迭代</p>
<h1 id="new-metaclass"><a href="#new-metaclass" class="headerlink" title="__new__ __metaclass__"></a>__new__ __metaclass__</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line">a = A()   <span class="comment"># a是通过A类实例化的对象</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，a 是通过 A 类实例化的对象，其实，不仅 a 是一个对象，A类本身也是一个对象，因为在Python中一切事物都是对象。</p>
<p>如果按照一切事物都是对象的理论：a对象是通过执行A类的构造方法创建，那么A类对象应该也是通过执行某个类的构造方法创建。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> type(a) <span class="comment"># 输出：&lt;class '__main__.A'&gt;     表示，a对象由A类创建</span></span><br><span class="line"><span class="keyword">print</span> type(A) <span class="comment"># 输出：&lt;type 'type'&gt;              表示，A类对象由type类创建</span></span><br></pre></td></tr></table></figure>

<p>所以，a对象是A类的一个实例，A类对象是<code>type</code>类的一个实例，即：A类对象是通过<code>type</code>类的构造方法创建</p>
<p>那么，创建类就可以有两种方式：</p>
<ul>
<li>普通方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"ps"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊方式（type类的构造函数）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"ps"</span>)</span><br><span class="line"> </span><br><span class="line">A = type(<span class="string">'A'</span>,(object,), &#123;<span class="string">'func'</span>: func&#125;)</span><br><span class="line"><span class="comment">#type第一个参数：类名</span></span><br><span class="line"><span class="comment">#type第二个参数：当前类的基类</span></span><br><span class="line"><span class="comment">#type第三个参数：类的成员</span></span><br></pre></td></tr></table></figure>

<p><strong>–&gt; 类是由type类实例化产生</strong></p>
<p>那么问题来了，类默认是由 type 类实例化产生，type类中如何实现的创建类？类又是如何创建对象？</p>
<p>答：类中有一个属性<code>__metaclass__</code> 其用来表示该类由<code>谁</code>来实例化创建，所以，我们可以为<code>__metaclass__</code>设置一个type类的派生类，从而查看<code>类</code>创建的过程</p>
<p><img src="http://oss.20150509.cn/QQ20160703-1.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyType</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, what, bases=None, dict=None)</span>:</span></span><br><span class="line">        super(MyType, self).__init__(what, bases, dict)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        obj = self.__new__(self, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        self.__init__(obj)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    __metaclass__ = MyType</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一阶段：解释器从上到下执行代码创建A类</span></span><br><span class="line"><span class="comment"># 第二阶段：通过A类创建a对象</span></span><br><span class="line">a = A()</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>__init__</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类成员之成员修饰符</title>
    <url>/2016/07/03/Python%E7%B1%BB%E6%88%90%E5%91%98%E4%B9%8B%E6%88%90%E5%91%98%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    <content><![CDATA[<blockquote>
<p>Python中的成员修饰符比Java中少了2个。只有公有和私有两种</p>
<p>Python Version: 3.5+</p>
</blockquote>
<p>成员修饰符是用来设置字段、方法和属性的。默认情况下，成员是公有的</p>
<h1 id="公有"><a href="#公有" class="headerlink" title="公有"></a>公有</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)  <span class="comment"># 在类的内部进行访问</span></span><br><span class="line"></span><br><span class="line">c = C(<span class="string">"ps"</span>)</span><br><span class="line">print(c.name)  <span class="comment"># 在类的外部进行访问</span></span><br><span class="line">c.func()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>

<p>像以上代码那样，字段从类的内部和外部都可以访问的情况，成员修饰符就是公有的</p>
<h1 id="私有"><a href="#私有" class="headerlink" title="私有"></a>私有</h1><p>在类中的成员名前面加上两个下划线<code>__</code>，就可以将该成员的属性设置为私有。私有的成员只有从类的内部访问的权限，出了该类的内部，其他任何地方都不允许访问，包括该类的派生类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__name)  <span class="comment"># 在类的内部进行访问</span></span><br><span class="line"></span><br><span class="line">c = C(<span class="string">"ps"</span>)</span><br><span class="line">print(c.__name)  <span class="comment"># 在类的外部进行访问</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/8/c5.py"</span>, line <span class="number">9</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(c.name)  <span class="comment"># 在类的外部进行访问</span></span><br><span class="line">AttributeError: <span class="string">'C'</span> object has no attribute <span class="string">'name'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__name)  <span class="comment"># 在类的内部进行访问</span></span><br><span class="line"></span><br><span class="line">c = C(<span class="string">"ps"</span>)</span><br><span class="line">c.func()  <span class="comment"># 只能通过该方法，从类的内部进行访问</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br></pre></td></tr></table></figure>

<h1 id="Python访问私有成员的后门"><a href="#Python访问私有成员的后门" class="headerlink" title="Python访问私有成员的后门"></a>Python访问私有成员的后门</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__name)  <span class="comment"># 在类的内部进行访问</span></span><br><span class="line"></span><br><span class="line">c = C(<span class="string">"ps"</span>)</span><br><span class="line"><span class="comment"># print(c.__name)  # 在类的外部进行访问</span></span><br><span class="line">print(c._C__name)</span><br></pre></td></tr></table></figure>

<p>通过<code>_类名__成员名</code>这样的语法格式来强制访问类中的私有成员</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>成员修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象中类的成员</title>
    <url>/2016/07/03/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%AD%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98/</url>
    <content><![CDATA[<blockquote>
<p>Python面向对象中类的成员总共有三种，分别是字段、方法和属性</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><h2 id="普通字段"><a href="#普通字段" class="headerlink" title="普通字段"></a>普通字段</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		<span class="comment"># 我就是字段，普通字段</span></span><br><span class="line">		self.name = <span class="string">"polarsnow"</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self.name)</span><br><span class="line">		<span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<p>在上面的代码块中，<code>self.name</code>就是类中的字段。该字段的信息会保存在每一个实例化的对象中</p>
<h2 id="静态字段"><a href="#静态字段" class="headerlink" title="静态字段"></a>静态字段</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="comment"># 我也是字段，我是静态字段</span></span><br><span class="line">	country = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		<span class="comment"># 我就是字段，普通字段</span></span><br><span class="line">		self.name = <span class="string">"polarsnow"</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self.name)</span><br><span class="line">		<span class="keyword">return</span> self.name</span><br></pre></td></tr></table></figure>

<p>静态字段保存在类中。每个实例化的类中，都保存了一个类对象指针指向一个类。每个对象自己封装了自己的普通字段信息，但是该类所有的对象都共用了一份儿静态字段。</p>
<p>静态字段的应用场景和好处是某个类中，共用的一些信息可以抽离出来当做静态字段，好处是每个对象可以不用再重复性的保存同一份数据。</p>
<h2 id="字段访问规则"><a href="#字段访问规则" class="headerlink" title="字段访问规则"></a>字段访问规则</h2><p>一般情况下：自己去访问自己的字段</p>
<p>例如：访问静态字段，前面提到了，静态字段保存在类中，所以原则上需要使用类去访问静态字段；如果访问普通字段，普通字段保存在对象中，所以只能使用对象去访问普通字段。</p>
<p>在Java中，强制性的要求静态字段只能由类去访问；但是在Python中比较特殊，类中的静态字段也是可以通过对象去访问的。你需要坚持的原则就是：自己去访问自己的字段。不到特殊情况下，不要使用对象去访问类中的静态字段</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="comment"># 我也是字段，我是静态字段</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 我就是字段，普通字段</span></span><br><span class="line">        self.name = <span class="string">"polarsnow"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A(<span class="string">"polarsnow"</span>)</span><br><span class="line">print(<span class="string">"使用对象访问普通字段"</span>)</span><br><span class="line">print(a.name)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用类访问静态字段"</span>)</span><br><span class="line">print(A.country)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用对象访问静态字段"</span>)</span><br><span class="line">print(a.country)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">使用对象访问普通字段</span><br><span class="line">polarsnow</span><br><span class="line">使用类访问静态字段</span><br><span class="line">China</span><br><span class="line">使用对象访问静态字段</span><br><span class="line">China</span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/QQ20160703-0.png" alt=""></p>
<p>由于每个对象都保存了类对象指针，当访问的字段在本对象中找不到的时候会去类中查找有没有对应的静态字段</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态字段在代码加载的时候就已经被创建；而普通字段只有在实例化一个对象时候才被创建</p>
<p>在类的内部访问静态字段，推荐也带上类名来访问<code>A.country</code>符合上面说的<code>自己去访问自己的字段</code>的访问原则</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>在其他面向对象语言中，类的方法有两种，但是在Python中有三种</p>
<h2 id="普通方法"><a href="#普通方法" class="headerlink" title="普通方法"></a>普通方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是普通方法 由对象调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"北京"</span>)</span><br><span class="line">b.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">北京</span><br></pre></td></tr></table></figure>

<p>普通方法，由对象去调用执行（方法属于类）</p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是普通方法 由对象调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_static</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"我是静态方法"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是静态方法"</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"北京"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用对象去调用执行普通方法"</span>)</span><br><span class="line">b.show()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用类去调用静态方法"</span>)</span><br><span class="line">B.func_static()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">使用对象去调用执行普通方法</span><br><span class="line">北京</span><br><span class="line">使用类去调用静态方法</span><br><span class="line">我是静态方法</span><br></pre></td></tr></table></figure>

<p><strong>普通方法和静态方法的区别</strong>：在上面的字段介绍中，静态字段和普通字段的区别是，静态字段一般由类去调用而普通字段一定是由对象去调用。静态方法和普通方法也是一样，静态方法一般是由类去调用执行，而普通方法是由对象去调用执行</p>
<p><strong>定义一个静态方法</strong></p>
<p>定义一个静态方法，首先需要在方法上面加上一个装饰器<code>@staticmethod</code>，下面的方法参数中，不要再含有<code>self</code>参数。至于静态方法的用法，和普通的函数用法没有任何区别，后面可以添加任意参数进行传值</p>
<p><strong>小结：</strong>静态方法虽然在类中，属于类，但是静态方法和对象没有任何关系，它是由类去调用的。这一点在静态方法的参数列表中也可以很明显的看出，它没有接受self参数，也就是没有接受对象。静态方法的调用不依赖与任何一个具体的对象。那为什么这个方法和类没有关系还要放在这个类中呢？一般情况下，我们把某些和类相关的操作都会放在类中，方便查找和使用，所以很多时候，类中会出现和对象不相关，但是和类却息息相关的操作。</p>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><p>类方法是Python独有的一个方法。本质上静态方法的一种特殊形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    country = <span class="string">"China"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是普通方法 由对象调用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是静态方法</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_static</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"我是静态方法"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是静态方法"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 我是类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func_class</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"我是类方法"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我是类方法"</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="string">"北京"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用对象去调用执行普通方法"</span>)</span><br><span class="line">b.show()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用类去调用静态方法"</span>)</span><br><span class="line">B.func_static()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"使用类去调用类方法"</span>)</span><br><span class="line">B.func_class()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">使用对象去调用执行普通方法</span><br><span class="line">北京</span><br><span class="line">使用类去调用静态方法</span><br><span class="line">我是静态方法</span><br><span class="line">使用类去调用类方法</span><br><span class="line">我是类方法</span><br></pre></td></tr></table></figure>

<p>在静态方法中，可以没有任何参数，也可以有任意多个参数，使用类去调用；但是在类方法中，至少要有一个参数<code>cls</code>， 也是使用类去调用。这一特点和普通方法又很像，普通方法也是至少要有一个参数，但普通方法的必有参数为<code>self</code></p>
<ul>
<li>self在普通方法中，代指了对象</li>
<li>cls在类方法中，代指了类。跟self一样会隐式传递</li>
</ul>
<p>类方法比静态方法只多了一步，就是隐式的把类传递给了类方法</p>
<p><strong>类方法的应用：</strong>单例模式的实现</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Python中类的三个方法都属于类</p>
<ul>
<li>普通方法 至少要有一个self参数 通过对象去执行</li>
<li>静态方法 参数可有可无 通过类去执行（也可以对象执行）</li>
<li>类方法 至少有一个cls参数 通过类去执行（也可以对象执行）</li>
</ul>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><strong>属性的特征是：拥有普通方法的样式和表现形式，却拥有字段的访问方式</strong></p>
<p>现有如下需求：需要做一个分页器，每10条内容分一页，最后得出一共分出多少页的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先使用普通方法的方式来实现这个功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pageer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        p1, p2 = divmod(self.num, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = Pageer(<span class="number">59</span>)</span><br><span class="line">print(p.all_pager())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用属性的方式来实现这个功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pageer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        p1, p2 = divmod(self.num, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">p = Pageer(<span class="number">59</span>)</span><br><span class="line">print(p.all_pager)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>对比两段代码可以看出，有两点区别</p>
<ul>
<li>在普通方法的上面加了一个<code>@property</code>装饰器</li>
<li>在调用这个普通成员的时候，第一段代码使用了标准的普通方法调用执行的方式<code>p.all_pager()</code>；第二段代码则使用了访问普通字段的方式<code>p.all_pager</code></li>
</ul>
<p>这就是上面说的属性的特征，既拥有和普通方法一样的表现形式，又有访问普通字段那样的访问形式</p>
<h2 id="对属性的赋值"><a href="#对属性的赋值" class="headerlink" title="对属性的赋值"></a>对属性的赋值</h2><p>上面的小例子实现了对属性的取值。对于访问普通字段来说，不仅可以访问，还是为普通字段赋值。那么属性既然有着普通字段的访问形式，能不能也去实现像普通字段那样的赋值呢？<code>p.all_pager = 1991</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pageer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        p1, p2 = divmod(self.num, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @all_pager.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(value)</span><br><span class="line"></span><br><span class="line">p = Pageer(<span class="number">59</span>)</span><br><span class="line">print(p.all_pager)</span><br><span class="line"></span><br><span class="line">p.all_pager = <span class="number">1991</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">1991</span></span><br></pre></td></tr></table></figure>

<p>对属性进行赋值的关键语法：</p>
<ul>
<li>一定要使用<code>属性取值方法的方法名.setter</code>装饰器</li>
<li>赋值方法的函数名必须和取值方法的方法名一致</li>
<li>在赋值方法中，接受一个赋值参数<code>value</code></li>
</ul>
<p>在为<code>all_pager</code>赋值的时候，会自动执行<code>@all_pager.setter</code>下面的方法（特别注意：属性赋值方法中不能return返回值）</p>
<h2 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h2><p>在对字段的操作中，可以访问字段，给字段赋值，还可以删除字段。上面的属性中，已经实现了属性的访问和赋值，接下来要实现属性的删除，这样一来，属性就拥有了和字段一样的操作特性了（查，改，删）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pageer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        p1, p2 = divmod(self.num, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">if</span> p2 == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> p1</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> p1 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @all_pager.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(value)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @all_pager.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"del all_pager"</span>)</span><br><span class="line"></span><br><span class="line">p = Pageer(<span class="number">59</span>)</span><br><span class="line">print(p.all_pager)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"为属性赋值"</span>)</span><br><span class="line">p.all_pager = <span class="number">1991</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"删除属性"</span>)</span><br><span class="line"><span class="keyword">del</span> p.all_pager</span><br></pre></td></tr></table></figure>

<h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p>属性具有方法的表现形式，同时具有字段的访问形式<em>（通过不加括号<code>()</code>的方式去执行了一个方法）</em></p>
<p>由于属性的这个访问特性是我们通过三个方法来伪造出来的，所以每个操作对应了具体什么内容，需要我们来自己定义。就像上面的删除方法，我只是print了一下而已~~ Python只是根据我们操作属性的方式，提供了一种关联方式而已，具体里面需要实现哪些功能都需要我们自己去定义</p>
<p>注意：如果你想真的在内存中实现删除all_pager属性，你可能会这样写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@all_pager.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_pager</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.all_pager</span><br></pre></td></tr></table></figure>

<p>这样做的结果是会进入一个死循环。因为你在外面调用del函数来删除对象属性的时候，会去deleter里面执行<code>del self.all_pager</code>代码，该代码又会跳到deleter里面执行<code>del self.all_pager</code>,所以会进入一个死循环。属性的删除方法，应该根据实际需要调整他的功能</p>
<p><strong>属性存在意义是：访问属性时可以制造出和访问字段完全相同的假象。属性由方法变种而来，如果Python中没有属性，方法完全可以代替其功能</strong></p>
<h2 id="属性的第二种表现形式"><a href="#属性的第二种表现形式" class="headerlink" title="属性的第二种表现形式"></a>属性的第二种表现形式</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pageer</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        self.num = num</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1991</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"set"</span>, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"del"</span>)</span><br><span class="line"></span><br><span class="line">    func = property(fget=func1, fset=func2, fdel=func3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Pageer(<span class="number">59</span>)</span><br><span class="line">print(p.func)  <span class="comment"># 自动去调用fget=func1</span></span><br><span class="line">p.func = <span class="number">2016</span>  <span class="comment"># 自动去调用fset=func2</span></span><br><span class="line"><span class="keyword">del</span> p.func  <span class="comment"># 自动去调用fdel=func3</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">1991</span></span><br><span class="line">set <span class="number">2016</span></span><br><span class="line"><span class="keyword">del</span></span><br></pre></td></tr></table></figure>

<p>property的构造方法中有个四个参数</p>
<ul>
<li>第一个参数是方法名，调用 对象.属性 时自动触发执行方法</li>
<li>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</li>
<li>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法</li>
<li>第四个参数是字符串，调用 对象.属性.<strong>doc</strong> ，此参数是该属性的描述信息</li>
</ul>
<p>这种通过静态字段的方式实现属性的操作在很多源码中很常见，使用的频率是最高的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python WEB框架 Django 的视图中 request.POST 就是使用的静态字段的方式创建的属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WSGIRequest</span><span class="params">(http.HttpRequest)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ)</span>:</span></span><br><span class="line">        script_name = get_script_name(environ)</span><br><span class="line">        path_info = get_path_info(environ)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path_info:</span><br><span class="line">            <span class="comment"># Sometimes PATH_INFO exists, but is empty (e.g. accessing</span></span><br><span class="line">            <span class="comment"># the SCRIPT_NAME URL without a trailing slash). We really need to</span></span><br><span class="line">            <span class="comment"># operate as if they'd requested '/'. Not amazingly nice to force</span></span><br><span class="line">            <span class="comment"># the path like this, but should be harmless.</span></span><br><span class="line">            path_info = <span class="string">'/'</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.path_info = path_info</span><br><span class="line">        self.path = <span class="string">'%s/%s'</span> % (script_name.rstrip(<span class="string">'/'</span>), path_info.lstrip(<span class="string">'/'</span>))</span><br><span class="line">        self.META = environ</span><br><span class="line">        self.META[<span class="string">'PATH_INFO'</span>] = path_info</span><br><span class="line">        self.META[<span class="string">'SCRIPT_NAME'</span>] = script_name</span><br><span class="line">        self.method = environ[<span class="string">'REQUEST_METHOD'</span>].upper()</span><br><span class="line">        _, content_params = cgi.parse_header(environ.get(<span class="string">'CONTENT_TYPE'</span>, <span class="string">''</span>))</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'charset'</span> <span class="keyword">in</span> content_params:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                codecs.lookup(content_params[<span class="string">'charset'</span>])</span><br><span class="line">            <span class="keyword">except</span> LookupError:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.encoding = content_params[<span class="string">'charset'</span>]</span><br><span class="line">        self._post_parse_error = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            content_length = int(environ.get(<span class="string">'CONTENT_LENGTH'</span>))</span><br><span class="line">        <span class="keyword">except</span> (ValueError, TypeError):</span><br><span class="line">            content_length = <span class="number">0</span></span><br><span class="line">        self._stream = LimitedStream(self.environ[<span class="string">'wsgi.input'</span>], content_length)</span><br><span class="line">        self._read_started = <span class="literal">False</span></span><br><span class="line">        self.resolver_match = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_scheme</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.environ.get(<span class="string">'wsgi.url_scheme'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_request</span><span class="params">(self)</span>:</span></span><br><span class="line">        warnings.warn(<span class="string">'`request.REQUEST` is deprecated, use `request.GET` or '</span></span><br><span class="line">                      <span class="string">'`request.POST` instead.'</span>, RemovedInDjango19Warning, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_request'</span>):</span><br><span class="line">            self._request = datastructures.MergeDict(self.POST, self.GET)</span><br><span class="line">        <span class="keyword">return</span> self._request</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># The WSGI spec says 'QUERY_STRING' may be absent.</span></span><br><span class="line">        raw_query_string = get_bytes_from_wsgi(self.environ, <span class="string">'QUERY_STRING'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> http.QueryDict(raw_query_string, encoding=self._encoding)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_post</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_post'</span>):</span><br><span class="line">            self._load_post_and_files()</span><br><span class="line">        <span class="keyword">return</span> self._post</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_post</span><span class="params">(self, post)</span>:</span></span><br><span class="line">        self._post = post</span><br><span class="line"></span><br><span class="line"><span class="meta">    @cached_property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">COOKIES</span><span class="params">(self)</span>:</span></span><br><span class="line">        raw_cookie = get_str_from_wsgi(self.environ, <span class="string">'HTTP_COOKIE'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> http.parse_cookie(raw_cookie)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_files</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'_files'</span>):</span><br><span class="line">            self._load_post_and_files()</span><br><span class="line">        <span class="keyword">return</span> self._files</span><br><span class="line"></span><br><span class="line">    POST = property(_get_post, _set_post)</span><br><span class="line">    </span><br><span class="line">    FILES = property(_get_files)</span><br><span class="line">    REQUEST = property(_get_request)</span><br></pre></td></tr></table></figure>

<ul>
<li>第70行，定义了属性的两个方法，取值和赋值</li>
<li>第52行，取值</li>
<li>第57行，赋值</li>
</ul>
<h1 id="特别强调"><a href="#特别强调" class="headerlink" title="特别强调"></a>特别强调</h1><p>最后再一次强调，本站关于Python的介绍大多数是基于Python3.5+</p>
<p>上面关于属性通过装饰器的方式来实现不同的操作时，均是在Python3.5+的环境下，如果你在Python2.x的环境下，得到的结果肯定会不一样。因为Python2.x中</p>
<ul>
<li>经典类中的属性只有一种访问方式，其对应被<code>@property</code>修饰的方法</li>
<li>新式类中的属性有三种访问方式，并分别对应了三个被<code>@property</code> <code>@方法名.setter</code> <code>@方法名.deleter</code>修饰的方法</li>
</ul>
<p>但是在Python3中，经典类也是拥有这三种访问方式的。</p>
<p><em>继承了object的类就是新式类，否则为经典类</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>方法</tag>
        <tag>面向对象</tag>
        <tag>字段</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象基础篇之多态</title>
    <url>/2016/07/03/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<blockquote>
<p>Python是否支持多态的问题争论已久，在面向对象语言中，有三大特性（封装 继承 多态）Python作为典型的面向对象语言，怎么可能会不支持多态呢</p>
</blockquote>
<p>产生这个问题的原因在于Python是一门动态编程语言，在运行的时候可以更改自己的结构。在java等面向对象语言中，定义一个变量，强制要求首先声明他的数据类型；而在Python中，这个步骤是完全可以忽略的。由于Python动态语言的特性，Python天生就支持多态，不需要像其他面向对象的语言那样使用了多态语法来实现多态的特性。大家争论Python是否支持多态，其实都是纠结在Python没有多态的语法。</p>
<ul>
<li><p>在java中，如果一个变量被声明是int类型，如果被赋值为一个字符串对象，那一定会报错。在像Java这种强类型的语言中，一个变量被声明数据类型时候，只允许被这个类或这个类的派生类赋值。</p>
</li>
<li><p>而在Python中，声明一个变量，你可以给他赋任何类型的值（对象）</p>
</li>
</ul>
<p>多态可以简单的理解为多种形态，多种类型。在Python中，不需要特殊的多态语法来实现多态的特性。</p>
<p><strong>动态语言的优势与劣势</strong></p>
<p>毋庸置疑，动态语言带来的便捷是显而易见的，我们不需要关心变量的数据类型，因为在赋值的过程中，Python会动态的改变自己的结构。</p>
<p>由于Python动态语言的特性，一个变量可以被任何数据类型赋值，也造成了一个困扰，就是在读别人源码的时候，如果参数只写了一个<code>arg</code>,那我们是不知道它具体是需要传递什么样类型的参数的。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title>pickle load自定义对象报错</title>
    <url>/2016/07/03/pickle-load%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<blockquote>
<p>Python中的pickle可以保存Python中的任意对象到文件中。当我们dump一个自定义类实例化出来的对象之后，如果需要在其他Python模块（文件）中load进来，需要注意，一定要先导入这个自定义的类，否则执行对象的方法的时候会报错</p>
</blockquote>
<p>实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">	print(<span class="string">"--dump--"</span>)</span><br><span class="line">	a = A(<span class="string">"polarsnow"</span>)</span><br><span class="line">	pickle.dump(a, open(<span class="string">'db'</span>, <span class="string">'wb'</span>))</span><br><span class="line">	</span><br><span class="line">	print(<span class="string">"--load--"</span>)</span><br><span class="line">	ret = pickle.load(open(<span class="string">'db'</span>, <span class="string">'rb'</span>))</span><br><span class="line">	print(ret)</span><br><span class="line">	ret.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">--dump--</span><br><span class="line">--load--</span><br><span class="line">&lt;__main__.A object at <span class="number">0x101b77e10</span>&gt;</span><br><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<ul>
<li>创建一个自定义的类</li>
<li>实例化这个类的对象</li>
<li>将这个对象从内存中dump到一个文件中</li>
<li>从本程序load pickle文件到内存中</li>
<li>执行对象的一个方法</li>
</ul>
<p>上面从本程序中，load自定义类实例化出来的对象，执行对象的操作是没有问题的。那么如果是从另一个文件load这个对象呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">ret = pickle.load(open(<span class="string">'db'</span>, <span class="string">'rb'</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/8/loadpickle.py"</span>, line <span class="number">3</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ret = pickle.load(open(<span class="string">'db'</span>, <span class="string">'rb'</span>))</span><br><span class="line">AttributeError: Can<span class="string">'t get attribute '</span>A<span class="string">' on &lt;module '</span>__main__<span class="string">' from '</span>/Users/lvrui/PycharmProjects/untitled/<span class="number">8</span>/loadpickle.py<span class="string">'&gt;</span></span><br></pre></td></tr></table></figure>

<p>从另一个Python文件中load一个自定义类的对象时报错了！为什么会报错？因为对象是由类而产生的，在新的Python文件中，类没有被加载到内存中，所以load这个类的对象的时候就会报错。在报错信息中也可以看出，没有在当前文件中找到A这个类。</p>
<p>解决这个问题有两个途径：</p>
<ul>
<li>将类导入到这个Python文件中</li>
<li>将类的代码直接copy到这个文件中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">from</span> dumppickle <span class="keyword">import</span> A</span><br><span class="line"></span><br><span class="line">ret = pickle.load(open(<span class="string">'db'</span>, <span class="string">'rb'</span>))</span><br><span class="line">print(ret)</span><br><span class="line">ret.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;dumppickle.A object at <span class="number">0x1013777b8</span>&gt;</span><br><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<p>注意：一个对象，有它对应的类才有意义。所以在load pickle文件中的对象的时候，一定要保证它的类先被导入</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>pickle</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象基础篇之继承</title>
    <url>/2016/06/28/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<blockquote>
<p>在Java和C#这类面向对象的语言中，一个类只允许有一个父类。而在Python中，可以有多个父类。继承，顾名思义，就是子类默认获得父类中的所有成员。当子类中不包含与父类同名的成员时，Python会自动去父类中查找并使用父类的成员；当子类中的成员与父类中的成员名称相同时，优先使用子类的成员。这种覆盖父类成员属性的特性被称之为“重写”或“复写”</p>
</blockquote>
<h1 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h1><p>继承可以简单的理解为，将父类中的所有成员copy一份到子类中，子类和父类如果有相同的成员名，优先使用子类的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'show'</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'get'</span>)</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我让B类去继承了A类，也就是说A类是B类的父类。现在B类和A类中没有名字相同的成员，所以可以简单的看做是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'show'</span>)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'get'</span>)</span><br></pre></td></tr></table></figure>

<p>接下来执行如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = B()</span><br><span class="line">b.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">show</span><br></pre></td></tr></table></figure>

<p>通过上面的额代码可以验证，在B类中，并没有show方法，但是B类继承了A类，相当于继承了A类所有的代码，所以B类的对象可以使用A类的成员方法。</p>
<h1 id="重写的特性"><a href="#重写的特性" class="headerlink" title="重写的特性"></a>重写的特性</h1><p>上面我们说到，只有在子类中与父类的成员方法名字不冲突的时候，才会<code>将父类中的成员方法copy到子类中使用</code>（继承到子类）那么，假如子类和父类的某些方法名字冲突了会怎样呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'A show'</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'get'</span>)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'B show'</span>)</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">b.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">B show</span><br></pre></td></tr></table></figure>

<h1 id="在父类中调用子类的成员属性或方法"><a href="#在父类中调用子类的成员属性或方法" class="headerlink" title="在父类中调用子类的成员属性或方法"></a>在父类中调用子类的成员属性或方法</h1><ul>
<li>实例一</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A show'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'get'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B show'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b = B(<span class="string">'polarsnow'</span>)</span><br><span class="line">b.func()</span><br><span class="line">b.func2()</span><br></pre></td></tr></table></figure>

<p>猜一猜会有什么样的结果？会打印出<code>polarsnow</code>和<code>get</code>吗？</p>
<p>按照之前的说法，我们可以把上面的继承看成下面这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">		self.name = name</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(self.name)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.get()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'get'</span>)</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'B show'</span>)</span><br><span class="line">		</span><br><span class="line">b = B(<span class="string">'polarsnow'</span>)</span><br><span class="line">b.func()</span><br></pre></td></tr></table></figure>

<p>这样看答案就清楚了吧，肯定是会打印<code>polarsnow</code>和<code>get</code>的</p>
<p>这里只是举个例子，实际使用中，不推荐在父类中去调用子类的属性，因为有的时候，你不能确定所有继承这个父类的子类都拥有这个成员属性。</p>
<ul>
<li>实例二</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.f2()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'A f2'</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.f1()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'B f2'</span>)</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">b.f3()</span><br></pre></td></tr></table></figure>

<p>创建了B类的对象b，然后执行了对象b的f3方法，在f3方法中又执行了f1方法，f1方法在B类中没有，但是B类继承了A类的代码，（注意这里是继承了A类的成员，可以理解为copy过来的成员，而不是去A类中找相应的成员）执行了f1方法后，又调用了f2方法，思考，这个f2是调用了A类中的f2还是B类中的f2？</p>
<p>根据继承的原理，我们把上面的代码看做如下代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.f2()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'A f2'</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.f2()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(self)</span>:</span></span><br><span class="line">		self.f1()</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'B f2'</span>)</span><br><span class="line">		</span><br><span class="line">b = B()</span><br><span class="line">b.f3()</span><br></pre></td></tr></table></figure>

<p>将父类中有而子类中没有的成员copy到子类中，子类中有而父类中也有的优先使用子类的成员（重写父类成员）所以A类中只有f1这个成员方法被copy到了B类中。</p>
<p>当B类的对象b调用f3方法时，调用本类中的f1方法（继承过来的成员方法），接着在f1方法中又调用了本类中已经存在的f2方法。所以最后调用的是B类中的f2方法。</p>
<p>如果执行以下命令，执行的f2是哪里的f2？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = A()</span><br><span class="line">a.f1()</span><br></pre></td></tr></table></figure>

<p>当然会执行本类中的f2方法，也就是A类中的f2方法</p>
<p><strong>总结：</strong>由于Python类中self隐式传递对象自己本身的特性，可以看出，如果调用了子类中不存在的成员，那么去父类中查找的时候，self变量仍然等于原对象自己本身，也就是说，继承的每次查找，都会返回到最底层的（调用对象的那一层）类中去找，如果找不到，才会去父类中查找。（记住每次寻找失败都回到原点）</p>
<h1 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h1><ul>
<li>一个类同时继承两个类的情况下，会优先去左边的父类中查找，如果没有则去右边的类中查找</li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160628-1@2x.png" alt=""></p>
<ul>
<li>一个类同时继承两个类，左边的类又继承了一个类的情况下，会优先从最左边的类开始找，如果没有，则继续向上查找，如果上面的类还有单继承，就继续向上查找，直到找到没有继承的类为止</li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160628-2@2x.png" alt=""></p>
<ul>
<li>如果多继承出现了如下的继承关系，那么左边的类将找到没有继承或公共继承的类为止，然后就切到了第二个类中继续向上查找，公共继承的类会在最右边的类中被找到</li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160628-3@2x.png" alt=""></p>
<h1 id="查看Python源码的技巧"><a href="#查看Python源码的技巧" class="headerlink" title="查看Python源码的技巧"></a>查看Python源码的技巧</h1><p>在Python的源码中，我们看到好多的pass，却不知道真正的函数体或方法体写在了哪里，那么看完Python的多继承，将完全解决这个问题！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line">s = socketserver.ThreadingTCPServer()</span><br><span class="line">s.serve_forever()</span><br></pre></td></tr></table></figure>

<p><code>socketserver.ThreadingTCPServer()</code>创建了一个对象，而创建对象时需要执行<code>__init__</code>方法，我们来看看源码中有没有提供这个init方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingTCPServer</span><span class="params">(ThreadingMixIn, TCPServer)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>从上面的源码中可以看出，这个类直接被pass掉了。根据上面的多继承的知识，本类中没有init方法，我们需要去他的父类中去查找，首先去左边第一个父类中去查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingMixIn</span>:</span></span><br><span class="line">    <span class="string">"""Mix-in class to handle each request in a new thread."""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decides how threads will act upon termination of the</span></span><br><span class="line">    <span class="comment"># main process</span></span><br><span class="line">    daemon_threads = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request_thread</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Same as in BaseServer but as a thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In addition, exception handling is done here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.finish_request(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Start a new thread to process the request."""</span></span><br><span class="line">        t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                             args = (request, client_address))</span><br><span class="line">        t.daemon = self.daemon_threads</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p>这边也没有init方法，这个时候由于这个类不再有继承关系，所以需要回到原点查找第二个父类中有没有init方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span><span class="params">(BaseServer)</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, server_address, RequestHandlerClass, bind_and_activate=True)</span>:</span></span><br><span class="line">        <span class="string">"""Constructor.  May be extended, do not override."""</span></span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.server_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>哎~ 在这里找到了init方法，那么最开始创建的对象的代码的init方法，就会使用这里的代码啦！</p>
<p>至此，<code>s = socketserver.TreadingTCPServer()</code>这一行代码就执行完毕啦。</p>
<p>接下来需要执行这个对象的<code>server.forver()</code>方法</p>
<p>接着又回到这个类中查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingTCPServer</span><span class="params">(ThreadingMixIn, TCPServer)</span>:</span> <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>没有，从左边的父类找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingMixIn</span>:</span></span><br><span class="line">    <span class="string">"""Mix-in class to handle each request in a new thread."""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decides how threads will act upon termination of the</span></span><br><span class="line">    <span class="comment"># main process</span></span><br><span class="line">    daemon_threads = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request_thread</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Same as in BaseServer but as a thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In addition, exception handling is done here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.finish_request(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Start a new thread to process the request."""</span></span><br><span class="line">        t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                             args = (request, client_address))</span><br><span class="line">        t.daemon = self.daemon_threads</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p>左边没有，去右边查找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span><span class="params">(BaseServer)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>右边也没有找到，但是右边的父类中，还有一个继承，继续向上查找！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">serve_forever</span><span class="params">(self, poll_interval=<span class="number">0.5</span>)</span>:</span></span><br><span class="line">        <span class="string">"""Handle one request at a time until shutdown.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Polls for shutdown every poll_interval seconds. Ignores</span></span><br><span class="line"><span class="string">        self.timeout. If you need to do periodic tasks, do them in</span></span><br><span class="line"><span class="string">        another thread.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.__is_shut_down.clear()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># <span class="doctag">XXX:</span> Consider using another file descriptor or connecting to the</span></span><br><span class="line">            <span class="comment"># socket to wake this up instead of polling. Polling reduces our</span></span><br><span class="line">            <span class="comment"># responsiveness to a shutdown request and wastes cpu at all other</span></span><br><span class="line">            <span class="comment"># times.</span></span><br><span class="line">            <span class="keyword">with</span> _ServerSelector() <span class="keyword">as</span> selector:</span><br><span class="line">                selector.register(self, selectors.EVENT_READ)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">                    ready = selector.select(poll_interval)</span><br><span class="line">                    <span class="keyword">if</span> ready:</span><br><span class="line">                        self._handle_request_noblock()</span><br><span class="line"></span><br><span class="line">                    self.service_actions()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">            self.__is_shut_down.set()</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>啊哈，原来在这里找到了它！！！但是这里面又调用了<code>self._handle_request_noblock()</code>这个方法，根据之前的继承原理，这里的self指的是调用对象的地址，所以需要重新回到<code>socketserver.ThreadingTCPServer()</code>开始查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 源码</span><br><span class="line">class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass</span><br></pre></td></tr></table></figure>

<p>没有，找左边</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingMixIn</span>:</span></span><br><span class="line">    <span class="string">"""Mix-in class to handle each request in a new thread."""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decides how threads will act upon termination of the</span></span><br><span class="line">    <span class="comment"># main process</span></span><br><span class="line">    daemon_threads = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request_thread</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Same as in BaseServer but as a thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In addition, exception handling is done here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.finish_request(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Start a new thread to process the request."""</span></span><br><span class="line">        t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                             args = (request, client_address))</span><br><span class="line">        t.daemon = self.daemon_threads</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p>左边没有找右边</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span><span class="params">(BaseServer)</span>:</span></span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>右边也没有，继续向上找</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseServer</span>:</span></span><br><span class="line">	...</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">_handle_request_noblock</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Handle one request, without blocking.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        I assume that selector.select() has returned that the socket is</span></span><br><span class="line"><span class="string">        readable before this function was called, so there should be no risk of</span></span><br><span class="line"><span class="string">        blocking in get_request().</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            request, client_address = self.get_request()</span><br><span class="line">        <span class="keyword">except</span> OSError:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.verify_request(request, client_address):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.process_request(request, client_address)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.handle_error(request, client_address)</span><br><span class="line">                self.shutdown_request(request)</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>找到了！但是这里面又执行了<code>self.process_request()</code>,有self，仍需要回到最开始的地方查找</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 源码</span><br><span class="line">class ThreadingTCPServer(ThreadingMixIn, TCPServer): pass</span><br></pre></td></tr></table></figure>

<p>没有，找左边</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 源码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadingMixIn</span>:</span></span><br><span class="line">    <span class="string">"""Mix-in class to handle each request in a new thread."""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Decides how threads will act upon termination of the</span></span><br><span class="line">    <span class="comment"># main process</span></span><br><span class="line">    daemon_threads = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request_thread</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Same as in BaseServer but as a thread.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        In addition, exception handling is done here.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.finish_request(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request, client_address)</span>:</span></span><br><span class="line">        <span class="string">"""Start a new thread to process the request."""</span></span><br><span class="line">        t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                             args = (request, client_address))</span><br><span class="line">        t.daemon = self.daemon_threads</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<p>找到啦！！！</p>
<hr>
<p>这就是socketserver的源码阅读方法，也适用于所有源码的阅读方法，再次强调，遇到self一定要回到原点再次寻找</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象基础篇之封装</title>
    <url>/2016/06/28/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B9%8B%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>在上一篇Python面向对象的开篇中，简单介绍了Python下的封装特性，主要封装的对象是基本数据类型，Python中除了可以封装基本数据类型外，还可以封装类似于list，tuple，set等常见的引用数据类型，甚至可以封装我们自定义的对象。</p>
<p>本篇就是主要介绍Python的对象中封装对象的功能及实现。</p>
</blockquote>
<p><strong>对象中封装对象实例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, b_obj)</span>:</span></span><br><span class="line">		self.host = host</span><br><span class="line">		self.b_obj = b_obj</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username, password)</span>:</span></span><br><span class="line">		self.username = username</span><br><span class="line">		self.password = password</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'class B func show'</span>)</span><br><span class="line">		</span><br><span class="line">b = B(<span class="string">'ps'</span>, <span class="string">'password'</span>)</span><br><span class="line">a = A(<span class="string">'192.168.1.1'</span>, b)</span><br><span class="line">print(a.b_obj.username)</span><br><span class="line">print(a.b_obj.password)	</span><br><span class="line">a.b_obj.show()</span><br><span class="line">print(a.host)	</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br><span class="line">password</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">func</span> <span class="title">show</span></span></span><br><span class="line"><span class="class">192.168.1.1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第1-4行：定义了一个A类，构造方法中，接收两个参数，一个是主机名，一个是账户对象（注意，这里接收的是一个对象）</li>
<li>第6-9行：定义了一个B类，构造方法接收用户名和密码两个字符串参数</li>
<li>第11-12行：B类中的一个对象方法</li>
<li>第14行：实例化一个B类的对象</li>
<li>第15行：实例化一个A类的对象，并将B类的对象b当做参数传递给A类的构造方法</li>
<li>第16行：a对象的第二个成员变量是一个B类型的对象，a.b_obj指向的就是B类的对象b，而a.b_obj.username等同于执行了b.username</li>
<li>第17-18行：同理，等同于执行了<code>b.password</code>和<code>b.show()</code></li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160628-0@2x.png" alt=""></p>
<p><strong>接下来感受一下对象中封装两层对象的情况</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, b_obj)</span>:</span></span><br><span class="line">		self.host = host</span><br><span class="line">		self.b_obj = b_obj</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, username, password)</span>:</span></span><br><span class="line">		self.username = username</span><br><span class="line">		self.password = password</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">		print(<span class="string">'class B func show'</span>)</span><br><span class="line">		</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, db, a_obj)</span>:</span></span><br><span class="line">		self.db = db</span><br><span class="line">		self.a_obj = a_obj</span><br><span class="line">		</span><br><span class="line">b = B(<span class="string">'ps'</span>, <span class="string">'password'</span>)</span><br><span class="line">a = A(<span class="string">'192.168.1.1'</span>, b)</span><br><span class="line">c = C(<span class="string">'MySQL'</span>, a)</span><br><span class="line"></span><br><span class="line">print(c.a_obj.b_obj.username)</span><br><span class="line">print(c.a_obj.b_obj.password)</span><br><span class="line">c.a_obj.b_obj.show()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ps</span><br><span class="line">password</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">func</span> <span class="title">show</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
        <tag>封装</tag>
      </tags>
  </entry>
  <entry>
    <title>Python面向对象开篇</title>
    <url>/2016/06/25/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<blockquote>
<p>Python是一门非常适合初学者学习的语言。Python本身是支持面向对象编程的。但是在运维界，Python很多时候被称之为脚本语言，因为Python不仅仅支持面向对象编程，还支持函数式编程。这是Java和C#这种OOP语言所不支持的</p>
<p>Linux中的bash shell被当做一种脚本语言，本身也是支持函数式编程的，但是很多时候，shell的面向过程编程简单、粗暴、高效</p>
<p>而Python不仅仅支持OOP面向对象编程，还支持脚本语言的特性，相面过程编程和函数式编程</p>
</blockquote>
<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>面向过程：根据业务逻辑从上到下写代码</li>
<li>函数式编程：将某个功能的代码封装到一个函数中，后面用到该功能的时候无需重新编写，仅需要调用函数即可</li>
<li>面向过程：对函数进行分类和封装，终极目标“消除重复代码”</li>
</ul>
<p>我的OOP启蒙导师之一 <code>Mars</code>（之前是千峰教育的负责人，2016年离职创业，现在是<code>育知同创</code>的创始人之一）曾经给OOP一个比喻，说重复代码就好比是别人往你的脸上吐了口痰，我们的终极目标就是“消除重复代码”</p>
<p><strong>首先来感受下面向过程编程和函数式编程</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 面向过程编程</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>：</span><br><span class="line">    <span class="keyword">if</span> cpu利用率 &gt; <span class="number">90</span>%:</span><br><span class="line">        <span class="comment">#发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 硬盘使用空间 &gt; <span class="number">90</span>%:</span><br><span class="line">        <span class="comment">#发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 内存占用 &gt; <span class="number">80</span>%:</span><br><span class="line">        <span class="comment">#发送邮件提醒</span></span><br><span class="line">        连接邮箱服务器</span><br><span class="line">        发送邮件</span><br><span class="line">        关闭连接</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数式编程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 发送邮件<span class="params">(内容)</span></span></span><br><span class="line"><span class="function">    #发送邮件提醒</span></span><br><span class="line"><span class="function">    连接邮箱服务器</span></span><br><span class="line"><span class="function">    发送邮件</span></span><br><span class="line"><span class="function">    关闭连接</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="title">True</span>：</span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="title">cpu</span>利用率 &gt; 90%:</span></span><br><span class="line">        发送邮件(<span class="string">'CPU报警'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 硬盘使用空间 &gt; <span class="number">90</span>%:</span><br><span class="line">        发送邮件(<span class="string">'硬盘报警'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 内存占用 &gt; <span class="number">80</span>%:</span><br><span class="line">        发送邮件(<span class="string">'内存报警'</span>)</span><br></pre></td></tr></table></figure>

<p>每种写法都有自己存在的价值，世界上没有最好的编程方式，只有最合适的编程方式</p>
<h1 id="创建类和对象"><a href="#创建类和对象" class="headerlink" title="创建类和对象"></a>创建类和对象</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 创建类中的函数（类中的函数又被称作类的方法）</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">	</span><br><span class="line">		<span class="comment"># 函数体 方法体</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 创建Foo这个类的对象</span></span><br><span class="line"><span class="comment"># 创建一个类的对象，又被称作类的实例化对象</span></span><br><span class="line">obj = Foo()</span><br></pre></td></tr></table></figure>

<p><strong>体验一下上面的报警功能用OOP是如何实现的</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mail</span><span class="params">()</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> 发送邮件<span class="params">(self, 内容)</span>:</span></span><br><span class="line">		<span class="comment">#发送邮件提醒</span></span><br><span class="line">    	连接邮箱服务器</span><br><span class="line">    	发送邮件</span><br><span class="line">    	关闭连接</span><br><span class="line">    	</span><br><span class="line">m = mail()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>：</span><br><span class="line">    <span class="keyword">if</span> cpu利用率 &gt; <span class="number">90</span>%:</span><br><span class="line">        m.发送邮件(<span class="string">'CPU报警'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 硬盘使用空间 &gt; <span class="number">90</span>%:</span><br><span class="line">        m.发送邮件(<span class="string">'硬盘报警'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> 内存占用 &gt; <span class="number">80</span>%:</span><br><span class="line">        m.发送邮件(<span class="string">'内存报警'</span>)</span><br></pre></td></tr></table></figure>

<p>为什么用了OOP，反而代码量比函数式编程还要多了呢，而且调用方法时不能直接调用了，需要使用mail类的对象来调用。</p>
<p>总结：OOP的优势在极少的代码量的情况下很难体现出来。而且应对不同场景，使用不通的方式编程很重要。函数式编程的应用场景–&gt;各个函数之间是独立的且没有共用的数据。</p>
<h1 id="类和对象的创建"><a href="#类和对象的创建" class="headerlink" title="类和对象的创建"></a>类和对象的创建</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment"># 创建类中的函数</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 根据类Foo创建对象obj</span></span><br><span class="line">obj = Foo()</span><br></pre></td></tr></table></figure>

<h1 id="对象和类的关系"><a href="#对象和类的关系" class="headerlink" title="对象和类的关系"></a>对象和类的关系</h1><p>创建类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>创建对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj1 = Foo()</span><br><span class="line">obj2 = Foo()</span><br><span class="line"></span><br><span class="line">obj1.func()</span><br><span class="line">obj2.func()</span><br></pre></td></tr></table></figure>

<p>上面的代码中，我们使用Foo类分别创建了<code>obj1</code>和<code>obj2</code>两个对象，在调用Foo类中的func方法时（调用对象方法），Python帮我们隐式地将这个对象传递给了func函数的self参数。在一个类的众多对象中，就是通过隐式的把自己传递给self参数，从而实现了每个对象个性之处。</p>
<p>每一个由类实例化出来的对象，都保存了一个<code>类对象指针</code>指向自己的类</p>
<h1 id="形式参数self"><a href="#形式参数self" class="headerlink" title="形式参数self"></a>形式参数self</h1><p>在创建类的时候，如果我们需要让一个方法在不同的对象操作时实现不同的效果，那么我们就需要把这个方法创建成为对象方法。类中的对象方法有个很明显的标记就是<code>self</code>关键字，每个对象方法的头一个参数，都是self！</p>
<p>这个<code>self</code>起到的作用就是区分不同的对象，从而实现对象不同，方法执行的效果就不同。我们在实例化一个对象的时候，该对象调用类中的对象方法，不需要显示的去给<code>self</code>参数传值，因为Python会<code>隐式的</code>帮我们把对象的名字传递给对象方法中的第一个<code>self</code>参数。简单的说，就是哪个对象去执行对象方法，self就是谁。例如上面的例子中，<code>obj1</code>和<code>obj2</code>分别调用了对象方法，那么<code>obj1</code>调用<code>func</code>时，<code>self</code>就等于<code>obj1</code>，<code>obj2</code>调用<code>func</code>时，<code>self</code>就等于<code>obj2</code></p>
<h1 id="构造方法-构造函数"><a href="#构造方法-构造函数" class="headerlink" title="构造方法/构造函数"></a>构造方法/构造函数</h1> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 操作MySQL数据库的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConnMySQL</span>:</span></span><br><span class="line">	<span class="comment"># 构造方法 __init__(self)</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port, username, pasword)</span>:</span></span><br><span class="line">		print(self, <span class="string">'每一个对象被创建的时候都会执行这个方法'</span>)</span><br><span class="line">		self.host = host</span><br><span class="line">		self.port = port</span><br><span class="line">		self.username = username</span><br><span class="line">		self.password = possword</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">modify</span><span class="params">(self, sql)</span>:</span></span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 实例化操作MySQL数据库的对象</span></span><br><span class="line">my1 = ConnMySQL(<span class="string">'192.168.1.1'</span>, <span class="number">3306</span>, <span class="string">'root'</span>, <span class="string">'p@55\/\/0rd'</span>)</span><br><span class="line">my2 = ConnMySQL(<span class="string">'192.168.1.2'</span>, <span class="number">3307</span>, <span class="string">'admin'</span>, <span class="string">'password'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用对象去操作数据库</span></span><br><span class="line"><span class="comment"># 分别去两个数据库中操作sql语句</span></span><br><span class="line">my1.select(<span class="string">'select uid, username, password from userinfo where age=26'</span>)</span><br><span class="line">my2.select(<span class="string">'select uid, username, password from userinfo where age=26'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ul>
<li>在函数式编程中，Python解释器从上向下解释执行，如果一个方法A中依赖另一个方法B，那么B必须要在A之前定义，否则Python解释器会报错。但是在类中不需要，类中的函数可以调用任意位置的函数。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>OOP</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Python压缩文件处理模块</title>
    <url>/2016/06/25/Python%E5%8E%8B%E7%BC%A9%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>Python中的zipfile和tarfile两个模块可以实现对文件的压缩和解压缩。并且支持向压缩包中压入新的文件，和在压缩包中指定文件进行解压缩</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的压缩文件</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">'docs.zip'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 添加需要压缩的文件</span></span><br><span class="line">z.write(<span class="string">"c1.py"</span>)</span><br><span class="line">z.write(<span class="string">"c2.py"</span>)</span><br><span class="line">z.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向已存在的压缩包中添加文件</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">'docs.zip'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 添加需要压缩的文件</span></span><br><span class="line">z.write(<span class="string">"test.conf"</span>)</span><br><span class="line">z.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩所有文件</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">'docs.zip'</span>, <span class="string">'r'</span>)</span><br><span class="line">z.extractall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩指定文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出压缩包中的所有文件名</span></span><br><span class="line">z = zipfile.ZipFile(<span class="string">'docs.zip'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> z.namelist():</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 指定文件名称进行解压</span></span><br><span class="line">z.extract(<span class="string">"c1.py"</span>)</span><br><span class="line">z.close()</span><br></pre></td></tr></table></figure>

<p>解压缩补充：</p>
<ul>
<li><code>path</code> 可以指定解压缩之后的文件的路径</li>
<li><code>pwd</code> 可以指定去哪个目录下解压缩文件</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self, member, path=None, pwd=None)</span>:</span></span><br><span class="line">    <span class="string">"""Extract a member from the archive to the current working directory,</span></span><br><span class="line"><span class="string">       using its full name. Its file information is extracted as accurately</span></span><br><span class="line"><span class="string">       as possible. `member' may be a filename or a ZipInfo object. You can</span></span><br><span class="line"><span class="string">       specify a different directory using `path'.</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure>

<h1 id="tar-gz"><a href="#tar-gz" class="headerlink" title="tar.gz"></a>tar.gz</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tarfile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新的压缩文件</span></span><br><span class="line">t = tarfile.open(<span class="string">'docs.zip'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 添加需要压缩的文件</span></span><br><span class="line">t.add(<span class="string">"c1.py"</span>)</span><br><span class="line">t.add(<span class="string">"c2.py"</span>, arcname=<span class="string">"tc2.py"</span>)</span><br><span class="line">t.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向已存在的压缩包中添加文件</span></span><br><span class="line">t = tarfile.open(<span class="string">'docs.zip'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 添加需要压缩的文件</span></span><br><span class="line">t.add(<span class="string">"test.conf"</span>)</span><br><span class="line">t.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩所有文件</span></span><br><span class="line">t = tarfile.open(<span class="string">'docs.zip'</span>, <span class="string">'r'</span>)</span><br><span class="line">t.extractall()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩指定文件</span></span><br><span class="line"><span class="comment"># 列出压缩包中的所有文件名</span></span><br><span class="line">t = tarfile.open(<span class="string">'docs.zip'</span>, <span class="string">'r'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t.getnames():</span><br><span class="line">    print(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件名称进行解压</span></span><br><span class="line">t.extract(<span class="string">"tc2.py"</span>)</span><br><span class="line">t.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用文件名获取该文件对象,指定该文件对象进行解压缩</span></span><br><span class="line">o = t.getmember(<span class="string">'tc2.py'</span>)</span><br><span class="line">t.extract(o)</span><br><span class="line">t.close()</span><br></pre></td></tr></table></figure>

<p>解压缩补充：</p>
<ul>
<li><code>tarfile</code>解压缩单个文件时支持两种方式进行解压，一种是指定文件名，一种是指定文件对象。</li>
<li>解压方法支持解压缩文件到指定目录中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extractall</span><span class="params">(self, path=<span class="string">"."</span>, members=None, *, numeric_owner=False)</span>:</span></span><br><span class="line">        <span class="string">"""Extract all members from the archive to the current working</span></span><br><span class="line"><span class="string">           directory and set owner, modification time and permissions on</span></span><br><span class="line"><span class="string">           directories afterwards. `path' specifies a different directory</span></span><br><span class="line"><span class="string">           to extract to. `members' is optional and must be a subset of the</span></span><br><span class="line"><span class="string">           list returned by getmembers(). If `numeric_owner` is True, only</span></span><br><span class="line"><span class="string">           the numbers for user/group names are used and not the names.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract</span><span class="params">(self, member, path=<span class="string">""</span>, set_attrs=True, *, numeric_owner=False)</span>:</span></span><br><span class="line">        <span class="string">"""Extract a member from the archive to the current working directory,</span></span><br><span class="line"><span class="string">           using its full name. Its file information is extracted as accurately</span></span><br><span class="line"><span class="string">           as possible. `member' may be a filename or a TarInfo object. You can</span></span><br><span class="line"><span class="string">           specify a different directory using `path'. File attributes (owner,</span></span><br><span class="line"><span class="string">           mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`</span></span><br><span class="line"><span class="string">           is True, only the numbers for user/group names are used and not</span></span><br><span class="line"><span class="string">           the names.</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>zipfile</tag>
        <tag>tarfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Python高级文件处理模块shutil</title>
    <url>/2016/06/23/Python%E9%AB%98%E7%BA%A7%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%9D%97shutil/</url>
    <content><![CDATA[<blockquote>
<p>shutil是Python中的高级文件处理模块，可以使用它来对文件进行更细粒度的操作，如仅复制权限、内容、属组、用户、状态等信息，而且shutil模块还可以做到对压缩文件进行简单的处理。</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="将文件内容拷贝到另一个文件中"><a href="#将文件内容拷贝到另一个文件中" class="headerlink" title="将文件内容拷贝到另一个文件中"></a>将文件内容拷贝到另一个文件中</h1><p>shutil.copyfileobj(fsrc, fdst[, length])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.copyfileobj(open(<span class="string">'old.xml'</span>,<span class="string">'r'</span>), open(<span class="string">'new.xml'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure>


<h1 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h1><p>shutil.copyfile(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copyfile(<span class="string">'f1.log'</span>, <span class="string">'f2.log'</span>)</span><br></pre></td></tr></table></figure>


<h1 id="仅拷贝权限。内容、组、用户均不变"><a href="#仅拷贝权限。内容、组、用户均不变" class="headerlink" title="仅拷贝权限。内容、组、用户均不变"></a>仅拷贝权限。内容、组、用户均不变</h1><p>shutil.copymode(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copymode(<span class="string">'f1.log'</span>, <span class="string">'f2.log'</span>)</span><br></pre></td></tr></table></figure>


<h1 id="仅拷贝状态的信息，包括：mode-bits-atime-mtime-flags"><a href="#仅拷贝状态的信息，包括：mode-bits-atime-mtime-flags" class="headerlink" title="仅拷贝状态的信息，包括：mode bits, atime, mtime, flags"></a>仅拷贝状态的信息，包括：mode bits, atime, mtime, flags</h1><p>shutil.copystat(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shutil.copystat(<span class="string">'f1.log'</span>, <span class="string">'f2.log'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="拷贝文件和权限"><a href="#拷贝文件和权限" class="headerlink" title="拷贝文件和权限"></a>拷贝文件和权限</h1><p>shutil.copy(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.copy(<span class="string">'f1.log'</span>, <span class="string">'f2.log'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="拷贝文件和状态信息"><a href="#拷贝文件和状态信息" class="headerlink" title="拷贝文件和状态信息"></a>拷贝文件和状态信息</h1><p>shutil.copy2(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.copy2(<span class="string">'f1.log'</span>, <span class="string">'f2.log'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="递归的去拷贝文件夹"><a href="#递归的去拷贝文件夹" class="headerlink" title="递归的去拷贝文件夹"></a>递归的去拷贝文件夹</h1><p>shutil.ignore_patterns(*patterns)<br>shutil.copytree(src, dst, symlinks=False, ignore=None)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.copytree(<span class="string">'folder1'</span>, <span class="string">'folder2'</span>, ignore=shutil.ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure>

<p>复制中软连接的问题：如果symlinks为True，那么软连接的文件会被copy到目标目录中，如果symlinks为False，那么只会将软连接进行copy，假如链接的目录不存在则会抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">shutil.copytree(<span class="string">'f1'</span>, <span class="string">'f2'</span>, symlinks=<span class="literal">True</span>, ignore=shutil.ignore_patterns(<span class="string">'*.pyc'</span>, <span class="string">'tmp*'</span>))</span><br></pre></td></tr></table></figure>

<h1 id="递归的去删除文件"><a href="#递归的去删除文件" class="headerlink" title="递归的去删除文件"></a>递归的去删除文件</h1><p>shutil.rmtree(path[, ignore_errors[, onerror]])</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.rmtree(<span class="string">'folder1'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="递归的去移动文件-重命名，类似mv命令"><a href="#递归的去移动文件-重命名，类似mv命令" class="headerlink" title="递归的去移动文件/重命名，类似mv命令"></a>递归的去移动文件/重命名，类似mv命令</h1><p>shutil.move(src, dst)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"> </span><br><span class="line">shutil.move(<span class="string">'folder1'</span>, <span class="string">'folder3'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="压缩文件的处理"><a href="#压缩文件的处理" class="headerlink" title="压缩文件的处理"></a>压缩文件的处理</h1><p>shutil.make_archive(base_name, format,…)</p>
<p>参数说明：</p>
<ul>
<li>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，<ul>
<li>如：docs.tar.gz =&gt; 保存至当前路径,并以此为文件名</li>
<li>如：/Users/PolarSnow/docs.tar.gz =&gt;保存至/Users/PolarSnow/ 并以docs.tar.gz的文件名保存</li>
</ul>
</li>
<li>format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”</li>
<li>root_dir：    要压缩的文件夹路径（默认当前目录）</li>
<li>owner：    用户，默认当前用户</li>
<li>group：    组，默认当前组</li>
<li>logger：    用于记录日志，通常是logging.Logger对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将 /Users/polarsnow/Downloads/docs 下的文件打包放置当前程序目录</span></span><br><span class="line"><span class="comment"># base_name不需要指定文件名的后缀，压缩后会自动在后面加上tar.gz的后缀</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">ret = shutil.make_archive(<span class="string">"docs"</span>, <span class="string">'gztar'</span>, root_dir=<span class="string">'/Users/wupeiqi/Downloads/docs'</span>)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#将 /Users/polarsnow/Downloads/docs 下的文件打包放置 /Users/polarsnow/目录下，并以docs.tar.gz命名</span></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line">ret = shutil.make_archive(<span class="string">"/Users/wupeiqi/docs"</span>, <span class="string">'gztar'</span>, root_dir=<span class="string">'/Users/wupeiqi/Downloads/test'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>shutil</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下的系统命令模块subprocess</title>
    <url>/2016/06/23/Python%E4%B8%8B%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%9D%97subprocess/</url>
    <content><![CDATA[<blockquote>
<p>在Python3中，commands模块被移除掉，commands模块执行shell命令的相关模块和函数的功能，在subprocess模块总均可实现，并且提供了更加丰富的功能</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="call"><a href="#call" class="headerlink" title="call"></a>call</h1><p>执行命令，返回状态码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = subprocess.call([<span class="string">"df"</span>,<span class="string">"-h"</span>], shell=<span class="literal">False</span>)</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/disk1      <span class="number">233</span>G  <span class="number">107</span>G  <span class="number">127</span>G  <span class="number">46</span>% /</span><br><span class="line">/dev/disk2s1     <span class="number">58</span>G   <span class="number">36</span>G   <span class="number">22</span>G  <span class="number">63</span>% /Volumes/SanDisk</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ret)</span><br><span class="line"><span class="number">0</span></span><br><span class="line">------------</span><br><span class="line"><span class="comment"># 以shell的模式运行</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = subprocess.call(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>)</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/disk1      <span class="number">233</span>G  <span class="number">107</span>G  <span class="number">127</span>G  <span class="number">46</span>% /</span><br><span class="line">/dev/disk2s1     <span class="number">58</span>G   <span class="number">36</span>G   <span class="number">22</span>G  <span class="number">63</span>% /Volumes/SanDisk</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ret)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h1 id="check-call"><a href="#check-call" class="headerlink" title="check_call"></a>check_call</h1><p>检查执行命令后的返回值，如果是0则返回，如果不是则抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = subprocess.check_call(<span class="string">"exit 1"</span>, shell=<span class="literal">True</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">"/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/subprocess.py"</span>, line <span class="number">584</span>, <span class="keyword">in</span> check_call</span><br><span class="line">    <span class="keyword">raise</span> CalledProcessError(retcode, cmd)</span><br><span class="line">subprocess.CalledProcessError: Command <span class="string">'exit 1'</span> returned non-zero exit status <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="check-output"><a href="#check-output" class="headerlink" title="check_output"></a>check_output</h1><p>检查执行命令后的返回值，如果是0则返回执行结果，如果不是则抛出异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = subprocess.check_output(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(ret)</span><br><span class="line"><span class="string">b'Filesystem      Size  Used Avail Use% Mounted on\n/dev/disk1      233G  107G  127G  46% /\n/dev/disk2s1     58G   36G   22G  63% /Volumes/SanDisk\n'</span></span><br></pre></td></tr></table></figure>

<h1 id="Popen"><a href="#Popen" class="headerlink" title="Popen"></a>Popen</h1><p>用于执行复杂的系统命令</p>
<p><strong>参数：</strong></p>
<ul>
<li>args：shell命令，可以是字符串或者序列类型（如：list，元组）</li>
<li>bufsize：指定缓冲。0 无缓冲,1 行缓冲,其他 缓冲区大小,负值 系统缓冲</li>
<li>stdin, stdout, stderr：分别表示程序的标准输入、输出、错误句柄</li>
<li>preexec_fn：只在Unix平台下有效，用于指定一个可执行对象（callable object），它将在子进程运行之前被调用</li>
<li>close_sfs：在windows平台下，如果close_fds被设置为True，则新创建的子进程将不会继承父进程的输入、输出、错误管道。<br>所以不能将close_fds设置为True同时重定向子进程的标准输入、输出与错误(stdin, stdout, stderr)。</li>
<li>shell：同上</li>
<li>cwd：用于设置子进程的当前目录</li>
<li>env：用于指定子进程的环境变量。如果env = None，子进程的环境变量将从父进程中继承。</li>
<li>universal_newlines：不同系统的换行符不同，True -&gt; 同意使用 \n</li>
<li>startupinfo与createionflags只在windows下有效<br>将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如：主窗口的外观，进程的优先级等等 </li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line">ret1 = subprocess.Popen([<span class="string">"mkdir"</span>,<span class="string">"t1"</span>])</span><br><span class="line">ret2 = subprocess.Popen(<span class="string">"mkdir t2"</span>, shell=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="非交互模式的命令"><a href="#非交互模式的命令" class="headerlink" title="非交互模式的命令"></a>非交互模式的命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"polarsnow"</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">polarsnow</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/disk1      <span class="number">233</span>G  <span class="number">107</span>G  <span class="number">127</span>G  <span class="number">46</span>% /</span><br><span class="line">/dev/disk2s1     <span class="number">58</span>G   <span class="number">36</span>G   <span class="number">22</span>G  <span class="number">63</span>% /Volumes/SanDisk</span><br></pre></td></tr></table></figure>

<p>从上面的例子🌰看到，父进程在开启子进程之后并没有等待子进程结束，而是直接运行了print</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>)</span><br><span class="line">obj.wait()</span><br><span class="line">print(<span class="string">"polarsnow"</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/disk1      <span class="number">233</span>G  <span class="number">107</span>G  <span class="number">127</span>G  <span class="number">46</span>% /</span><br><span class="line">/dev/disk2s1     <span class="number">58</span>G   <span class="number">36</span>G   <span class="number">22</span>G  <span class="number">63</span>% /Volumes/SanDisk</span><br><span class="line">polarsnow</span><br></pre></td></tr></table></figure>

<p>加入了wait之后，可以看到，父进程会等待子进程运行结束后再执行print</p>
<p>此外，你还可以在父进程中对子进程进行如下其他的操作：</p>
<ul>
<li>obj.poll()  检查子进程的状态</li>
<li>obj.kill() 终止子进程</li>
<li>obj.sent_signal() 向子进程发送信号</li>
<li>obj.terminate() 终止子进程</li>
<li>obj.pid 查看子进程的pid</li>
<li>obj.args 查看shell命令</li>
</ul>
<h2 id="子进程的文本流控制"><a href="#子进程的文本流控制" class="headerlink" title="子进程的文本流控制"></a>子进程的文本流控制</h2><ul>
<li>obj.stdin 标准输入</li>
<li>obj.stdout 标准输出</li>
<li>obj.stderr 标准错误</li>
</ul>
<p>可以在Popen建立子进程的时候改变子进程的标准输入、标准输出和标准错误。并可以利用subprocess.PIPE将多个子进程的输入输出连接在一起，构成管道</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">print(obj.stdout.read())</span><br></pre></td></tr></table></figure>

<p>使用了subprocess提供的管道，子进程执行命令后的输出不会再默认输出到屏幕上了，而是放到了管道里，等待用户提取管道中的数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"df -h"</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">print(obj.communicate())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">(<span class="string">b'Filesystem      Size  Used Avail Use% Mounted on\n/dev/disk1      233G  107G  127G  46% /\n/dev/disk2s1     58G   36G   22G  63% /Volumes/SanDisk\n'</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>communicate()会返回执行命令的结果和标准错误，但是上面的例子中，我只是将子进程的标准输出放到的subprocess的管道中，并没有对标准错误应用subprocess的管道，所以，不管有没有报错，这里的返回值返回的标准错误永远是None。下面来验证一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"df -y"</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE)</span><br><span class="line">print(obj.communicate())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">df: invalid option -- <span class="string">'y'</span></span><br><span class="line">Try <span class="string">'df --help'</span> <span class="keyword">for</span> more information.</span><br><span class="line">(<span class="string">b''</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>果然，报错默认打在了屏幕上，而communicate的返回值中的标准错误依然是None</p>
<p><strong>实现Linux中 | 管道的效果</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj1 = subprocess.Popen(<span class="string">"cat /etc/passwd"</span>, shell=<span class="literal">True</span>, stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">obj2 = subprocess.Popen(<span class="string">"grep root"</span>, shell=<span class="literal">True</span>, stdin=obj1.stdout, stdout=subprocess.PIPE, stderr=subprocess.PIPE)</span><br><span class="line">out = obj2.communicate()</span><br><span class="line">print(out)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">(<span class="string">b'root:*:0:0:System Administrator:/var/root:/bin/sh\ndaemon:*:1:1:System Services:/var/root:/usr/bin/false\n_cvmsroot:*:212:212:CVMS Root:/var/empty:/usr/bin/false\n'</span>, <span class="string">b''</span>)</span><br></pre></td></tr></table></figure>

<p>第3行：创建了一个子进程去执行命令，并将标准输入输出和错误放到了subprocess提供的管道中。</p>
<p>第4行：创建了另一个子进程去执行命令，命令的标准输入是上一条命令的标准输出，所以把obj1中的标准输出从subprocess的管道中取出当做标准输入传递给第二个子进程</p>
<p>你可能会想，在之前的例子中，如果不加wait的话，父进程不管子进程有没有执行完都会往下执行，那么假如第一条命令执行时间比较长，父进程如果继续向下走，执行第二条命令时，还没有拿到第一条的标准输出，会不会报错呢？首先，这是个好问题！下面详细分析一下</p>
<ul>
<li>程序会继续向下执行，但是会分两种情况，一种情况是第二条命令是阻塞的命令，第二种情况是非阻塞的命令。<ul>
<li>假如第二条是阻塞的命令，进程会一直卡住，等待接收输入，这种情况下，程序会一直等下去，等到第一条命令执行结束，把标准输出放到管道为止。</li>
<li>假如第二条命令是非阻塞的命令，父进程会立即向下执行，虽然第一条命令还没有把标准输出放到管道中，第二条命令会认为你要给我传的就是空，所以第二条命令会被迅速执行完毕，而上面的例子中，调用了第二条命令对象的communicate方法，只会等待第二条命令执行完毕，一旦第二条命令执行完毕，不管第一条有没有执行完都会立即退出</li>
</ul>
</li>
</ul>
<p>subprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。<br>注意：communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成</p>
<h2 id="实现类似pexpect的交互式命令"><a href="#实现类似pexpect的交互式命令" class="headerlink" title="实现类似pexpect的交互式命令"></a>实现类似pexpect的交互式命令</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"passwd ps"</span>, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=<span class="literal">True</span>)</span><br><span class="line">obj.stdin.write(<span class="string">"123\n"</span>)</span><br><span class="line">obj.stdin.write(<span class="string">"123\n"</span>)</span><br><span class="line">obj.stdin.close()</span><br><span class="line"></span><br><span class="line">cmd_out = obj.stdout.read()</span><br><span class="line">obj.stdout.close()</span><br><span class="line">cmd_error = obj.stderr.read()</span><br><span class="line">obj.stderr.close()</span><br><span class="line"></span><br><span class="line">print(cmd_out)</span><br><span class="line">print(cmd_error)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Changing password <span class="keyword">for</span> user ps.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">New password: BAD PASSWORD: it <span class="keyword">is</span> WAY too short</span><br><span class="line">BAD PASSWORD: <span class="keyword">is</span> too simple</span><br><span class="line">Retype new password:</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"passwd ps"</span>, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=<span class="literal">True</span>)</span><br><span class="line">obj.stdin.write(<span class="string">"123\n"</span>)</span><br><span class="line">obj.stdin.write(<span class="string">"123\n"</span>)</span><br><span class="line"></span><br><span class="line">cmd_out, cmd_error = obj.communicate()</span><br><span class="line">print(cmd_out)</span><br><span class="line">print(cmd_error)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Changing password <span class="keyword">for</span> user ps.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">New password: BAD PASSWORD: it <span class="keyword">is</span> WAY too short</span><br><span class="line">BAD PASSWORD: <span class="keyword">is</span> too simple</span><br><span class="line">Retype new password:</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">obj = subprocess.Popen(<span class="string">"passwd ps"</span>, shell=<span class="literal">True</span>, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, universal_newlines=<span class="literal">True</span>)</span><br><span class="line">cmd_out, cmd_error = obj.communicate(<span class="string">'123\n123\n'</span>)</span><br><span class="line">print(cmd_out)</span><br><span class="line">print(cmd_error)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Changing password <span class="keyword">for</span> user ps.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"></span><br><span class="line">New password: BAD PASSWORD: it <span class="keyword">is</span> WAY too short</span><br><span class="line">BAD PASSWORD: <span class="keyword">is</span> too simple</span><br><span class="line">Retype new password:</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>subprocess</tag>
      </tags>
  </entry>
  <entry>
    <title>lvm的创建和扩容</title>
    <url>/2016/06/22/lvm%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h1 id="创建LVM"><a href="#创建LVM" class="headerlink" title="创建LVM"></a>创建LVM</h1><p>查看磁盘信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; fdisk -l</span><br><span class="line"></span><br><span class="line">Disk /dev/sdb: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x000cd8ec</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048    41943039    20970496   83  Linux</span><br><span class="line"></span><br><span class="line">Disk /dev/sdc: 536.9 GB, 536870912000 bytes, 1048576000 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>

<p>对新磁盘分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; fdisk /dev/sdc </span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">Building a new DOS disklabel with disk identifier 0xe80f8142.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (1-4, default 1): 1</span><br><span class="line">First sector (2048-1048575999, default 2048): </span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-1048575999, default 1048575999): </span><br><span class="line">Using default value 1048575999</span><br><span class="line">Partition 1 of <span class="built_in">type</span> Linux and of size 500 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Selected partition 1</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>更新分区表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; partprobe</span><br></pre></td></tr></table></figure>

<p>创建PV</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; pvcreate /dev/sdc1 </span><br><span class="line">  Physical volume <span class="string">"/dev/sdc1"</span> successfully created</span><br><span class="line">&gt; pvdisplay </span><br><span class="line">  <span class="string">"/dev/sdc1"</span> is a new physical volume of <span class="string">"500.00 GiB"</span></span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/sdc1</span><br><span class="line">  VG Name               </span><br><span class="line">  PV Size               500.00 GiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0   </span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               tBxBUK-gOTa-bdtK-1kbZ-01KQ-ASwQ-fuIwLi</span><br></pre></td></tr></table></figure>

<p>创建VG</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; vgcreate VolGroup00 /dev/sdc1 </span><br><span class="line">  Volume group <span class="string">"VolGroup00"</span> successfully created</span><br><span class="line">&gt; vgdisplay </span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               VolGroup00</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  1</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                0</span><br><span class="line">  Open LV               0</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               500.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              127999</span><br><span class="line">  Alloc PE / Size       0 / 0   </span><br><span class="line">  Free  PE / Size       127999 / 500.00 GiB</span><br><span class="line">  VG UUID               xjcgUh-oZ1N-Fytd-qGCa-9otf-YV4S-Jpjc7W</span><br></pre></td></tr></table></figure>

<p>创建LV</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; lvcreate -l 127999 -n lvData VolGroup00</span><br><span class="line">  Logical volume <span class="string">"lvData"</span> created.</span><br><span class="line">&gt; lvdisplay </span><br><span class="line">  --- Logical volume ---</span><br><span class="line">  LV Path                /dev/VolGroup00/lvData</span><br><span class="line">  LV Name                lvData</span><br><span class="line">  VG Name                VolGroup00</span><br><span class="line">  LV UUID                pVPwru-Eu7W-3lOp-JUKc-qQYF-c3DM-vQ39g1</span><br><span class="line">  LV Write Access        <span class="built_in">read</span>/write</span><br><span class="line">  LV Creation host, time 3-9, 2016-06-22 15:47:18 +0800</span><br><span class="line">  LV Status              available</span><br><span class="line">  <span class="comment"># open                 0</span></span><br><span class="line">  LV Size                500.00 GiB</span><br><span class="line">  Current LE             127999</span><br><span class="line">  Segments               1</span><br><span class="line">  Allocation             inherit</span><br><span class="line">  Read ahead sectors     auto</span><br><span class="line">  - currently <span class="built_in">set</span> to     256</span><br><span class="line">  Block device           253:0</span><br></pre></td></tr></table></figure>

<p><code>lvcreate -l 指定PE数量创建（精确）</code></p>
<p><code>lvcreate -L 500G 按单位大小创建（可能会有剩余PE）</code></p>
<p>格式化磁盘</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mkfs.ext4 /dev/VolGroup00/lvData </span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Discarding device blocks: <span class="keyword">done</span>                            </span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">32768000 inodes, 131070976 blocks</span><br><span class="line">6553548 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=2279604224</span><br><span class="line">4000 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks: </span><br><span class="line">        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, </span><br><span class="line">        4096000, 7962624, 11239424, 20480000, 23887872, 71663616, 78675968, </span><br><span class="line">        102400000</span><br><span class="line"></span><br><span class="line">Allocating group tables: <span class="keyword">done</span>                            </span><br><span class="line">Writing inode tables: <span class="keyword">done</span>                            </span><br><span class="line">Creating journal (32768 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>挂载使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mount /dev/VolGroup00/lvData /apps/</span><br><span class="line">&gt; df -h</span><br><span class="line">Filesystem                     Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/sda1                       20G  2.8G   16G  15% /</span><br><span class="line">devtmpfs                       912M     0  912M   0% /dev</span><br><span class="line">tmpfs                          920M     0  920M   0% /dev/shm</span><br><span class="line">tmpfs                          920M  8.4M  912M   1% /run</span><br><span class="line">tmpfs                          920M     0  920M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs                          184M     0  184M   0% /run/user/0</span><br><span class="line">tmpfs                          184M     0  184M   0% /run/user/1000</span><br><span class="line">/dev/mapper/VolGroup00-lvData  493G   73M  467G   1% /apps</span><br></pre></td></tr></table></figure>

<h1 id="LVM扩容"><a href="#LVM扩容" class="headerlink" title="LVM扩容"></a>LVM扩容</h1><ol>
<li>分区 <code>fdisk /dev/sdd</code></li>
<li>创建PV <code>pvcreate /dev/sdd1 &amp;&amp; partprob</code></li>
<li>扩展VG <code>vgextend VolGroup00 /dev/sdd1</code></li>
<li>扩展LV <code>lvextend -L +59G /dev/VolGroup00/lvData</code></li>
<li>检查LV <code>e2fsck -f /dev/VolGroup00/lvData</code></li>
<li>重新定义分区大小 <code>resize2fs /dev/VolGroup00/lvData</code></li>
<li>检查容量 <code>df -h</code></li>
</ol>
<p>注意： 如果是xfs文件系统，<code>resize2fs</code>命令要替换成<code>xfs_growfs</code></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>lvm</tag>
      </tags>
  </entry>
  <entry>
    <title>python处理XML文件</title>
    <url>/2016/06/22/python%E5%A4%84%E7%90%86XML%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="解析XML"><a href="#解析XML" class="headerlink" title="解析XML"></a>解析XML</h1><h2 id="利用ElementTree-XML将字符串解析成xml对象"><a href="#利用ElementTree-XML将字符串解析成xml对象" class="headerlink" title="利用ElementTree.XML将字符串解析成xml对象"></a>利用ElementTree.XML将字符串解析成xml对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件，读取XML内容</span></span><br><span class="line">str_xml = open(<span class="string">'xo.xml'</span>, <span class="string">'r'</span>).read()</span><br><span class="line">print(str_xml, type(str_xml))</span><br><span class="line"><span class="comment"># 将字符串解析成xml特殊对象，root代指xml文件的根节点</span></span><br><span class="line">root = ET.XML(str_xml)</span><br><span class="line">print(root, type(root))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;data&gt;</span><br><span class="line">    &lt;country name=<span class="string">"Liechtenstein"</span>&gt;</span><br><span class="line">        &lt;rank updated="yes"&gt;2&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2023&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;141100&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor direction=<span class="string">"E"</span> name=<span class="string">"Austria"</span> /&gt;</span><br><span class="line">        &lt;neighbor direction=<span class="string">"W"</span> name=<span class="string">"Switzerland"</span> /&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=<span class="string">"Singapore"</span>&gt;</span><br><span class="line">        &lt;rank updated="yes"&gt;5&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2026&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;59900&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor direction=<span class="string">"N"</span> name=<span class="string">"Malaysia"</span> /&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">    &lt;country name=<span class="string">"Panama"</span>&gt;</span><br><span class="line">        &lt;rank updated="yes"&gt;69&lt;/rank&gt;</span><br><span class="line">        &lt;year&gt;2026&lt;/year&gt;</span><br><span class="line">        &lt;gdppc&gt;13600&lt;/gdppc&gt;</span><br><span class="line">        &lt;neighbor direction=<span class="string">"W"</span> name=<span class="string">"Costa Rica"</span> /&gt;</span><br><span class="line">        &lt;neighbor direction=<span class="string">"E"</span> name=<span class="string">"Colombia"</span> /&gt;</span><br><span class="line">    &lt;/country&gt;</span><br><span class="line">&lt;/data&gt; &lt;class 'str'&gt;</span><br><span class="line">&lt;Element <span class="string">'data'</span> at <span class="number">0x101383cc8</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">xml</span>.<span class="title">etree</span>.<span class="title">ElementTree</span>.<span class="title">Element</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>从结果中可以看出，<code>root</code>变量获取到了xml文件的根节点信息，且数据类型为<code>xml.etree.ElementTree.Element</code></p>
<h2 id="利用ElementTree-parse将文件解析成xml对象"><a href="#利用ElementTree-parse将文件解析成xml对象" class="headerlink" title="利用ElementTree.parse将文件解析成xml对象"></a>利用ElementTree.parse将文件解析成xml对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接解析xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">"xo.xml"</span>)</span><br><span class="line">print(tree, type(tree)</span><br><span class="line"><span class="comment"># 获取xml文件的根节点</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line">print(root, type(root))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&lt;xml.etree.ElementTree.ElementTree object at <span class="number">0x101178780</span>&gt; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">xml</span>.<span class="title">etree</span>.<span class="title">ElementTree</span>.<span class="title">ElementTree</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">Element</span> '<span class="title">data</span>' <span class="title">at</span> 0<span class="title">x101283cc8</span>&gt; &lt;<span class="title">class</span> '<span class="title">xml</span>.<span class="title">etree</span>.<span class="title">ElementTree</span>.<span class="title">Element</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="两种解析方式的区别"><a href="#两种解析方式的区别" class="headerlink" title="两种解析方式的区别"></a>两种解析方式的区别</h2><p>读取字符串和读取文件的方式的区别：</p>
<ul>
<li><p>读取字符串的方式没有创建tree对象</p>
</li>
<li><p>读取文件的方式自动创建了tree对象</p>
</li>
</ul>
<p>而如果需要将在内存修改过的element对象保存成文件的时候，就必须需要用tree对象的write方法来写。</p>
<p>如果直接读取了字符串，默认没有创建tree对象，那么在需要写入到本地文件时，就必须先创建tree对象再进行写入</p>
<h1 id="操作XML"><a href="#操作XML" class="headerlink" title="操作XML"></a>操作XML</h1><p>每一个节点就是一个element对象，每一个element对象都有如下方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span>:</span></span><br><span class="line">    <span class="string">"""An XML element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    This class is the reference implementation of the Element interface.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    An element's length is its number of subelements.  That means if you</span></span><br><span class="line"><span class="string">    want to check if an element is truly empty, you should check BOTH</span></span><br><span class="line"><span class="string">    its length AND its text attribute.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    The element tag, attribute names, and attribute values can be either</span></span><br><span class="line"><span class="string">    bytes or strings.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    *tag* is the element name.  *attrib* is an optional dictionary containing</span></span><br><span class="line"><span class="string">    element attributes. *extra* are additional element attributes given as</span></span><br><span class="line"><span class="string">    keyword arguments.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Example form:</span></span><br><span class="line"><span class="string">        &lt;tag attrib&gt;text&lt;child/&gt;...&lt;/tag&gt;tail</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    当前节点的标签名</span><br><span class="line">    tag = <span class="literal">None</span></span><br><span class="line">    <span class="string">"""The element's name."""</span></span><br><span class="line"></span><br><span class="line">    当前节点的属性</span><br><span class="line"></span><br><span class="line">    attrib = <span class="literal">None</span></span><br><span class="line">    <span class="string">"""Dictionary of the element's attributes."""</span></span><br><span class="line"></span><br><span class="line">    当前节点的内容</span><br><span class="line">    text = <span class="literal">None</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Text before first subelement. This is either a string or the value None.</span></span><br><span class="line"><span class="string">    Note that if there is no text, this attribute may be either</span></span><br><span class="line"><span class="string">    None or the empty string, depending on the parser.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    tail = <span class="literal">None</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Text after this element's end tag, but before the next sibling element's</span></span><br><span class="line"><span class="string">    start tag.  This is either a string or the value None.  Note that if there</span></span><br><span class="line"><span class="string">    was no text, this attribute may be either None or an empty string,</span></span><br><span class="line"><span class="string">    depending on the parser.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, tag, attrib=&#123;&#125;, **extra)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(attrib, dict):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">"attrib must be dict, not %s"</span> % (</span><br><span class="line">                attrib.__class__.__name__,))</span><br><span class="line">        attrib = attrib.copy()</span><br><span class="line">        attrib.update(extra)</span><br><span class="line">        self.tag = tag</span><br><span class="line">        self.attrib = attrib</span><br><span class="line">        self._children = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;%s %r at %#x&gt;"</span> % (self.__class__.__name__, self.tag, id(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeelement</span><span class="params">(self, tag, attrib)</span>:</span></span><br><span class="line">        创建一个新节点</span><br><span class="line">        <span class="string">"""Create a new element with the same type.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *tag* is a string containing the element name.</span></span><br><span class="line"><span class="string">        *attrib* is a dictionary containing the element attributes.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Do not call this method, use the SubElement factory function instead.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.__class__(tag, attrib)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">copy</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Return copy of current element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This creates a shallow copy. Subelements will be shared with the</span></span><br><span class="line"><span class="string">        original tree.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        elem = self.makeelement(self.tag, self.attrib)</span><br><span class="line">        elem.text = self.text</span><br><span class="line">        elem.tail = self.tail</span><br><span class="line">        elem[:] = self</span><br><span class="line">        <span class="keyword">return</span> elem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._children)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">"The behavior of this method will change in future versions.  "</span></span><br><span class="line">            <span class="string">"Use specific 'len(elem)' or 'elem is not None' test instead."</span>,</span><br><span class="line">            FutureWarning, stacklevel=<span class="number">2</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> len(self._children) != <span class="number">0</span> <span class="comment"># emulate old behaviour, for now</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._children[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, index, element)</span>:</span></span><br><span class="line">        <span class="comment"># if isinstance(index, slice):</span></span><br><span class="line">        <span class="comment">#     for elt in element:</span></span><br><span class="line">        <span class="comment">#         assert iselement(elt)</span></span><br><span class="line">        <span class="comment"># else:</span></span><br><span class="line">        <span class="comment">#     assert iselement(element)</span></span><br><span class="line">        self._children[index] = element</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self._children[index]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, subelement)</span>:</span></span><br><span class="line">        为当前节点追加一个子节点</span><br><span class="line">        <span class="string">"""Add *subelement* to the end of this element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The new element will appear in document order after the last existing</span></span><br><span class="line"><span class="string">        subelement (or directly after the text, if it's the first subelement),</span></span><br><span class="line"><span class="string">        but before the end tag for this element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.append(subelement)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extend</span><span class="params">(self, elements)</span>:</span></span><br><span class="line">        为当前节点扩展 n 个子节点</span><br><span class="line">        <span class="string">"""Append subelements from a sequence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *elements* is a sequence with zero or more elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> element <span class="keyword">in</span> elements:</span><br><span class="line">            self._assert_is_element(element)</span><br><span class="line">        self._children.extend(elements)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, index, subelement)</span>:</span></span><br><span class="line">        在当前节点的子节点中插入某个节点，即：为当前节点创建子节点，然后插入指定位置</span><br><span class="line">        <span class="string">"""Insert *subelement* at position *index*."""</span></span><br><span class="line">        self._assert_is_element(subelement)</span><br><span class="line">        self._children.insert(index, subelement)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_assert_is_element</span><span class="params">(self, e)</span>:</span></span><br><span class="line">        <span class="comment"># Need to refer to the actual Python implementation, not the</span></span><br><span class="line">        <span class="comment"># shadowing C implementation.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(e, _Element_Py):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'expected an Element, not %s'</span> % type(e).__name__)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, subelement)</span>:</span></span><br><span class="line">        在当前节点在子节点中删除某个节点</span><br><span class="line">        <span class="string">"""Remove matching subelement.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Unlike the find methods, this method compares elements based on</span></span><br><span class="line"><span class="string">        identity, NOT ON tag value or contents.  To remove subelements by</span></span><br><span class="line"><span class="string">        other means, the easiest way is to use a list comprehension to</span></span><br><span class="line"><span class="string">        select what elements to keep, and then use slice assignment to update</span></span><br><span class="line"><span class="string">        the parent element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        ValueError is raised if a matching element could not be found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># assert iselement(element)</span></span><br><span class="line">        self._children.remove(subelement)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getchildren</span><span class="params">(self)</span>:</span></span><br><span class="line">        获取所有的子节点（废弃）</span><br><span class="line">        <span class="string">"""(Deprecated) Return all subelements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Elements are returned in document order.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">"This method will be removed in future versions.  "</span></span><br><span class="line">            <span class="string">"Use 'list(elem)' or iteration over elem instead."</span>,</span><br><span class="line">            DeprecationWarning, stacklevel=<span class="number">2</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">return</span> self._children</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, path, namespaces=None)</span>:</span></span><br><span class="line">        获取第一个寻找到的子节点</span><br><span class="line">        <span class="string">"""Find first matching element by tag name or path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *path* is a string having either an element tag or an XPath,</span></span><br><span class="line"><span class="string">        *namespaces* is an optional mapping from namespace prefix to full name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return the first matching element, or None if no element was found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> ElementPath.find(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findtext</span><span class="params">(self, path, default=None, namespaces=None)</span>:</span></span><br><span class="line">        获取第一个寻找到的子节点的内容</span><br><span class="line">        <span class="string">"""Find text for first matching element by tag name or path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *path* is a string having either an element tag or an XPath,</span></span><br><span class="line"><span class="string">        *default* is the value to return if the element was not found,</span></span><br><span class="line"><span class="string">        *namespaces* is an optional mapping from namespace prefix to full name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return text content of first matching element, or default value if</span></span><br><span class="line"><span class="string">        none was found.  Note that if an element is found having no text</span></span><br><span class="line"><span class="string">        content, the empty string is returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> ElementPath.findtext(self, path, default, namespaces)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findall</span><span class="params">(self, path, namespaces=None)</span>:</span></span><br><span class="line">        获取所有的子节点</span><br><span class="line">        <span class="string">"""Find all matching subelements by tag name or path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *path* is a string having either an element tag or an XPath,</span></span><br><span class="line"><span class="string">        *namespaces* is an optional mapping from namespace prefix to full name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns list containing all matching elements in document order.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> ElementPath.findall(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iterfind</span><span class="params">(self, path, namespaces=None)</span>:</span></span><br><span class="line">        获取所有指定的节点，并创建一个迭代器（可以被<span class="keyword">for</span>循环）</span><br><span class="line">        <span class="string">"""Find all matching subelements by tag name or path.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *path* is a string having either an element tag or an XPath,</span></span><br><span class="line"><span class="string">        *namespaces* is an optional mapping from namespace prefix to full name.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return an iterable yielding all matching elements in document order.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> ElementPath.iterfind(self, path, namespaces)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear</span><span class="params">(self)</span>:</span></span><br><span class="line">        清空节点</span><br><span class="line">        <span class="string">"""Reset element.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This function removes all subelements, clears all attributes, and sets</span></span><br><span class="line"><span class="string">        the text and tail attributes to None.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.attrib.clear()</span><br><span class="line">        self._children = []</span><br><span class="line">        self.text = self.tail = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        获取当前节点的属性值</span><br><span class="line">        <span class="string">"""Get element attribute.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Equivalent to attrib.get, but some implementations may handle this a</span></span><br><span class="line"><span class="string">        bit more efficiently.  *key* is what attribute to look for, and</span></span><br><span class="line"><span class="string">        *default* is what to return if the attribute was not found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns a string containing the attribute value, or the default if</span></span><br><span class="line"><span class="string">        attribute was not found.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.attrib.get(key, default)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        为当前节点设置属性值</span><br><span class="line">        <span class="string">"""Set element attribute.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Equivalent to attrib[key] = value, but some implementations may handle</span></span><br><span class="line"><span class="string">        this a bit more efficiently.  *key* is what attribute to set, and</span></span><br><span class="line"><span class="string">        *value* is the attribute value to set it to.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.attrib[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">keys</span><span class="params">(self)</span>:</span></span><br><span class="line">        获取当前节点的所有属性的 key</span><br><span class="line"></span><br><span class="line">        <span class="string">"""Get list of attribute names.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Names are returned in an arbitrary order, just like an ordinary</span></span><br><span class="line"><span class="string">        Python dict.  Equivalent to attrib.keys()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.attrib.keys()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">items</span><span class="params">(self)</span>:</span></span><br><span class="line">        获取当前节点的所有属性值，每个属性都是一个键值对</span><br><span class="line">        <span class="string">"""Get element attributes as a sequence.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The attributes are returned in arbitrary order.  Equivalent to</span></span><br><span class="line"><span class="string">        attrib.items().</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return a list of (name, value) tuples.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.attrib.items()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">iter</span><span class="params">(self, tag=None)</span>:</span></span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点，并返回一个迭代器（可以被<span class="keyword">for</span>循环）。</span><br><span class="line">        <span class="string">"""Create tree iterator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The iterator loops over the element and all subelements in document</span></span><br><span class="line"><span class="string">        order, returning all elements with a matching tag.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If the tree structure is modified during iteration, new or removed</span></span><br><span class="line"><span class="string">        elements may or may not be included.  To get a stable set, use the</span></span><br><span class="line"><span class="string">        list() function on the iterator, and loop over the resulting list.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        *tag* is what tags to look for (default is to return all elements)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Return an iterator containing all the matching elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">"*"</span>:</span><br><span class="line">            tag = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> tag <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.tag == tag:</span><br><span class="line">            <span class="keyword">yield</span> self</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> self._children:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> e.iter(tag)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compatibility</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getiterator</span><span class="params">(self, tag=None)</span>:</span></span><br><span class="line">        <span class="comment"># Change for a DeprecationWarning in 1.4</span></span><br><span class="line">        warnings.warn(</span><br><span class="line">            <span class="string">"This method will be removed in future versions.  "</span></span><br><span class="line">            <span class="string">"Use 'elem.iter()' or 'list(elem.iter())' instead."</span>,</span><br><span class="line">            PendingDeprecationWarning, stacklevel=<span class="number">2</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> list(self.iter(tag))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">itertext</span><span class="params">(self)</span>:</span></span><br><span class="line">        在当前节点的子孙中根据节点名称寻找所有指定的节点的内容，并返回一个迭代器（可以被<span class="keyword">for</span>循环）。</span><br><span class="line">        <span class="string">"""Create text iterator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        The iterator loops over the element and all subelements in document</span></span><br><span class="line"><span class="string">        order, returning all inner text.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        tag = self.tag</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(tag, str) <span class="keyword">and</span> tag <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.text:</span><br><span class="line">            <span class="keyword">yield</span> self.text</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> self:</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">from</span> e.itertext()</span><br><span class="line">            <span class="keyword">if</span> e.tail:</span><br><span class="line">                <span class="keyword">yield</span> e.tail</span><br></pre></td></tr></table></figure>

<h2 id="遍历XML文档的所有内容"><a href="#遍历XML文档的所有内容" class="headerlink" title="遍历XML文档的所有内容"></a>遍历XML文档的所有内容</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 直接解析xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">"xo.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取xml文件的根节点</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取顶层标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历xml文档的第二层</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> root:</span><br><span class="line">    <span class="comment"># 第二层节点的标签名称和标签属性</span></span><br><span class="line">    print(i.tag, i.attrib)</span><br><span class="line">    <span class="comment"># 遍历xml文档的第三层</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i:</span><br><span class="line">        print(j.tag, j.text)</span><br><span class="line">        </span><br><span class="line"> ------------</span><br><span class="line">data</span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Liechtenstein'</span>&#125;</span><br><span class="line">rank <span class="number">2</span></span><br><span class="line">year <span class="number">2023</span></span><br><span class="line">gdppc <span class="number">141100</span></span><br><span class="line">neighbor <span class="literal">None</span></span><br><span class="line">neighbor <span class="literal">None</span></span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Singapore'</span>&#125;</span><br><span class="line">rank <span class="number">5</span></span><br><span class="line">year <span class="number">2026</span></span><br><span class="line">gdppc <span class="number">59900</span></span><br><span class="line">neighbor <span class="literal">None</span></span><br><span class="line">country &#123;<span class="string">'name'</span>: <span class="string">'Panama'</span>&#125;</span><br><span class="line">rank <span class="number">69</span></span><br><span class="line">year <span class="number">2026</span></span><br><span class="line">gdppc <span class="number">13600</span></span><br><span class="line">neighbor <span class="literal">None</span></span><br><span class="line">neighbor <span class="literal">None</span></span><br></pre></td></tr></table></figure>

<h2 id="遍历指定节点"><a href="#遍历指定节点" class="headerlink" title="遍历指定节点"></a>遍历指定节点</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接解析xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">"xo.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取xml文件的根节点</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取顶层标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># root.iter()的参数中可以填入任意一个节点名称</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.iter(<span class="string">"gdppc"</span>):</span><br><span class="line">    <span class="comment"># 节点的标签名称和内容</span></span><br><span class="line">    print(node.tag, node.text)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">data</span><br><span class="line">gdppc <span class="number">141100</span></span><br><span class="line">gdppc <span class="number">59900</span></span><br><span class="line">gdppc <span class="number">13600</span></span><br></pre></td></tr></table></figure>

<h2 id="修改节点的内容"><a href="#修改节点的内容" class="headerlink" title="修改节点的内容"></a>修改节点的内容</h2><p>由于修改节点时，均是在内存中进行，不会影响到文件中的内容。所以如果想要修改，则需要重新将内存中的内容写入到文件。</p>
<ul>
<li>解析字符创的方式来修改和保存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件,将文件的内容读到内存中</span></span><br><span class="line">str_xml = open(<span class="string">"xo.xml"</span>, <span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串解析成xml特殊对象,root代指xml文件的根节点</span></span><br><span class="line">root = ET.XML(str_xml)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始操作xml对象</span></span><br><span class="line"><span class="comment"># 打印一下顶层的标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环所有的year节点</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.iter(<span class="string">"year"</span>):</span><br><span class="line">    <span class="comment"># 将year节点中的内容自增一</span></span><br><span class="line">    new_year = int(node.text) + <span class="number">1</span></span><br><span class="line">    node.text = str(new_year)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置属性</span></span><br><span class="line">    node.set(<span class="string">"name"</span>, <span class="string">"polarsnow"</span>)</span><br><span class="line">    node.set(<span class="string">"age"</span>, <span class="string">"25"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除属性</span></span><br><span class="line">    <span class="keyword">del</span> node.attrib[<span class="string">"age"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line"><span class="comment">## 使用读取字符串的方式在保存之前需要先创建ElementTree对象</span></span><br><span class="line">tree = ET.ElementTree(root)</span><br><span class="line">tree.write(<span class="string">"newxo.xml"</span>, encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>解析文件的方式来修改和保存</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接解析xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">"xo.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取xml文件的根节点</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始操作xml对象</span></span><br><span class="line"><span class="comment"># 顶层标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环所有的year节点</span></span><br><span class="line"><span class="keyword">for</span> node <span class="keyword">in</span> root.iter(<span class="string">"year"</span>):</span><br><span class="line">    <span class="comment"># 将year节点中的内容自增一</span></span><br><span class="line">    new_year = int(node.text) + <span class="number">1</span></span><br><span class="line">    node.text = str(new_year)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置属性</span></span><br><span class="line">    node.set(<span class="string">"name"</span>, <span class="string">"polarsnow"</span>)</span><br><span class="line">    node.set(<span class="string">"age"</span>, <span class="string">"25"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除属性</span></span><br><span class="line">    <span class="keyword">del</span> node.attrib[<span class="string">"age"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line"><span class="comment">## 使用parse的方式直接解析xml文件，已经生成了ElementTree对象</span></span><br><span class="line"><span class="comment">## 可以直接调用写的方法</span></span><br><span class="line">tree.write(<span class="string">"newxo.xml"</span>, encoding=<span class="string">"utf-8"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>xo.xml</code> </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Liechtenstein"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2023<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>141100<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"E"</span> <span class="attr">name</span>=<span class="string">"Austria"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"W"</span> <span class="attr">name</span>=<span class="string">"Switzerland"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Singapore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2026<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>59900<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"N"</span> <span class="attr">name</span>=<span class="string">"Malaysia"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Panama"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>69<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>2026<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>13600<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"W"</span> <span class="attr">name</span>=<span class="string">"Costa Rica"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"E"</span> <span class="attr">name</span>=<span class="string">"Colombia"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>newxo.xml</code></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Liechtenstein"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span> <span class="attr">name</span>=<span class="string">"polarsnow"</span>&gt;</span>2024<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>141100<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"E"</span> <span class="attr">name</span>=<span class="string">"Austria"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"W"</span> <span class="attr">name</span>=<span class="string">"Switzerland"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Singapore"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span> <span class="attr">name</span>=<span class="string">"polarsnow"</span>&gt;</span>2027<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>59900<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"N"</span> <span class="attr">name</span>=<span class="string">"Malaysia"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">country</span> <span class="attr">name</span>=<span class="string">"Panama"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rank</span> <span class="attr">updated</span>=<span class="string">"yes"</span>&gt;</span>69<span class="tag">&lt;/<span class="name">rank</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span> <span class="attr">name</span>=<span class="string">"polarsnow"</span>&gt;</span>2027<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">gdppc</span>&gt;</span>13600<span class="tag">&lt;/<span class="name">gdppc</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"W"</span> <span class="attr">name</span>=<span class="string">"Costa Rica"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">neighbor</span> <span class="attr">direction</span>=<span class="string">"E"</span> <span class="attr">name</span>=<span class="string">"Colombia"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><ul>
<li>解析字符串的方式来删除节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件，读取XML内容</span></span><br><span class="line">str_xml = open(<span class="string">'xo.xml'</span>, <span class="string">'r'</span>).read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字符串解析成xml特殊对象，root代指xml文件的根节点</span></span><br><span class="line">root = ET.XML(str_xml)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始操作xml对象</span></span><br><span class="line"><span class="comment"># 顶层标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历data下的所有country节点</span></span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):</span><br><span class="line">    <span class="comment"># 获取每一个country节点下rank节点的内容</span></span><br><span class="line">    rank = int(country.find(<span class="string">'rank'</span>).text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rank &gt; <span class="number">50</span>:</span><br><span class="line">        <span class="comment"># 删除指定country节点</span></span><br><span class="line">        root.remove(country)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">tree = ET.ElementTree(root)</span><br><span class="line">tree.write(<span class="string">"newxo.xml"</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>解析文件的方式来删除节点</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接解析xml文件</span></span><br><span class="line">tree = ET.parse(<span class="string">"xo.xml"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取xml文件的根节点</span></span><br><span class="line">root = tree.getroot()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始操作xml对象</span></span><br><span class="line"><span class="comment"># 顶层标签</span></span><br><span class="line">print(root.tag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历data下的所有country节点</span></span><br><span class="line"><span class="keyword">for</span> country <span class="keyword">in</span> root.findall(<span class="string">'country'</span>):</span><br><span class="line">    <span class="comment"># 获取每一个country节点下rank节点的内容</span></span><br><span class="line">    rank = int(country.find(<span class="string">'rank'</span>).text)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rank &gt; <span class="number">50</span>:</span><br><span class="line">        <span class="comment"># 删除指定country节点</span></span><br><span class="line">        root.remove(country)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存文件</span></span><br><span class="line">tree.write(<span class="string">"newnew.xml"</span>, encoding=<span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="创建xml文档"><a href="#创建xml文档" class="headerlink" title="创建xml文档"></a>创建xml文档</h1><ul>
<li>第一种创建方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二级节点</span></span><br><span class="line">country1 = ET.Element(<span class="string">"country"</span>, &#123;<span class="string">"name"</span>: <span class="string">"China"</span>&#125;)</span><br><span class="line">country2 = ET.Element(<span class="string">"country"</span>, &#123;<span class="string">"name"</span>: <span class="string">"America"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建三级节点</span></span><br><span class="line">city1 = ET.Element(<span class="string">"city"</span>, &#123;<span class="string">"name"</span>: <span class="string">"BeiJing"</span>&#125;)</span><br><span class="line">city2 = ET.Element(<span class="string">"city"</span>, &#123;<span class="string">"name"</span>: <span class="string">"TangShan"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把创建的三级节点添加到二级节点下面</span></span><br><span class="line">country1.append(city1)</span><br><span class="line">country1.append(city2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再把二级节点添加到跟节点中</span></span><br><span class="line">root.append(country1)</span><br><span class="line">root.append(country2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ElementTree对象</span></span><br><span class="line">tree = ET.ElementTree(root)</span><br><span class="line">tree.write(<span class="string">"xxxx.xml"</span>, encoding=<span class="string">"utf-8"</span>, short_empty_elements=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/QQ20160623-0@2x.png" alt=""></p>
<ul>
<li>第二种创建方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二级节点</span></span><br><span class="line">country1 = root.makeelement(<span class="string">"country"</span>, &#123;<span class="string">"name"</span>: <span class="string">"China"</span>&#125;)</span><br><span class="line">country2 = root.makeelement(<span class="string">"country"</span>, &#123;<span class="string">"name"</span>: <span class="string">"America"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建三级节点</span></span><br><span class="line">city1 = country1.makeelement(<span class="string">"city"</span>, &#123;<span class="string">"name"</span>: <span class="string">"BeiJing"</span>&#125;)</span><br><span class="line">city2 = country1.makeelement(<span class="string">"city"</span>, &#123;<span class="string">"name"</span>: <span class="string">"TangShan"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把创建的三级节点添加到二级节点下面</span></span><br><span class="line">country1.append(city1)</span><br><span class="line">country1.append(city2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再把二级节点添加到跟节点中</span></span><br><span class="line">root.append(country1)</span><br><span class="line">root.append(country2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建ElementTree对象</span></span><br><span class="line">tree = ET.ElementTree(root)</span><br><span class="line">tree.write(<span class="string">"xxxx.xml"</span>, encoding=<span class="string">"utf-8"</span>, short_empty_elements=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>第三种创建方式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二级节点</span></span><br><span class="line">country1 = ET.SubElement(root, <span class="string">"country"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"China"</span>&#125;)</span><br><span class="line">country2 = ET.SubElement(root, <span class="string">"country"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"America"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建三级节点</span></span><br><span class="line">city1 = ET.SubElement(country1, <span class="string">"city"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"BeiJing"</span>&#125;)</span><br><span class="line">city2 = ET.SubElement(country1, <span class="string">"city"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"TangShan"</span>&#125;)</span><br><span class="line"></span><br><span class="line">et = ET.ElementTree(root)  <span class="comment"># 生成文档对象</span></span><br><span class="line"><span class="comment"># xml_declaration 添加xml版本信息注释</span></span><br><span class="line">et.write(<span class="string">"test.xml"</span>, encoding=<span class="string">"utf-8"</span>, xml_declaration=<span class="literal">True</span>, short_empty_elements=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>第三种方式不同于上面两种方式的是在创建节点的时候，已经指定了该节点与其他节点的关系。</p>
<ul>
<li>缩进</li>
</ul>
<p>原生保存的XML默认没有缩进，如果需要缩进，可以使用如下方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> xml.etree <span class="keyword">import</span> ElementTree <span class="keyword">as</span> ET</span><br><span class="line"><span class="keyword">from</span> xml.dom <span class="keyword">import</span> minidom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prettify</span><span class="params">(elem)</span>:</span></span><br><span class="line">    <span class="string">"""将节点转换成字符串，并添加缩进"""</span></span><br><span class="line">    rough_string = ET.tostring(elem, <span class="string">'utf-8'</span>)</span><br><span class="line">    reparsed = minidom.parseString(rough_string)</span><br><span class="line">    <span class="keyword">return</span> reparsed.toprettyxml(indent=<span class="string">"\t"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建根节点</span></span><br><span class="line">root = ET.Element(<span class="string">"World"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建二级节点</span></span><br><span class="line">country1 = ET.SubElement(root, <span class="string">"country"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"China"</span>&#125;)</span><br><span class="line">country2 = ET.SubElement(root, <span class="string">"country"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"America"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建三级节点</span></span><br><span class="line">city1 = ET.SubElement(country1, <span class="string">"city"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"BeiJing"</span>&#125;)</span><br><span class="line">city2 = ET.SubElement(country1, <span class="string">"city"</span>, attrib=&#123;<span class="string">"name"</span>: <span class="string">"TangShan"</span>&#125;)</span><br><span class="line"></span><br><span class="line">raw_str = prettify(root)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"xxoo.xml"</span>, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(raw_str)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Python配置文件模块configparser</title>
    <url>/2016/06/22/Python%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97configparser/</url>
    <content><![CDATA[<blockquote>
<p> Python中的configparser模块用来处理特定格式的文件，其本质上是利用open来操作文件。</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="configparser指定的格式"><a href="#configparser指定的格式" class="headerlink" title="configparser指定的格式"></a>configparser指定的格式</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 注释1</span><br><span class="line">;  注释2</span><br><span class="line"> </span><br><span class="line">[section1] # 节点</span><br><span class="line">k1 &#x3D; v1    # 值</span><br><span class="line">k2:v2       # 值</span><br><span class="line"> </span><br><span class="line">[section2] # 节点</span><br><span class="line">k1 &#x3D; v1    # 值</span><br></pre></td></tr></table></figure>

<h1 id="获取所有节点信息"><a href="#获取所有节点信息" class="headerlink" title="获取所有节点信息"></a>获取所有节点信息</h1><p>实例配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">version&#x3D;5.7</span><br><span class="line"></span><br><span class="line">[python]</span><br><span class="line">version:3.5</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">ret = config.sections()</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'mysql'</span>, <span class="string">'python'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="获取指定节点下的所有键值对"><a href="#获取指定节点下的所有键值对" class="headerlink" title="获取指定节点下的所有键值对"></a>获取指定节点下的所有键值对</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">ret = config.items(<span class="string">'mysql'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[(<span class="string">'version'</span>, <span class="string">'5.7'</span>)]</span><br></pre></td></tr></table></figure>

<h2 id="获取指定节点下的所有键"><a href="#获取指定节点下的所有键" class="headerlink" title="获取指定节点下的所有键"></a>获取指定节点下的所有键</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">ret = config.options(<span class="string">'mysql'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'version'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="获取指定节点下的所有值"><a href="#获取指定节点下的所有值" class="headerlink" title="获取指定节点下的所有值"></a>获取指定节点下的所有值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment"># ret = config.get('mysql', 'version')</span></span><br><span class="line"><span class="comment"># print(ret, type(ret))</span></span><br><span class="line"><span class="comment"># ret = config.getint('mysql', 'version')</span></span><br><span class="line"><span class="comment"># print(ret, type(ret))</span></span><br><span class="line">ret = config.getfloat(<span class="string">'mysql'</span>, <span class="string">'version'</span>)</span><br><span class="line">print(ret, type(ret))</span><br><span class="line"><span class="comment"># ret = config.getboolean('mysql', 'version')</span></span><br><span class="line"><span class="comment"># print(ret, type(ret))</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">5.7</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">float</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="节点的增删查"><a href="#节点的增删查" class="headerlink" title="节点的增删查"></a>节点的增删查</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件中有没有指定的节点</span></span><br><span class="line">has_sec = config.has_section(<span class="string">'mysql'</span>)</span><br><span class="line">print(has_sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在配置文件中添加新的节点</span></span><br><span class="line">config.add_section(<span class="string">'java'</span>)</span><br><span class="line">config.write(open(<span class="string">'test.conf'</span>, <span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在配置文件中删除已有的节点</span></span><br><span class="line">config.remove_section(<span class="string">'python'</span>)</span><br><span class="line">config.write(open(<span class="string">'test.conf'</span>, <span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cat test.conf</span><br><span class="line">[mysql]</span><br><span class="line">version = 5.7</span><br><span class="line"></span><br><span class="line">[java]</span><br></pre></td></tr></table></figure>

<h1 id="节点内键值对的删改查"><a href="#节点内键值对的删改查" class="headerlink" title="节点内键值对的删改查"></a>节点内键值对的删改查</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cat test.conf</span><br><span class="line">[mysql]</span><br><span class="line">version = 5.7</span><br><span class="line">path = /usr/<span class="built_in">local</span>/mysql</span><br><span class="line"></span><br><span class="line">[java]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> configparser</span><br><span class="line"></span><br><span class="line">config = configparser.ConfigParser()</span><br><span class="line">config.read(<span class="string">'test.conf'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查配置文件中有没有指定的节点</span></span><br><span class="line">has_opt = config.has_option(<span class="string">'mysql'</span>, <span class="string">'version'</span>)</span><br><span class="line">print(has_opt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在配置文件中修改节点</span></span><br><span class="line">config.set(<span class="string">'mysql'</span>, <span class="string">'path'</span>, <span class="string">'/usr/local/src/mysql'</span>)</span><br><span class="line">config.write(open(<span class="string">'test.conf'</span>, <span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除节点下指定的键值对</span></span><br><span class="line">config.remove_option(<span class="string">'mysql'</span>, <span class="string">'version'</span>)</span><br><span class="line">config.write(open(<span class="string">'test.conf'</span>, <span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; cat test.conf</span><br><span class="line">[mysql]</span><br><span class="line">path = /usr/<span class="built_in">local</span>/src/mysql</span><br><span class="line"></span><br><span class="line">[java]</span><br></pre></td></tr></table></figure>

<p>configparser模块中，<strong>对节点没有修改的操作</strong>，<strong>对节点下的键值对没有增加的操作</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>configparser</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的正则表达式模块re</title>
    <url>/2016/06/17/Python%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A8%A1%E5%9D%97re/</url>
    <content><![CDATA[<blockquote>
<p>在Python中<code>re</code>模块提供了正则表达式的相关操作。其本质，RE是一种小型的，高度专业化的编程语言，通过re模块来实现其功能。正则表达式被编译成一系列字节码，然后由C编写的匹配引擎执行。</p>
<p>我们将涉及两个重要的功能，这将被用于处理的正则表达式。但是首先：有各种各样的字符，当它们在正则表达式中使用，将有特殊的意义。为了避免在处理正则表达式的任何困惑，将使用原始字符串作为r’expression“。</p>
<p>Python Version：3.5+</p>
</blockquote>
<h1 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h1><h2 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h2><ul>
<li>.        默认匹配除换行符以外的任意字符</li>
<li>^        匹配字符串的开始</li>
<li>$        匹配字符串的结束</li>
<li>[]    指定字符范围匹配</li>
<li>|        或</li>
<li>\        转义字符，反斜杠本身需要反斜杠去转义</li>
<li>()    分组，去已经匹配到的数据中再去提取数据</li>
<li>\d  匹配任何十进制数；它相当于类 [0-9]。</li>
<li>\D  匹配任何非数字字符；它相当于类 [^0-9]。</li>
<li>\s  匹配任何空白字符；它相当于类  [ \t\n\r\f\v]。</li>
<li>\S  匹配任何非空白字符；它相当于类 [^ \t\n\r\f\v]。</li>
<li>\w  匹配任何字母数字字符；它相当于类 [a-zA-Z0-9_]。</li>
<li>\W  匹配任何非字母数字字符；它相当于类 [^a-zA-Z0-9_]</li>
<li>\b    匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</li>
<li>\B    匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</li>
</ul>
<h2 id="次数匹配"><a href="#次数匹配" class="headerlink" title="次数匹配"></a>次数匹配</h2><ul>
<li><ul>
<li>重复0次或多次</li>
</ul>
</li>
<li><ul>
<li>重复1次或多次</li>
</ul>
</li>
<li>?        重复0次或1次</li>
<li>{n}    重复n次</li>
<li>{n,}    重复n次或多次</li>
<li>{n, m}    重复n次到m次</li>
</ul>
<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><ul>
<li>re.I    使匹配对大小写不敏感</li>
<li>re.L    做本地化识别（locale-aware）匹配</li>
<li>re.M    多行匹配，影响 ^ 和 $</li>
<li>re.S    使 . 匹配包括换行在内的所有字符</li>
<li>re.U    根据Unicode字符集解析字符。这个标志影响 \w, \W, \b, \B.</li>
<li>re.X    该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。</li>
</ul>
<h1 id="正则表达式实例"><a href="#正则表达式实例" class="headerlink" title="正则表达式实例"></a>正则表达式实例</h1><h2 id="普通字符匹配"><a href="#普通字符匹配" class="headerlink" title="普通字符匹配"></a>普通字符匹配</h2><ul>
<li><code>python</code>    匹配 <code>python</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r"python"</span>, <span class="string">"Pythonpythoner"</span>, re.I)</span><br><span class="line">[<span class="string">'Python'</span>, <span class="string">'python'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="锚点匹配"><a href="#锚点匹配" class="headerlink" title="锚点匹配"></a>锚点匹配</h2><ul>
<li><code>^python$</code>     匹配以<code>python</code>开头结尾的字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r"^python$"</span>, <span class="string">"Pythonpythoner"</span>, re.I)</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r"^python$"</span>, <span class="string">"Python"</span>, re.I)</span><br><span class="line">[<span class="string">'Python'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="范围匹配"><a href="#范围匹配" class="headerlink" title="范围匹配"></a>范围匹配</h2><ul>
<li>[Pp]ython    匹配 “Python” 或 “python”</li>
<li>rub[ye]    匹配 “ruby” 或 “rube”</li>
<li>[aeiou]    匹配中括号内的任意一个字母</li>
<li>[0-9]    匹配任何数字。类似于 [0123456789]</li>
<li>[a-z]    匹配任何小写字母</li>
<li>[A-Z]    匹配任何大写字母</li>
<li>[a-zA-Z0-9]    匹配任何字母及数字</li>
<li>[^aeiou]    除了aeiou字母以外的所有字符</li>
<li>[^0-9]    匹配除了数字外的字符</li>
</ul>
<h2 id="或匹配"><a href="#或匹配" class="headerlink" title="或匹配"></a>或匹配</h2><ul>
<li><code>python|java</code>        匹配<code>python</code>或<code>java</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r"python|java"</span>, <span class="string">"Python and java"</span>, re.I)</span><br><span class="line">[<span class="string">'Python'</span>, <span class="string">'java'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="匹配反斜杠"><a href="#匹配反斜杠" class="headerlink" title="匹配反斜杠"></a>匹配反斜杠</h2><ul>
<li><code>\\</code> 匹配<code>\</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r"\\"</span>, <span class="string">"Python\ and java"</span>, re.I)</span><br><span class="line">[<span class="string">'\\'</span>]</span><br></pre></td></tr></table></figure>

<p>注意：在匹配的使用，如果想匹配字符串中的一个反斜杠，需要在原生字符串中写两个反斜杠。在匹配结果中，re中匹配到了一个<code>\</code>但是返回的却是<code>\\</code>，是因为Python中也需要使用两个反斜杠来表示一个反斜杠</p>
<p>这里需要详细解释一下：<strong>Python与re之间的转义</strong></p>
<p>在之前的笔记中，我们已经知道<code>原生字符串</code>的概念，简单来说，就是我在python中一旦在字符串前面加了<code>r</code>就表示后面这串字符串中所有的字符都当做普通字符来处理。在上面的例子中，我们已经使用了原生字符串的写法，声明字符串中的<code>\</code>已经是普通字符了，为什么到了re中，需要python给出<code>\\</code>才能匹配到<code>\</code>呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'\\'</span>)</span><br><span class="line">\</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'\\'</span>)</span><br><span class="line">\\</span><br></pre></td></tr></table></figure>

<p>这是因为，re和Python其实是两套系统，在Python中虽然明确给出了让re去匹配<code>\</code>，但是这一个<code>\</code>传递给re时，在re中一个<code>\</code>也是特殊字符，表示转义，所以不能正确在字符串中匹配到字符<code>\</code>，为了抵消掉re中<code>\</code>的特殊含义，需要使用<code>\\</code>来匹配到一个<code>\</code>,所以从re的角度来说，就要求Python传递过去的是<code>\\</code>才能让re在字符串中匹配到<code>\</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">"\\\\"</span>, <span class="string">"Python\ and java"</span>, re.I)</span><br><span class="line">[<span class="string">'\\'</span>]</span><br></pre></td></tr></table></figure>

<p>对比一下，如果不使用原生字符串的话，re仍然需要Python传递过去<code>\\</code>才能匹配到<code>\</code>，但是Python中的字符串如果没有声明是原生字符串的话需要使用<code>\\\\</code>才能表示<code>\\</code></p>
<h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>上面简单的介绍完re的基本表达式，下面就可以实际使用re的函数来操作匹配字符串啦</p>
<h2 id="match"><a href="#match" class="headerlink" title="match"></a>match</h2><p>match，从起始位置开始匹配，匹配成功返回一个对象，未匹配成功返回None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match</span><span class="params">(pattern, string, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Try to apply the pattern at the start of the string, returning</span></span><br><span class="line"><span class="string">    a match object, or None if no match was found."""</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).match(string)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>pattern    正则表达式</li>
<li>string    字符串</li>
<li>flags    编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li>
</ul>
<p><strong>匹配对象方法</strong></p>
<ul>
<li>group()    获取匹配到的所有结果</li>
<li>groups()    获取模型中匹配到的分组结果</li>
<li>groupdict() 获取模型中匹配到的分组结果</li>
<li>start()    返回匹配开始的位置</li>
<li>end()    返回匹配结束的位置</li>
<li>span()    返回一个元组包含匹配 (开始,结束) 的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无分组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = re.match(<span class="string">'com'</span>, <span class="string">'comwww.runcomoob'</span>)</span><br><span class="line">print(r.group())</span><br><span class="line">print(r.groups())</span><br><span class="line">print(r.groupdict())</span><br><span class="line"></span><br><span class="line">r = re.match(<span class="string">'com'</span>, <span class="string">'Comwww.runComoob'</span>, re.I)</span><br><span class="line">print(r.group())</span><br><span class="line">print(r.groups())</span><br><span class="line">print(r.groupdict())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">com</span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br><span class="line">Com</span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有分组</span></span><br><span class="line"><span class="comment"># 为何要有分组？提取匹配成功的指定内容（先匹配成功全部正则，再匹配成功的局部内容提取出来）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = re.match(<span class="string">'c(..)'</span>, <span class="string">'comwww.runcomoob'</span>)</span><br><span class="line">print(r.group())</span><br><span class="line">print(r.groups())</span><br><span class="line">print(r.groupdict())</span><br><span class="line"></span><br><span class="line">r = re.match(<span class="string">'c(..)'</span>, <span class="string">'Comwww.runComoob'</span>, re.I)</span><br><span class="line">print(r.group())</span><br><span class="line">print(r.groups())</span><br><span class="line">print(r.groupdict())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">com</span><br><span class="line">(<span class="string">'om'</span>,)</span><br><span class="line">&#123;&#125;</span><br><span class="line">Com</span><br><span class="line">(<span class="string">'om'</span>,)</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>观察取出来的结果，<code>groups()</code>中有了匹配结果，匹配的是<code>group()</code>中的结果。也就是说，使用分组，意味着在匹配到整个字符串中再次进行匹配并取值(取括号中的值)</p>
<h2 id="search"><a href="#search" class="headerlink" title="search"></a>search</h2><p>search,浏览整个字符串去匹配第一个，未匹配成功返回None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(pattern, string, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Scan through string looking for a match to the pattern, returning</span></span><br><span class="line"><span class="string">    a match object, or None if no match was found."""</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).search(string)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>pattern    正则表达式</li>
<li>string    字符串</li>
<li>flags    编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li>
</ul>
<p><strong>匹配对象方法</strong></p>
<ul>
<li>group()    获取匹配到的所有结果</li>
<li>groups()    获取模型中匹配到的分组结果</li>
<li>groupdict() 获取模型中匹配到的分组结果</li>
<li>start()    返回匹配开始的位置</li>
<li>end()    返回匹配结束的位置</li>
<li>span()    返回一个元组包含匹配 (开始,结束) 的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = re.search(<span class="string">'\dcom'</span>, <span class="string">'www.4comrunoob.5com'</span>)</span><br><span class="line">print(r.group())</span><br><span class="line">print(r.groups())</span><br><span class="line">print(r.groupdict())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">4</span>com</span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>

<h1 id="re-match与re-search的区别"><a href="#re-match与re-search的区别" class="headerlink" title="re.match与re.search的区别"></a>re.match与re.search的区别</h1><p>re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">line = <span class="string">"Cats are smarter than dogs"</span></span><br><span class="line"></span><br><span class="line">matchObj = re.match(<span class="string">r'dogs'</span>, line, re.M | re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">    print(<span class="string">"match --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No match!!"</span>)</span><br><span class="line"></span><br><span class="line">matchObj = re.search(<span class="string">r'dogs'</span>, line, re.M | re.I)</span><br><span class="line"><span class="keyword">if</span> matchObj:</span><br><span class="line">    print(<span class="string">"search --&gt; matchObj.group() : "</span>, matchObj.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No match!!"</span>)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">No match!!</span><br><span class="line">search --&gt; matchObj.group() :  dogs</span><br></pre></td></tr></table></figure>

<h2 id="findall"><a href="#findall" class="headerlink" title="findall"></a>findall</h2><p>findall，找到 RE 匹配的所有子串，并把它们作为一个列表返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findall</span><span class="params">(pattern, string, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Return a list of all non-overlapping matches in the string.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If one or more capturing groups are present in the pattern, return</span></span><br><span class="line"><span class="string">    a list of groups; this will be a list of tuples if the pattern</span></span><br><span class="line"><span class="string">    has more than one group.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Empty matches are included in the result."""</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).findall(string)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>pattern    正则表达式</li>
<li>string    字符串</li>
<li>flags    编译标志位，用于修改正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无分组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = re.findall(<span class="string">r'\d+'</span>, <span class="string">'1one1two2three3four4'</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有分组</span></span><br><span class="line">r = re.findall(<span class="string">r'\d+(..)'</span>, <span class="string">'1one1two2three3four4'</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'1'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>]</span><br><span class="line">[<span class="string">'on'</span>, <span class="string">'tw'</span>, <span class="string">'th'</span>, <span class="string">'fo'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="finditer"><a href="#finditer" class="headerlink" title="finditer"></a>finditer</h2><p>找到 RE 匹配的所有子串，并把它们作为一个迭代器返回</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span></span><br><span class="line"></span><br><span class="line">r = re.finditer(<span class="string">r'\d+'</span>, <span class="string">'1one1two2three3four4'</span>)</span><br><span class="line">print(r)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> r:</span><br><span class="line">    print(i.span(), i.group(), i.groupdict())</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">&lt;callable_iterator object at <span class="number">0x101178748</span>&gt;</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>) <span class="number">1</span> &#123;&#125;</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>) <span class="number">1</span> &#123;&#125;</span><br><span class="line">(<span class="number">8</span>, <span class="number">9</span>) <span class="number">2</span> &#123;&#125;</span><br><span class="line">(<span class="number">14</span>, <span class="number">15</span>) <span class="number">3</span> &#123;&#125;</span><br><span class="line">(<span class="number">19</span>, <span class="number">20</span>) <span class="number">4</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sub"><a href="#sub" class="headerlink" title="sub"></a>sub</h2><p>sub，替换匹配成功的指定位置字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(pattern, repl, string, count=<span class="number">0</span>, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Return the string obtained by replacing the leftmost</span></span><br><span class="line"><span class="string">    non-overlapping occurrences of the pattern in string by the</span></span><br><span class="line"><span class="string">    replacement repl.  repl can be either a string or a callable;</span></span><br><span class="line"><span class="string">    if a string, backslash escapes in it are processed.  If it is</span></span><br><span class="line"><span class="string">    a callable, it's passed the match object and must return</span></span><br><span class="line"><span class="string">    a replacement string to be used."""</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).sub(repl, string, count)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>pattern： 正则模型</li>
<li>repl   ： 要替换的字符串或可执行对象</li>
<li>string ： 要匹配的字符串</li>
<li>count  ： 指定匹配个数</li>
<li>flags  ： 匹配模式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 与分组无关</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">r = re.sub(<span class="string">"a\w+"</span>, <span class="string">"18"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">2</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">hello ps bcd ps lge ps <span class="number">18</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>


<h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><p>split，根据正则匹配分割字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">split</span><span class="params">(pattern, string, maxsplit=<span class="number">0</span>, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Split the source string by the occurrences of the pattern,</span></span><br><span class="line"><span class="string">    returning a list containing the resulting substrings.  If</span></span><br><span class="line"><span class="string">    capturing parentheses are used in pattern, then the text of all</span></span><br><span class="line"><span class="string">    groups in the pattern are also returned as part of the resulting</span></span><br><span class="line"><span class="string">    list.  If maxsplit is nonzero, at most maxsplit splits occur,</span></span><br><span class="line"><span class="string">    and the remainder of the string is returned as the final element</span></span><br><span class="line"><span class="string">    of the list."""</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags).split(string, maxsplit)</span><br></pre></td></tr></table></figure>

<ul>
<li>pattern： 正则模型</li>
<li>string ： 要匹配的字符串</li>
<li>maxsplit：指定分割个数</li>
<li>flags  ： 匹配模式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无分组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">origin = <span class="string">"hello ps bcd ps lge ps acd 25"</span></span><br><span class="line">r = re.split(<span class="string">"ps"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">1</span>)</span><br><span class="line">print(r)</span><br><span class="line">r = re.split(<span class="string">"ps"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">2</span>)</span><br><span class="line">print(r)</span><br><span class="line">r = re.split(<span class="string">"ps"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">3</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'hello '</span>, <span class="string">' bcd ps lge ps acd 25'</span>]</span><br><span class="line">[<span class="string">'hello '</span>, <span class="string">' bcd '</span>, <span class="string">' lge ps acd 25'</span>]</span><br><span class="line">[<span class="string">'hello '</span>, <span class="string">' bcd '</span>, <span class="string">' lge '</span>, <span class="string">' acd 25'</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有分组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">origin = <span class="string">"hello ps bcd ps lge ps acd 25"</span></span><br><span class="line">r = re.split(<span class="string">"(ps)"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">1</span>)</span><br><span class="line">print(r)</span><br><span class="line">r = re.split(<span class="string">"p(s)"</span>, <span class="string">"hello ps bcd ps lge ps acd 25"</span>, <span class="number">1</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'hello '</span>, <span class="string">'ps'</span>, <span class="string">' bcd ps lge ps acd 25'</span>]</span><br><span class="line">[<span class="string">'hello '</span>, <span class="string">'s'</span>, <span class="string">' bcd ps lge ps acd 25'</span>]</span><br></pre></td></tr></table></figure>

<p>从上面的实例中可以看出，在不分组的情况下，列表的长度=maxsplit+1，匹配到的分割字符串并不会返回回来；而在分组的情况下，列表的长度=maxsplit+2，匹配到的字符串也会返回到列表中</p>
<h2 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h2><p>compile,编译正则表达式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compile</span><span class="params">(pattern, flags=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"Compile a regular expression pattern, returning a pattern object."</span></span><br><span class="line">    <span class="keyword">return</span> _compile(pattern, flags)</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>pattern： 正则模型</li>
<li>flags  ： 匹配模式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">p = re.compile(<span class="string">r'\d+(...)'</span>)</span><br><span class="line">print(p.findall(<span class="string">'123one134two256three378four469'</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'thr'</span>, <span class="string">'fou'</span>]</span><br></pre></td></tr></table></figure>

<p>先把正则表达式编译再匹配，在遍历匹配大型文件时，效率会提高很多，免去了每次还要编译正则表达式</p>
<h1 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h1><ul>
<li>IP：<code>^(25[0-5]|2[0-4]\d|[0-1]?\d?\d)(\.(25[0-5]|2[0-4]\d|[0-1]?\d?\d)){3}$</code></li>
<li>手机号：<code>^1[3|4|5|8][0-9]\d{8}$</code></li>
<li>邮箱：<code>[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+</code></li>
</ul>
<h1 id="正则表达式计算器实例"><a href="#正则表达式计算器实例" class="headerlink" title="正则表达式计算器实例"></a>正则表达式计算器实例</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># test_expression = '12+33*(11.5+22.5)*44/2+59-(2*3)+(8*5-(10/2))'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">qukuohao</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    将表达式中所有括号中的内容计算成数值,去掉表达式中所有的括号</span></span><br><span class="line"><span class="string">    :param s: 计算表达式[str]</span></span><br><span class="line"><span class="string">    :return: 没有括号的计算表达式[str]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'('</span> <span class="keyword">in</span> s:</span><br><span class="line">            r = re.split(<span class="string">r'\(([^()]*)\)'</span>, s, <span class="number">1</span>)</span><br><span class="line">            <span class="comment"># ret = eval(r[1])</span></span><br><span class="line">            ret = cal(r[<span class="number">1</span>])</span><br><span class="line">            s = r[<span class="number">0</span>] + str(ret) + r[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuhao</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理符号的问题</span></span><br><span class="line"><span class="string">    :param s: 计算表达式</span></span><br><span class="line"><span class="string">    :return: 计算表达式</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ss = s.replace(<span class="string">'+-'</span>, <span class="string">'-'</span>)</span><br><span class="line">    sss = ss.replace(<span class="string">'--'</span>, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">return</span> sss</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chengshufajisuan</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    专门用来计算不带括号的计算表达式中的乘除法</span></span><br><span class="line"><span class="string">    :param s: 不带括号的计算表达式</span></span><br><span class="line"><span class="string">    :return: 只有加减法的计算表达式(如果不再有加减法,直接返回计算结果)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'*'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'/'</span> <span class="keyword">in</span> s:</span><br><span class="line">            r = re.split(<span class="string">r'(\d+\.?\d*[*|/]-?\d+\.?\d*)'</span>, s, <span class="number">1</span>)</span><br><span class="line">            ss = eval(r[<span class="number">1</span>])</span><br><span class="line">            s = r[<span class="number">0</span>] + str(ss) + r[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jiajianfajisuan</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    专门用来计算不带括号的计算表示式中的加减法</span></span><br><span class="line"><span class="string">    :param s: 不带括号且只有加减法的表达式</span></span><br><span class="line"><span class="string">    :return: 最终的计算结果</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    s = fuhao(s)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    	<span class="comment"># 5-9的情况；-5-9的情况都需要额外考虑</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">or</span> s.count(<span class="string">'-'</span>) &gt; <span class="number">1</span> <span class="keyword">or</span> (s.count(<span class="string">'-'</span>) == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> s.startswith(<span class="string">'-'</span>)):</span><br><span class="line">            r = re.split(<span class="string">r'(-?\d+\.?\d*[+|-]\d+\.?\d*)'</span>, s, <span class="number">1</span>)</span><br><span class="line">            ss = eval(r[<span class="number">1</span>])</span><br><span class="line">            s = r[<span class="number">0</span>]+str(ss)+r[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    + - * / 混合运算</span></span><br><span class="line"><span class="string">    :param s:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">'*'</span> <span class="keyword">in</span> s <span class="keyword">or</span> <span class="string">'/'</span> <span class="keyword">in</span> s:</span><br><span class="line">        s = chengshufajisuan(s)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">or</span> s.count(<span class="string">'-'</span>) &gt; <span class="number">1</span>:</span><br><span class="line">            s = jiajianfajisuan(s)</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">elif</span> <span class="string">'+'</span> <span class="keyword">in</span> s <span class="keyword">or</span> s.count(<span class="string">'-'</span>) &gt; <span class="number">1</span> <span class="keyword">or</span> (s.count(<span class="string">'-'</span>) == <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">not</span> s.startswith(<span class="string">'-'</span>)):</span><br><span class="line">        s = jiajianfajisuan(s)</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(cal(qukuohao(test_expression)))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            e = input(<span class="string">'输入计算表达式&gt; '</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'('</span> <span class="keyword">in</span> e:</span><br><span class="line">                print(cal(qukuohao(e)))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(cal(e))</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        print(<span class="string">'Bye'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>参考文档：</p>
<ul>
<li><a href="http://wiki.ubuntu.org.cn/Python正则表达式操作指南" target="_blank" rel="noopener">http://wiki.ubuntu.org.cn/Python正则表达式操作指南</a></li>
<li><a href="http://www.cnblogs.com/wupeiqi/articles/5501365.html" target="_blank" rel="noopener">http://www.cnblogs.com/wupeiqi/articles/5501365.html</a></li>
</ul>
<p>在线正则匹配工具：</p>
<ul>
<li><a href="http://tool.chinaz.com/regex?jdfwkey=6iptw" target="_blank" rel="noopener">http://tool.chinaz.com/regex?jdfwkey=6iptw</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>Python反射详解</title>
    <url>/2016/06/16/Python%E5%8F%8D%E5%B0%84%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>反射，可以理解为利用字符串的形式去对象中操作成员属性和方法</p>
<p>反射的这点特性让我联想到了<code>exec</code>函数，也是把利用字符串的形式去让Python解释器去执行命令</p>
<p>Python Version: 3.5+</p>
</blockquote>
<p>解释Python的反射，先提一个简单的需求，现在我有一个简易的网站，由两个文件组成，一个是具体执行操作的<code>commons.py</code>文件，一个是入口文件<code>index.py</code>，现在我需要在入口文件中设置，让用户输入url，根据用户输入的url去后端执行相应的操作，内容如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># commons.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'登录页面!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'退出页面!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'主页面'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># index.py</span></span><br><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"></span><br><span class="line">inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> inp == <span class="string">'login'</span>:</span><br><span class="line">    commons.login()</span><br><span class="line"><span class="keyword">elif</span> inp == <span class="string">'logout'</span>:</span><br><span class="line">    commons.logout()</span><br><span class="line"><span class="keyword">elif</span> inp == <span class="string">'index'</span>:</span><br><span class="line">    commons.index()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">url &gt; login</span><br><span class="line">登录页面!</span><br></pre></td></tr></table></figure>

<p>上面我使用了if判断，根据每一个url请求去后端执行指定的函数。那现在我的网站内容变多了，在<code>commons.py</code>中有100个页面操作，那么相对应的我在<code>index.py</code>中也要使用if else 对这100个页面函数进行手动指定。</p>
<p>有了Python🐍反射的特性，这个需求就变得异常简单了，先不多解释，先看代码(commons.py保持文件不变，还是拿三个页面的操作举例🌰)：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># index.py</span></span><br><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> hasattr(commons, inp):</span><br><span class="line">        func = getattr(commons, inp)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">url &gt; logout</span><br><span class="line">退出页面!</span><br></pre></td></tr></table></figure>

<p>Look! Python的反射立了大功，使用这几行代码，可以应对<code>commons.py</code>文件中任意多个页面函数的调用！接下来我们来详细介绍Python反射中用到的内建函数</p>
<h1 id="getattr"><a href="#getattr" class="headerlink" title="getattr()"></a>getattr()</h1><p>先看下源码中的解释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getattr</span><span class="params">(object, name, default=None)</span>:</span> <span class="comment"># known special case of getattr</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    getattr(object, name[, default]) -&gt; value</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.</span></span><br><span class="line"><span class="string">    When a default argument is given, it is returned when the attribute doesn't</span></span><br><span class="line"><span class="string">    exist; without it, an exception is raised in that case.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>getattr()</code>函数执行成功后会将参数中对象中的方法赋值给新的变量（会返回参数中指定的对象中的方法）相当于参数中的方法又多了一个栈区的变量去引用</p>
<p><code>getattr()</code>函数的第一个参数需要是个对象，上面的例子中，我导入了自定义的commons模块，commons就是个对象；第二个参数是指定前面对象中的一个方法名称。<code>getattr(x, &#39;y&#39;)</code> 等价于执行了 <code>x.y</code>。假如第二个参数输入了前面对象中不存在的方法，该函数会抛出异常并退出。所以这个时候，为了程序的健壮性，我们需要先判断一下该对象中有没有这个方法，于是<code>hasattr()</code>函数登场了~~</p>
<h1 id="hasattr"><a href="#hasattr" class="headerlink" title="hasattr()"></a>hasattr()</h1><p>还是先看下源码的解释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasattr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether the object has an attribute with the given name.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    This is done by calling getattr(obj, name) and catching AttributeError.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>hasattr()</code>函数返回对象是否拥有指定名称的属性，简单的说就是检查在第一个参数的对象中，能否找到与第二参数名相同的方法。源码的解释还说，该函数的实现其实就是调用了<code>getattr()</code>函数，只不过它捕获了异常而已。所以通过这个函数，我们可以先去判断对象中有没有这个方法，有则使用<code>getattr()</code>来获取该方法。</p>
<h1 id="delattr"><a href="#delattr" class="headerlink" title="delattr()"></a>delattr()</h1><p>删除指定对象中的指定方法，特别提示：只是在本次运行程序的内存中将该方法删除，并没有影响到文件的内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"></span><br><span class="line">print(dir(commons))</span><br><span class="line">delattr(commons, <span class="string">'index'</span>)</span><br><span class="line">print(dir(commons))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'index'</span>, <span class="string">'login'</span>, <span class="string">'logout'</span>]</span><br><span class="line">[<span class="string">'__builtins__'</span>, <span class="string">'__cached__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>, <span class="string">'login'</span>, <span class="string">'logout'</span>]</span><br></pre></td></tr></table></figure>

<h1 id="setattr"><a href="#setattr" class="headerlink" title="setattr()"></a>setattr()</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setattr</span><span class="params">(x, y, v)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Sets the named attribute on the given object to the specified value.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    setattr(x, 'y', v) is equivalent to ``x.y = v''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>setattr()</code>函数用来给指定对象中的方法重新赋值（将新的函数体/方法体赋值给指定的对象名）仅在本次程序运行的内存中生效。<code>setattr(x, &#39;y&#39;, v)</code> 等价于 <code>x.y = v</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> commons</span><br><span class="line"></span><br><span class="line">commons.index()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newindex</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'new 主页面!'</span>)</span><br><span class="line"></span><br><span class="line">setattr(commons, <span class="string">'index'</span>, newindex)</span><br><span class="line"></span><br><span class="line">commons.index()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">主页面</span><br><span class="line">new 主页面!</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="import"><a href="#import" class="headerlink" title="__import__"></a>__import__</h1><p>好的，网站发展至今，功能有了很多的扩展，现在一个后台文件已经不能满足我的需求，这个时候需要根据职能划分后台文件，现在我又新增了一个<code>account.py</code>这个用户管理类的文件，也需要导入到首页以备调用。</p>
<p>这个时候，我的首页通过反射，只能指定<code>commons</code>模块的方法任意调用，现在新增了<code>account</code>模块，是不是我又要加入if去判断啦？不用！Python已经帮我们想到这一点了！最后搬出<code>__import__</code>这个大救星。</p>
<p>由于模块的导入也需要使用Python反射的特性，所以模块名也要加入到url中，所以现在url请求变成了类似于<code>commons/index</code>的形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># account.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_user</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'添加用户'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">del_user</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'删除用户'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># commons.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'登录页面!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logout</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'退出页面!'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'主页面'</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># index.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">    obj_module = __import__(m)</span><br><span class="line">    <span class="keyword">if</span> hasattr(obj_module, f):</span><br><span class="line">        func = getattr(obj_module, f)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="comment"># python3 index.py</span></span><br><span class="line">url &gt; account/add_user</span><br><span class="line">添加用户</span><br><span class="line"></span><br><span class="line"><span class="comment"># python3 index.py</span></span><br><span class="line">url &gt; commons/login</span><br><span class="line">登录页面!</span><br></pre></td></tr></table></figure>

<p>能体会到<code>__import__</code>的作用了吗，就是把字符串当做模块去导入。<code>import &#39;sys&#39;</code> 和 <code>import sys</code> 是不一样的，不信你执行一下~~要想导入字符串<code>&#39;sys&#39;</code>只能通过<code>__import__(&#39;sys&#39;)</code>的方式导入</p>
<p>等等，还没完，我的网站进一步细化分工，现在又多了一层目录结构，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|- index.py</span><br><span class="line">|- commons.py</span><br><span class="line">|- account.py</span><br><span class="line">|- lib</span><br><span class="line">	|- __init__.py</span><br><span class="line">	|- connectdb.py</span><br></pre></td></tr></table></figure>

<p>现在我想在<code>index</code>页面中调用<code>lib</code>包下<code>connectdb</code>模块中的方法，还是用之前的方式调用可以吗？我们试一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">    obj_module = __import__(<span class="string">'lib.'</span> + m)</span><br><span class="line">    <span class="keyword">if</span> hasattr(obj_module, f):</span><br><span class="line">        func = getattr(obj_module, f)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line"><span class="number">404</span></span><br></pre></td></tr></table></figure>

<p>哎呦，不行啊。上面我为了测试调用lib下的模块，抛弃了对所有同级目录模块的支持，可还是不行，居然找不到这个这个模块的这个方法。还是来看下源码是怎么说的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__import__</span><span class="params">(name, globals=None, locals=None, fromlist=<span class="params">()</span>, level=<span class="number">0</span>)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    __import__(name, globals=None, locals=None, fromlist=(), level=0) -&gt; module</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Import a module. Because this function is meant for use by the Python</span></span><br><span class="line"><span class="string">    interpreter and not for general use it is better to use</span></span><br><span class="line"><span class="string">    importlib.import_module() to programmatically import a module.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    The globals argument is only used to determine the context;</span></span><br><span class="line"><span class="string">    they are not modified.  The locals argument is unused.  The fromlist</span></span><br><span class="line"><span class="string">    should be a list of names to emulate ``from name import ...'', or an</span></span><br><span class="line"><span class="string">    empty list to emulate ``import name''.</span></span><br><span class="line"><span class="string">    When importing a module from a package, note that __import__('A.B', ...)</span></span><br><span class="line"><span class="string">    returns package A when fromlist is empty, but its submodule B when</span></span><br><span class="line"><span class="string">    fromlist is not empty.  Level is used to determine whether to perform </span></span><br><span class="line"><span class="string">    absolute or relative imports. 0 is absolute while a positive number</span></span><br><span class="line"><span class="string">    is the number of parent directories to search relative to the current module.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>__import__</code>函数中有一个<code>fromlist</code>参数，源码解释说，如果在一个包中导入一个模块，这个参数如果为空，则return这个包对象，如果这个参数不为空，则返回包下面指定的模块对象，于是做出如下修改</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">    obj_module = __import__(<span class="string">'lib.'</span> + m, fromlist=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">if</span> hasattr(obj_module, f):</span><br><span class="line">        func = getattr(obj_module, f)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">url &gt; connectdb/mysql</span><br><span class="line">已连接mysql</span><br></pre></td></tr></table></figure>

<p>成功了~~ 但是为了这次成功，我写死了lib前缀，相当于抛弃了commons和account两个导入的功能，所以以上代码并不完善，需求复杂后，还是需要对请求的url做一下判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    <span class="keyword">if</span> len(inp.split(<span class="string">'/'</span>)) == <span class="number">2</span>:</span><br><span class="line">        m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">        obj_module = __import__(m)</span><br><span class="line">        <span class="keyword">if</span> hasattr(obj_module, f):</span><br><span class="line">            func = getattr(obj_module, f)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'404'</span>)</span><br><span class="line">    <span class="keyword">elif</span> len(inp.split(<span class="string">'/'</span>)) == <span class="number">3</span>:</span><br><span class="line">        p, m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">        obj_module = __import__(p + <span class="string">'.'</span> + m, fromlist=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">if</span> hasattr(obj_module, f):</span><br><span class="line">            func = getattr(obj_module, f)</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行</span></span><br><span class="line"><span class="comment"># python3 index.py</span></span><br><span class="line">url &gt; lib/connectdb/mysql</span><br><span class="line">已连接mysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># python3 index.py</span></span><br><span class="line">url &gt; account/del_user</span><br><span class="line">删除用户</span><br></pre></td></tr></table></figure>

<p>虽然重复代码量不高，但我们仍要有一颗消除重复代码的❤️</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(inp.split(<span class="string">'/'</span>)) == <span class="number">2</span>:</span><br><span class="line">        m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">        obj_module = __import__(m)</span><br><span class="line">        getf(obj_module, f)</span><br><span class="line">    <span class="keyword">elif</span> len(inp.split(<span class="string">'/'</span>)) == <span class="number">3</span>:</span><br><span class="line">        p, m, f = inp.split(<span class="string">'/'</span>)</span><br><span class="line">        obj_module = __import__(p + <span class="string">'.'</span> + m, fromlist=<span class="literal">True</span>)</span><br><span class="line">        getf(obj_module, f)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getf</span><span class="params">(m, f)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> hasattr(m, f):</span><br><span class="line">        func = getattr(m, f)</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'404'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    inp = input(<span class="string">'url &gt; '</span>)</span><br><span class="line">    run()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Python加密模块</title>
    <url>/2016/06/15/Python%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97hashlibx/</url>
    <content><![CDATA[<blockquote>
<p>Python中的hashlib和hmac加密模块都是内置模块，可以方便的进行字符串加密，这些加密都是单向的，加密后的字符串不可反解成原字符串。但是由于某个固定的字符串使用某个固定的算法得出的加密串是固定的，所以有通过撞库来反解出密码的危险</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="hashlib模块"><a href="#hashlib模块" class="headerlink" title="hashlib模块"></a>hashlib模块</h1><h2 id="md5"><a href="#md5" class="headerlink" title="md5"></a>md5</h2><p>hashlib模块用于加密相关的操作，代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5</span></span><br><span class="line"><span class="comment"># 创建md5对象</span></span><br><span class="line">hash = hashlib.md5()</span><br><span class="line"><span class="comment"># update方法接收一个字节类型的数据是Python3+中的强制要求</span></span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"><span class="comment"># 返回一个十六进制的字符串</span></span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"><span class="comment"># 返回一个二进制的字符串</span></span><br><span class="line">print(hash.digest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">72</span>c5c8f4fcfeb39c1ebce3be56ebb9f8</span><br><span class="line"><span class="string">b'r\xc5\xc8\xf4\xfc\xfe\xb3\x9c\x1e\xbc\xe3\xbeV\xeb\xb9\xf8'</span></span><br></pre></td></tr></table></figure>

<h2 id="sha1"><a href="#sha1" class="headerlink" title="sha1"></a>sha1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha1</span></span><br><span class="line"><span class="comment"># 创建sha1对象</span></span><br><span class="line">hash = hashlib.sha1()</span><br><span class="line"><span class="comment"># 按照指定的字符编码加密字符串</span></span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">299</span>a06d4672c5a57facee0cf132593132084a3c0</span><br></pre></td></tr></table></figure>

<h2 id="sha256"><a href="#sha256" class="headerlink" title="sha256"></a>sha256</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha256</span></span><br><span class="line">hash = hashlib.sha256()</span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">f379eefa6d3a0447d807d679dbd02f0593e8b3c3377da53dd909d98b4dcac9ad</span><br></pre></td></tr></table></figure>

<h2 id="sha384"><a href="#sha384" class="headerlink" title="sha384"></a>sha384</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha384</span></span><br><span class="line">hash = hashlib.sha384()</span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">768e16</span>e89a691905e7e2413fc67ba2846a39a3d2dd064a7930eb54c36e58a2694b5bf57ca7bb52cea0ad33feaf718ad6</span><br></pre></td></tr></table></figure>

<h2 id="sha512"><a href="#sha512" class="headerlink" title="sha512"></a>sha512</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># sha512</span></span><br><span class="line">hash = hashlib.sha512()</span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">print(hash.hexdigest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">ef510ae0c752261359b87e8260b1a8d90a1d9bc373fd5a107e091e9340d60877909b1e7996c32ecb5a571378815aa524e284a65d7d91d33b8fe29f1376ff048e</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自定义key加密"><a href="#自定义key加密" class="headerlink" title="自定义key加密"></a>自定义key加密</h2><p>上面的加密算法虽然已经足够强大，但是还是存在缺陷，即可以通过撞库反解密码。所以，有必要对加密算法中添加自定义key再来做加密。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment"># md5</span></span><br><span class="line">hash = hashlib.md5(bytes(<span class="string">'9ol4rfv'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line">hash.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">'utf8'</span>))</span><br><span class="line"><span class="comment"># 返回一个十六进制的字符串</span></span><br><span class="line">print(hash.hexdigest()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">6e4257</span>d3855aaf563ce5c8d499156137</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="hmac模块"><a href="#hmac模块" class="headerlink" title="hmac模块"></a>hmac模块</h1><p>hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hmac</span><br><span class="line"></span><br><span class="line">h = hmac.new(bytes(<span class="string">'9ol4rfv'</span>, encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">h.update(bytes(<span class="string">'polarsnow'</span>, encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">print(h.hexdigest())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">2</span>d7acf84247e563213d0ec8e325831ba</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>hashlib</tag>
        <tag>hmac</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系统模块</title>
    <url>/2016/06/15/Python%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>Python下有两个系统模块<code>sys</code> <code>os</code>，<code>sys</code>模块用于提供对Python解释器相关的操作；<code>os</code>模块用于提供系统级别的操作</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h1><p>sys模块中常用的函数</p>
<ul>
<li>sys.argv           命令行参数List，第一个元素是程序本身路径</li>
<li>sys.exit(n)        退出程序，正常退出时exit(0)</li>
<li>sys.version        获取Python解释程序的版本信息</li>
<li>sys.maxint         最大的Int值</li>
<li>sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</li>
<li>sys.platform       返回操作系统平台名称</li>
<li>sys.stdin          输入相关</li>
<li>sys.stdout         输出相关</li>
<li>sys.stderror       错误相关</li>
</ul>
<h1 id="os"><a href="#os" class="headerlink" title="os"></a>os</h1><ul>
<li>os.getcwd()                 获取当前工作目录，即当前python脚本工作的目录路径</li>
<li>os.chdir(“dirname”)         改变当前脚本工作目录；相当于shell下cd</li>
<li>os.curdir                   返回当前目录: (‘.’)</li>
<li>os.pardir                   获取当前目录的父目录字符串名：(‘..’)</li>
<li>os.makedirs(‘dir1/dir2’)    可生成多层递归目录</li>
<li>os.removedirs(‘dirname1’)   若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推</li>
<li>os.mkdir(‘dirname’)         生成单级目录；相当于shell中mkdir dirname</li>
<li>os.rmdir(‘dirname’)         删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname</li>
<li>os.listdir(‘dirname’)       列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印</li>
<li>os.remove()                 删除一个文件</li>
<li>os.rename(“oldname”,”new”)  重命名文件/目录</li>
<li>os.stat(‘path/filename’)    获取文件/目录信息</li>
<li>os.sep                      操作系统特定的路径分隔符，win下为”\“,Linux下为”/“</li>
<li>os.linesep                  当前平台使用的行终止符，win下为”\t\n”,Linux下为”\n”</li>
<li>os.pathsep                  用于分割文件路径的字符串</li>
<li>os.name                     字符串指示当前使用平台。win-&gt;’nt’; Linux-&gt;’posix’</li>
<li>os.system(“bash command”)   运行shell命令，直接显示</li>
<li>os.environ                  获取系统环境变量</li>
<li>os.path.abspath(path)       返回path规范化的绝对路径</li>
<li>os.path.split(path)         将path分割成目录和文件名二元组返回</li>
<li>os.path.dirname(path)       返回path的目录。其实就是os.path.split(path)的第一个元素</li>
<li>os.path.basename(path)      返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素</li>
<li>os.path.exists(path)        如果path存在，返回True；如果path不存在，返回False</li>
<li>os.path.isabs(path)         如果path是绝对路径，返回True</li>
<li>os.path.isfile(path)        如果path是一个存在的文件，返回True。否则返回False</li>
<li>os.path.isdir(path)         如果path是一个存在的目录，则返回True。否则返回False</li>
<li>os.path.join(path1[, path2[, …]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略</li>
<li>os.path.getatime(path)      返回path所指向的文件或者目录的最后存取时间</li>
<li>os.path.getmtime(path)      返回path所指向的文件或者目录的最后修改时间</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>模块</tag>
        <tag>os</tag>
        <tag>sys</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现终端下的进度条</title>
    <url>/2016/06/15/Python%E5%AE%9E%E7%8E%B0%E7%BB%88%E7%AB%AF%E4%B8%8B%E7%9A%84%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍在Python下实现进度条的几种方法</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="第一种：简单的字符拼接"><a href="#第一种：简单的字符拼接" class="headerlink" title="第一种：简单的字符拼接"></a>第一种：简单的字符拼接</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取终端的宽度</span></span><br><span class="line">w = os.get_terminal_size().columns</span><br><span class="line"><span class="comment"># -5个字符是为了为后面'&gt;100%'留地方</span></span><br><span class="line"><span class="comment"># 所以'-'所占用的最大宽度为总终端宽度-5</span></span><br><span class="line"><span class="comment"># 然后计算出每增长1%需要增长几个'-'字符</span></span><br><span class="line">item = (w - <span class="number">5</span>) / <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">view_bar</span><span class="params">(num, total)</span>:</span></span><br><span class="line">	<span class="comment"># 计算出进度百分比</span></span><br><span class="line">    rate = num / total</span><br><span class="line">    rate_num = int(rate * <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># int(rate_num*item) 根据当前进度计算出需要多少个'-'字符（取整数）字符串中的\r是必须存在的</span></span><br><span class="line">    r1 = <span class="string">'\r%s&gt;%d%%'</span> %(<span class="string">"-"</span> * int(rate_num*item), rate_num)</span><br><span class="line">    <span class="comment"># 在终端中输出（不换行）</span></span><br><span class="line">    sys.stdout.write(r1)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    view_bar(i, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>这里特别说明下，上面的代码中，获取终端宽度的方法<code>os.get_terminal_size().columns</code>是Python3+版本中的新功能，如果是2+的Python，可以通过以下方式获取终端宽度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> curses</span><br><span class="line">screen = curses.initscr()</span><br><span class="line">height, width = screen.getmaxyx()</span><br></pre></td></tr></table></figure>

<h1 id="第二种：使用第三方模块"><a href="#第二种：使用第三方模块" class="headerlink" title="第二种：使用第三方模块"></a>第二种：使用第三方模块</h1><p>感受下<del>~ 是不是瞬间不想重复造轮子了</del></p>
<h2 id="progressive"><a href="#progressive" class="headerlink" title="progressive"></a>progressive</h2><p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/20160615171759.gif" alt=""></p>
<h2 id="progressbar"><a href="#progressbar" class="headerlink" title="progressbar"></a>progressbar</h2><p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/20160615173459.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>进度条</tag>
      </tags>
  </entry>
  <entry>
    <title>Python导入模块</title>
    <url>/2016/06/15/Python%E5%AF%BC%E5%85%A5%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>模块，即某个功能代码的集合</p>
</blockquote>
<h1 id="导入模块的基本方法"><a href="#导入模块的基本方法" class="headerlink" title="导入模块的基本方法"></a>导入模块的基本方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module</span><br><span class="line"><span class="keyword">from</span> module.xx.xx <span class="keyword">import</span> xx</span><br><span class="line"><span class="keyword">from</span> module.xx.xx <span class="keyword">import</span> xx <span class="keyword">as</span> rename </span><br><span class="line"><span class="keyword">from</span> module.xx.xx <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure>

<p>导入模块其实就是告诉Python解释器去解释那个py文件</p>
<ul>
<li>导入一个py文件，解释器解释该py文件</li>
<li>导入一个包，解释器解释该包下的 <code>__init__.py</code> 文件</li>
</ul>
<h1 id="导入模块的路径"><a href="#导入模块的路径" class="headerlink" title="导入模块的路径"></a>导入模块的路径</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br><span class="line">[<span class="string">''</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python35.zip'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/plat-darwin'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/lib-dynload'</span>, <span class="string">'/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages'</span>]</span><br></pre></td></tr></table></figure>

<h1 id="导入指定路径的模块"><a href="#导入指定路径的模块" class="headerlink" title="导入指定路径的模块"></a>导入指定路径的模块</h1><p>加入需要导入sys.path中不存在的路径下的模块，此时可以手动添加指定路径到sys.path中（仅当次生效）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加上上级目录到path中</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">project_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(project_path)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>__file__</code> 获取以当前路径为基准的文件相对路径</li>
<li><code>os.path.abspath(__file__)</code> 获取当前文件的绝对路径</li>
<li><code>os.path.dirname(os.path.abspath(__file__))</code> 获取当前文件所在文件夹的绝对路径（上级目录）</li>
<li><code>os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</code> 获取当前文件的上上级目录</li>
</ul>
<h1 id="模块中的特殊变量"><a href="#模块中的特殊变量" class="headerlink" title="模块中的特殊变量"></a>模块中的特殊变量</h1><ul>
<li><p>__doc__ 获取模块实现功能的简单描述</p>
</li>
<li><p>__file__ 获取以当前路径为基准的文件相对路径</p>
</li>
<li><p>__package__ 获取该文件的上层包名</p>
</li>
<li><p>__cached__ 实际被导入的缓存文件绝对路径</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> maopao</span><br><span class="line"></span><br><span class="line">print(maopao.__cached__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">/Users/lvrui/PycharmProjects/untitled/<span class="number">6</span>/c/__pycache__/maopao.cpython<span class="number">-35.</span>pyc</span><br></pre></td></tr></table></figure>

<ul>
<li>__name__ 获取模块/文件的调用者</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># maopao.py</span></span><br><span class="line">print(__name__)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line"><span class="keyword">import</span> maopao</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">maopao</span><br><span class="line">__main__</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>import</tag>
      </tags>
  </entry>
  <entry>
    <title>Python冒泡 选择 插入排序算法详解</title>
    <url>/2016/06/13/Python%E5%86%92%E6%B3%A1-%E9%80%89%E6%8B%A9-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的原理是两个元素相邻的元素进行比较，小的数放在前面，大的数放在后面。</p>
<p>第一次排序：首先比较第1个数字和第2个数字，小数放前，大数放后；然后比较第2个数和第3个数，小数放前，大数放后……以此类推，找到倒数第二个数字和最后一个数字进行比较，首次排序会将队列中最大的数字放在最后一位</p>
<p>第二次排序：还是从第1位开始和第2位比较，小数放前，大数放后……一直比到倒数第二个数（因为倒数第一个数在第一次排序中已经确定是最大值了）</p>
<p>以此类推，重复以上过程，直到最终排序完毕。</p>
<p>由于排序过程中，永远是小数往前放，大数往后放，类似于气泡上升，所以被称之为冒泡排序，接下来通过Python代码来演示冒泡排序的过程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先来直观感受一下冒泡排序的代码</span></span><br><span class="line">l = [<span class="number">34</span>, <span class="number">16</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[i+<span class="number">1</span>]:</span><br><span class="line">            l[i], l[i+<span class="number">1</span>] = l[i+<span class="number">1</span>], l[i]</span><br><span class="line">            </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<p>接下来我们来一步一步实现上面的代码</p>
<h2 id="首次循环"><a href="#首次循环" class="headerlink" title="首次循环"></a>首次循环</h2><p>需要相邻两个数进行比较，小值放前，大值放后。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先需要确定循环多少次</span></span><br><span class="line"><span class="comment"># 循环到每个元素需要 len(l) 次, 对应遍历的索引下标是 range(len(l))</span></span><br><span class="line"><span class="comment"># 由于是两两比较，最后一次比较，取得的是倒数第二个 len(l) - 2 这个元素，去和最后一个元素 len(l) - 1 进行比较</span></span><br><span class="line"><span class="comment"># 所以实际需要遍历的次数比这个列表的总长度要少1</span></span><br><span class="line"><span class="comment"># 而range有从0开始且左闭右开的特性，所以在range中只需-1，至此可以确定需要遍历下表的索引就是 range(len(l) - 1)</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>):</span><br><span class="line">	<span class="comment"># 里面的判断很简单，根据冒泡算法的核心原理</span></span><br><span class="line">	<span class="comment"># 判断当前元素和下一个元素的大小，小放前，大放后</span></span><br><span class="line">    <span class="keyword">if</span> l[i] &gt; l[i + <span class="number">1</span>]:</span><br><span class="line">    	<span class="comment"># 如果当前元素大于下一个元素，则交换两个值得位置</span></span><br><span class="line">        l[i], l[i + <span class="number">1</span>] = l[i + <span class="number">1</span>], l[i]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至此，完成了冒泡排序的第一次循环</span></span><br><span class="line"><span class="comment"># l列表中有7个元素，则len(l) == 7</span></span><br><span class="line"><span class="comment"># 实际只需遍历6个元素即可 len(l) - 1 == 6</span></span><br><span class="line"><span class="comment"># 根据得到的需要遍历的总元素个数，去生成一串索引遍历数组</span></span><br><span class="line"><span class="comment"># range(6) --&gt; 0 1 2 3 4 5 从0开始且左闭右开</span></span><br><span class="line"><span class="comment"># 这样就取到了需要遍历元素的索引</span></span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 再来看个详细输出每次交换信息的版本</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>): </span><br><span class="line">    print(<span class="string">'比较:'</span>, l[i], l[i+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> l[i] &gt; l[i + <span class="number">1</span>]: </span><br><span class="line">        l[i], l[i + <span class="number">1</span>] = l[i + <span class="number">1</span>], l[i]</span><br><span class="line">        print(<span class="string">'交换后的数组:'</span>, l)</span><br><span class="line">        </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">比较: <span class="number">34</span> <span class="number">16</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">78</span></span><br><span class="line">比较: <span class="number">78</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">37</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">56</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br><span class="line">[<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<h1 id="依次循环"><a href="#依次循环" class="headerlink" title="依次循环"></a>依次循环</h1><p>首次循环之后，已经选出了列表中的最大值并放到了最后一位，接下来要做的是再次循环，选择第二大的数字放在倒数第二位</p>
<p>而上面已经实现了首次循环，现在我需要在这次基本循环外，再套上一层循环，由外层循环控制内层的循环总共循环6次。这个表达式很好写<code>range(len(l) - 1)</code> 就能得到6次循环，得到的结果是<code>0 1 2 3 4 5</code>, so, 我可以对代码做出如下修改即可完成冒泡排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - <span class="number">1</span>): </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>): </span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[i + <span class="number">1</span>]: </span><br><span class="line">            l[i], l[i + <span class="number">1</span>] = l[i + <span class="number">1</span>], l[i]</span><br><span class="line">            </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 来感受下带详细输出的版本</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - <span class="number">1</span>): </span><br><span class="line">    print(<span class="string">'---第'</span>, j, <span class="string">'次循环---'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>): </span><br><span class="line">        print(<span class="string">'比较:'</span>, l[i], l[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[i + <span class="number">1</span>]: </span><br><span class="line">            l[i], l[i + <span class="number">1</span>] = l[i + <span class="number">1</span>], l[i]</span><br><span class="line">            print(<span class="string">'交换后的数组:'</span>, l)</span><br><span class="line">            </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">---第 <span class="number">0</span> 次循环---</span><br><span class="line">比较: <span class="number">34</span> <span class="number">16</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">78</span></span><br><span class="line">比较: <span class="number">78</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">37</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">56</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">1</span> 次循环---</span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">56</span> <span class="number">78</span></span><br><span class="line">---第 <span class="number">2</span> 次循环---</span><br><span class="line">比较: <span class="number">16</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">78</span></span><br><span class="line">---第 <span class="number">3</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">16</span></span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">78</span></span><br><span class="line">---第 <span class="number">4</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">16</span></span><br><span class="line">比较: <span class="number">16</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">78</span></span><br><span class="line">---第 <span class="number">5</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">5</span></span><br><span class="line">比较: <span class="number">5</span> <span class="number">16</span></span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">78</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<p>上面已经实现了对一个数组进行冒泡排序，但是还有一个缺陷，就是每次内部循环都换循环6次，而通过冒泡算法的核心原理我们已经得知，在每次循环中都会选出最大的数字依次从后往前放置，那么，也就是说，内侧循环的循环规律只要满足分别range<code>6 5 4 3 2 1</code>即可拿到最终的排序结果，请接着往下看</p>
<h2 id="优化调整"><a href="#优化调整" class="headerlink" title="优化调整"></a>优化调整</h2><p>前面的分析得出，首次遍历不需要遍历到最后一位，因为是前一位和后一位去比，所以只需遍历到<code>倒数第二位</code>，与<code>倒数第二位+1</code>的元素进行比较就行啦</p>
<p>当首次循环结束后，最后一位已经确定是最大，不需要遍历，根据前面的规律，首次排序后的数组倒数第二位也不需要遍历，因为会有倒数第三位主动与之比较，所以拿上面的数组举例🌰，得到的规律是，数组长度为7，内层循环第一次需要循环6次，第二次需要循环5次，第三次需要循环4次，第四次需要循环3次，第五次需要循环2次，第六次需要循环1次，退出。</p>
<p>我们再来找一下规律（拿首次循环的情况举例🌰）：</p>
<ul>
<li><p>内层循环需要的<code>range</code>参数是<code>6</code>, 由<code>len(l) - 1</code>得出<code>0 1 2 3 4 5</code></p>
</li>
<li><p>外层循环需要的<code>range</code>参数也是<code>6</code>，也由<code>len(l) - 1</code>得出<code>0 1 2 3 4 5</code></p>
</li>
</ul>
<p>内层循环需要6，但是外层循环<code>range(6)</code>之后得到的队列是<code>0 1 2 3 4 5</code>,我们只需让range从大往小取值即可<code>range(6, 0, -1)</code>取到得值即为<code>6 5 4 3 2 1</code>,正好可以拿到内层循环用，于是，可以做出如下修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一次循环</span><br><span class="line">外层 for j in 6 5 4 3 2 1</span><br><span class="line">	内层 range(6) ---&gt; 0 1 2 3 4 5</span><br><span class="line">第二次循环</span><br><span class="line">外层 for j in 5 4 3 2 1</span><br><span class="line">	内层 range(5) ---&gt; 0 1 2 3 4</span><br><span class="line">第三次循环</span><br><span class="line">外层 for j in 4 3 2 1</span><br><span class="line">	内存 range(4) ---&gt; 0 1 2 3</span><br><span class="line">...</span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最终代码实现</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[i+<span class="number">1</span>]:</span><br><span class="line">            l[i], l[i+<span class="number">1</span>] = l[i+<span class="number">1</span>], l[i]</span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 详细输出版</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(len(l) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    print(<span class="string">'---第'</span>, j, <span class="string">'次循环---'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(j):</span><br><span class="line">        print(<span class="string">'比较:'</span>, l[i], l[i+<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[i+<span class="number">1</span>]:</span><br><span class="line">            l[i], l[i+<span class="number">1</span>] = l[i+<span class="number">1</span>], l[i]</span><br><span class="line">            print(<span class="string">'交换后的数组:'</span>, l)</span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">---第 <span class="number">6</span> 次循环---</span><br><span class="line">比较: <span class="number">34</span> <span class="number">16</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">78</span></span><br><span class="line">比较: <span class="number">78</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">78</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">37</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">78</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">56</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>, <span class="number">5</span>]</span><br><span class="line">比较: <span class="number">78</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">34</span>, <span class="number">2</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">5</span> 次循环---</span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">5</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">56</span></span><br><span class="line">比较: <span class="number">56</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">16</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">4</span> 次循环---</span><br><span class="line">比较: <span class="number">16</span> <span class="number">2</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">5</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">37</span></span><br><span class="line">比较: <span class="number">37</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">3</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">16</span></span><br><span class="line">比较: <span class="number">16</span> <span class="number">34</span></span><br><span class="line">比较: <span class="number">34</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">2</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">16</span></span><br><span class="line">比较: <span class="number">16</span> <span class="number">5</span></span><br><span class="line">交换后的数组: [<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br><span class="line">---第 <span class="number">1</span> 次循环---</span><br><span class="line">比较: <span class="number">2</span> <span class="number">5</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<p>打完收工~~</p>
<h2 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h2><ul>
<li>稳定 </li>
<li>空间复杂度<code>O(1)</code> </li>
<li>时间复杂度<code>O(n2)</code> </li>
<li>最差情况：反序，需要交换<code>n*(n-1)/2</code>个元素 </li>
<li>最好情况：正序，不需要交换元素<code>O(n)</code></li>
</ul>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序和冒泡排序非常像，和冒泡的区别在于，在冒泡中，相邻两个值进行比较，只要后面的数比前面的数大就交换位置；而插入排序每次假设第0索引的元素是最大值，去和队列中剩余所有的元素进行比较，但是插入排序不会实际去交换两个数的位置，而是会保存最大的那个值得索引，比到最后时，将最大值插入到列表的最后面。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先感受下代码</span></span><br><span class="line">l = [<span class="number">34</span>, <span class="number">16</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    maxindex = <span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> l[j] &gt; l[maxindex]:</span><br><span class="line">            maxindex = j </span><br><span class="line">    l[i], l[maxindex] = l[maxindex], l[i]</span><br><span class="line">    </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>外层循环和冒泡的没有任何区别，那此例来说都是取到了<code>6 5 4 3 2 1</code>这个队列</li>
<li>第4行代码设置了一个最大值的索引，我假设每次第0个元素都是最大值，这一步是插入排序的核心，用来保存最大值的索引位置</li>
<li>第5行内存循环和冒泡的有些差别<ul>
<li>为什么冒泡从0开始，而插入要指定从1开始？因为插入排序已经指定了最大值的索引的是0，插入排序会拿这个“最大值”去和每一个元素比较，所以当然要从1开始啦！！</li>
<li>为什么以<code>i+1</code>结束？上面也说到了，假设的最大值索引0，要和剩余的所有的元素进行比较，包括取最后一个元素的索引进行比较，而range有左闭右开的特性，不包含右边的值，所以在这里要<code>+1</code>一下，才能取到最后一个值的索引。</li>
</ul>
</li>
<li>第6行，拿列表中的其他元素与“最大值”进行比较</li>
<li>第7行，如果成立，则保存最大值的索引</li>
<li>第8行，在整个列表遍历一次过后，<code>maxindex</code>的索引就是最大值，故将队列中最后一个元素与<code>maxindex</code>对应的元素进行调换，这样一来，每次都会把最大值依次从后往前放置。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 体验下详细的信息输出</span></span><br><span class="line">l = [<span class="number">34</span>, <span class="number">16</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l) - <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    maxindex = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> l[j] &gt; l[maxindex]:</span><br><span class="line">            maxindex = j</span><br><span class="line">    l[i], l[maxindex] = l[maxindex], l[i]</span><br><span class="line">    print(l, i)</span><br><span class="line">    </span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">[<span class="number">34</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">6</span></span><br><span class="line">[<span class="number">34</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">5</span></span><br><span class="line">[<span class="number">34</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">4</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">3</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">2</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>] <span class="number">1</span></span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<p>插入排序相对于冒泡排序的好处是，每次内层循环结束后，不管队列的数值怎样分布，都只会有一次实际的换值操作。</p>
<h2 id="效率分析-1"><a href="#效率分析-1" class="headerlink" title="效率分析"></a>效率分析</h2><ul>
<li>稳定 </li>
<li>空间复杂度O(1) </li>
<li>时间复杂度O(n2) </li>
<li>最差情况：反序，需要移动n*(n-1)/2个元素 </li>
<li>最好情况：正序，不需要移动元素</li>
</ul>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序的核心思想是始终维护一个有序的队列，依次用队列中的每一个元素与后面的所有元素进行对比，小放前，大放后</p>
<p>例如现有如下列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">34</span>, <span class="number">16</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p>选择排序算法实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">用第<span class="number">1</span>个元素和第<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>的元素进行对比</span><br><span class="line">用第<span class="number">2</span>个元素和第<span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>的元素进行对比</span><br><span class="line">用第<span class="number">3</span>个元素和第<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>的元素进行对比</span><br><span class="line">......</span><br><span class="line">依次类推</span><br></pre></td></tr></table></figure>

<p>每次对比完后，拿来对比的那个基准值都会被换成<strong>当次循环</strong>的最小值，从这里可以对比冒泡和排序</p>
<ul>
<li>冒泡是相邻两两比较，只要比前面的值小就交换位置，属于从大往小排</li>
<li>插入排序也是相邻两两比较，每次都假设索引0为最大值，与剩余的所有元素进行比较，记录最大值的索引，把最后一个值与最大值进行交换，属于从大往小排</li>
<li>选择排序是从小往大排，第一次取第0索引去和所有元素比较，换得最小值放到了最前面，第二次取第1索引去和所有元素比较，换得的最小值依次从前往后排</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">34</span>, <span class="number">16</span>, <span class="number">78</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(l)<span class="number">-1</span>):</span><br><span class="line">    print(<span class="string">'------'</span> * <span class="number">9</span>)</span><br><span class="line">    print(<span class="string">'待操作的列表---&gt;'</span>, l, <span class="string">'操作索引---&gt;'</span>, i)</span><br><span class="line">    print(<span class="string">'------'</span> * <span class="number">9</span>)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, len(l)):</span><br><span class="line">        print(l[i], l[j])</span><br><span class="line">        <span class="keyword">if</span> l[i] &gt; l[j]:</span><br><span class="line">            print(<span class="string">'调换位置%s, %s'</span> %(l[j], l[i]))</span><br><span class="line">            l[i], l[j] = l[j], l[i]</span><br><span class="line">            print(<span class="string">'调换完位置的列表---&gt;'</span>, l)</span><br><span class="line"></span><br><span class="line">print(l)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [34, 16, 78, 2, 34, 56, 5] 操作索引---&gt; 0</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">34</span> <span class="number">16</span></span><br><span class="line">调换位置<span class="number">16</span>, <span class="number">34</span></span><br><span class="line">调换完位置的列表---&gt; [16, 34, 78, 2, 34, 56, 5]</span><br><span class="line"><span class="number">16</span> <span class="number">78</span></span><br><span class="line"><span class="number">16</span> <span class="number">2</span></span><br><span class="line">调换位置<span class="number">2</span>, <span class="number">16</span></span><br><span class="line">调换完位置的列表---&gt; [2, 34, 78, 16, 34, 56, 5]</span><br><span class="line"><span class="number">2</span> <span class="number">34</span></span><br><span class="line"><span class="number">2</span> <span class="number">56</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [2, 34, 78, 16, 34, 56, 5] 操作索引---&gt; 1</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">34</span> <span class="number">78</span></span><br><span class="line"><span class="number">34</span> <span class="number">16</span></span><br><span class="line">调换位置<span class="number">16</span>, <span class="number">34</span></span><br><span class="line">调换完位置的列表---&gt; [2, 16, 78, 34, 34, 56, 5]</span><br><span class="line"><span class="number">16</span> <span class="number">34</span></span><br><span class="line"><span class="number">16</span> <span class="number">56</span></span><br><span class="line"><span class="number">16</span> <span class="number">5</span></span><br><span class="line">调换位置<span class="number">5</span>, <span class="number">16</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 78, 34, 34, 56, 16]</span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [2, 5, 78, 34, 34, 56, 16] 操作索引---&gt; 2</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">78</span> <span class="number">34</span></span><br><span class="line">调换位置<span class="number">34</span>, <span class="number">78</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 34, 78, 34, 56, 16]</span><br><span class="line"><span class="number">34</span> <span class="number">34</span></span><br><span class="line"><span class="number">34</span> <span class="number">56</span></span><br><span class="line"><span class="number">34</span> <span class="number">16</span></span><br><span class="line">调换位置<span class="number">16</span>, <span class="number">34</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 16, 78, 34, 56, 34]</span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [2, 5, 16, 78, 34, 56, 34] 操作索引---&gt; 3</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">78</span> <span class="number">34</span></span><br><span class="line">调换位置<span class="number">34</span>, <span class="number">78</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 16, 34, 78, 56, 34]</span><br><span class="line"><span class="number">34</span> <span class="number">56</span></span><br><span class="line"><span class="number">34</span> <span class="number">34</span></span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [2, 5, 16, 34, 78, 56, 34] 操作索引---&gt; 4</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">78</span> <span class="number">56</span></span><br><span class="line">调换位置<span class="number">56</span>, <span class="number">78</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 16, 34, 56, 78, 34]</span><br><span class="line"><span class="number">56</span> <span class="number">34</span></span><br><span class="line">调换位置<span class="number">34</span>, <span class="number">56</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 16, 34, 34, 78, 56]</span><br><span class="line">------------------------------------------------------</span><br><span class="line">待操作的列表---&gt; [2, 5, 16, 34, 34, 78, 56] 操作索引---&gt; 5</span><br><span class="line">------------------------------------------------------</span><br><span class="line"><span class="number">78</span> <span class="number">56</span></span><br><span class="line">调换位置<span class="number">56</span>, <span class="number">78</span></span><br><span class="line">调换完位置的列表---&gt; [2, 5, 16, 34, 34, 56, 78]</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">34</span>, <span class="number">34</span>, <span class="number">56</span>, <span class="number">78</span>]</span><br></pre></td></tr></table></figure>

<h2 id="效率分析-2"><a href="#效率分析-2" class="headerlink" title="效率分析"></a>效率分析</h2><ul>
<li>不稳定</li>
<li>空间复杂度：O(1)</li>
<li>时间复杂度：O(n2)</li>
<li>最坏情况：O(n2) 第一个元素为最大元素，其余元素正序，需要交换n-1个元素</li>
<li>最好情况：O(n2) 正序，不需要交换元素</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>冒泡排序</tag>
        <tag>选择排序</tag>
        <tag>插入排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Python日志模块-logging</title>
    <url>/2016/06/08/Python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97-logging/</url>
    <content><![CDATA[<blockquote>
<p>Python的logging模块提供了标准的日志接口，你可以通过它便捷地记录和存储各种格式的日志。</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="日志的等级"><a href="#日志的等级" class="headerlink" title="日志的等级"></a>日志的等级</h1><ol>
<li><strong>DEBUG</strong>    <em>Detailed information, typically of interest only when diagnosing problems.</em></li>
<li><strong>INFO</strong>    <em>Confirmation that things are working as expected.</em></li>
<li><strong>WARNING</strong>    <em>An indication that something unexpected happened, or indicative of some problem in the near future (e.g. ‘disk space low’). The software is still working as expected.</em></li>
<li><strong>ERROR</strong>    <em>Due to a more serious problem, the software has not been able to perform some function.</em></li>
<li><strong>CRITICAL</strong>    <em>A serious error, indicating that the program itself may be unable to continue running.</em></li>
</ol>
<h1 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h1><h2 id="最简单的用法"><a href="#最简单的用法" class="headerlink" title="最简单的用法"></a>最简单的用法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line">logging.warning(<span class="string">"user [ps] attempted wrong password more than 3 times"</span>)</span><br><span class="line">logging.critical(<span class="string">"server is down"</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">WARNING:root:user [ps] attempted wrong password more than <span class="number">3</span> times</span><br><span class="line">CRITICAL:root:server <span class="keyword">is</span> down</span><br></pre></td></tr></table></figure>


<h2 id="logging-basicConfig"><a href="#logging-basicConfig" class="headerlink" title="logging.basicConfig()"></a>logging.basicConfig()</h2><h3 id="filename"><a href="#filename" class="headerlink" title="filename"></a>filename</h3><p>Specifies that a FileHandler be created, using the specified<br>filename, rather than a StreamHandler</p>
<p>日志写入到文件，提供的文件名称</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>)</span><br><span class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</span><br><span class="line">logging.info(<span class="string">'So should this'</span>)</span><br><span class="line">logging.warning(<span class="string">'And this, too'</span>)</span><br></pre></td></tr></table></figure>

<p><code>example.log</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DEBUG:root:This message should go to the log file</span><br><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br></pre></td></tr></table></figure>

<h3 id="level"><a href="#level" class="headerlink" title="level"></a>level</h3><p>Set the root logger level to the specified level.</p>
<p>设置日志级别</p>
<p><code>bash cmd</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -fr example.log</span><br></pre></td></tr></table></figure>

<p><code>Python Code</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>,level=logging.INFO)</span><br><span class="line">logging.debug(<span class="string">'This message should go to the log file'</span>)</span><br><span class="line">logging.info(<span class="string">'So should this'</span>)</span><br><span class="line">logging.warning(<span class="string">'And this, too'</span>)</span><br></pre></td></tr></table></figure>

<p><code>example.log</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br></pre></td></tr></table></figure>

<p>明明写了三条日志，怎么会只有两条写入了呢？</p>
<p>在basicConfig中设置了<code>level=logging.INFO</code>，Python程序中，只有严重级别大于等于INFO级别的日志才会被写入到日志中</p>
<h3 id="filemode"><a href="#filemode" class="headerlink" title="filemode"></a>filemode</h3><p>Specifies the mode to open the file, if filename is specified(if filemode is unspecified, it defaults to ‘a’)</p>
<p>设置文件打开的默认，如果不设置，默认为追加</p>
<p>在上面的小例子之前，我手动删除了之前已经生成的日志文件，现在我在不删除文件的情况下，再次执行一遍上面的代码，日志文件会被追加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br><span class="line">INFO:root:So should this</span><br><span class="line">WARNING:root:And this, too</span><br></pre></td></tr></table></figure>

<p>如果改成<code>w</code>每次写入日志前，该文件内容都会被清空</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(filename=<span class="string">'example.log'</span>,filemode=<span class="string">'w'</span>, level=logging.INFO)</span><br><span class="line">logging.warning(<span class="string">"filemode='w'"</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WARNING:root:filemode&#x3D;&#39;w&#39;</span><br></pre></td></tr></table></figure>

<h3 id="datefmt"><a href="#datefmt" class="headerlink" title="datefmt"></a>datefmt</h3><p>Use the specified date/time format.</p>
<p>使用time模块的日期格式来格式化日期或时间的显示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(format=<span class="string">'%(asctime)s %(message)s'</span>, datefmt=<span class="string">'%m/%d/%Y %I:%M:%S %p'</span>)</span><br><span class="line">logging.warning(<span class="string">'is when this event was logged.'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">12</span>/<span class="number">12</span>/<span class="number">2010</span> <span class="number">11</span>:<span class="number">46</span>:<span class="number">36</span> AM <span class="keyword">is</span> when this event was logged.</span><br></pre></td></tr></table></figure>

<h3 id="format"><a href="#format" class="headerlink" title="format"></a>format</h3><p>Use the specified format string for the handler.</p>
<p>日志的格式设置</p>
<p>上面的例子已经用到的时间的格式输出到log，logging模块中，有如下信息可以被写入到日志</p>
<p><img src="http://oss.20150509.cn/20160608030759.png" alt=""></p>
<h3 id="其他参数"><a href="#其他参数" class="headerlink" title="其他参数"></a>其他参数</h3><ul>
<li><strong>stream</strong> <em>Use the specified stream to initialize the StreamHandler. Note that this argument is incompatible with ‘filename’ - if both are present, ‘stream’ is ignored.</em></li>
<li><strong>handlers</strong> <em>If specified, this should be an iterable of already created handlers, which will be added to the root handler. Any handler in the list which does not have a formatter assigned will be assigned the formatter created in this function.</em></li>
</ul>
<p>以上这两个参数，在logging对象中使用的情况比较多，将在后面logging对象中介绍和使用</p>
<h2 id="同时在终端和日志文件中记录日志"><a href="#同时在终端和日志文件中记录日志" class="headerlink" title="同时在终端和日志文件中记录日志"></a>同时在终端和日志文件中记录日志</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment">#create logger</span></span><br><span class="line">logger = logging.getLogger(<span class="string">'TEST-LOG'</span>)</span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># create console handler and set level to debug</span></span><br><span class="line">ch = logging.StreamHandler()</span><br><span class="line">ch.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create file handler and set level to warning</span></span><br><span class="line">fh = logging.FileHandler(<span class="string">"access.log"</span>)</span><br><span class="line">fh.setLevel(logging.WARNING)</span><br><span class="line"><span class="comment"># create formatter</span></span><br><span class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add formatter to ch and fh</span></span><br><span class="line">ch.setFormatter(formatter)</span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line"><span class="comment"># add ch and fh to logger</span></span><br><span class="line">logger.addHandler(ch)</span><br><span class="line">logger.addHandler(fh)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 'application' code</span></span><br><span class="line">logger.debug(<span class="string">'debug message'</span>)</span><br><span class="line">logger.info(<span class="string">'info message'</span>)</span><br><span class="line">logger.warn(<span class="string">'warn message'</span>)</span><br><span class="line">logger.error(<span class="string">'error message'</span>)</span><br><span class="line">logger.critical(<span class="string">'critical message'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<p>首先需要创建一个日志对象<code>logger = logging.getLogger(&#39;TEST-LOG&#39;)</code></p>
<p>查看<code>getLogger</code>源码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getLogger</span><span class="params">(name=None)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return a logger with the specified name, creating it if necessary.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    If no name is specified, return the root logger.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> name:</span><br><span class="line">        <span class="keyword">return</span> Logger.manager.getLogger(name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<p>正常情况下return了<code>Logger.manager.getLogger(name)</code></p>
<p>再去找<code>manager</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Logger.manager = Manager(Logger.root)</span><br></pre></td></tr></table></figure>

<p><code>Logger.manager</code>是<code>Manager</code>的实例化对象，再去找<code>Manager</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    There is [under normal circumstances] just one Manager instance, which</span></span><br><span class="line"><span class="string">    holds the hierarchy of loggers.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, rootnode)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize the manager with the root node of the logger hierarchy.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = rootnode</span><br><span class="line">        self.disable = <span class="number">0</span></span><br><span class="line">        self.emittedNoHandlerWarning = <span class="literal">False</span></span><br><span class="line">        self.loggerDict = &#123;&#125;</span><br><span class="line">        self.loggerClass = <span class="literal">None</span></span><br><span class="line">        self.logRecordFactory = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getLogger</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a logger with the specified name (channel name), creating it</span></span><br><span class="line"><span class="string">        if it doesn't yet exist. This name is a dot-separated hierarchical</span></span><br><span class="line"><span class="string">        name, such as "a", "a.b", "a.b.c" or similar.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        If a PlaceHolder existed for the specified name [i.e. the logger</span></span><br><span class="line"><span class="string">        didn't exist but a child of it did], replace it with the created</span></span><br><span class="line"><span class="string">        logger and fix up the parent/child references which pointed to the</span></span><br><span class="line"><span class="string">        placeholder to now point to the logger.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rv = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(name, str):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'A logger name must be a string'</span>)</span><br><span class="line">        _acquireLock()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> name <span class="keyword">in</span> self.loggerDict:</span><br><span class="line">                rv = self.loggerDict[name]</span><br><span class="line">                <span class="keyword">if</span> isinstance(rv, PlaceHolder):</span><br><span class="line">                    ph = rv</span><br><span class="line">                    rv = (self.loggerClass <span class="keyword">or</span> _loggerClass)(name)</span><br><span class="line">                    rv.manager = self</span><br><span class="line">                    self.loggerDict[name] = rv</span><br><span class="line">                    self._fixupChildren(ph, rv)</span><br><span class="line">                    self._fixupParents(rv)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                rv = (self.loggerClass <span class="keyword">or</span> _loggerClass)(name)</span><br><span class="line">                rv.manager = self</span><br><span class="line">                self.loggerDict[name] = rv</span><br><span class="line">                self._fixupParents(rv)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            _releaseLock()</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setLoggerClass</span><span class="params">(self, klass)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set the class to be used when instantiating a logger with this Manager.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> klass != Logger:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> issubclass(klass, Logger):</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">"logger not derived from logging.Logger: "</span></span><br><span class="line">                                + klass.__name__)</span><br><span class="line">        self.loggerClass = klass</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setLogRecordFactory</span><span class="params">(self, factory)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set the factory to be used when instantiating a log record with this</span></span><br><span class="line"><span class="string">        Manager.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.logRecordFactory = factory</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fixupParents</span><span class="params">(self, alogger)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure that there are either loggers or placeholders all the way</span></span><br><span class="line"><span class="string">        from the specified logger to the root of the logger hierarchy.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        name = alogger.name</span><br><span class="line">        i = name.rfind(<span class="string">"."</span>)</span><br><span class="line">        rv = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) <span class="keyword">and</span> <span class="keyword">not</span> rv:</span><br><span class="line">            substr = name[:i]</span><br><span class="line">            <span class="keyword">if</span> substr <span class="keyword">not</span> <span class="keyword">in</span> self.loggerDict:</span><br><span class="line">                self.loggerDict[substr] = PlaceHolder(alogger)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                obj = self.loggerDict[substr]</span><br><span class="line">                <span class="keyword">if</span> isinstance(obj, Logger):</span><br><span class="line">                    rv = obj</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">assert</span> isinstance(obj, PlaceHolder)</span><br><span class="line">                    obj.append(alogger)</span><br><span class="line">            i = name.rfind(<span class="string">"."</span>, <span class="number">0</span>, i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> rv:</span><br><span class="line">            rv = self.root</span><br><span class="line">        alogger.parent = rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_fixupChildren</span><span class="params">(self, ph, alogger)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Ensure that children of the placeholder ph are connected to the</span></span><br><span class="line"><span class="string">        specified logger.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        name = alogger.name</span><br><span class="line">        namelen = len(name)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> ph.loggerMap.keys():</span><br><span class="line">            <span class="comment">#The if means ... if not c.parent.name.startswith(nm)</span></span><br><span class="line">            <span class="keyword">if</span> c.parent.name[:namelen] != name:</span><br><span class="line">                alogger.parent = c.parent</span><br><span class="line">                c.parent = alogger</span><br><span class="line"></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#   Logger classes and functions</span></span><br><span class="line"><span class="comment">#---------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure>

<p>终于找到了！是在上面那里创建了一个logger对象</p>
<p>以后代码都是使用这个logger对象来操作的，那么我们来看看，这个logger对象里面都给我提供了哪些东西~~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span><span class="params">(Filterer)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Instances of the Logger class represent a single logging channel. A</span></span><br><span class="line"><span class="string">    "logging channel" indicates an area of an application. Exactly how an</span></span><br><span class="line"><span class="string">    "area" is defined is up to the application developer. Since an</span></span><br><span class="line"><span class="string">    application can have any number of areas, logging channels are identified</span></span><br><span class="line"><span class="string">    by a unique string. Application areas can be nested (e.g. an area</span></span><br><span class="line"><span class="string">    of "input processing" might include sub-areas "read CSV files", "read</span></span><br><span class="line"><span class="string">    XLS files" and "read Gnumeric files"). To cater for this natural nesting,</span></span><br><span class="line"><span class="string">    channel names are organized into a namespace hierarchy where levels are</span></span><br><span class="line"><span class="string">    separated by periods, much like the Java or Python package namespace. So</span></span><br><span class="line"><span class="string">    in the instance given above, channel names might be "input" for the upper</span></span><br><span class="line"><span class="string">    level, and "input.csv", "input.xls" and "input.gnu" for the sub-levels.</span></span><br><span class="line"><span class="string">    There is no arbitrary limit to the depth of nesting.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, level=NOTSET)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize the logger with a name and an optional level.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        Filterer.__init__(self)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.level = _checkLevel(level)</span><br><span class="line">        self.parent = <span class="literal">None</span></span><br><span class="line">        self.propagate = <span class="literal">True</span></span><br><span class="line">        self.handlers = []</span><br><span class="line">        self.disabled = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setLevel</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Set the logging level of this logger.  level must be an int or a str.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.level = _checkLevel(level)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with severity 'DEBUG'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.debug("Houston, we have a %s", "thorny problem", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(DEBUG):</span><br><span class="line">            self._log(DEBUG, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with severity 'INFO'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.info("Houston, we have a %s", "interesting problem", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(INFO):</span><br><span class="line">            self._log(INFO, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warning</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with severity 'WARNING'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.warning("Houston, we have a %s", "bit of a problem", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(WARNING):</span><br><span class="line">            self._log(WARNING, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">warn</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        warnings.warn(<span class="string">"The 'warn' method is deprecated, "</span></span><br><span class="line">            <span class="string">"use 'warning' instead"</span>, DeprecationWarning, <span class="number">2</span>)</span><br><span class="line">        self.warning(msg, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">error</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with severity 'ERROR'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.error("Houston, we have a %s", "major problem", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(ERROR):</span><br><span class="line">            self._log(ERROR, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exception</span><span class="params">(self, msg, *args, exc_info=True, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Convenience method for logging an ERROR with exception information.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.error(msg, *args, exc_info=exc_info, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">critical</span><span class="params">(self, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with severity 'CRITICAL'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.critical("Houston, we have a %s", "major disaster", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(CRITICAL):</span><br><span class="line">            self._log(CRITICAL, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    fatal = critical</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(self, level, msg, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Log 'msg % args' with the integer severity 'level'.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        To pass exception information, use the keyword argument exc_info with</span></span><br><span class="line"><span class="string">        a true value, e.g.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logger.log(level, "We have a %s", "mysterious problem", exc_info=1)</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> isinstance(level, int):</span><br><span class="line">            <span class="keyword">if</span> raiseExceptions:</span><br><span class="line">                <span class="keyword">raise</span> TypeError(<span class="string">"level must be an integer"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.isEnabledFor(level):</span><br><span class="line">            self._log(level, msg, args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCaller</span><span class="params">(self, stack_info=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Find the stack frame of the caller so that we can note the source</span></span><br><span class="line"><span class="string">        file name, line number and function name.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        f = currentframe()</span><br><span class="line">        <span class="comment">#On some versions of IronPython, currentframe() returns None if</span></span><br><span class="line">        <span class="comment">#IronPython isn't run with -X:Frames.</span></span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            f = f.f_back</span><br><span class="line">        rv = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span>, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> hasattr(f, <span class="string">"f_code"</span>):</span><br><span class="line">            co = f.f_code</span><br><span class="line">            filename = os.path.normcase(co.co_filename)</span><br><span class="line">            <span class="keyword">if</span> filename == _srcfile:</span><br><span class="line">                f = f.f_back</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            sinfo = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> stack_info:</span><br><span class="line">                sio = io.StringIO()</span><br><span class="line">                sio.write(<span class="string">'Stack (most recent call last):\n'</span>)</span><br><span class="line">                traceback.print_stack(f, file=sio)</span><br><span class="line">                sinfo = sio.getvalue()</span><br><span class="line">                <span class="keyword">if</span> sinfo[<span class="number">-1</span>] == <span class="string">'\n'</span>:</span><br><span class="line">                    sinfo = sinfo[:<span class="number">-1</span>]</span><br><span class="line">                sio.close()</span><br><span class="line">            rv = (co.co_filename, f.f_lineno, co.co_name, sinfo)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">makeRecord</span><span class="params">(self, name, level, fn, lno, msg, args, exc_info,</span></span></span><br><span class="line"><span class="function"><span class="params">                   func=None, extra=None, sinfo=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        A factory method which can be overridden in subclasses to create</span></span><br><span class="line"><span class="string">        specialized LogRecords.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        rv = _logRecordFactory(name, level, fn, lno, msg, args, exc_info, func,</span><br><span class="line">                             sinfo)</span><br><span class="line">        <span class="keyword">if</span> extra <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> extra:</span><br><span class="line">                <span class="keyword">if</span> (key <span class="keyword">in</span> [<span class="string">"message"</span>, <span class="string">"asctime"</span>]) <span class="keyword">or</span> (key <span class="keyword">in</span> rv.__dict__):</span><br><span class="line">                    <span class="keyword">raise</span> KeyError(<span class="string">"Attempt to overwrite %r in LogRecord"</span> % key)</span><br><span class="line">                rv.__dict__[key] = extra[key]</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_log</span><span class="params">(self, level, msg, args, exc_info=None, extra=None, stack_info=False)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Low-level logging routine which creates a LogRecord and then calls</span></span><br><span class="line"><span class="string">        all the handlers of this logger to handle the record.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        sinfo = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> _srcfile:</span><br><span class="line">            <span class="comment">#IronPython doesn't track Python frames, so findCaller raises an</span></span><br><span class="line">            <span class="comment">#exception on some versions of IronPython. We trap it here so that</span></span><br><span class="line">            <span class="comment">#IronPython can use logging.</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                fn, lno, func, sinfo = self.findCaller(stack_info)</span><br><span class="line">            <span class="keyword">except</span> ValueError: <span class="comment"># pragma: no cover</span></span><br><span class="line">                fn, lno, func = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment"># pragma: no cover</span></span><br><span class="line">            fn, lno, func = <span class="string">"(unknown file)"</span>, <span class="number">0</span>, <span class="string">"(unknown function)"</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">if</span> isinstance(exc_info, BaseException):</span><br><span class="line">                exc_info = (type(exc_info), exc_info, exc_info.__traceback__)</span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> isinstance(exc_info, tuple):</span><br><span class="line">                exc_info = sys.exc_info()</span><br><span class="line">        record = self.makeRecord(self.name, level, fn, lno, msg, args,</span><br><span class="line">                                 exc_info, func, extra, sinfo)</span><br><span class="line">        self.handle(record)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Call the handlers for the specified record.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This method is used for unpickled records received from a socket, as</span></span><br><span class="line"><span class="string">        well as those created locally. Logger-level filtering is applied.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">not</span> self.disabled) <span class="keyword">and</span> self.filter(record):</span><br><span class="line">            self.callHandlers(record)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addHandler</span><span class="params">(self, hdlr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Add the specified handler to this logger.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _acquireLock()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (hdlr <span class="keyword">in</span> self.handlers):</span><br><span class="line">                self.handlers.append(hdlr)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            _releaseLock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeHandler</span><span class="params">(self, hdlr)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Remove the specified handler from this logger.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        _acquireLock()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> hdlr <span class="keyword">in</span> self.handlers:</span><br><span class="line">                self.handlers.remove(hdlr)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            _releaseLock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasHandlers</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        See if this logger has any handlers configured.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Loop through all handlers for this logger and its parents in the</span></span><br><span class="line"><span class="string">        logger hierarchy. Return True if a handler was found, else False.</span></span><br><span class="line"><span class="string">        Stop searching up the hierarchy whenever a logger with the "propagate"</span></span><br><span class="line"><span class="string">        attribute set to zero is found - that will be the last logger which</span></span><br><span class="line"><span class="string">        is checked for the existence of handlers.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c = self</span><br><span class="line">        rv = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            <span class="keyword">if</span> c.handlers:</span><br><span class="line">                rv = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c.propagate:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c = c.parent</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">callHandlers</span><span class="params">(self, record)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Pass a record to all relevant handlers.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Loop through all handlers for this logger and its parents in the</span></span><br><span class="line"><span class="string">        logger hierarchy. If no handler was found, output a one-off error</span></span><br><span class="line"><span class="string">        message to sys.stderr. Stop searching up the hierarchy whenever a</span></span><br><span class="line"><span class="string">        logger with the "propagate" attribute set to zero is found - that</span></span><br><span class="line"><span class="string">        will be the last logger whose handlers are called.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        c = self</span><br><span class="line">        found = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> c:</span><br><span class="line">            <span class="keyword">for</span> hdlr <span class="keyword">in</span> c.handlers:</span><br><span class="line">                found = found + <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> record.levelno &gt;= hdlr.level:</span><br><span class="line">                    hdlr.handle(record)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> c.propagate:</span><br><span class="line">                c = <span class="literal">None</span>    <span class="comment">#break out</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                c = c.parent</span><br><span class="line">        <span class="keyword">if</span> (found == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> lastResort:</span><br><span class="line">                <span class="keyword">if</span> record.levelno &gt;= lastResort.level:</span><br><span class="line">                    lastResort.handle(record)</span><br><span class="line">            <span class="keyword">elif</span> raiseExceptions <span class="keyword">and</span> <span class="keyword">not</span> self.manager.emittedNoHandlerWarning:</span><br><span class="line">                sys.stderr.write(<span class="string">"No handlers could be found for logger"</span></span><br><span class="line">                                 <span class="string">" \"%s\"\n"</span> % self.name)</span><br><span class="line">                self.manager.emittedNoHandlerWarning = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getEffectiveLevel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get the effective level for this logger.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Loop through this logger and its parents in the logger hierarchy,</span></span><br><span class="line"><span class="string">        looking for a non-zero logging level. Return the first one found.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        logger = self</span><br><span class="line">        <span class="keyword">while</span> logger:</span><br><span class="line">            <span class="keyword">if</span> logger.level:</span><br><span class="line">                <span class="keyword">return</span> logger.level</span><br><span class="line">            logger = logger.parent</span><br><span class="line">        <span class="keyword">return</span> NOTSET</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEnabledFor</span><span class="params">(self, level)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Is this logger enabled for level 'level'?</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.manager.disable &gt;= level:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> level &gt;= self.getEffectiveLevel()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getChild</span><span class="params">(self, suffix)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a logger which is a descendant to this one.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        This is a convenience method, such that</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logging.getLogger('abc').getChild('def.ghi')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        is the same as</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        logging.getLogger('abc.def.ghi')</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        It's useful, for example, when the parent logger is named using</span></span><br><span class="line"><span class="string">        __name__ rather than a literal string.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="keyword">not</span> self:</span><br><span class="line">            suffix = <span class="string">'.'</span>.join((self.name, suffix))</span><br><span class="line">        <span class="keyword">return</span> self.manager.getLogger(suffix)</span><br></pre></td></tr></table></figure>

<p>上面实例中用到的<code>logger.setLevel</code> <code>logger.addHandler</code> <code>logger.debug</code> <code>logger.info</code> <code>logger.warn</code> <code>logger.error</code> <code>logger.critical</code> 都是这里提供的功能，这些都是对象方法，设置的参数和打印的日志都是对象的行为，与logging类一定要区分开（logging.basicConfig是类方法，logger.setLevel是对象方法）</p>
<p><code>formatter = logging.Formatter(&#39;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#39;)</code>，这句的意思是生成了一个formatter对象，这个对象保存了日志输出的格式，实例中，这个对象被当做参数传递到了<code>logging.StreamHandler()</code>和<code>logging.FileHandler(&quot;access.log&quot;)</code>对象中，意思是声明让这两个日志输出形式以<code>formatter</code>对象指定的格式进行输出</p>
<p>最后需要说明的是<code>logger.addHandler</code>, Handler是输出方式，<code>logging.StreamHandler()</code>是输出到屏幕的对象（句柄），<code>logging.FileHandler(&quot;access.log&quot;)</code>是输出到文件的对象（句柄），上面的实例中，将这两个对象都添加到了logger对象中，所以使logger拥有了既输出到屏幕又写入到日志的能力。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
        <tag>logging</tag>
      </tags>
  </entry>
  <entry>
    <title>Python时间模块详解</title>
    <url>/2016/06/08/Python%E6%97%B6%E9%97%B4%E6%A8%A1%E5%9D%97%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>Python常用的跟时间相关的模块有两个<code>time</code>和<code>datetime</code></p>
<p>其中<code>datetime</code>是<code>time</code>模块更高层次的封装，在实际使用中，两个模块各有千秋</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()  <span class="comment">#获取时间戳，从1970年1月1日0：00到现在的秒数</span></span><br><span class="line"><span class="number">1465321187.56645</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time() - <span class="number">86400</span>  <span class="comment">#可以按需 + - 秒数</span></span><br><span class="line"><span class="number">1465234811.8091</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime()  <span class="comment">#返回'Wed Jun  8 01:42:41 2016'格式的日期时间字符串</span></span><br><span class="line"><span class="string">'Wed Jun  8 01:42:41 2016'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime() - <span class="number">86400</span>  <span class="comment">#报错！ctime返回的字符串，是不能 + - 的 </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;input&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unsupported operand type(s) <span class="keyword">for</span> -: <span class="string">'str'</span> <span class="keyword">and</span> <span class="string">'int'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.ctime(time.time() - <span class="number">86400</span>)  <span class="comment">#ctime可以接收时间戳参数并转化为日期时间字符串，通过这个功能，可以把时间戳的时间进行 + - 后传递给ctime进行转换</span></span><br><span class="line"><span class="string">'Tue Jun  7 01:45:09 2016'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.gmtime() <span class="comment">#返回一个格式化的时间对象</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">6</span>, tm_mday=<span class="number">7</span>, tm_hour=<span class="number">17</span>, tm_min=<span class="number">47</span>, tm_sec=<span class="number">1</span>, tm_wday=<span class="number">1</span>, tm_yday=<span class="number">159</span>, tm_isdst=<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(time.gmtime())</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">time</span>.<span class="title">struct_time</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">gmtime</span><span class="params">(time.time<span class="params">()</span> - <span class="number">86400</span>)</span>  #也可以通过传递时间戳来更改时间</span></span><br><span class="line"><span class="class"><span class="title">time</span>.<span class="title">struct_time</span><span class="params">(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">6</span>, tm_mday=<span class="number">6</span>, tm_hour=<span class="number">17</span>, tm_min=<span class="number">48</span>, tm_sec=<span class="number">27</span>, tm_wday=<span class="number">0</span>, tm_yday=<span class="number">158</span>, tm_isdst=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">gmtime</span><span class="params">()</span>[0]  #可以通过索引的方式去取值</span></span><br><span class="line"><span class="class">2016</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">gmtime</span><span class="params">()</span>[1]</span></span><br><span class="line"><span class="class">6</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">gmtime</span><span class="params">()</span>[2]  #问题来了，现在已经是8号了却还显示7，是因为这里显示的是格林威治时间，不是本地时间</span></span><br><span class="line"><span class="class">7</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">localtime</span><span class="params">()</span>  #本地时间来了！这个方法显示的是本地时区的时间！返回的格式与<span class="title">gmtime</span>是一样的，用法也一样</span></span><br><span class="line"><span class="class"><span class="title">time</span>.<span class="title">struct_time</span><span class="params">(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">6</span>, tm_mday=<span class="number">8</span>, tm_hour=<span class="number">1</span>, tm_min=<span class="number">56</span>, tm_sec=<span class="number">5</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">160</span>, tm_isdst=<span class="number">0</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">mktime</span><span class="params">(time.localtime<span class="params">()</span>)</span>  #该方法接收一个<span class="title">tuple</span>类型的参数，可接收<span class="title">struct_time</span>对象并将其转化为时间戳</span></span><br><span class="line"><span class="class">1465322289.0</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">strftime</span><span class="params">(<span class="string">"%Y-%m-%d"</span>, time.localtime<span class="params">()</span>)</span>  #将<span class="title">struct_time</span>对象以指定的格式显示</span></span><br><span class="line"><span class="class">'2016-06-08'</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">strptime</span><span class="params">(<span class="string">'2016-06-08'</span>, <span class="string">"%Y-%m-%d"</span>)</span>  #将日期字符串以指定的格式转化为<span class="title">struct_time</span>对象</span></span><br><span class="line"><span class="class"><span class="title">time</span>.<span class="title">struct_time</span><span class="params">(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">6</span>, tm_mday=<span class="number">8</span>, tm_hour=<span class="number">0</span>, tm_min=<span class="number">0</span>, tm_sec=<span class="number">0</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">160</span>, tm_isdst=<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">sleep</span><span class="params">(<span class="number">4</span>)</span> </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; </span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">time</span>.<span class="title">clock</span><span class="params">()</span>  #在<span class="title">Unix</span>系统上表示进程时间。在<span class="title">Windows</span>上第一次返回进程时间，第二次返回第一次到第二次之间的时间</span></span><br><span class="line"><span class="class">29.472588</span></span><br></pre></td></tr></table></figure>

<h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.today()  <span class="comment">#2016-06-08</span></span><br><span class="line">datetime.date(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.date.today())</span><br><span class="line"><span class="number">2016</span><span class="number">-06</span><span class="number">-08</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.date.fromtimestamp(time.time())  <span class="comment">#将时间戳转为日期格式</span></span><br><span class="line">datetime.date(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now() <span class="comment">#返回当前时间</span></span><br><span class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">18</span>, <span class="number">57</span>, <span class="number">453874</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.datetime.now())</span><br><span class="line"><span class="number">2016</span><span class="number">-06</span><span class="number">-08</span> <span class="number">02</span>:<span class="number">19</span>:<span class="number">08.895585</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().timetuple()  <span class="comment">#转化为struct_time对象</span></span><br><span class="line">time.struct_time(tm_year=<span class="number">2016</span>, tm_mon=<span class="number">6</span>, tm_mday=<span class="number">8</span>, tm_hour=<span class="number">2</span>, tm_min=<span class="number">20</span>, tm_sec=<span class="number">17</span>, tm_wday=<span class="number">2</span>, tm_yday=<span class="number">160</span>, tm_isdst=<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now().replace(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">9</span>)   <span class="comment">#替换指定的日期或时间</span></span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">21</span>, <span class="number">39</span>, <span class="number">897457</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.strptime(<span class="string">"09/05/15 7:56"</span>, <span class="string">"%d/%m/%y %H:%M"</span>)  <span class="comment">#将日期时间字符串转为时间格式，并以指定的格式进行显示</span></span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">56</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now() + datetime.timedelta(days=<span class="number">10</span>) <span class="comment">#比现在加10天</span></span><br><span class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">18</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">46</span>, <span class="number">45019</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now() + datetime.timedelta(days=<span class="number">-10</span>) <span class="comment">#比现在减10天</span></span><br><span class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">29</span>, <span class="number">2</span>, <span class="number">26</span>, <span class="number">53</span>, <span class="number">536217</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now() + datetime.timedelta(hours=<span class="number">-10</span>) <span class="comment">#比现在减10小时</span></span><br><span class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">16</span>, <span class="number">27</span>, <span class="number">0</span>, <span class="number">717995</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.datetime.now() + datetime.timedelta(seconds=<span class="number">120</span>) <span class="comment">#比现在+120s</span></span><br><span class="line">datetime.datetime(<span class="number">2016</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">29</span>, <span class="number">7</span>, <span class="number">456727</span>)</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>附录1：</li>
</ul>
<table>
<thead>
<tr>
<th>索引（Index）</th>
<th>属性（Attribute）</th>
<th>值（Values）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>tm_year（年）</td>
<td>比如2011</td>
</tr>
<tr>
<td>1</td>
<td>tm_mon（月）</td>
<td>1 - 12</td>
</tr>
<tr>
<td>2</td>
<td>tm_mday（日）</td>
<td>1 - 31</td>
</tr>
<tr>
<td>3</td>
<td>tm_hour（时）</td>
<td>0 - 23</td>
</tr>
<tr>
<td>4</td>
<td>tm_min（分）</td>
<td>0 - 59</td>
</tr>
<tr>
<td>5</td>
<td>tm_sec（秒）</td>
<td>0 - 61</td>
</tr>
<tr>
<td>6</td>
<td>tm_wday（weekday）</td>
<td>0 - 6（0表示周日）</td>
</tr>
<tr>
<td>7</td>
<td>tm_yday（一年中的第几天）</td>
<td>1 - 366</td>
</tr>
<tr>
<td>8</td>
<td>tm_isdst（是否是夏令时）</td>
<td>默认为-1</td>
</tr>
</tbody></table>
<ul>
<li>附录2：</li>
</ul>
<table>
<thead>
<tr>
<th>格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>%a</td>
<td>本地（locale）简化星期名称</td>
</tr>
<tr>
<td>%A</td>
<td>本地完整星期名称</td>
</tr>
<tr>
<td>%b</td>
<td>本地简化月份名称</td>
</tr>
<tr>
<td>%B</td>
<td>本地完整月份名称</td>
</tr>
<tr>
<td>%c</td>
<td>本地相应的日期和时间表示</td>
</tr>
<tr>
<td>%d</td>
<td>一个月中的第几天（01 - 31）</td>
</tr>
<tr>
<td>%H</td>
<td>一天中的第几个小时（24小时制，00 - 23）</td>
</tr>
<tr>
<td>%I</td>
<td>第几个小时（12小时制，01 - 12）</td>
</tr>
<tr>
<td>%j</td>
<td>一年中的第几天（001 - 366）</td>
</tr>
<tr>
<td>%m</td>
<td>月份（01 - 12）</td>
</tr>
<tr>
<td>%M</td>
<td>分钟数（00 - 59）</td>
</tr>
<tr>
<td>%p</td>
<td>本地am或者pm的相应符</td>
</tr>
<tr>
<td>%S</td>
<td>秒（01 - 61）</td>
</tr>
<tr>
<td>%U</td>
<td>一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。</td>
</tr>
<tr>
<td>%w</td>
<td>一个星期中的第几天（0 - 6，0是星期天）</td>
</tr>
<tr>
<td>%W</td>
<td>和%U基本相同，不同的是%W以星期一为一个星期的开始</td>
</tr>
<tr>
<td>%x</td>
<td>本地相应日期</td>
</tr>
<tr>
<td>%X</td>
<td>本地相应时间</td>
</tr>
<tr>
<td>%y</td>
<td>去掉世纪的年份（00 - 99）</td>
</tr>
<tr>
<td>%Y</td>
<td>完整的年份</td>
</tr>
<tr>
<td>%Z</td>
<td>时区的名字（如果不存在为空字符）</td>
</tr>
<tr>
<td>%%</td>
<td>‘%’字符</td>
</tr>
</tbody></table>
<ul>
<li>附录3：time模块，时间之间的转换关系</li>
</ul>
<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/20160608021359.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python模块</tag>
        <tag>time</tag>
        <tag>datetime</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的序列化和反序列化</title>
    <url>/2016/06/07/Python%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>序列化（Serialzation）将对象的状态信息转换为可以存储或传输的形式的过程叫做序列化。反之将读取到的文本信息转换为对象叫做反序列化。本篇文章介绍三种Python下序列化的方法</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>json是当今最流行的序列化格式之一，拥有超轻量级的数据交换格式。由于json的跨平台，跨语言交换信息的特性，在json中的字符串必须使用双引号引起来，在有的语言中有明确的定义，单引号只能表示单个字符，所以在json中使用单引号会产生意想不到的效果~~</p>
<p>json可以转化的Python对象有：</p>
<ul>
<li>list</li>
<li>dict</li>
</ul>
<p>本篇文章主要介绍json的4个方法：</p>
<ul>
<li>dumps() 直接操作Python的数据类型转换成json字符串</li>
<li>loads() 直接将json字符串转换为Python的数据类型</li>
<li>dump() 先将Python的数据类型转换成json字符串，再写入文件</li>
<li>load() 先从文件中读取json字符串，再装换为Python的数据类型</li>
</ul>
<h2 id="dumps"><a href="#dumps" class="headerlink" title="dumps()"></a>dumps()</h2><p>将list或dict对象序列化成json格式的字符串</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>&#125;</span><br><span class="line">print(d, type(d))</span><br><span class="line"></span><br><span class="line">result = json.dumps(d)</span><br><span class="line">print(result, type(result))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line">&#123;"k1": "v1"&#125; &lt;class 'str'&gt;</span><br></pre></td></tr></table></figure>

<p>注意：上面已经强调了，在json中的字符串必须使用双引号。在上面的小例子中，我在创建Python字典的时候使用了单引号，但是在序列化成json格式时，json自动帮我们换上了双引号。</p>
<h2 id="loads"><a href="#loads" class="headerlink" title="loads()"></a>loads()</h2><p>将json格式的字符串反序列化成list或dict对象</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">s = <span class="string">'&#123;"k1": "v1"&#125;'</span></span><br><span class="line">print(s, type(s))</span><br><span class="line"></span><br><span class="line">d = json.loads(s)</span><br><span class="line">print(d, type(d))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">"k1"</span>: <span class="string">"v1"</span>&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line">&#123;'k1': 'v1'&#125; &lt;class 'dict'&gt;</span><br></pre></td></tr></table></figure>

<h2 id="dump"><a href="#dump" class="headerlink" title="dump()"></a>dump()</h2><p>将list或dict对象转换为json格式的字符串并写入到文件中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>&#125;</span><br><span class="line">print(d, type(d))</span><br><span class="line"></span><br><span class="line">result = json.dump(d, open(<span class="string">'a.json'</span>, <span class="string">'w'</span>))</span><br><span class="line">print(result, type(result))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br><span class="line"><span class="class"><span class="title">None</span> &lt;<span class="title">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用dump写入文件后，不再有返回值</p>
<p><code>cat a.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"k1"</span>: <span class="string">"v1"</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="load"><a href="#load" class="headerlink" title="load()"></a>load()</h2><p>将文件中json格式的字符串转化为Python的list或dict对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = json.load(open(<span class="string">'a.json'</span>, <span class="string">'r'</span>))</span><br><span class="line">print(d, type(d))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'k1'</span>: <span class="string">'v1'</span>&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>pickle是Python语言自己的序列化方式，其优点是可以序列化任何Python对象，不仅限于json的list和dict。我们说Python是面向对象语言，万物皆对象，那么对于pickle来说就是Python的万物皆可序列化。这既是它的优点，也是它的缺点，由于pickle是Python自己的序列化方式，它不支持与其他语言的信息交换。json可以跨语言进行信息交换，但是pickle不行，pickle只能在Python语言下进行信息的交换，而且Python的版本不同，对pickle来说可能还会有兼容性的问题。</p>
<p>本篇文章主要介绍pickle的4个方法：</p>
<ul>
<li>dumps()</li>
<li>loads()</li>
<li>dump()</li>
<li>load()</li>
</ul>
<h2 id="dumps-1"><a href="#dumps-1" class="headerlink" title="dumps()"></a>dumps()</h2><p>将任何Python对象转化成二进制字节类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">ret = pickle.dumps(u)</span><br><span class="line">print(ret, type(ret))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="string">b'\x80\x03c__main__\nUser\nq\x00)\x81q\x01.'</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">bytes</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="loads-1"><a href="#loads-1" class="headerlink" title="loads()"></a>loads()</h2><p>将二进制字节类型的数据转化为Python对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">u = User()</span><br><span class="line">ret = pickle.dumps(u)</span><br><span class="line">print(ret, type(ret))</span><br><span class="line"></span><br><span class="line">o = pickle.loads(ret)</span><br><span class="line">print(o, type(o))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="string">b'\x80\x03c__main__\nUser\nq\x00)\x81q\x01.'</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">bytes</span>'&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">__main__</span>.<span class="title">User</span> <span class="title">object</span> <span class="title">at</span> 0<span class="title">x101b78a90</span>&gt; &lt;<span class="title">class</span> '<span class="title">__main__</span>.<span class="title">User</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="dump-1"><a href="#dump-1" class="headerlink" title="dump()"></a>dump()</h2><p>将Python对象转化成二进制字节，再写入到文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">u = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">ret = pickle.dump(u, open(<span class="string">'a.pkl'</span>, <span class="string">'wb'</span>))</span><br><span class="line">print(ret, type(ret))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">None</span> &lt;<span class="class"><span class="keyword">class</span> '<span class="title">NoneType</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：由于pickle把对象转化成了二进制的字节，所以在写入文件的时候，一定要加上<code>b</code></p>
<h2 id="load-1"><a href="#load-1" class="headerlink" title="load()"></a>load()</h2><p>读取文件中的二进制字节，将其转化为Python对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">o = pickle.load(open(<span class="string">'a.pkl'</span>, <span class="string">'rb'</span>))</span><br><span class="line">print(o, type(o))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) &lt;<span class="class"><span class="keyword">class</span> '<span class="title">tuple</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：读取的时候也要加上<code>b</code></p>
<h1 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h1><p>YAML格式是最近几年大红大紫的交换格式，作为运维，最直观的感觉就是从运维自动化概念的开始，到容器技术的普及，让YAML的使用频率一高再高。YAML拥有比json更高的可读性，尤其用在配置文件（如saltstack，docker描述文件等）在合适不过了！</p>
<p>本篇文章主要介绍YAML的两个方法：</p>
<ul>
<li>dump()</li>
<li>load()</li>
</ul>
<p>由于YAML绝大部分的是对文件来操作，所以这里介绍时调换一下顺序，先介绍load()</p>
<p>首先写一个YAML的配置文件出来<code>conf.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">host1:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">php</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">16G</span></span><br><span class="line"></span><br><span class="line"><span class="attr">host2:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">logstash</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kibana</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">128G</span></span><br></pre></td></tr></table></figure>

<h2 id="load-2"><a href="#load-2" class="headerlink" title="load()"></a>load()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">o = yaml.load(open(<span class="string">'conf.yml'</span>))</span><br><span class="line">print(o, type(o))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">&#123;<span class="string">'host1'</span>: &#123;<span class="string">'app'</span>: [<span class="string">'httpd'</span>, <span class="string">'mysql'</span>, <span class="string">'php'</span>], <span class="string">'IP'</span>: <span class="string">'192.168.1.1'</span>, <span class="string">'memory'</span>: <span class="string">'16G'</span>&#125;, <span class="string">'host2'</span>: &#123;<span class="string">'app'</span>: [<span class="string">'logstash'</span>, <span class="string">'kibana'</span>, <span class="string">'elasticsearch'</span>, <span class="string">'kafka'</span>, <span class="string">'zookeeper'</span>], <span class="string">'IP'</span>: <span class="string">'192.168.1.2'</span>, <span class="string">'memory'</span>: <span class="string">'128G'</span>&#125;&#125; &lt;<span class="class"><span class="keyword">class</span> '<span class="title">dict</span>'&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="dump-2"><a href="#dump-2" class="headerlink" title="dump()"></a>dump()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">o = yaml.load(open(<span class="string">'conf.yml'</span>))</span><br><span class="line"></span><br><span class="line">o[<span class="string">'host3'</span>] = &#123;<span class="string">'app'</span>: [<span class="string">'docker'</span>, <span class="string">'jenkins'</span>], <span class="string">'IP'</span>: <span class="string">'192.168.1.3'</span>, <span class="string">'memory'</span>: <span class="string">'64G'</span>&#125;</span><br><span class="line">yaml.dump(o, open(<span class="string">'conf.yml'</span>, <span class="string">'w'</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host1:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">[httpd,</span> <span class="string">mysql,</span> <span class="string">php]</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">16G</span></span><br><span class="line"><span class="attr">host2:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">[logstash,</span> <span class="string">kibana,</span> <span class="string">elasticsearch,</span> <span class="string">kafka,</span> <span class="string">zookeeper]</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">128G</span></span><br><span class="line"><span class="attr">host3:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">app:</span> <span class="string">[docker,</span> <span class="string">jenkins]</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">64G</span></span><br></pre></td></tr></table></figure>

<p>可以使用<code>default_flow_style=False</code>来保证高可读性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line">o = yaml.load(open(<span class="string">'conf.yml'</span>))</span><br><span class="line"></span><br><span class="line">o[<span class="string">'host3'</span>] = &#123;<span class="string">'app'</span>: [<span class="string">'docker'</span>, <span class="string">'jenkins'</span>], <span class="string">'IP'</span>: <span class="string">'192.168.1.3'</span>, <span class="string">'memory'</span>: <span class="string">'64G'</span>&#125;</span><br><span class="line"><span class="comment">#yaml.dump(o, open('conf.yml', 'w'))</span></span><br><span class="line">yaml.dump(o, open(<span class="string">'conf.yml'</span>, <span class="string">'w'</span>), default_flow_style=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">host1:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">httpd</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mysql</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">php</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">16G</span></span><br><span class="line"><span class="attr">host2:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.2</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">logstash</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kibana</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">elasticsearch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">zookeeper</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">128G</span></span><br><span class="line"><span class="attr">host3:</span></span><br><span class="line">  <span class="attr">IP:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.3</span></span><br><span class="line">  <span class="attr">app:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">jenkins</span></span><br><span class="line">  <span class="attr">memory:</span> <span class="string">64G</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>YAML</tag>
        <tag>Python模块</tag>
        <tag>序列化</tag>
        <tag>反序列化</tag>
        <tag>pickle</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的迭代器和生成器</title>
    <url>/2016/06/07/Python%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>Python Version：3.5+</p>
</blockquote>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>一个函数调用时返回一个迭代器（可迭代的对象），那这个函数就叫做生成器（generator）；如果函数中包含yield语法，那这个函数就会变成生成器；</p>
<p>在函数中，有return语句，在执行函数的时候，一旦执行到return语句，函数会立即返回结果并退出函数；而如果使用了yield语句，当函数执行到yield时，会立即将yield后的值返回，并等待下一次调用。</p>
<p>形象点来说，return相当于按下了停止键；而yield相当于按下了暂停键。他们之间的区别就在于，暂停键是可以继续播放的，而停止了之后再播放需要从头播放。</p>
<p><strong>感受一下生成器</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">f = func()</span><br><span class="line"></span><br><span class="line">print(type(f))</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line">print(f.__next__())</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/5/test.py"</span>, line <span class="number">85</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(f.__next__())</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>这里的<code>f.__next__()</code>就相当于“播放”键，每执行一次，都会让函数从上次停止的位置继续执行。函数中，定义了一共可以有四次暂停键，而我在调用时，按了五次播放键，到最后，抛出了StopIteration异常，说明该迭代对象已经遍历完毕。</p>
<p>实例：将列表进行拆分，例如[1, 2, 3]拆分成[1, 2] [2, 3]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mylist</span><span class="params">(li)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(li) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> (li[i], li[i + <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">li = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">generator_list = mylist(li)</span><br><span class="line">print(generator_list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> generator_list:</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">&lt;generator object mylist at <span class="number">0x101380888</span>&gt;</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">(<span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>迭代器是访问集合元素的一种方式。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退，不过这也没什么，因为人们很少在迭代途中往后退。另外，迭代器的一大优点是不要求事先准备好整个迭代过程中所有的元素。迭代器仅仅在迭代到某个元素时才计算该元素，而在这之前或之后，元素可以不存在或者被销毁。这个特点使得它特别适合用于遍历一些巨大的或是无限的集合，比如几个G的文件</p>
<p><strong>特点：</strong></p>
<ul>
<li>访问者不需要关心迭代器内部的结构，仅需通过next()方法不断去取下一个内容</li>
<li>不能随机访问集合中的某个值 ，只能从头到尾依次访问</li>
<li>访问到一半时不能往回退</li>
<li>便于循环比较大的数据集合，节省内存</li>
</ul>
<h2 id="如何判断是否是可迭代对象"><a href="#如何判断是否是可迭代对象" class="headerlink" title="如何判断是否是可迭代对象"></a>如何判断是否是可迭代对象</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i</span><br><span class="line">&lt;list_iterator object at <span class="number">0x1032fa390</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(i)</span><br><span class="line">[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__iter__'</span>, <span class="string">'__le__'</span>, <span class="string">'__length_hint__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__next__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br></pre></td></tr></table></figure>

<p>一个对象中，同时拥有<code>__iter__</code> <code>__next__</code>这两个方法的对象就是可迭代对象。</p>
<p>迭代对象靠什么迭代？靠<code>__next__</code>方法进行迭代。而Python中的for循环语句，内部帮我们调用了对象的<code>__next__</code>方法，而且帮我们自动捕获了StopIteration异常。So <code>for</code>循环就是Python中的迭代器</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>生成器</tag>
        <tag>迭代器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python for 递归</title>
    <url>/2016/06/07/Python-for-%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<blockquote>
<p>递归：程序执行过程中，调动自身的编程技巧称之为递归，如果你需要了解更多关于递归的说明，可以移步下面的链接查看百度百科。好吧，我们这里不谈递归的概念，只谈实现</p>
</blockquote>
<p><a href="http://baike.baidu.com/link?url=XwtAqR--kKYDNpBVGDColI-LJjrm8Pz1kL2-VO0oB5RYs0pIF_sgxmc8AT15IGHjJqC80vnHhuYaSs_eIRx6m_" target="_blank" rel="noopener">百度百科：递归</a></p>
<p>在去实现递归之前，先来看一个小🌰例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Polar Snow'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">b</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> b()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> c()</span><br><span class="line"></span><br><span class="line">d()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Polar Snow</span><br></pre></td></tr></table></figure>

<p>如代码所示，我执行了<code>d()</code>，但是在d的内部又执行了<code>c()</code>,在c的内部又执行了<code>b()</code>,在b的内部执行了<code>a()</code>，调用关系如下图所示：</p>
<p><img src="http://oss.20150509.cn/20160607014959.png" alt=""></p>
<p>执行<code>d()</code>的时候，先走红色线的调用，到<code>a()</code>后，走蓝色线的返回值，最后的<code>print(r)</code>实际上就是<code>a()</code>函数的返回值</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>了解了上面的例子后，会更容易递归的实现，现有如下递归实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(n)</span>:</span></span><br><span class="line">    n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n &gt;= <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'end'</span></span><br><span class="line">    <span class="keyword">return</span> func(n)</span><br><span class="line"></span><br><span class="line">r = func(<span class="number">1</span>)</span><br><span class="line">print(r)</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/20160607021259.png" alt=""></p>
<p>红色的线是调用线，蓝色的线是返回线。可以看到，递归是逐层调用，当条件满足时结束调用自己，并逐层将值返回。上面的案例中，每层的值都是按照原值进行返回，在实际应用中，可以对每下一层返回的值进行计算后再返回给上一层。</p>
<p><strong>思考题</strong></p>
<ul>
<li>使用递归的方式计算：<code>7的阶乘</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> n * cal(n<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">print(cal(<span class="number">7</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">5040</span></span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/20160607024859.png" alt=""></p>
<ul>
<li>使用递归的方式计算：<code>1*2*3*4*5*6*7</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> n * cal(n+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(cal(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">5040</span></span><br></pre></td></tr></table></figure>

<p><img src="http://20150509.oss-cn-qingdao.aliyuncs.com/20160607024959.png" alt=""></p>
<p><strong>总结</strong>：从以上两种对递归的使用来看，可以总结出，递归计算的两个关键点</p>
<ul>
<li>return点：递归到第几层的时候开始返回，返回什么？</li>
<li>计算点：当下一层的函数返回数据的时候，需要对数据做什么样的计算？</li>
</ul>
<p>第一种计算阶乘的思路是传递一个最大值，让函数帮我从大往小乘。有了这个信息就确定了<code>计算点</code>的方式！是从大往小乘，大的值就是原参数的值，小的值是通过下一层计算得来的，所以就确定了计算点的表达式<code>n * cal(n-1)</code>。最后还需要确定递归的第一个返回值，也就是<code>return点</code>，既然是从大往小乘，return点就是最小值1，阶乘算到1就不用往下算了，所以在递归中加入判断，当值=1时，返回1.</p>
<p>第二种计算阶乘的思路是传递一个最小值，在递归内部，写死了计算到7的阶乘，递归到最深层的时候返回7到上一层，交给上一层的<code>n * 7</code>表达式来处理，由于函数中，每层的调用n都加了1，那么此时的n肯定是6，所以表达式会计算<code>6 * 7</code>,并将结果42返回给上一层。而再上一层的n肯定是5，所以又会去计算<code>5 * 42</code>并将结果返回至上层</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字符串格式化</title>
    <url>/2016/06/06/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>Python中格式化字符串的方式有两种，一种是使用百分号的方式；一种是使用format方式。使用百分号的方式比较古老，而使用format则是比较“先进”的方式，目前两者并存</p>
<p>Python Version: 3.5+</p>
</blockquote>
<h1 id="百分号的方式格式化字符串"><a href="#百分号的方式格式化字符串" class="headerlink" title="百分号的方式格式化字符串"></a>百分号的方式格式化字符串</h1><p><strong>语法格式：</strong></p>
<p><code>%[(name)][flags][width].[precision]typecode</code></p>
<p>在学习更多参数之前，我们先来回顾以下，使用百分号的最简单的用法，是怎么实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %s, I am %d.'</span> % (<span class="string">'Polar Snow'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br></pre></td></tr></table></figure>

<p>在这种多占位符的情况下，后面的括号中传入的是一个列表，根据索引，分别对应前面字符串占位符的第0个和第1个。</p>
<h2 id="name"><a href="#name" class="headerlink" title="(name)"></a>(name)</h2><p>可选，用于选择指定的key</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br></pre></td></tr></table></figure>

<p>使用这种方式的好处是显而易见的，如果一长串字符串中有N多个占位符，极有可能无法保证一一对应，而且占位符多了，很容易记混第几个占位符是干嘛的。使用这种“字典”的方式，给每个占位符起名字，赋值的时候根据名字赋值，传递的位置不需要一一对应。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, Hello %(name)s.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, Hello Polar Snow.'</span></span><br></pre></td></tr></table></figure>

<h2 id="flags"><a href="#flags" class="headerlink" title="flags"></a>flags</h2><p>可选，提供以下的值可以选择：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>对齐</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>右对齐</td>
<td>正数前加<code>+</code>，负数前加<code>-</code></td>
</tr>
<tr>
<td>-</td>
<td>左对齐</td>
<td>正数前无符号，负数前加<code>-</code></td>
</tr>
<tr>
<td>空格</td>
<td>右对齐</td>
<td>正数前加空格，负数前加<code>-</code></td>
</tr>
<tr>
<td>0</td>
<td>右对齐</td>
<td>正数前无符号，负数前加<code>-</code>，用0填充空白处</td>
</tr>
</tbody></table>
<p>对齐的特性需要<code>width</code>参数的支持</p>
<ul>
<li>+</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)+d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am +25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)+d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">-25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am -25.'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)-d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)-d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">-25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am -25.'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>空格</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age) d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [ 25].'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age) d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">-25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [-25].'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>0</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)0d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am %(age)0d.'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">-25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am -25.'</span></span><br></pre></td></tr></table></figure>

<h2 id="width"><a href="#width" class="headerlink" title="width"></a>width</h2><p>可选，占位符的宽度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age)05d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">-25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [-0025].'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age)05d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [00025].'</span></span><br></pre></td></tr></table></figure>

<p>有个宽度的设置，上面的对齐才能看出效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age)+5d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [  +25].'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age) 5d].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [   25].'</span></span><br></pre></td></tr></table></figure>

<h2 id="precision"><a href="#precision" class="headerlink" title=".precision"></a>.precision</h2><p>可选，小数点后保留的位数(还有四舍五入哦！)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is %(name)s, I am [%(age) 9.3f].'</span> % &#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25.2525252525</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am [   25.253].'</span></span><br></pre></td></tr></table></figure>

<h2 id="typecode"><a href="#typecode" class="headerlink" title="typecode"></a>typecode</h2><ul>
<li>s，获取传入对象的<strong>str</strong>方法的返回值，并将其格式化到指定位置</li>
<li>r，获取传入对象的<strong>repr</strong>方法的返回值，并将其格式化到指定位置</li>
<li>c，整数：将数字转换成其unicode对应的值，10进制范围为 0 &lt;= i &lt;= 1114111（py27则只支持0-255）；字符：将字符添加到指定位置</li>
<li>o，将整数转换成 八  进制表示，并将其格式化到指定位置</li>
<li>x，将整数转换成十六进制表示，并将其格式化到指定位置</li>
<li>d，将整数、浮点数转换成 十 进制表示，并将其格式化到指定位置</li>
<li>e，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（小写e）</li>
<li>E，将整数、浮点数转换成科学计数法，并将其格式化到指定位置（大写E）</li>
<li>f， 将整数、浮点数转换成浮点数表示，并将其格式化到指定位置（默认保留小数点后6位）<br>F，同上</li>
<li>g，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是e；）</li>
<li>G，自动调整将整数、浮点数转换成 浮点型或科学计数法表示（超过6位数用科学计数法），并将其格式化到指定位置（如果是科学计数则是E；）</li>
<li>%，当字符串中存在格式化标志时，需要用 %%表示一个百分号</li>
</ul>
<p>虽然上面列举辣么多字符类型，但是最常用的前面的例子中都已经使用过了！没错，就是<code>s</code> <code>d</code> <code>f</code>这三个货，特别提示一下，当你需要在字符串中打印<code>%</code>时，需要输入<code>%%</code>才能显示一个<code>%</code></p>
<hr>
<h1 id="format方式格式化字符串"><a href="#format方式格式化字符串" class="headerlink" title="format方式格式化字符串"></a>format方式格式化字符串</h1><p><strong>语法格式：</strong></p>
<p><code>[[fill]align][sign][#][0][width][,][.precision][type]</code></p>
<p>使用format的最简单方式格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;&#125;, I am &#123;&#125;.'</span>.format(<span class="string">'Polar Snow'</span>, <span class="number">25.2525252525</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.2525252525.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;&#125;, I am &#123;&#125;.'</span>.format(<span class="string">'Polar Snow'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;name&#125;, I am &#123;age&#125;.'</span>.format(name=<span class="string">'Polar Snow'</span>, age=<span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br></pre></td></tr></table></figure>

<p>在之前的Python笔记中，讲到参数的时候，提到过使用<code>*args, **kwargs</code>来当万能参数，包罗万象~ 而当参数为一个列表，而希望列表中的每一个元素去充当参数时，我们加上了<code>*</code>这个关键符号。区别就是如果传入参数的是一个列表，如果不加<code>*</code>，那么意味着整个列表是一个参数；而加上了<code>*</code>，则意味着将列表中的每一个元素取出充当参数。这个原理同样适用于字符串格式化，下面我们就用这种方法实现上面同样的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;&#125;, I am &#123;&#125;.'</span>.format(*[<span class="string">'Polar Snow'</span>, <span class="number">25</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;name&#125;, I am &#123;age&#125;.'</span>.format(**&#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br></pre></td></tr></table></figure>

<p>注意：只有format的方式支持加<code>*</code> <code>**</code>关键字符，使用%的方式不支持！</p>
<h2 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h2><p>可选，空白处填充的字符，需要配合width才能看出效果</p>
<h2 id="align"><a href="#align" class="headerlink" title="align"></a>align</h2><p>可选，对齐方式，需要配合width才能看出效果</p>
<ul>
<li>&lt;，内容左对齐</li>
<li><blockquote>
<p>，内容右对齐(默认)</p>
</blockquote>
</li>
<li>＝，内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。 即使：符号+填充物+数字</li>
<li>^，内容居中</li>
</ul>
<h2 id="sign"><a href="#sign" class="headerlink" title="sign"></a>sign</h2><p>可选，数字前的符号</p>
<ul>
<li>+，正号加正，负号加负；</li>
<li>-，正号不变，负号加负；</li>
<li>空格 ，正号空格，负号加负；</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title="#"></a><code>#</code></h2><p>可选，对于二进制、八进制、十六进制，如果加上#，会显示 0b/0o/0x，否则不显示</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=","></a><code>,</code></h2><p>可选，为数字添加分隔符，如：1,000,000</p>
<h2 id="width-1"><a href="#width-1" class="headerlink" title="width"></a>width</h2><p>可选，格式化占位符所占的宽度</p>
<h2 id="precision-1"><a href="#precision-1" class="headerlink" title=".precision"></a>.precision</h2><p>可选，小数位保留精度</p>
<h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>可选，格式化类型</p>
<ul>
<li>传入” 字符串类型 “的参数<ul>
<li>s，格式化字符串类型数据</li>
<li>空白，未指定类型，则默认是None，同s</li>
</ul>
</li>
<li>传入“ 整数类型 ”的参数<ul>
<li>b，将10进制整数自动转换成2进制表示然后格式化</li>
<li>c，将10进制整数自动转换为其对应的unicode字符</li>
<li>d，十进制整数</li>
<li>o，将10进制整数自动转换成8进制表示然后格式化；</li>
<li>x，将10进制整数自动转换成16进制表示然后格式化（小写x）</li>
<li>X，将10进制整数自动转换成16进制表示然后格式化（大写X）</li>
</ul>
</li>
<li>传入“ 浮点型或小数类型 ”的参数<ul>
<li>e， 转换为科学计数法（小写e）表示，然后格式化；</li>
<li>E， 转换为科学计数法（大写E）表示，然后格式化;</li>
<li>f ， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>F， 转换为浮点型（默认小数点后保留6位）表示，然后格式化；</li>
<li>g， 自动在e和f中切换</li>
<li>G， 自动在E和F中切换</li>
<li>%，显示百分比（默认显示小数点后6位）</li>
</ul>
</li>
</ul>
<h2 id="format中常用的格式化"><a href="#format中常用的格式化" class="headerlink" title="format中常用的格式化"></a>format中常用的格式化</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先从最简单的开始</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;&#125;, I am &#123;&#125;.'</span>.format(<span class="string">'Polar Snow'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line"><span class="comment"># 列表的形式传值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;&#125;, I am &#123;&#125;.'</span>.format(*[<span class="string">'Polar Snow'</span>, <span class="number">25</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line"><span class="comment"># 指定值列表的索引</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;0&#125;, I am &#123;1&#125;.'</span>.format(<span class="string">'Polar Snow'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;0&#125;, I am &#123;0&#125;.'</span>.format(<span class="string">'Polar Snow'</span>, <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am Polar Snow.'</span></span><br><span class="line"><span class="comment"># 甚至可以在嵌套中取值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;0[0]&#125;, I am &#123;0[1]&#125;.'</span>.format([<span class="string">'Polar Snow'</span>, <span class="string">'Larry'</span>], <span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am Larry.'</span></span><br><span class="line">------</span><br><span class="line"><span class="comment"># 设置占位符名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;name&#125;, I am &#123;age&#125;.'</span>.format(name=<span class="string">'Polar Snow'</span>, age=<span class="number">25</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line"><span class="comment"># 字典的形式传值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'My name is &#123;name&#125;, I am &#123;age&#125;.'</span>.format(**&#123;<span class="string">'name'</span>: <span class="string">'Polar Snow'</span>, <span class="string">'age'</span>: <span class="number">25</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'My name is Polar Snow, I am 25.'</span></span><br><span class="line">------</span><br><span class="line"><span class="comment"># format最省心的是不需要指定字符串类型，但是你也可以选择去指定</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"i am &#123;:s&#125;, age &#123;:d&#125;, money &#123;:f&#125;"</span>.format(<span class="string">"seven"</span>, <span class="number">25</span>, <span class="number">88888.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'i am seven, age 25, money 88888.100000'</span></span><br><span class="line"><span class="comment"># 保留两位小数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"i am &#123;:s&#125;, age &#123;:d&#125;, money &#123;:.2f&#125;"</span>.format(<span class="string">"seven"</span>, <span class="number">25</span>, <span class="number">88888.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'i am seven, age 25, money 88888.10'</span></span><br><span class="line"><span class="comment"># 保留两位小数并在数字中用,分隔</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"i am &#123;:s&#125;, age &#123;:d&#125;, money &#123;:,.2f&#125;"</span>.format(<span class="string">"seven"</span>, <span class="number">25</span>, <span class="number">88888.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'i am seven, age 25, money 88,888.10'</span></span><br><span class="line">------</span><br><span class="line"><span class="comment"># 居中显示，插入[]是为了展示居中的效果更直观</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"i am &#123;:s&#125;, age [&#123;:^10d&#125;], money &#123;:,.2f&#125;"</span>.format(<span class="string">"seven"</span>, <span class="number">25</span>, <span class="number">88888.1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'i am seven, age [    25    ], money 88,888.10'</span></span><br><span class="line">------</span><br><span class="line"><span class="comment"># 数字的展示</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"numbers: &#123;0:b&#125;,&#123;0:o&#125;,&#123;0:d&#125;,&#123;0:x&#125;,&#123;0:X&#125;, &#123;0:%&#125;"</span>.format(<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'numbers: 1111,17,15,f,F, 1500.000000%'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"numbers: &#123;num:b&#125;,&#123;num:o&#125;,&#123;num:d&#125;,&#123;num:x&#125;,&#123;num:X&#125;, &#123;num:%&#125;"</span>.format(num=<span class="number">15</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'numbers: 1111,17,15,f,F, 1500.000000%'</span></span><br></pre></td></tr></table></figure>

<p>如果以上这些还不能满足你的需求，请移步Python官方文档：<a href="https://docs.python.org/3/library/string.html" target="_blank" rel="noopener">Python Docs 4 String Format</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>format</tag>
        <tag>字符串格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内置函数详解</title>
    <url>/2016/06/03/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="http://oss.20150509.cn/Snip20160603_1.png" alt=""></p>
<h1 id="abs-x"><a href="#abs-x" class="headerlink" title="abs(x)"></a>abs(x)</h1><p>abs函数用来返回参数的绝对值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-59</span>)</span><br><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="all-iterable"><a href="#all-iterable" class="headerlink" title="all(iterable)"></a>all(iterable)</h1><p>all函数接收一个可迭代的对象作为参数，所有元素均为真则返回真</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">True</span>]</span><br><span class="line">print(all(l1))</span><br><span class="line"></span><br><span class="line">l2 = [<span class="number">0</span>, <span class="string">'1'</span>, <span class="literal">True</span>]</span><br><span class="line">print(all(l2))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment">#0为假，可迭代对象中只要全为真才返回为真</span></span><br></pre></td></tr></table></figure>

<p>相当于做了如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>


<h1 id="any-iterable"><a href="#any-iterable" class="headerlink" title="any(iterable)"></a>any(iterable)</h1><p>any函数接收一个可迭代的对象作为参数，只要有一个元素为真即返回为真</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">1</span>, <span class="string">'1'</span>, <span class="literal">True</span>]</span><br><span class="line">print(any(l1))</span><br><span class="line"></span><br><span class="line">l2 = [<span class="number">0</span>, <span class="string">'1'</span>, <span class="literal">True</span>]</span><br><span class="line">print(any(l2))</span><br><span class="line"></span><br><span class="line">l3 = [<span class="number">0</span>, <span class="string">''</span>, <span class="literal">False</span>]</span><br><span class="line">print(any(l3))</span><br><span class="line"></span><br><span class="line">-----------</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>相当于做了如下操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">any</span><span class="params">(iterable)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> iterable:</span><br><span class="line">        <span class="keyword">if</span> element:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="all-iterable-与-any-iterable-的区别"><a href="#all-iterable-与-any-iterable-的区别" class="headerlink" title="all(iterable) 与 any(iterable) 的区别"></a>all(iterable) 与 any(iterable) 的区别</h2><ul>
<li>all(iterable) 可迭代的参数对象中，只要有一个值为假，则立即返回<code>False</code>，所有值都为真才返回为<code>True</code></li>
<li>any(iterable) 可迭代的参数对象中，只要有一个值为真，则立即返回<code>True</code>，所有值都为假才返回<code>False</code></li>
</ul>
<hr>
<h1 id="ascii-object"><a href="#ascii-object" class="headerlink" title="ascii(object)"></a>ascii(object)</h1><p>ascii 自动执行对象的<code>__repr__</code>方法</p>
<p>这个函数跟<code>repr()</code>函数一样，返回一个可打印的对象字符串方式表示。</p>
<p>当遇到非ASCII码时，就会输出<code>\x</code> <code>\u</code>或<code>\U</code>等字符来表示。</p>
<p>与Python 2版本里的repr()是等效的函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">c</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'repr'</span></span><br><span class="line"></span><br><span class="line">print(ascii(c()))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">repr</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">"'\\u6781\\u5730\\u745e\\u96ea'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="string">"'Polar Snow'"</span></span><br></pre></td></tr></table></figure>

<h1 id="repr-object"><a href="#repr-object" class="headerlink" title="repr(object)"></a>repr(object)</h1><p>而repr(object)转化为供<code>解释器</code>读取的字符串形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">"'极地瑞雪'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="string">"'Polar Snow'"</span></span><br></pre></td></tr></table></figure>


<h1 id="str-object-’’"><a href="#str-object-’’" class="headerlink" title="str(object=’’)"></a>str(object=’’)</h1><p><strong>class str(object=b’’, encoding=’utf-8’, errors=’strict’)</strong></p>
<p>函数str(object=’’)用于将值转化为适于<code>人</code>阅读的<code>字符串</code>形式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">'极地瑞雪'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="string">'Polar Snow'</span></span><br></pre></td></tr></table></figure>

<h2 id="ascii-object-与-repr-object-的区别"><a href="#ascii-object-与-repr-object-的区别" class="headerlink" title="ascii(object) 与 repr(object) 的区别"></a>ascii(object) 与 repr(object) 的区别</h2><blockquote>
<p>两者的作用都是将对象转化为字符串</p>
</blockquote>
<ul>
<li>ascii()方法返回的字符串为非ascii码能表示的字符时，使用\x, \u or \U来表示</li>
<li>repr()方法返回对<code>Python解释器</code>友好的字符串格式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">"'\\u6781\\u5730\\u745e\\u96ea'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="string">"'Polar Snow'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ascii(<span class="number">59</span>)</span><br><span class="line"><span class="string">'59'</span></span><br><span class="line">------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">"'极地瑞雪'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"'Polar Snow'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="number">59</span>)</span><br><span class="line"><span class="string">'59'</span></span><br></pre></td></tr></table></figure>

<h2 id="repr-object-与-str-object-’’-的区别"><a href="#repr-object-与-str-object-’’-的区别" class="headerlink" title="repr(object) 与 str(object=’’) 的区别"></a>repr(object) 与 str(object=’’) 的区别</h2><blockquote>
<p>两者的作用都是将对象转化为字符串</p>
</blockquote>
<ul>
<li>repr()方法返回对<code>Python解释器</code>友好的字符串格式</li>
<li>str()方法返回对<code>人阅读</code>友好的字符串格式</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">"'极地瑞雪'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"'Polar Snow'"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="number">59</span>)</span><br><span class="line"><span class="string">'59'</span></span><br><span class="line">------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">'极地瑞雪'</span>)</span><br><span class="line"><span class="string">'极地瑞雪'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">'Polar Snow'</span>)</span><br><span class="line"><span class="string">'Polar Snow'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="number">59</span>)</span><br><span class="line"><span class="string">'59'</span></span><br></pre></td></tr></table></figure>

<ul>
<li><a href="http://www.oschina.net/translate/difference-between-str-and-repr-in-python" target="_blank" rel="noopener">更详细的区别可以参考这篇文章</a></li>
</ul>
<hr>
<h1 id="bin-x"><a href="#bin-x" class="headerlink" title="bin(x)"></a>bin(x)</h1><p>bin(x) 接收一个十进制,返回二进制 0b</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">59</span>)</span><br><span class="line"><span class="string">'0b111011'</span></span><br></pre></td></tr></table></figure>

<h1 id="oct-x"><a href="#oct-x" class="headerlink" title="oct(x)"></a>oct(x)</h1><p>oct(x) 接收一个十进制,返回八进制 0o</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">59</span>)</span><br><span class="line"><span class="string">'0o73'</span></span><br></pre></td></tr></table></figure>

<h1 id="hex-x"><a href="#hex-x" class="headerlink" title="hex(x)"></a>hex(x)</h1><p>hex(x) 接收一个十进制,返回十六进制 0x</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">59</span>)</span><br><span class="line"><span class="string">'0x3b'</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="bool-x"><a href="#bool-x" class="headerlink" title="bool([x])"></a>bool([x])</h1><p>bool([x]) 判断元素真假, 以下元素为常出现的假元素：</p>
<ul>
<li>0</li>
<li>‘’</li>
<li>[]</li>
<li>()</li>
<li>{}</li>
<li>set()</li>
<li>False</li>
</ul>
<hr>
<h1 id="bytes"><a href="#bytes" class="headerlink" title="bytes"></a>bytes</h1><p>betes() 把指定的字符串转换为字节类型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes(<span class="string">'极地瑞雪'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'\xe6\x9e\x81\xe5\x9c\xb0\xe7\x91\x9e\xe9\x9b\xaa'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">b'\xe6\x9e\x81\xe5\x9c\xb0\xe7\x91\x9e\xe9\x9b\xaa'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'极地瑞雪'</span></span><br><span class="line">------------</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes(<span class="string">'极地瑞雪'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line"><span class="string">b'\xbc\xab\xb5\xd8\xc8\xf0\xd1\xa9'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(<span class="string">b'\xbc\xab\xb5\xd8\xc8\xf0\xd1\xa9'</span>, encoding=<span class="string">'gbk'</span>)</span><br><span class="line"><span class="string">'极地瑞雪'</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一个汉字使用utf-8编码的话占用三个字节,使用gbk编码的话占用两个字节</p>
</blockquote>
<ul>
<li>打开文件乱码实况再现:</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">u = bytes(<span class="string">'吕瑞'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">s = str(u, encoding=<span class="string">'gbk'</span>)</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">######运行结果</span></span><br><span class="line">鍚曠憺</span><br></pre></td></tr></table></figure>

<p><strong>如果一个文件是以utf-8的编码方式保存,每三个字节是一个汉字,再同样以utf-8的方式读取,会正确的按照3个字节一个汉字去读取文件,而如果以gbk的方式读取文件,会按照两个字节一个汉字的方式读取,所以会产生乱码的情况</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                        极地瑞雪(UTF-8)</span><br><span class="line">二进制:    11100110 10011110 10000001 11100101 10011100 10110000 11100111 10010001 10011110 11101001 10011011 10101010</span><br><span class="line">十进制:    230 158 129 229 156 176 231 145 158 233 155 170</span><br><span class="line">十六进制:   e6 9e 81 e5 9c b0 e7 91 9e e9 9b aa</span><br><span class="line"></span><br><span class="line">注意：二进制的表现形式为字节</span><br></pre></td></tr></table></figure>

<ul>
<li>用香来表示精确数字的小故事(二进制转十进制)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一支香有两种状态,点燃的情况和熄灭的情况</span><br><span class="line">现在定义:香熄灭[I]的状态表示0,点燃[i]的情况表示为1</span><br><span class="line">0:  那么我现在要表示0,很简单,一支香足够,熄灭就行了--[I]</span><br><span class="line">                                               0</span><br><span class="line">1:  一支香足够,点燃即可--[i]</span><br><span class="line">                       1</span><br><span class="line">2:  一支香最多只能表示到1,如果要表示2,需要在前面加一支香来表示2,这样我只需点燃头一支香即可表示2--[iI]</span><br><span class="line">                                                                                      10</span><br><span class="line">3: 两支香的话,第一支表示2,第一支最多表示1,只需将第二支点燃即可表示3--[ii]</span><br><span class="line">                                                              11</span><br><span class="line">4: 两支香最大可表示到3,现在需要加第三支香来表示4--[iII]</span><br><span class="line">                                             100</span><br><span class="line">5: 以此类推--[iIi]</span><br><span class="line">             101</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关系图:</span><br><span class="line">        最大表示:1</span><br><span class="line">0:             [I]</span><br><span class="line">           状态:0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:1</span><br><span class="line">1:             [i]</span><br><span class="line">           状态:1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:2 1</span><br><span class="line">2:             [i I]</span><br><span class="line">           状态:1 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:2 1</span><br><span class="line">3:             [i i]</span><br><span class="line">           状态:1 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:4 2 1</span><br><span class="line">4:             [i I I]</span><br><span class="line">           状态:1 0 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:4 2 1</span><br><span class="line">5:             [i I i]</span><br><span class="line">           状态:1 0 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:4 2 1</span><br><span class="line">6:             [i i I]</span><br><span class="line">           状态:1 1 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:4 2 1</span><br><span class="line">7:             [i i i]</span><br><span class="line">           状态:1 1 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">8:             [i I I I]</span><br><span class="line">           状态:1 0 0 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">9:             [i I I i]</span><br><span class="line">           状态:1 0 0 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">10:            [i I i I]</span><br><span class="line">           状态:1 0 1 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">11:            [i I i i]</span><br><span class="line">           状态:1 0 1 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">12:            [i i I I]</span><br><span class="line">           状态:1 1 0 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">13:            [i i I i]</span><br><span class="line">           状态:1 1 0 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">14:            [i i i I]</span><br><span class="line">           状态:1 1 1 0</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:8 4 2 1</span><br><span class="line">15:            [i i i i]</span><br><span class="line">           状态:1 1 1 1</span><br><span class="line">-------------------</span><br><span class="line">        最大表示:16 8 4 2 1</span><br><span class="line">16:             [i I I I I]</span><br><span class="line">            状态:1 0 0 0 0</span><br><span class="line">-------------------</span><br><span class="line">……以此类推</span><br><span class="line">从2开始,每翻一番就多一支香来表示</span><br><span class="line">4(2支),8(3支),16(4支)都增加了一支香类表示</span><br><span class="line">32(5支),64(6支),128(7支),256(8支),512(9支),1024(10支)</span><br><span class="line">也可以把&quot;支&quot;换成&quot;2的x次方&quot;--&gt; 2的10次方&#x3D;1024</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="callable-object"><a href="#callable-object" class="headerlink" title="callable(object)"></a>callable(object)</h1><p>callable(object) 检查对象是否可以被执行调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># f1()</span></span><br><span class="line"></span><br><span class="line">f2 = <span class="number">123</span></span><br><span class="line"><span class="comment"># f2()</span></span><br><span class="line"></span><br><span class="line">print(callable(f1))</span><br><span class="line">print(callable(f2))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="chr-i"><a href="#chr-i" class="headerlink" title="chr(i)"></a>chr(i)</h1><p>chr(i) 将数字转换为字符</p>
<p>Python3中，chr() 不仅包含ascii的对照表，还包含了Unicode对照表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">59</span>)</span><br><span class="line"><span class="string">';'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">8364</span>)</span><br><span class="line"><span class="string">'€'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">201559</span>)</span><br><span class="line"><span class="string">'\U00031357'</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="classmethod-function"><a href="#classmethod-function" class="headerlink" title="classmethod(function)"></a>classmethod(function)</h1><p>classmethod(function) 是一个装饰器函数，一般会使用<code>@classmethod</code>的方式来调用，用来表示下面的方法是<code>类方法</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls, arg1, arg2, ...)</span>:</span> ...</span><br></pre></td></tr></table></figure>

<p>代码实例：<a href="http://www.pythontab.com/html/2013/hanshu_0129/186.html" target="_blank" rel="noopener">参考自Pythontab</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">... </span>    @classmethod</span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">"This is a class method"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.f()</span><br><span class="line">This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c.f()</span><br><span class="line">This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">class</span> <span class="title">D</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">print</span> <span class="string">" This is not a class method "</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.f()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: unbound method f() must be called <span class="keyword">with</span> D instance <span class="keyword">as</span> first argument (got nothing instead)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = D()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.f()</span><br><span class="line">This <span class="keyword">is</span> <span class="keyword">not</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure>

<h1 id="staticmethod-function"><a href="#staticmethod-function" class="headerlink" title="staticmethod(function)"></a>staticmethod(function)</h1><p>staticmethod(function) 是一个装饰器函数， 一般会使用<code>@staticmethod</code>的方式来调用，用来表示下面的方法的<code>静态方法</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(arg1, arg2, ...)</span>:</span> ...</span><br></pre></td></tr></table></figure>

<h2 id="classmethod-function-staticmethod-function-和实例方法的区别"><a href="#classmethod-function-staticmethod-function-和实例方法的区别" class="headerlink" title="classmethod(function) / staticmethod(function) 和实例方法的区别"></a>classmethod(function) / staticmethod(function) 和实例方法的区别</h2><blockquote>
<p>实例的方法针对的是具体某一实例化对象的方法；类方法针对的是某一类的方法；静态方法可以与类或实例化无关</p>
</blockquote>
<ul>
<li>类方法：<ul>
<li>类方法的第一个参数是<code>class</code></li>
<li>类方法可以通过类直接调用，不需要传递实例的引用</li>
<li>默认将该class对象（不是class实例化对象）隐式的传递给方法</li>
</ul>
</li>
<li>静态方法：<ul>
<li>静态方法可以认为是全局函数</li>
<li>静态方法可以用类调用，也可以用对象调用</li>
<li>不会隐式的传入任何参数</li>
</ul>
</li>
<li>实例方法：<ul>
<li>实例方法的第一个参数是<code>self</code></li>
<li>实例方法必须通过实例化的对象去调用（Python3可以传递任意对象，Python2中会报错）</li>
<li>默认将该实例化对象隐式的传递给方法</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span>    <span class="comment">#定义了实例方法</span></span><br><span class="line">        print(<span class="string">"object"</span>)</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(clss)</span>:</span>    <span class="comment">#定义了类方法</span></span><br><span class="line">        print(<span class="string">"class"</span>)</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test3</span><span class="params">()</span>:</span>    <span class="comment">#定义了静态方法</span></span><br><span class="line">        print(<span class="string">"static"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实例方法的调用方式</span></span><br><span class="line"><span class="comment"># 第一种方式，先生成对象（先实例化）再调用</span></span><br><span class="line">f1 = Foo()</span><br><span class="line">f1.test()</span><br><span class="line"><span class="comment"># 第二种方式，自己传递实例的引用</span></span><br><span class="line">Foo.test(f1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类方法的调用方式</span></span><br><span class="line"><span class="comment"># 可以直接使用类来调用,不需要传递实例的引用</span></span><br><span class="line">Foo.test2()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法的调用方式</span></span><br><span class="line"><span class="comment"># 第一种方式,使用实例化对象来调用静态方法</span></span><br><span class="line">f3 = Foo()</span><br><span class="line">f3.test3()</span><br><span class="line"><span class="comment"># 第二种方式,使用类来调用静态方法</span></span><br><span class="line">Foo.test3()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">object</span><br><span class="line">object</span><br><span class="line"><span class="class"><span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">static</span></span></span><br><span class="line"><span class="class"><span class="title">static</span></span></span><br></pre></td></tr></table></figure>




<p>代码实例：<a href="http://genggeng.iteye.com/blog/1290458" target="_blank" rel="noopener">参考自ITEYE</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"init"</span>  </span><br><span class="line"> </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayHello</span><span class="params">(hello)</span>:</span>  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hello:  </span><br><span class="line">            hello=<span class="string">'hello'</span>  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"i will sya %s"</span> %hello  </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">    @classmethod  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">introduce</span><span class="params">(clazz,hello)</span>:</span>  </span><br><span class="line">        clazz.sayHello(hello)  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"from introduce method"</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self,hello)</span>:</span>  </span><br><span class="line">        self.sayHello(hello)  </span><br><span class="line">        <span class="keyword">print</span> <span class="string">"from hello method"</span>         </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>  </span><br><span class="line">    Person.sayHello(<span class="string">"haha"</span>)  </span><br><span class="line">    Person.introduce(<span class="string">"hello world!"</span>)  </span><br><span class="line">    <span class="comment">#Person.hello("self.hello") #TypeError: unbound method hello() must be called with Person instance as first argument (got str instance instead)  </span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">print</span> <span class="string">"*"</span> * <span class="number">20</span>  </span><br><span class="line">    p = Person()  </span><br><span class="line">    p.sayHello(<span class="string">"haha"</span>)  </span><br><span class="line">    p.introduce(<span class="string">"hello world!"</span>)  </span><br><span class="line">    p.hello(<span class="string">"self.hello"</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:  </span><br><span class="line">    main() </span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">i will sya haha  </span><br><span class="line">i will sya hello world!  </span><br><span class="line"><span class="keyword">from</span> introduce method  </span><br><span class="line">********************  </span><br><span class="line">init  </span><br><span class="line">i will sya haha  </span><br><span class="line">i will sya hello world!  </span><br><span class="line"><span class="keyword">from</span> introduce method  </span><br><span class="line">i will sya self.hello  </span><br><span class="line"><span class="keyword">from</span> hello method </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment"># compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)</span></span><br><span class="line"></span><br><span class="line">compile(source, filename, mode, flags=<span class="number">0</span>, dont_inherit=<span class="literal">False</span>, optimize=<span class="number">-1</span>) 把字符串编译成Pythontab代码，编译后可以通过`eval()`或`exec()`来执行</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">s = <span class="string">"print(123)"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译，single，eval，exec</span></span><br><span class="line"><span class="comment"># 将字符串编译成python代码</span></span><br><span class="line">r = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">"exec"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行python代码</span></span><br><span class="line">exec(r)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><code>print(123)</code>和<code>&#39;print(123)&#39;</code>的区别是，前者可以被Python解释器自动编译执行，而后者只是个字符串而已。如果想让后面的字符串去单过Python的命令的去执行，第一步就是先手动将该字符串进行编译，编译后的对象保存在内存中，可以被<code>eval()</code>或<code>exec()</code>来执行</p>
<p><strong>mode参数有三个：</strong></p>
<ul>
<li>single: 执行单条语句  —&gt; exec()</li>
<li>exec: 可以执行多条语句  —&gt; exec()</li>
<li>evel: 进行表达式计算  —&gt; evel()</li>
</ul>
<h1 id="eval-expression-globals-None-locals-None"><a href="#eval-expression-globals-None-locals-None" class="headerlink" title="eval(expression, globals=None, locals=None)"></a>eval(expression, globals=None, locals=None)</h1><p>eval(expression, globals=None, locals=None) 执行参数中的表达式并返回结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(<span class="string">'x+1'</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>eval() 函数同样可以处理compile()函数生成的对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(eval(<span class="string">'5 * 9'</span>))</span><br><span class="line"></span><br><span class="line">s = <span class="string">'5 * 9'</span></span><br><span class="line">ret = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">'eval'</span>)</span><br><span class="line">print(eval(ret))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">45</span></span><br><span class="line"><span class="number">45</span></span><br></pre></td></tr></table></figure>

<h1 id="exec-object-globals-locals"><a href="#exec-object-globals-locals" class="headerlink" title="exec(object[, globals[, locals]])"></a>exec(object[, globals[, locals]])</h1><p>exec(object[, globals[, locals]]) 执行参数中的命令，返回值为None（区别于eval，eval是计算，计算就需要有返回值返回计算结果）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ret = exec(<span class="string">'print(123)'</span>)</span><br><span class="line">print(ret)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>exec() 函数处理compile()函数生成的对象—mod:single—处理单行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'print(123)'</span></span><br><span class="line">ret = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">'single'</span>)</span><br><span class="line">print(exec(ret))    <span class="comment">#返回值为None</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>exec() 函数处理compile()函数生成的对象—mod:single—处理多行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'for i in range(5): print(i)'</span></span><br><span class="line">ret = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">'single'</span>)</span><br><span class="line">print(exec(ret))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/4/test.py"</span>, line <span class="number">43</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    ret = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">'single'</span>)</span><br><span class="line">  File <span class="string">"&lt;string&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>): print(i)</span><br><span class="line">                              ^</span><br><span class="line">SyntaxError: unexpected EOF <span class="keyword">while</span> parsing</span><br><span class="line"><span class="comment"># single 模式无法处理多行命令，应该使用 exec模式</span></span><br></pre></td></tr></table></figure>

<p>exec() 函数处理compile()函数生成的对象—mod:exec—处理多行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'for i in range(5): print(i)'</span></span><br><span class="line">ret = compile(s, <span class="string">"&lt;string&gt;"</span>, <span class="string">'exec'</span>)</span><br><span class="line">print(exec(ret))    <span class="comment">#返回值为None</span></span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure>

<p>代码实例：<a href="http://www.pythoner.com/56.html" target="_blank" rel="noopener">参考Pythoner</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval_code = compile( <span class="string">'1+2'</span>, <span class="string">''</span>, <span class="string">'eval'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval_code</span><br><span class="line">&lt;code object &lt;module&gt; at <span class="number">0142</span>ABF0, file <span class="string">""</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>eval(eval_code)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>single_code = compile( <span class="string">'print "pythoner.com"'</span>, <span class="string">''</span>, <span class="string">'single'</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>single_code</span><br><span class="line">&lt;code object &lt;module&gt; at <span class="number">01</span>C68848, file <span class="string">""</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(single_code)</span><br><span class="line">pythoner.com</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec_code = compile( <span class="string">"""for i in range(5):</span></span><br><span class="line"><span class="string"><span class="meta">... </span>  print "iter time: %d" % i"""</span>, <span class="string">''</span>, <span class="string">'exec'</span> )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec_code</span><br><span class="line">&lt;code object &lt;module&gt; at <span class="number">01</span>C68968, file <span class="string">""</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(exec_code)</span><br><span class="line">iter time: <span class="number">0</span></span><br><span class="line">iter time: <span class="number">1</span></span><br><span class="line">iter time: <span class="number">2</span></span><br><span class="line">iter time: <span class="number">3</span></span><br><span class="line">iter time: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<h1 id="Python反射相关"><a href="#Python反射相关" class="headerlink" title="Python反射相关"></a>Python反射相关</h1><ul>
<li>delattr()</li>
<li>hasattr()</li>
<li>getattr()</li>
<li>setattr()</li>
<li>__import__()</li>
</ul>
<p>详细介绍请<a href="http://docs.20150509.cn/2016/06/16/Python反射详解/" target="_blank" rel="noopener">点击这里查看</a></p>
<h1 id="未整理完的内建函数"><a href="#未整理完的内建函数" class="headerlink" title="未整理完的内建函数"></a>未整理完的内建函数</h1><ol>
<li>bytearray()</li>
<li>complex()</li>
<li>dict()</li>
<li>dir()</li>
<li>divmod()</li>
<li>enumerate()</li>
<li>filter()</li>
<li>float()</li>
<li>format()</li>
<li>frozenset()</li>
<li>globals()</li>
<li>hash()</li>
<li>help()</li>
<li>id()</li>
<li>input()</li>
<li>int()</li>
<li>isinstance()</li>
<li>issubclass()</li>
<li>iter()</li>
<li>len()</li>
<li>list()</li>
<li>locals()</li>
<li>map()</li>
<li>max()</li>
<li>memoryview()</li>
<li>min()</li>
<li>next()</li>
<li>object()</li>
<li>open()</li>
<li>pow()</li>
<li>print()</li>
<li>property()</li>
<li>range()</li>
<li>reversed()</li>
<li>round()</li>
<li>set()</li>
<li>slice()</li>
<li>sorted()</li>
<li>sum()</li>
<li>super()</li>
<li>tuple()</li>
<li>type()</li>
<li>vars()</li>
<li>zip()</li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python标准库</tag>
        <tag>Python内建函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes入门简介</title>
    <url>/2016/05/31/Kubernetes%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>Kubernetes是谷歌开源的一款大规模容器管理平台，在介绍这一平台之前，先跟大家讨论一下这个单词的读法！实际上，这个单词你在英文词典上根本查不着，因为它不是一个“英文单词”，Kubernetes，古希腊语是舵手的意思，是Cyber的词源。根据其拼写，我习惯称呼它为“k8s”</p>
</blockquote>
<h1 id="国内哪些公司在大规模的使用Kubernetes"><a href="#国内哪些公司在大规模的使用Kubernetes" class="headerlink" title="国内哪些公司在大规模的使用Kubernetes"></a>国内哪些公司在大规模的使用Kubernetes</h1><ul>
<li><p>滴滴</p>
</li>
<li><p>网宿</p>
</li>
</ul>
<h1 id="Kubernetes是什么"><a href="#Kubernetes是什么" class="headerlink" title="Kubernetes是什么"></a>Kubernetes是什么</h1><p>Kubernetes是Google开源的容器集群管理系统。它构建在Docker之上，为容器话的应用提供资源调度、部署运行、服务发现、扩容缩容等一整套功能，本质上可以看做是基于容器技术的Micro-PaaS平台，是第三代PaaS技术的代表之作。</p>
<p>Google从2004年开始就已经开始在使用容器技术了，于2006年发布了Cgroup，而且内部开发的强大的集群资源管理平台Borg和Omega，这些都已经广泛用在Google的各个基础设施中，而Kubernetes得灵感来源于Google内部的Borg系统，更是吸收了包括Omega在内的容器管理器的经验和教训。</p>
<p>Kubernetes有着以下优秀的特性：</p>
<ul>
<li><p>强大的容器编排能力</p>
<p>Kubernetes可以说是同Docker一起发展起来的，深度集成了Docker，天然适应容器的特点，设计出强大的容器编排能力，比如容器组合、标签选择和服务发现等，可以满足企业级的需求</p>
</li>
<li><p>轻量级</p>
<p>Kubernetes遵循微服务架构理论，整个系统划分出各个功能独立的组件，组件之间边界清晰，部署简单，可以轻易地运行在各种系统和环境中。同时Kubernetes中的许多功能都实现了插件化，可以非常方便地进行扩展和替换。</p>
</li>
<li><p>开放 开源</p>
<p>Kubernetes顺应了开放开源的趋势，吸引了大批开发者和公司参与其中，协同工作，共同构建生态圈。同时，Kubernetes同Openstack、Docker等开源社区积极合作、共同发展</p>
</li>
</ul>
<h1 id="Kubernetes的发展史"><a href="#Kubernetes的发展史" class="headerlink" title="Kubernetes的发展史"></a>Kubernetes的发展史</h1><p>Kubernetes自推出之后就迅速获得极高的关注与参与，2015年7月经过400多位贡献者一年的努力，多达14000次代码的提交，Google正式对外发布了Kubernetes v1.0，意味着这个开源容器编排系统可以正式在生产环境中使用。</p>
<ul>
<li><p>2014年6月：谷歌宣布Kubernetes开源</p>
</li>
<li><p>2014年7月：MicroSoft、RedHat、IBM、Docker、CoreOS、Mesosphere、Saltstack加入到Kubernetes社区</p>
</li>
<li><p>2014年8月：Mesosphere宣布将Kubernetes作为框架整合到Mesosphere生态系统中，用于Docker容器集群的调度、部署和管理</p>
</li>
<li><p>2014年8月：VMware加入Kubernetes社区</p>
</li>
<li><p>2014年11月：HP加入Kubernetes社区</p>
</li>
<li><p>2014年11月：Google容器引擎Alpha启动</p>
</li>
<li><p>2015年1月：Kubernetes被引入到Openstack</p>
</li>
<li><p>2015年4月：Google和CoreOS联合发布Tectonic，它将Kubernetes和CoreOS软件栈整合到了一起</p>
</li>
<li><p>2015年5月：Intel加入到Kubernetes社区</p>
</li>
<li><p>2015年6月：Google容器进入到beta版</p>
</li>
<li><p>2015年7月：Kubernetes v1.0版本正式发布</p>
</li>
</ul>
<h1 id="Kubernetes的核心概念"><a href="#Kubernetes的核心概念" class="headerlink" title="Kubernetes的核心概念"></a>Kubernetes的核心概念</h1><h2 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h2><p>Pod是若干相关容器的组合，Pod包含的容器运行在同一台宿主机上，这些容器使用相同的网络命名空间、IP地址和端口，相互之间能通过localhost来发现和通信。这些容器还可以共享一块存储卷空间。在Kubernetes中创建、调度和管理的最小单元就是Pod，而不是容器，Pod通过更高层次的抽象，提供了更加灵活的部署和管理模式。</p>
<h2 id="Replication-Controller"><a href="#Replication-Controller" class="headerlink" title="Replication Controller"></a>Replication Controller</h2><p>Replication Controller用来控制管理Pod副本，它确保任何时候Kubernetes集群中有指定数量的Pod副本在运行。如果少于指定数量的Pod副本，它会启动新的Pod副本，反之它会杀死多余的副本以保证数量不变。而且，Replication Controller是弹性伸缩、滚动升级的实现核心</p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service是真实应用服务的抽象，定义了Pod的逻辑集合和访问这个Pod集合的策略。Service将代理Pod对外表现为一个单一的访问接口，外部不需要了解后端Pod是如何运行的，这给扩展和维护带来很多好处，提供了一套简化的服务代理和发现机制</p>
<h2 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h2><p>Label是用于区分Pod、Service、Replication Controller和Key/Value对，实际上，Kubernetes中的任意API对象都可以通过Label进行标识。每个API对象可以有多个Label，但是每个Label的Key只能对应一个Value。Label是Service和Replication Controller运行的基础，他们都通过Label来关联Pod，相比于强绑定模型，这是一种非常好的松耦合关系。</p>
<h2 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h2><p>Kubernetes属于主从分布式集群架构，Kubernetes Node运行并管理容器。Node作为Kubernetes的操作单元，用来分配给Pod进行绑定，Pod最终运行在Node上，Node可以认为是Pod的宿主机</p>
<hr>
<p><strong>在接下来的章节中，我将以《Kubernetes的官方文档》以及《Kubernetes实战》为依据，跟大家分享Kubernetes的架构、部署和应用</strong></p>
<p><a href="http://kubernetes.io" target="_blank" rel="noopener">Kubernetes官方网站：http://kubernetes.io</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器详解</title>
    <url>/2016/05/31/Python%E8%A3%85%E9%A5%B0%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章讨论Python的装饰器，Python装饰器帮助我们在不改变函数内部结构的情况下，对函数功能进行扩展，接下来进入正题，在讨论装饰器之前，先拿函数定义的原理抛砖引玉</p>
<p>Python version: 3.5+</p>
</blockquote>
<h1 id="函数定义的原理"><a href="#函数定义的原理" class="headerlink" title="函数定义的原理"></a>函数定义的原理</h1><p>在Python中通过<code>def fun_name(): pass</code>来定义一个函数。那么在这个小函数中，<code>fun_name</code>是函数的名字，<code>pass</code>是函数体。我们通常会说，Python在解释代码时，会把<code>pass</code>函数体放在内存中，并在内存中用<code>fun_name</code>去指向<code>pass</code>函数体。</p>
<p>话是这么说没错，但对于初学者来说，同样都是放在内存中，为啥还要指来指去的呢？具体来说，函数名在内存存放的地区是<code>栈区</code>，函数体在内存中存放的地区是<code>堆区</code>，存在栈区的函数名会指向存在堆区的函数体。在前面的Python学习笔记中，提到的两大数据类型的分类，一个是<code>基本数据类型</code>，一个是<code>引用数据类型</code>，所有的<code>引用数据类型</code>的名字都是压在了<code>栈区</code>，其对应的对象,都是存在了<code>堆区</code>。所以关于指向的问题，并不在内存中胡乱去指的~~</p>
<p><img src="http://oss.20150509.cn/QQ20160530-0@2x.png" alt=""></p>
<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><h2 id="装饰器前传"><a href="#装饰器前传" class="headerlink" title="装饰器前传"></a>装饰器前传</h2><p>现有如下程序猿代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br></pre></td></tr></table></figure>

<p>现在老板需求是：在打印输出前，先输出<code>loading...</code></p>
<p>于是程序猿做出如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br></pre></td></tr></table></figure>

<p>老板觉得，打印输入后输出<code>Done</code>更好</p>
<p>于是程序猿又去修改代码了~~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line">  print(<span class="string">'Done'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  print(<span class="string">'Done'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'loading...'</span>)</span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br><span class="line">  print(<span class="string">'Done'</span>)</span><br></pre></td></tr></table></figure>

<p>之后老板又觉得……</p>
<hr>
<p><strong>有了装饰器后</strong></p>
<p>还是上面的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br></pre></td></tr></table></figure>

<p>如果使用了装饰器实现loading的需求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'loading...'</span>)</span><br><span class="line">    func()</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br></pre></td></tr></table></figure>

<p>使用装饰器实现Done的需求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'loading...'</span>)</span><br><span class="line">    func()</span><br><span class="line">    print(<span class="string">'Done'</span>)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br></pre></td></tr></table></figure>

<p>从上面简单的例子可以看出，使用<code>装饰器</code>可以在不改变原函数的情况下，对原函数的功能进行扩展！</p>
<h2 id="装饰器预热"><a href="#装饰器预热" class="headerlink" title="装饰器预热"></a>装饰器预热</h2><p>在详解装饰器前，我们还需要强调一个很重要的概念，就是函数的调用！</p>
<p>函数怎么调用？函数名后面跟了小括号就是调用，不加括号就不调用！</p>
<p>重要的事情说三遍！！！</p>
<ol>
<li>函数名后面跟了小括号就是调用，不加括号就不调用！</li>
<li>函数名后面跟了小括号就是调用，不加括号就不调用！</li>
<li>函数名后面跟了小括号就是调用，不加括号就不调用！</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'我被调用了'</span>)</span><br><span class="line"></span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">我被调用了</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'我被调用了'</span>)</span><br><span class="line"></span><br><span class="line">func</span><br><span class="line"></span><br><span class="line">------------</span><br></pre></td></tr></table></figure>
<p>下面的小程序只写了函数名，后没有跟括号，该函数被加载到内存，但是没有被调用！在学习装饰器之前，一定要清楚什么时候加括号什么时候不加括号</p>
<h2 id="装饰器解析"><a href="#装饰器解析" class="headerlink" title="装饰器解析"></a>装饰器解析</h2><h3 id="装饰器的创建"><a href="#装饰器的创建" class="headerlink" title="装饰器的创建"></a>装饰器的创建</h3><p>创建装饰器，最少需要嵌套一层函数，且在内层函数加载到内存之后返回内存函数</p>
<p><img src="http://oss.20150509.cn/QQ20160530-1@2x.png" alt=""></p>
<h3 id="装饰器的使用"><a href="#装饰器的使用" class="headerlink" title="装饰器的使用"></a>装饰器的使用</h3><p>使用装饰器的方法很简单，只需要在被装饰的函数上面用<code>@</code>符号引用装饰器名即可</p>
<p><img src="http://oss.20150509.cn/QQ20160530-2@2x.png" alt=""></p>
<h3 id="装饰器的功能"><a href="#装饰器的功能" class="headerlink" title="装饰器的功能"></a>装饰器的功能</h3><p>装饰器有两大功能：</p>
<ul>
<li>自动执行装饰器函数,且将下面的函数名当做参数传递给装饰器函数</li>
<li>将装饰器函数的返回值,重新赋值给函数</li>
</ul>
<p>第一大功能，当Python在遇到<code>@装饰器名</code>时，会去执行该装饰器；我们来说说第二大功能，装饰器函数的返回值会重新赋值给函数！</p>
<p><img src="http://oss.20150509.cn/QQ20160530-3@2x.png" alt=""></p>
<p>所有装饰器函数的返回值都是其内层函数，也就是说，内层函数会重新赋值给原函数。说到这里时，就需要引入开篇提到的<code>函数定义原理</code>,下面我们假设程序调用了<code>f1()</code>.我们来看看在Python的内部都发生了什么。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'loading...'</span>)</span><br><span class="line">    func()</span><br><span class="line">    print(<span class="string">'Done'</span>)</span><br><span class="line">  <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br><span class="line">  </span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">loading...</span><br><span class="line">f1 func</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<ol>
<li>在该程序中，f1的函数被outer装饰器所装饰</li>
<li>Python在从上至下解释代码时，先将outer装饰器加载到内存中</li>
<li>当执行到@outer时，触发了Python装饰器的第一大功能，他将帮助我们去执行装饰器函数，上一条，outer装饰器已经加载到内存，还没有被调用执行。遇到@outer后，会触发<code>outer()</code>操作，当outer函数被执行后，其内层函数将被加载到内存中等待调用，outer的最后，返回了内层inner函数</li>
<li>装饰器外层函数的调用返回内层函数后，触发了Python装饰器的第二大功能，他将自动帮我们把返回的内存的函数重新赋值给被装饰的函数f1</li>
<li>最后，当f1被调用时，实际指向的是inner函数的函数体，也就是说，当f1函数被装饰器所装饰后，调用时所运行的函数体，实际上是装饰器函数中的内层函数。</li>
</ol>
<p>如果上面的文字描述你还没有看懂的话，没关系，下面还有图文并茂的<del>~</del></p>
<ul>
<li>Python解释器从上至下解释，先将<code>outer</code>这个函数名字放入栈区，outer的整个函数体将被完整的加载到内存的堆区中，内存状态如下：</li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160530-4@2x.png" alt=""></p>
<ul>
<li>接下来，Python解释器遇到<code>@outer</code>时，Python内部控制将去自动将下一行函数的名字（f1）作为参数传入到<code>outer</code>装饰器函数中，并自动执行<code>outer</code>函数，此时outer函数的形式参数<code>func</code>在栈区指向了堆区的<code>f1</code>函数体，内存状态如下：</li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160530-5@2x.png" alt=""></p>
<ul>
<li>outer函数执行完后，会将内层函数的返回值重新复制给原函数（f1）想当于执行了<code>f1 = outer(f1)</code></li>
</ul>
<p><img src="http://oss.20150509.cn/QQ20160530-6@2x.png" alt=""></p>
<ul>
<li>最后，当f1被被调用时，可以通过上图看出，实际调用的是装饰的内层函数，而装饰器中的内存函数体里又引用了原f1的函数体（已经将f1函数体堆区地址引用给了栈区的func）</li>
</ul>
<p>总结：通过上面剖析的小例子可以看出，虽然<code>print(&#39;f1 func&#39;)</code>是f1的函数体，但是f1只有一瞬间拥有该函数体。在遇到<code>@outer</code>之后，f1就被当做参数传递给了outer装饰器，func与f1同时指向放在堆区的函数体。在outer函数执行后，内层函数被重新赋值给了f1，此时f1失去了对原函数体的控制而指向了inner的堆区地址，func独自控制了<code>print(&#39;f1 func&#39;)</code>该函数体。</p>
<hr>
<h2 id="原函数有返回值的装饰器"><a href="#原函数有返回值的装饰器" class="headerlink" title="原函数有返回值的装饰器"></a>原函数有返回值的装饰器</h2><p>现在我的基础函数有返回值的需求，改成了如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>如果是这样的函数被装饰，函数体中不仅有计算和输出，而且有返回值，那么我们就需要在装饰器中，接收原函数的返回值，并进行返回：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'loading...'</span>)</span><br><span class="line">        ret = func()   <span class="comment"># 因为原函数有返回值，在这里调用时去接收原函数的返回值</span></span><br><span class="line">        print(<span class="string">'Done'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret    <span class="comment"># 在新函数的结尾，返回原函数的返回值</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f1 func'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f2 func'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'f3 func'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">f1()</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">loading...</span><br><span class="line">f1 func</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="带参数的函数被装饰-参数个数确定"><a href="#带参数的函数被装饰-参数个数确定" class="headerlink" title="带参数的函数被装饰(参数个数确定)"></a>带参数的函数被装饰(参数个数确定)</h2><p>现在我的代码变成了带参数的函数，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1)</span>:</span></span><br><span class="line">  print(<span class="string">'f1 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1)</span>:</span></span><br><span class="line">  print(<span class="string">'f2 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(arg1)</span>:</span></span><br><span class="line">  print(<span class="string">'f3 func'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>相应的，我的装饰器也应该做出改变。想想上面装饰器的原理—&gt;<code>装饰器的内层函数被返回并重新赋值给原函数</code> 也就是说，如果原函数有参数的话，相对应的，装饰器中的内层函数也应该有参数，故做出如下修改：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(arg)</span>:</span></span><br><span class="line">        print(<span class="string">'loading...'</span>)</span><br><span class="line">        ret = func(arg)</span><br><span class="line">        print(<span class="string">'Done'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f1 func'</span> + arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f2 func'</span> + arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f3 func'</span> + arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">f1(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">loading...</span><br><span class="line">f1 func123</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="带参数的函数被装饰-参数个数不确定"><a href="#带参数的函数被装饰-参数个数不确定" class="headerlink" title="带参数的函数被装饰(参数个数不确定)"></a>带参数的函数被装饰(参数个数不确定)</h2><p>上面的例子中，在装饰器的内层函数加入参数，解决了被装饰函数带参数的问题，那么，如果被装饰的函数如果参数不确定，如何保证装饰器仍然可用呢？参考如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'loading...'</span>)</span><br><span class="line">        ret = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'Done'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f1 func'</span> + arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'f2 func'</span> + arg1 + arg2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">'f3 func'</span> + arg1 + arg2 + arg3)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">f1(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">loading...</span><br><span class="line">f1 func123</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p><strong>好的，至此Python装饰器的常用用法就已经介绍完了，以上装饰器的知识足够解决Pythoner 80%的装饰问题啦，如果你有更高更复杂的需求，可以参考以下装饰器的用法</strong></p>
<hr>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>应用场景：上面的装饰器，前篇一律，类似于Java中的工厂方法模式，各类对象，不管你是方的圆的三角的，一进工厂，出来都是一个模样的~~ 那带参数的装饰器要解决的就是“个性化工厂方法”的功能。虽然都会进装饰器的“熔炉”，但是通过给装饰器传递的不同参数，可以实现对每个函数的个性化装饰</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">'loading...%s'</span> % (arg))</span><br><span class="line">            ret = func(*args, **kwargs)</span><br><span class="line">            print(<span class="string">'Done'</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> outer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx('f1f1f1')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f1 func'</span>+ arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx('f2f2f2')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'f2 func'</span> + arg1 + arg2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx('f3f3f3')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">'f3 func'</span> + arg1 + arg2 + arg3)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">loading...f1f1f1</span><br><span class="line">f1 func123</span><br><span class="line">Done</span><br></pre></td></tr></table></figure>

<p>我们使用调试模式来辅助理解带参数的装饰器是怎么执行的</p>
<p>Python解释器加载xxx函数到内存中</p>
<p><img src="http://oss.20150509.cn/QQ20160531-1@2x.png" alt=""></p>
<p>执行了xxx函数，并将参数传递给了xxx <code>相当于执行了xxx(&#39;f1f1f1&#39;)</code></p>
<p><img src="http://oss.20150509.cn/QQ20160531-2@2x.png" alt=""></p>
<p>解释器走到xxx函数的内部，开始执行xxx的函数体，发现又是一个函数，于是将代码完整的载入到内存中以备调用</p>
<p><img src="http://oss.20150509.cn/QQ20160531-3@2x.png" alt=""></p>
<p>xxx执行完毕后，把加载到内存中的outer返回</p>
<p><img src="http://oss.20150509.cn/QQ20160531-4@2x.png" alt=""></p>
<p>outer返回后被立即执行（前面提到过，装饰器的两个功能，第一大功能就拿到下一行的函数名当做参数传递给装饰器。在带参的装饰器中，调用装饰器时，其自身已经带有参数，不会直接去找下一行的函数进行传参操作，而是会先用自己已有的参数去执行自己，返回outer后，outer发现自己需要参数，于是去下一行找函数名并传参，接下来发生的事情就和上面介绍的不带参的装饰器的流程是一样的了）</p>
<p><img src="http://oss.20150509.cn/QQ20160531-5@2x.png" alt=""></p>
<p>outer函数被执行，将inner函数体加载到内存中</p>
<p><img src="http://oss.20150509.cn/QQ20160531-6@2x.png" alt=""></p>
<p>将inner返回（这是这里是将inner函数返回，不要在inner后面加括号！加了括号表示把inner执行结果的返回值返回给原函数f1）</p>
<p><img src="http://oss.20150509.cn/QQ20160531-7@2x.png" alt=""></p>
<p>装饰器内的操作执行完后，跳回到调用装饰器的地方（因为Python内部已经将原f1函数体的引用通过传参的方式指给了outer函数的func形参，所以Python解释器不会再去读f1的函数体了）</p>
<p><img src="http://oss.20150509.cn/QQ20160531-8@2x.png" alt=""></p>
<p>跳过f1的函数体之后进入到对下一个函数的装饰 …</p>
<p><img src="http://oss.20150509.cn/QQ20160531-9@2x.png" alt=""></p>
<p>最后Python解释器读到了程序的入口点（终于可以干活了！）</p>
<p><img src="http://oss.20150509.cn/QQ20160531-10@2x.png" alt=""></p>
<p>look！直接跳到了inner函数的内部去执行啦！看来之前分析的没有错，装饰器在返回的时候，将inner函数重新赋值给了f1</p>
<p><img src="http://oss.20150509.cn/QQ20160531-11@2x.png" alt=""></p>
<p>在运行到inner中的<code>func(*args, **kwargs)</code>的时候，程序跳到了f1原有的函数体。这也证明了上面的分析，func成为了唯一指向原函数体的变量</p>
<hr>
<h2 id="参数为函数的装饰器"><a href="#参数为函数的装饰器" class="headerlink" title="参数为函数的装饰器"></a>参数为函数的装饰器</h2><p>这样的需求也是有的，看过了上面的个性化定制之后，现在又有了新的需求，就是装饰器有可能会经常变，老板说了，时间长了会审美疲劳~~</p>
<p>应对这样的需求，装饰器也是可以做的，那就是让装饰器传递一个函数，该函数代替了之前写死在装饰器里的代码，可以灵活改变，而且更厉害的是，被装饰器当做参数的函数依然可以有参数~~</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">before</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'before'</span> + arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">after</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'after'</span> + arg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span><span class="params">(func_before, func_after)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(arg)</span>:</span></span><br><span class="line">            func_before(arg)</span><br><span class="line">            ret = func(arg)</span><br><span class="line">            func_after(arg)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> outer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx(before, after)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(arg1)</span>:</span></span><br><span class="line">    print(<span class="string">'f1 func'</span>+ arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx(before, after)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line">    print(<span class="string">'f2 func'</span> + arg1 + arg2)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@xxx(before, after)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">'f3 func'</span> + arg1 + arg2 + arg3)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1(<span class="string">'123'</span>)</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line">before123</span><br><span class="line">f1 func123</span><br><span class="line">after123</span><br></pre></td></tr></table></figure>

<p>通过上面这种方法实现后，在原有函数的基础上，可以随时方便的更改装饰内容~~</p>
<hr>
<h1 id="多层装饰器"><a href="#多层装饰器" class="headerlink" title="多层装饰器"></a>多层装饰器</h1><p>明白了单层装饰，多层装饰器就很容易理解啦~~</p>
<p>现对业务的具体功能有如下需求：</p>
<ul>
<li>首先验证用户是否登录</li>
<li>再验证登录的用户是否拥有权限</li>
</ul>
<p>现在我有大量的业务逻辑方法，每个方法在被调用前都需要去验证前两项，在这样一个项目需求中，多层装饰器就可以被发挥的淋漓尽致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">login_status = <span class="literal">True</span></span><br><span class="line">permission = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_login</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> login_status:</span><br><span class="line">            print(<span class="string">'---&gt;Login success'</span>)</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_permission</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> permission:</span><br><span class="line">            print(<span class="string">'---&gt;Authorized'</span>)</span><br><span class="line">            <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@check_login</span></span><br><span class="line"><span class="meta">@check_permission</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'rm -fr /'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    xxx()</span><br><span class="line">    </span><br><span class="line">------------</span><br><span class="line">---&gt;Login success</span><br><span class="line">---&gt;Authorized</span><br><span class="line">rm -fr /</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看出，在一个函数使用了多个装饰器之后，代码是从第一个装饰器的内部函数（inner）开始顺序向下执行，所以在使用多个装饰器时，一定要注意顺序问题！一定要在最上面先验证登录，再验证权限！接下来我们来具体分析一下，为什么不是离被装饰函数最近的装饰器先执行！</p>
<p>如果使用Debug模式来观察执行过程，可以很清楚的看到如下过程：</p>
<ol>
<li>首先Python解释器将代码的前两行放入到内存中</li>
<li>遇到<code>check_login</code>函数，将其函数名放入栈区，函数体放入堆区</li>
<li>遇到<code>check_permission</code>函数，将其函数名放入栈区，函数体放入堆区</li>
<li>执行到<code>@check_login</code>时，将获取下一行的函数作为参数，但是下一行不是函数，所以继续向下执行</li>
<li>执行到<code>@check_permission</code>时，获取下一行函数作为参数，并返回<code>check_permission</code>装饰器内的<code>inner</code>函数返回重新赋值给<code>xxx</code></li>
<li>此时之前跳过的<code>@check_login</code>装饰器终于得到了一个新函数作为参数（@check_login获得的函数是@check_permission内部的inner函数）故，将该函数传入到login装饰器中，并返回<code>@check_login</code>内部的<code>inner</code>函数。</li>
<li>当xxx函数被执行的时候，先执行的是<code>@check_login</code>中返回的<code>inner</code>函数，而在<code>@check_login</code>中的<code>inner</code>函数遇到<code>fun()</code>时，其实该函数是<code>@check_permission</code>函数返回的<code>inner</code>函数，所以在验证完登录后，会立即去permission函数中去验证权限，权限验证通过后再执行的<code>fun()</code>就是<code>xxx</code>函数自己原始的函数体了</li>
</ol>
<p><strong>总结：</strong>顺序很重要！多重嵌套的装饰一定要记住以下两点：</p>
<ul>
<li>Python解释代码时是从下往上返回函数</li>
<li>而程序执行时，功能是从上往下执行</li>
</ul>
<p><img src="http://oss.20150509.cn/20150607012559.png" alt=""></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
      </tags>
  </entry>
  <entry>
    <title>收获不止Oracle</title>
    <url>/2016/05/22/%E6%94%B6%E8%8E%B7%E4%B8%8D%E6%AD%A2Oracle/</url>
    <content><![CDATA[<blockquote>
<p>今天跟大家分享的标题叫<code>《收获不止Oracle》</code> 三年前我在一家书店“纳凉”时发现了一本书<code>《收获不止Oracle》</code>  今天抛开Oracle不谈，我们来聊聊这本书是怎么“收获不止Oracle”的</p>
</blockquote>
<p>《收获不止Oracle》这本书中讨论的是Oracle数据库调优的问题，到底是什么东西能让人们在本书中的收获不止Oracle的？这个问题要从如何解决Oracle性能瓶颈的问题来入手。</p>
<p>书中解决Oracle性能瓶颈的问题遵循的唯一原则就是<code>少做事儿！</code> 作者肯定的说，少做事儿，就一定能提高效率！道理很简单，举个例子来说~</p>
<ul>
<li><p>一个流程，原来需要走6步才能完成，现在在不增加额外负担的情况下把它优化成只需要5步，那效率就一定提高了！</p>
</li>
<li><p>拿算法来说，也可以简单的理解为根据具体情况，找到让CPU运算次数尽可能少的得到结果的办法</p>
</li>
</ul>
<p>少做事儿的思想可以应用到各行各业，当然不局限于Oracle。</p>
<p>如今大火的<code>运维自动化</code>、<code>DevOps</code>、<code>CMDB</code>等概念都是<code>少做事儿</code>的最佳体现！但是这三者有一个共同点！出发点都是<code>让人少做事儿</code>，将人工的重复劳动加以归类整合，让机器自己去完成，从而实现了通过少做事儿来提高工作效率。但以上这些理念并没有触及到业务的核心问题！就是业务上是否存在不必要的冗余！</p>
<p>上面提到的技术，解决了让人少做事儿提高效率的办法，那第二个层次就是让机器也少做事儿，就能再一次掀起技术革命，提高运行效率！让机器少做事儿，也可以归到以下两个层面</p>
<ul>
<li><p>代码：让单台机器上的代码少做事儿（减少代码级别的冗余）</p>
</li>
<li><p>流程：精简业务集群的工作流程（减少不必要的流程和交互）</p>
</li>
</ul>
<p>针对上面提到的代码级别的<code>少做事儿</code>实践中，最常见的就是优化业务逻辑和算法，比如购物平台的商品推荐算法、搜索引擎里推送广告的算法等等；还有一种情况是干了重复的事情，需要精简</p>
<p>针对流程级别的<code>少做事儿</code>实践中，最常见的优化方法是调整技术架构，精简不必要的流程和业务环节。例如：数据库很慢，就不要让数据库干那么多活，在数据层之上加入中间件就是让数据库少干活的经典体现。再例如：业务逻辑方面，可以让用户一步操作就完成的事儿，就不要弄得那么繁琐。</p>
<p>以上是基于<code>少做事儿</code>的个人理解。提到今天分享的内容，我想起刘龙军“前辈”关于“微服务”理念的那次分享，微服务其中解决的问题之一就是冗余问题，我觉得我们可以把微服务理念理解成面向对象编程里的封装这个概念！面向对象的终极目标是减少重复代码，实际也是少做事儿的一种体现。所以微服务当今大行其道是大势所趋。</p>
<hr>
<p>最后和大家分享两个我个人关于<code>少做事儿</code>的实践案例</p>
<blockquote>
<p>背景：我上家公司的日志处理流程，每天凌晨脚本在client端收集昨天的日志，处理后打包上传到分汇总，分汇总拿到所有数据后对数据进行处理后上传到汇总，汇总对数据处理后将源数据打包上传到备份服务器。大致流程： client–&gt;分汇总–&gt;汇总–&gt;备份</p>
</blockquote>
<ul>
<li><p><code>少做事儿</code>代码级别的体现：在client端，服务器以及应用的一些参数经常变化，导致脚本经常因为各种情况而崩溃。经过长时间的考察，我决定比较激进的将client端的环境变量根据更新频率的不同分为三个等级，每个等级的变量的刷新都有自己对应的方式，实现了<code>少做事儿</code>的理念</p>
<ol>
<li><p>变量被分级，每天脚本自动刷新的变量只有获取IP和时间（之前是每天都刷新所有的环境变量），减少因为人工误操作信息表，而读取到错误的应用配置信息</p>
</li>
<li><p>得益于变量刷新分级制，原来脚本中对于各种各样意外情况的try代码块可以完全剔除</p>
</li>
</ol>
</li>
<li><p><code>少做事儿</code>流程级别的体现：原日志备份从client端到备份服务器，需要经过分汇总和汇总两道关卡。熟悉业务流程并保证日志有足够多的冗余备份后，剔除掉了汇总这一层的备份流程。由： client–&gt;分汇总–&gt;汇总–&gt;备份  简化为： client–&gt;分汇总&amp;备份–&gt;汇总</p>
<ol>
<li>分汇总拿到源数据包后直接将上传到备份服务器，不再经过汇总服务器，减少了一个流程，效率就一定有提高！</li>
</ol>
</li>
</ul>
<p>上面举的两个实际案例都是<code>少做事儿</code>的非常简单的应用，希望抛砖引玉，可以给大家一点启发<del>~</del></p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记[2]</title>
    <url>/2016/05/22/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<blockquote>
<ol>
<li>常见的数据类型</li>
<li>字符串的常用操作</li>
<li>列表的语法和使用</li>
<li>元组的语法和使用</li>
<li>字典的语法和使用</li>
</ol>
</blockquote>
<h1 id="常见的数据类型"><a href="#常见的数据类型" class="headerlink" title="常见的数据类型"></a>常见的数据类型</h1><p>Python中的数据类型可以分为两类，一类是 <code>基本数据类型</code> 一类是 <code>引用数据类型</code> </p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ul>
<li>字符型： ‘a’, ‘message’</li>
<li>数值型： 59, 1991.59</li>
<li>布尔类型: True, False</li>
</ul>
<h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><ul>
<li>列表： [1, 2, 3], [‘abc’, ‘xyz’]</li>
<li>元组： (1, 2, 3), (‘abc’, ‘xyz’)</li>
<li>字典： {‘name’=’larry’, ‘age’: 25}</li>
<li>类</li>
</ul>
<p><strong>基本数据类型与引用数据类型的区别：前者传值，后者传址</strong></p>
<h1 id="字符串的常用操作"><a href="#字符串的常用操作" class="headerlink" title="字符串的常用操作"></a>字符串的常用操作</h1><ul>
<li>移除字符串的两端空白字符</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: a = <span class="string">'   aa   '</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: a</span><br><span class="line">Out[<span class="number">13</span>]: <span class="string">'   aa   '</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a.strip()</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'aa'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: a.lstrip()</span><br><span class="line">Out[<span class="number">15</span>]: <span class="string">'aa   '</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: a.rstrip()</span><br><span class="line">Out[<span class="number">16</span>]: <span class="string">'   aa'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将字符串以指定的分割符分割成列表</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: a = <span class="string">'a,b,c,d,e'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: a.split(<span class="string">','</span>)</span><br><span class="line">Out[<span class="number">18</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>统计字符串长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">19</span>]: a = <span class="string">'I am Chinese!'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: len(a)</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">13</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在字符串中找到指定字符的位置</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: a = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: a.index(<span class="string">'o'</span>)</span><br><span class="line">Out[<span class="number">22</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: a.index(<span class="string">'o'</span>, <span class="number">2</span>)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: a.index(<span class="string">'o'</span>, <span class="number">2</span>, <span class="number">6</span>)</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-24</span><span class="number">-2</span>bb3a06d2fe6&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 a.index('o', 2, 6)</span><br><span class="line"></span><br><span class="line">ValueError: substring <span class="keyword">not</span> found</span><br></pre></td></tr></table></figure>

<ul>
<li>切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">25</span>]: a = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: a[<span class="number">0</span>:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">26</span>]: <span class="string">'polar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">27</span>]: a[:<span class="number">5</span>] </span><br><span class="line">Out[<span class="number">27</span>]: <span class="string">'polar'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">28</span>]: a[<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">28</span>]: <span class="string">'w'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">29</span>]: a[<span class="number">-4</span>:]</span><br><span class="line">Out[<span class="number">29</span>]: <span class="string">'snow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">30</span>]: a[<span class="number">5</span>:] </span><br><span class="line">Out[<span class="number">30</span>]: <span class="string">'snow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">31</span>]: a[<span class="number">-4</span>:<span class="number">-1</span>]  <span class="comment">#注意Python中的切片是左闭右开</span></span><br><span class="line">Out[<span class="number">31</span>]: <span class="string">'sno'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计字符串中指定字符的个数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [32]: a &#x3D; &#39;polarsnow&#39;   </span><br><span class="line"></span><br><span class="line">In [33]: a.count(&#39;o&#39;)</span><br><span class="line">Out[33]: 2</span><br></pre></td></tr></table></figure>

<ul>
<li>将指定字符串置于中央</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">34</span>]: a = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">35</span>]: a.center(<span class="number">50</span>, <span class="string">'-'</span>)</span><br><span class="line">Out[<span class="number">35</span>]: <span class="string">'--------------------polarsnow---------------------'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断是否以指定字符串开头或结尾</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">38</span>]: a = <span class="string">'polarsnow'</span>  </span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a.endswith(<span class="string">'ow'</span>)</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">40</span>]: a.startswith(<span class="string">'po'</span>)</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串大小写或首字母大写</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">41</span>]: a = <span class="string">'polarsnow'</span>   </span><br><span class="line"></span><br><span class="line">In [<span class="number">42</span>]: a.upper()</span><br><span class="line">Out[<span class="number">42</span>]: <span class="string">'POLARSNOW'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: a.upper().lower()</span><br><span class="line">Out[<span class="number">43</span>]: <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: a.capitalize()</span><br><span class="line">Out[<span class="number">44</span>]: <span class="string">'Polarsnow'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串属性判断-isalnum-是否只含有字母和数字</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">46</span>]: a = <span class="string">'polarsnow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: a.isalnum()    </span><br><span class="line">Out[<span class="number">47</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">48</span>]: a = <span class="string">'polarsnow%'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">49</span>]: a.isalnum()     </span><br><span class="line">Out[<span class="number">49</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">50</span>]: a = <span class="string">'polarsnow5'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: a.isalnum()     </span><br><span class="line">Out[<span class="number">51</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: a = <span class="string">'polar snow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: a.isalnum()     </span><br><span class="line">Out[<span class="number">53</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串属性判断-isalpha-是否只含有字母</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: a = <span class="string">'polarsnow'</span> </span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: a.isalpha()</span><br><span class="line">Out[<span class="number">55</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">56</span>]: a = <span class="string">'polarsnow%'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: a.isalpha()     </span><br><span class="line">Out[<span class="number">57</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: a = <span class="string">'polarsnow5'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: a.isalpha()     </span><br><span class="line">Out[<span class="number">59</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">60</span>]: a = <span class="string">'polar snow'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">61</span>]: a.isalpha()     </span><br><span class="line">Out[<span class="number">61</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串属性判断-isdigit-是否只包含数字</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">62</span>]: a = <span class="string">'123'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">63</span>]: a.isdigit()</span><br><span class="line">Out[<span class="number">63</span>]: <span class="literal">True</span></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">- 字符串属性判断-isspace-是否只包含空格</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">In [<span class="number">71</span>]: a = <span class="string">' '</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">72</span>]: a.isspace()</span><br><span class="line">Out[<span class="number">72</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">73</span>]: a = <span class="string">''</span>     </span><br><span class="line"></span><br><span class="line">In [<span class="number">74</span>]: a.isspace()</span><br><span class="line">Out[<span class="number">74</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串其他属性判断</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str.isupper()  <span class="comment">#检查字符串所有的字母是否全部为大写</span></span><br><span class="line">str.islower()  <span class="comment">#检查字符串的所有字母是否全部为小写</span></span><br><span class="line">str.istitle()  <span class="comment">#检查字符串的所有单词拼写是否首字母大写，其余小写</span></span><br></pre></td></tr></table></figure>

<ul>
<li>字符串拼接可迭代对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">print(<span class="string">""</span>.join(l))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/lvrui/PycharmProjects/untitled/4/test.py"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    print(<span class="string">""</span>.join(l))</span><br><span class="line">TypeError: sequence item <span class="number">0</span>: expected str instance, int found</span><br></pre></td></tr></table></figure>

<p>使用join的方式把一个可迭代对象进行拼接的基本要求是，可迭代对象中的每一个元素必须是字符串！！！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</span><br><span class="line">print(<span class="string">"+"</span>.join(l))</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line"><span class="number">1</span>+<span class="number">2</span>+<span class="number">3</span>+<span class="number">4</span>+<span class="number">5</span></span><br></pre></td></tr></table></figure>


<h1 id="列表的常用操作"><a href="#列表的常用操作" class="headerlink" title="列表的常用操作"></a>列表的常用操作</h1><ul>
<li>列表的定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list_a = []  <span class="comment">#定义了一个空列表</span></span><br><span class="line">list_b = [<span class="number">1</span>, <span class="string">'a'</span>, [<span class="number">2</span>, <span class="string">'z'</span>]]  <span class="comment">#嵌套列表</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表的索引/取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">75</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">76</span>]: a[<span class="number">0</span>]</span><br><span class="line">Out[<span class="number">76</span>]: <span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: a[<span class="number">1</span>]</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">'b'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>列表的切片</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">78</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: a[<span class="number">2</span>:]</span><br><span class="line">Out[<span class="number">79</span>]: [<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: a[<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">80</span>]: <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: a[<span class="number">-2</span>:]  </span><br><span class="line">Out[<span class="number">81</span>]: [<span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">82</span>]: a[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">82</span>]: [<span class="string">'b'</span>, <span class="string">'c'</span>]  <span class="comment">#与字符串的切片相同，也要注意左闭右开</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">128</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">129</span>]: a[::<span class="number">2</span>]  <span class="comment">#设置步长</span></span><br><span class="line">Out[<span class="number">129</span>]: [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>列表的遍历</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">83</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">84</span>]: <span class="keyword">for</span> item <span class="keyword">in</span> a:</span><br><span class="line">   ....:     <span class="keyword">print</span> item</span><br><span class="line">   ....:     </span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<ul>
<li>向列表中追加数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: a.append(<span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: a</span><br><span class="line">Out[<span class="number">87</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'xxx'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>向列表中插入数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">107</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">108</span>]: a.insert(<span class="number">0</span>, <span class="string">'xxx'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">109</span>]: a</span><br><span class="line">Out[<span class="number">109</span>]: [<span class="string">'xxx'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除列表中的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">88</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">89</span>]: <span class="keyword">del</span> a[<span class="number">0</span>]  <span class="comment">#万能删除法 可以将整个变量删除</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">90</span>]: a</span><br><span class="line">Out[<span class="number">90</span>]: [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">91</span>]: a.pop()  <span class="comment">#将列表最后一个元素删除</span></span><br><span class="line">Out[<span class="number">91</span>]: <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">92</span>]: a</span><br><span class="line">Out[<span class="number">92</span>]: [<span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">93</span>]: a.remove(<span class="string">'c'</span>)  <span class="comment">#删除列表中，第一次出现的指定元素（即使有两个c，只会删除第一个）</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">94</span>]: a</span><br><span class="line">Out[<span class="number">94</span>]: [<span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">95</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]  <span class="comment">#重新赋值</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">96</span>]: a</span><br><span class="line">Out[<span class="number">96</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">97</span>]: <span class="keyword">del</span> a[<span class="number">1</span>:<span class="number">4</span>]  <span class="comment">#删除连续的元素 注意左闭右开</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">98</span>]: a</span><br><span class="line">Out[<span class="number">98</span>]: [<span class="string">'a'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>修改列表中的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">101</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">102</span>]: a[<span class="number">3</span>] = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: a[<span class="number">4</span>] = <span class="string">'e'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: a</span><br><span class="line">Out[<span class="number">104</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>列表的长度</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">105</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">106</span>]: len(a)</span><br><span class="line">Out[<span class="number">106</span>]: <span class="number">5</span>  <span class="comment">#长度为5 注意索引只到4</span></span><br></pre></td></tr></table></figure>

<ul>
<li>统计列表中指定元素的个数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">110</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">111</span>]: a.count(<span class="string">'a'</span>)</span><br><span class="line">Out[<span class="number">111</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>将列表中的元素顺序反转</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">112</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">113</span>]: a.reverse()</span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: a</span><br><span class="line">Out[<span class="number">114</span>]: [<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>排序（根据ascii码）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">115</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: a.sort()</span><br><span class="line"></span><br><span class="line">In [<span class="number">117</span>]: a</span><br><span class="line">Out[<span class="number">117</span>]: [<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>列表的扩展</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">120</span>]: a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">121</span>]: b = [<span class="string">'xxx'</span>, <span class="string">'yyy'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">122</span>]: a.extend(b)</span><br><span class="line"></span><br><span class="line">In [<span class="number">123</span>]: a</span><br><span class="line">Out[<span class="number">123</span>]: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'xxx'</span>, <span class="string">'yyy'</span>]</span><br></pre></td></tr></table></figure>

<h1 id="元组的语法和使用（元组就是不可变的列表）"><a href="#元组的语法和使用（元组就是不可变的列表）" class="headerlink" title="元组的语法和使用（元组就是不可变的列表）"></a>元组的语法和使用（元组就是不可变的列表）</h1><p><strong>元组中不可增，删，改。在取值的时候与列表操作类似，有以下常用方法</strong></p>
<ul>
<li><p>tuple.count(): 统计指定元素的个数</p>
</li>
<li><p>tuple.index(): 找到指定元素的索引</p>
</li>
</ul>
<h1 id="字典的语法和使用"><a href="#字典的语法和使用" class="headerlink" title="字典的语法和使用"></a>字典的语法和使用</h1><ul>
<li>字典的定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">132</span>]: a = &#123;&#125;  <span class="comment">#定义了一个空字典</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字典中增加元素/修改元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字典是不重复且无序的，增加元素的操作和修改类似，如果元素存在即修改，如果元素不存在即添加</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">133</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">134</span>]: a[<span class="string">'d'</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">135</span>]: a</span><br><span class="line">Out[<span class="number">135</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">4</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">136</span>]: a[<span class="string">'d'</span>] = <span class="number">59</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">137</span>]: a</span><br><span class="line">Out[<span class="number">137</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">59</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除字典中的元素</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">140</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">141</span>]: a.pop(<span class="string">'b'</span>)  <span class="comment">#因为字典是无序的 与列表中的pop删除最后一个元素的概念区分开 这里需要指定“键”</span></span><br><span class="line">Out[<span class="number">141</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">142</span>]: a</span><br><span class="line">Out[<span class="number">142</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">143</span>]: <span class="keyword">del</span> a[<span class="string">'a'</span>]  <span class="comment">#万能删除依然好用~~~</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">144</span>]: a</span><br><span class="line">Out[<span class="number">144</span>]: &#123;<span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定key取值</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">In [<span class="number">145</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">146</span>]: a[<span class="string">'a'</span>]</span><br><span class="line">Out[<span class="number">146</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">147</span>]: a[<span class="string">'d'</span>]  <span class="comment">#这种取值的方法如果没有找到，则报错</span></span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">KeyError                                  Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-147</span><span class="number">-0</span>b64a016a51f&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 a['d']</span><br><span class="line"></span><br><span class="line">KeyError: <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">148</span>]: a.get(<span class="string">'d'</span>)  <span class="comment">#使用get如果没有找到，则返回None</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">149</span>]: </span><br><span class="line"></span><br><span class="line">In [<span class="number">162</span>]: <span class="string">'a'</span> <span class="keyword">in</span> a  <span class="comment">#使用万能的in语法</span></span><br><span class="line">Out[<span class="number">162</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查找所有的”键”和所有的“值”</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">150</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">151</span>]: a.keys()</span><br><span class="line">Out[<span class="number">151</span>]: [<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">152</span>]: a.values()</span><br><span class="line">Out[<span class="number">152</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">153</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">154</span>]: a.items()</span><br><span class="line">Out[<span class="number">154</span>]: [(<span class="string">'a'</span>, <span class="number">1</span>), (<span class="string">'c'</span>, <span class="number">3</span>), (<span class="string">'b'</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">155</span>]: <span class="keyword">for</span> k,v <span class="keyword">in</span> a.items():  <span class="comment">#执行效率低下（有dict2list的转换过程），数据量大不推荐使用</span></span><br><span class="line">   .....:     print(<span class="string">'key: '</span>, k, <span class="string">'value: '</span>, v)</span><br><span class="line">   .....:     </span><br><span class="line">(<span class="string">'key: '</span>, <span class="string">'a'</span>, <span class="string">'value: '</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'key: '</span>, <span class="string">'c'</span>, <span class="string">'value: '</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="string">'key: '</span>, <span class="string">'b'</span>, <span class="string">'value: '</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">170</span>]: <span class="keyword">for</span> key <span class="keyword">in</span> a:  <span class="comment">#高效的字典遍历方法</span></span><br><span class="line">   .....:     print(key, a[key])</span><br><span class="line">   .....:     </span><br><span class="line">(<span class="string">'a'</span>, <span class="number">1</span>)</span><br><span class="line">(<span class="string">'c'</span>, <span class="number">3</span>)</span><br><span class="line">(<span class="string">'b'</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用子列表更新主列表中的元素（覆盖）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">157</span>]: a</span><br><span class="line">Out[<span class="number">157</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">158</span>]: b = &#123;<span class="string">'c'</span>: <span class="number">59</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">159</span>]: a.update(b)</span><br><span class="line"></span><br><span class="line">In [<span class="number">160</span>]: a</span><br><span class="line">Out[<span class="number">160</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">59</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>dict.setdefault(k,v)</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#根据k去取值，如果有则返回v，如果没有则添加这个元素</span></span><br><span class="line">In [<span class="number">164</span>]: a = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">165</span>]: a.setdefault(<span class="string">'a'</span>)</span><br><span class="line">Out[<span class="number">165</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">166</span>]: a.setdefault(<span class="string">'a'</span>, <span class="number">59</span>)</span><br><span class="line">Out[<span class="number">166</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">167</span>]: a.setdefault(<span class="string">'d'</span>, <span class="number">59</span>) </span><br><span class="line">Out[<span class="number">167</span>]: <span class="number">59</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">168</span>]: a</span><br><span class="line">Out[<span class="number">168</span>]: &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">3</span>, <span class="string">'d'</span>: <span class="number">59</span>&#125;</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)</title>
    <url>/2016/03/28/suEXEC-mechanism-enabled-wrapper-usr-sbin-suexec/</url>
    <content><![CDATA[<blockquote>
<p>前些日志在研究saltstack的api，使用了https的方式来访问api，创建一对儿密钥<code>/etc/pki/tls/certs/localhost.crt</code>和<code>/etc/pki/tls/certs/localhost.key</code> 过了几天后发现我实验的这台机器的Apache服务宕掉了，而且重启失败，故障信息如下</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; service httpd restart</span><br><span class="line">Stopping httpd:                                            [FAILED]</span><br><span class="line">Starting httpd:                                            [FAILED]</span><br><span class="line"></span><br><span class="line">shell&gt; tail /var/<span class="built_in">log</span>/httpd/error_log</span><br><span class="line">[Mon Mar 28 10:46:36 2016] [notice] suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)</span><br><span class="line"></span><br><span class="line">shell&gt; tail /var/<span class="built_in">log</span>/httpd/ssl_error_log</span><br><span class="line">[Mon Mar 28 10:49:19 2016] [warn] RSA server certificate CommonName (CN) `localhost<span class="string">' does NOT match server name!?</span></span><br><span class="line"><span class="string">[Mon Mar 28 10:49:19 2016] [error] Unable to configure RSA server private key</span></span><br><span class="line"><span class="string">[Mon Mar 28 10:49:19 2016] [error] SSL Library Error: 185073780 error:0B080074:x509 certificate routines:X509_check_private_key:key values mismatch</span></span><br></pre></td></tr></table></figure>

<ul>
<li>当我发现重启失败且终端没有报错输出时，当时打开了<code>/var/log/message</code>和<code>/var/log/httpd/error_log</code>两个log，重新重启Apache服务，发现message没有输出，而httpd的error_log有一行<code>[notice] suEXEC mechanism enabled (wrapper: /usr/sbin/suexec)</code>输出</li>
<li>发现suEXEC之后，我百度了该关键字，得知是负责处理CGI和SSI程序的请求，当我看到SSL的时候，就突然想起之前做过的salt-api的实验，当时创建了一对儿密钥，该密钥过期时间大概是24小时，猜测可能是Apache的默认配置文件加载了mod_ssl模块，而且引用了我创建密钥对儿的默认位置，而该密钥却处于失效状态，所以Apache服务无法启动（这是当时的猜测）</li>
<li>知道是SSL相关的问题之后，马上打开<code>/var/log/httpd/ssl_error_log</code>查看情况，有如下报错<code>[warn] RSA server certificate CommonName (CN)</code>localhost’ does NOT match server name!?` 当看到这一行报错的时候，已经确认上面猜测的第一点，就是Apache的默认配置文件加载了mod_ssl模块，而且指定密钥对儿的位置，就是我测试salt-api时创建密钥对儿的位置。而且还有一个错误就是我密钥对儿指定的hostname和Apache指定的hostname并不相同，基于密钥对主机名不符与密钥过期两点，造成了Apache无法启动的故障。</li>
<li>确定了问题之后，解决方案有很多种，核心思想就是让Apache的ssl配置失效<ul>
<li>第一种办法，可以在Apache的配置中禁用mod_ssl模块<code>/etc/httpd/conf.d/ssl.conf</code></li>
<li>第二种办法，在<code>/etc/httpd/conf.d/ssl.conf</code>配置文件中，指定其他密钥对儿的路径</li>
<li>第三种办法，我的salt-api已经测试完毕，可以把创建的密钥对儿删除或更名</li>
</ul>
</li>
<li>最终我是选择了第三种的方法，将原有的密钥对儿加了<code>.bak</code>后缀，之后重启Apache恢复正常，问题解决，回头再去查看<code>/etc/httpd/conf.d/ssl.conf</code>配置文件的时候，已经自动变成了<code>/etc/httpd/conf.d/ssl.conf.bak</code>相当于Apache找不到配置文件中指定的密钥对儿后，自动禁用了mod_ssl模块</li>
</ul>
<hr>
<p>如果你想了解suexec方面的东西，可以参考以下文章：</p>
<p><a href="http://blog.csdn.net/hulihong/article/details/5416056" target="_blank" rel="noopener">http://blog.csdn.net/hulihong/article/details/5416056</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>SSL</tag>
      </tags>
  </entry>
  <entry>
    <title>SaltStack RESTful API的调用[salt-api]</title>
    <url>/2016/03/21/SaltStack-RESTful-API%E7%9A%84%E8%B0%83%E7%94%A8-salt-api/</url>
    <content><![CDATA[<blockquote>
<p>如果需要通过第三方来调用SaltStack时，使用SaltStack自带的Python API并不能很好的满足需求。可以通过使用SaltStack基于RESTful风格的HTTP API。该API模块并不是内置的，需要单独安装。</p>
</blockquote>
<h1 id="Salt-REST-API简介"><a href="#Salt-REST-API简介" class="headerlink" title="Salt REST API简介"></a>Salt REST API简介</h1><p><em>这里简单的说明下，SaltStack官方支持三种REST API，分别是rest_cherry; rest_tonado和rest_wsgi</em></p>
<ul>
<li>rest_cherry和rest_tonado两个模块支持监听所有IP的指定端口接收请求</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; lsof -i:1559</span><br><span class="line">COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">salt-api 13443 root   14u  IPv4 21888585      0t0  TCP *:web2host (LISTEN)</span><br></pre></td></tr></table></figure>

<ul>
<li>rest_wsgi只支持本机访问，只绑定了127.0.0.1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; lsof -i:1559</span><br><span class="line">COMMAND    PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME</span><br><span class="line">salt-api 13443 root   14u  IPv4 21888585      0t0  TCP 127.0.0.1:web2host (LISTEN)</span><br></pre></td></tr></table></figure>

<p><img src="http://oss.20150509.cn/Snip20160321_1.png" alt="image"></p>
<p><strong>本文选择使用rest_cherry模块来实现SaltStack的HTTP API</strong></p>
<h1 id="安装Salt-API服务"><a href="#安装Salt-API服务" class="headerlink" title="安装Salt-API服务"></a>安装Salt-API服务</h1><p><em>一般情况下，salt-api会使用HTTPS，首次配置成功后，使用用户名和密码登陆，获得Token，Token创建后，默认有效期是12小时，在有效期之内，使用该Token可以代替使用用户名和密码来访问API（该有效时间可在salt-master配置文件中修改）</em></p>
<h2 id="必备安装包"><a href="#必备安装包" class="headerlink" title="必备安装包"></a>必备安装包</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum -y install gcc make python-devel libffi-devel</span><br><span class="line">shell&gt; pip install pyOpenSSL==0.15.1</span><br></pre></td></tr></table></figure>

<h2 id="借助salt工具来生成证书"><a href="#借助salt工具来生成证书" class="headerlink" title="借助salt工具来生成证书"></a>借助salt工具来生成证书</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; salt-call --<span class="built_in">local</span> tls.create_self_signed_cert</span><br><span class="line"><span class="built_in">local</span>:</span><br><span class="line">    Created Private Key: <span class="string">"/etc/pki/tls/certs/localhost.key."</span> Created Certificate: <span class="string">"/etc/pki/tls/certs/localhost.crt."</span></span><br></pre></td></tr></table></figure>

<p><em>salt-call是salt-minion的工具，如果没有这个命令，可以在master端安装minion，然后再执行以上命令</em></p>
<h2 id="安装salt-api"><a href="#安装salt-api" class="headerlink" title="安装salt-api"></a>安装salt-api</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum -y install salt-api</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="配置用户及权限"><a href="#配置用户及权限" class="headerlink" title="配置用户及权限"></a>配置用户及权限</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; useradd -M -s /sbin/nologin sa</span><br><span class="line">shell&gt; <span class="built_in">echo</span> <span class="string">"sapassword"</span> | passwd sa --stdin</span><br></pre></td></tr></table></figure>

<p>在salt-master的配置文件最后添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_auth:</span><br><span class="line">  pam:  #认证模式，pam指的是用Linux本身的用户认证模式</span><br><span class="line">    sa:  #Linux系统中真实存在的用户名</span><br><span class="line">      - &#39;*&#39;:  #设置用户的权限，允许该用户操作哪些主机，*代表全部</span><br><span class="line">        - test.*  #允许操作的模块及方法</span><br><span class="line">        - cmd.*</span><br></pre></td></tr></table></figure>

<p>其他认证模式可以参考官方文档：<a href="http://docs.saltstack.com/en/latest/topics/eauth/index.html" target="_blank" rel="noopener">http://docs.saltstack.com/en/latest/topics/eauth/index.html</a></p>
<h2 id="配置示例一-多用户（官方文档）"><a href="#配置示例一-多用户（官方文档）" class="headerlink" title="配置示例一:多用户（官方文档）"></a>配置示例一:多用户（官方文档）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_auth:</span><br><span class="line">  pam:</span><br><span class="line">    thatch:</span><br><span class="line">      - &#39;web*&#39;:</span><br><span class="line">        - test.*</span><br><span class="line">        - network.*</span><br><span class="line">    steve:</span><br><span class="line">      - .*</span><br></pre></td></tr></table></figure>

<h2 id="配置示例二：指定用户组（官方文档）"><a href="#配置示例二：指定用户组（官方文档）" class="headerlink" title="配置示例二：指定用户组（官方文档）"></a>配置示例二：指定用户组（官方文档）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_auth:</span><br><span class="line">  pam:</span><br><span class="line">    admins%:</span><br><span class="line">      - &#39;*&#39;:</span><br><span class="line">        - &#39;pkg.*&#39;</span><br></pre></td></tr></table></figure>

<p>使用<code>%</code>来表示用户组</p>
<h2 id="配置示例三：操作模块组（官方文档）"><a href="#配置示例三：操作模块组（官方文档）" class="headerlink" title="配置示例三：操作模块组（官方文档）"></a>配置示例三：操作模块组（官方文档）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">external_auth:</span><br><span class="line">  pam:</span><br><span class="line">    thatch:</span><br><span class="line">      - &#39;@wheel&#39;   # to allow access to all wheel modules</span><br><span class="line">      - &#39;@runner&#39;  # to allow access to all runner modules</span><br><span class="line">      - &#39;@jobs&#39;    # to allow access to the jobs runner and&#x2F;or wheel module</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.saltstack.com/en/latest/ref/wheel/all/index.html#all-salt-wheel" target="_blank" rel="noopener">点此查看wheel modules完整列表</a></p>
<p><a href="https://docs.saltstack.com/en/latest/ref/runners/all/index.html#all-salt-runners" target="_blank" rel="noopener">点此查看runner modules完整列表</a></p>
<hr>
<h1 id="配置salt-api服务"><a href="#配置salt-api服务" class="headerlink" title="配置salt-api服务"></a>配置salt-api服务</h1><p>在salt-master的配置文件最后添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rest_cherrypy:</span><br><span class="line">  port: 1559  #默认监听所有IP的1559端口</span><br><span class="line">  ssl_crt: &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;localhost.crt  #引用的正是前面创建的证书</span><br><span class="line">  ssl_key: &#x2F;etc&#x2F;pki&#x2F;tls&#x2F;certs&#x2F;localhost.key</span><br></pre></td></tr></table></figure>

<p>其他配置参数可以参考官方文档：<a href="https://docs.saltstack.com/en/latest/ref/netapi/all/salt.netapi.rest_cherrypy.html" target="_blank" rel="noopener">https://docs.saltstack.com/en/latest/ref/netapi/all/salt.netapi.rest_cherrypy.html</a></p>
<hr>
<h1 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; service salt-api start</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="登陆获得Token"><a href="#登陆获得Token" class="headerlink" title="登陆获得Token"></a>登陆获得Token</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSk https://www.20150509.cn:1559/login \</span><br><span class="line">    -H <span class="string">'Accept: application/x-yaml'</span> \</span><br><span class="line">    -d username=sa \</span><br><span class="line">    -d password=sapassword \</span><br><span class="line">    -d eauth=pam</span><br></pre></td></tr></table></figure>

<p>复制得到的Token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -sSk https://localhost:8000 \</span><br><span class="line">    -H <span class="string">'Accept: application/x-yaml'</span> \</span><br><span class="line">    -H <span class="string">'X-Auth-Token: 697adbdc8fe971d09ae4c2a3add7248859c87079'</span>\</span><br><span class="line">    -d client=<span class="built_in">local</span> \</span><br><span class="line">    -d tgt=<span class="string">'*'</span> \</span><br><span class="line">    -d fun=test.ping</span><br></pre></td></tr></table></figure>

<p><em>除了支持Token以外还支持使用cookies.txt文件来访问API，详情可查看官方文档</em></p>
<hr>
<h1 id="使用Python脚本来访问API"><a href="#使用Python脚本来访问API" class="headerlink" title="使用Python脚本来访问API"></a>使用Python脚本来访问API</h1><p><strong>在salt-api官方文档中，对python访问API给出了如下的格式要求</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="string">"client"</span>: <span class="string">"local"</span>,</span><br><span class="line">    <span class="string">"tgt"</span>: <span class="string">"*"</span>,</span><br><span class="line">    <span class="string">"fun"</span>: <span class="string">"test.fib"</span>,</span><br><span class="line">    <span class="string">"arg"</span>: [<span class="string">"10"</span>]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"client"</span>: <span class="string">"runner"</span>,</span><br><span class="line">    <span class="string">"fun"</span>: <span class="string">"jobs.lookup_jid"</span>,</span><br><span class="line">    <span class="string">"jid"</span>: <span class="string">"20130603122505459265"</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>以上的JSON代码中，指定了API去执行两个命令，一个模块命令，一个runner命令。Python代码实现如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line"> <span class="comment">#在python2.6x中，以下两行不是必须的</span></span><br><span class="line"><span class="keyword">import</span> ssl </span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.20150509.cn:1559'</span>  <span class="comment">#salt-api所在的“坐标”</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">  pre_data = [&#123;<span class="string">"client"</span>:<span class="string">"local"</span>, <span class="string">"tgt"</span>:<span class="string">"*"</span>, <span class="string">"fun"</span>:<span class="string">"test.ping"</span>&#125;]   <span class="comment">#根据上面官方文档的要求组成数组嵌套字典的形式</span></span><br><span class="line">  json_data = json.dumps(pre_data)    <span class="comment">#将其转化为json格式</span></span><br><span class="line">  </span><br><span class="line">  header = &#123;<span class="string">"Content-Type"</span>:<span class="string">"application/json"</span>, <span class="string">"Accept"</span>:<span class="string">"application/json"</span>, <span class="string">"X-Auth-Token"</span>:<span class="string">"697adbdc8fe971d09ae4c2a3add7248859c87079"</span>&#125;</span><br><span class="line">  <span class="comment">#这里说明下，Content-Type是声明传递给API的数据是什么格式的，这里指定了json，是因为上面的pre_data数据被我转化成了json格式</span></span><br><span class="line">  <span class="comment">#Accept是声明返回结果以什么样的格式显示，这里也指定了json格式来显示返回结果</span></span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url, json_data, header)    <span class="comment">#构造一次请求</span></span><br><span class="line">  response = urllib2.urlopen(request)    <span class="comment">#构造一次HTTP访问</span></span><br><span class="line"></span><br><span class="line">  html = response.read()</span><br><span class="line">  <span class="keyword">print</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  test()</span><br></pre></td></tr></table></figure>

<p>指定<code>Accept</code>为<code>application/json</code>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; python sa.py </span><br><span class="line">&#123;<span class="string">"return"</span>: [&#123;<span class="string">"vm3.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm2.salt.com"</span>: <span class="literal">true</span>, <span class="string">"ph1.salt.com"</span>: <span class="literal">true</span>, <span class="string">"ph2.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm1.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm4.salt.com"</span>: <span class="literal">true</span>, <span class="string">"localhost"</span>: <span class="literal">true</span>, <span class="string">"vm7.salt.com"</span>: <span class="literal">true</span>&#125;]&#125;</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>指定<code>Accept</code>为<code>application/x-yaml</code>执行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; python sa.py </span><br><span class="line"><span class="built_in">return</span>:</span><br><span class="line">- localhost: <span class="literal">true</span></span><br><span class="line">  ph1.salt.com: <span class="literal">true</span></span><br><span class="line">  ph2.salt.com: <span class="literal">true</span></span><br><span class="line">  vm1.salt.com: <span class="literal">true</span></span><br><span class="line">  vm2.salt.com: <span class="literal">true</span></span><br><span class="line">  vm3.salt.com: <span class="literal">true</span></span><br><span class="line">  vm4.salt.com: <span class="literal">true</span></span><br><span class="line">  vm7.salt.com: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="RESTful-API的日常操作"><a href="#RESTful-API的日常操作" class="headerlink" title="RESTful API的日常操作"></a>RESTful API的日常操作</h2><ul>
<li>运行远程模块</li>
<li>查询指定job</li>
<li>运行runner</li>
</ul>
<p><strong>稍后有时间会分别详细举出几个使用案例</strong></p>
<h2 id="REST-URI-参考"><a href="#REST-URI-参考" class="headerlink" title="REST URI 参考"></a>REST URI 参考</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;</span><br><span class="line">&#x2F;login</span><br><span class="line">&#x2F;logout</span><br><span class="line">&#x2F;minions</span><br><span class="line">&#x2F;jobs</span><br><span class="line">&#x2F;run</span><br><span class="line">&#x2F;events</span><br><span class="line">&#x2F;hook</span><br><span class="line">&#x2F;keys</span><br><span class="line">&#x2F;ws</span><br><span class="line">&#x2F;stats</span><br></pre></td></tr></table></figure>

<p><em>详细用法可参考salt-api rest_cherry官方文档</em></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p>salt-api：<a href="https://github.com/saltstack/salt-api" target="_blank" rel="noopener">https://github.com/saltstack/salt-api</a></p>
<p>rest_cherrypy：<a href="https://docs.saltstack.com/en/latest/ref/netapi/all/salt.netapi.rest_cherrypy.html" target="_blank" rel="noopener">https://docs.saltstack.com/en/latest/ref/netapi/all/salt.netapi.rest_cherrypy.html</a></p>
<p>认证模式：<a href="http://docs.saltstack.com/en/latest/topics/eauth/index.html" target="_blank" rel="noopener">http://docs.saltstack.com/en/latest/topics/eauth/index.html</a></p>
]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>SaltStack</tag>
        <tag>salt-api</tag>
        <tag>RESTful</tag>
        <tag>HTTPAPI</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>urllib2报错[SSL:CERTIFICATE_VERIFY_FAILED]</title>
    <url>/2016/03/21/urllib2%E6%8A%A5%E9%94%99-SSL-CERTIFICATE-VERIFY-FAILED/</url>
    <content><![CDATA[<blockquote>
<p>在python中使用urllib2库去访问一个自签名的网站时，会出现如下报错： <code>urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)&gt;</code></p>
</blockquote>
<p>出现以上错误的原因是因为python的版本问题，在python2.6（含2.6）以下版本中，在访问HTTPS的网站时，TLS握手期间不会检查服务器X509的证书签名是否是CA的可信任根证书。这种局面在python2.7 3.4 和 3.5版本中得到了修改。</p>
<h3 id="所以，以下代码在python2-6版本中测试是完全没有问题的"><a href="#所以，以下代码在python2-6版本中测试是完全没有问题的" class="headerlink" title="所以，以下代码在python2.6版本中测试是完全没有问题的"></a>所以，以下代码在python2.6版本中测试是完全没有问题的</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.20150509.cn:1559'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  pre_data = [&#123;<span class="string">"client"</span>:<span class="string">"local"</span>, <span class="string">"tgt"</span>:<span class="string">"*"</span>, <span class="string">"fun"</span>:<span class="string">"test.ping"</span>&#125;]</span><br><span class="line"></span><br><span class="line">  json_data = json.dumps(pre_data)</span><br><span class="line">  </span><br><span class="line">  header = &#123;<span class="string">"Content-Type"</span>:<span class="string">"application/json"</span>, <span class="string">"Accept"</span>:<span class="string">"application/json"</span>, <span class="string">"X-Auth-Token"</span>:<span class="string">"b91e7uj86g4f97cc**********b92778ujh4kedf"</span>&#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url, json_data, header)</span><br><span class="line"></span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line"></span><br><span class="line">  html = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">print</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  test()</span><br></pre></td></tr></table></figure>

<h4 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; python sa.py </span><br><span class="line">&#123;<span class="string">"return"</span>: [&#123;<span class="string">"vm3.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm2.salt.com"</span>: <span class="literal">true</span>, <span class="string">"ph1.salt.com"</span>: <span class="literal">true</span>, <span class="string">"ph2.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm1.salt.com"</span>: <span class="literal">true</span>, <span class="string">"vm4.salt.com"</span>: <span class="literal">true</span>, <span class="string">"localhost"</span>: <span class="literal">true</span>, <span class="string">"vm7.salt.com"</span>: <span class="literal">true</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="在python2-7-版本就会报上述错误"><a href="#在python2-7-版本就会报上述错误" class="headerlink" title="在python2.7+版本就会报上述错误"></a>在python2.7+版本就会报上述错误</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; python sa.py </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"sa.py"</span>, line 25, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    <span class="built_in">test</span>()</span><br><span class="line">  File <span class="string">"sa.py"</span>, line 17, <span class="keyword">in</span> <span class="built_in">test</span></span><br><span class="line">    response = urllib2.urlopen(request)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 154, <span class="keyword">in</span> urlopen</span><br><span class="line">    <span class="built_in">return</span> opener.open(url, data, timeout)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 431, <span class="keyword">in</span> open</span><br><span class="line">    response = self._open(req, data)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 449, <span class="keyword">in</span> _open</span><br><span class="line">    <span class="string">'_open'</span>, req)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 409, <span class="keyword">in</span> _call_chain</span><br><span class="line">    result = func(*args)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 1240, <span class="keyword">in</span> https_open</span><br><span class="line">    context=self._context)</span><br><span class="line">  File <span class="string">"/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python2.7/urllib2.py"</span>, line 1197, <span class="keyword">in</span> do_open</span><br><span class="line">    raise URLError(err)</span><br><span class="line">urllib2.URLError: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:590)&gt;</span><br></pre></td></tr></table></figure>

<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> ssl   <span class="comment">#add line 1</span></span><br><span class="line"></span><br><span class="line">ssl._create_default_https_context = ssl._create_unverified_context  <span class="comment">#add line 2</span></span><br><span class="line"></span><br><span class="line">url=<span class="string">'https://www.20150509.cn:1559'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">  </span><br><span class="line">  pre_data = [&#123;<span class="string">"client"</span>:<span class="string">"local"</span>, <span class="string">"tgt"</span>:<span class="string">"*"</span>, <span class="string">"fun"</span>:<span class="string">"test.ping"</span>&#125;]</span><br><span class="line"></span><br><span class="line">  json_data = json.dumps(pre_data)</span><br><span class="line">  </span><br><span class="line">  header = &#123;<span class="string">"Content-Type"</span>:<span class="string">"application/json"</span>, <span class="string">"Accept"</span>:<span class="string">"application/json"</span>, <span class="string">"X-Auth-Token"</span>:<span class="string">"b91e7uj86g4f97cc**********b92778ujh4kedf"</span>&#125;</span><br><span class="line"></span><br><span class="line">  request = urllib2.Request(url, json_data, header)</span><br><span class="line"></span><br><span class="line">  response = urllib2.urlopen(request)</span><br><span class="line"></span><br><span class="line">  html = response.read()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">print</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">  test()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参考文档："><a href="#参考文档：" class="headerlink" title="参考文档："></a>参考文档：</h3><p><a href="http://https://www.python.org/dev/peps/pep-0476/" target="_blank" rel="noopener">http://https://www.python.org/dev/peps/pep-0476/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>ssl</tag>
        <tag>urllib2</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL问题汇总</title>
    <url>/2016/03/08/MySQL%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>以下出现的MySQL问题均为本人亲历，所以本文的“问题汇总”实际为个人版本的“问题汇总”，如有其它MySQL问题，欢迎Email联系我共同讨论！</p>
</blockquote>
<p><strong>MySQL初始化问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql</span><br><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/lib/mysql/mysql.sock<span class="string">' (2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shell&gt; service mysqld restart</span></span><br><span class="line"><span class="string">Stopping mysqld:                                           [  OK  ]</span></span><br><span class="line"><span class="string">MySQL Daemon failed to start.</span></span><br><span class="line"><span class="string">Starting mysqld:                                           [FAILED]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#日志中报错如下：</span></span><br><span class="line"><span class="string">[ERROR] Fatal error: mysql.user table is damaged. Please run mysql_upgrade.</span></span><br><span class="line"><span class="string">[ERROR] Aborting</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#这种情况本人是在MySQL5.1到5.7版本升级时遇到的，升级到5.7后，数据库启动失败</span></span><br><span class="line"><span class="string">#解决的办法就是重新初始化数据库</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shell&gt; rm -fr /var/lib/mysql</span></span><br><span class="line"><span class="string">shell&gt; mysqld --initialize --user=mysql</span></span><br><span class="line"><span class="string">shell&gt; service mysqld restart</span></span><br><span class="line"><span class="string">Stopping mysqld:                                           [  OK  ]</span></span><br><span class="line"><span class="string">Starting mysqld:                                           [  OK  ]</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>mysql-files文件问题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#MySQL启动失败，日志中报错如下：</span></span><br><span class="line">[ERROR] Failed to access directory <span class="keyword">for</span> --secure-file-priv. Please make sure that directory exists and is accessible by MySQL Server. Supplied value : /var/lib/mysql-files</span><br><span class="line"></span><br><span class="line"><span class="comment">#造成这种情况可能是因为mysql-files文件夹不存在或权限错误</span></span><br><span class="line"><span class="comment">#解决办法如下：</span></span><br><span class="line">shell&gt; touch /var/lib/mysql-files</span><br><span class="line">shell&gt; chown mysql:mysql /var/lib/mysql-files</span><br><span class="line">shell&gt; service mysqld restart</span><br><span class="line">Stopping mysqld:                                           [  OK  ]</span><br><span class="line">Starting mysqld:                                           [  OK  ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Error</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6系列安装MySQL5.7</title>
    <url>/2016/03/08/CentOS6%E7%B3%BB%E5%88%97%E5%AE%89%E8%A3%85MySQL5-7/</url>
    <content><![CDATA[<blockquote>
<p>CentOS6系列，自带的repo库中，默认安装的依然是MySQL5.1版本，过于老旧，而5.6+版本相比5.1版本在各个方面均有全名的提升，对性能要求较高的应用优先考虑5.6+版本。本篇文章介绍使用MySQL官方源安装MySQL5.7</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">shell&gt; wget http://repo.mysql.com//mysql57-community-release-el6-7.noarch.rpm</span><br><span class="line">shell&gt; rpm -ivh mysql57-community-release-el6-7.noarch.rpm</span><br><span class="line">shell&gt; yum install mysql-server  <span class="comment">#这里会默认安装mysql-community-server和对应版本的mysql-community-client</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>如果已经安装有5.1的老版本，可以先将其卸载，再执行上面的安装步骤</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum remove mysql</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Setting up Remove Process</span><br><span class="line">Resolving Dependencies</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package mysql.x86_64 0:5.1.73-5.el6_6 will be erased</span><br><span class="line">--&gt; Processing Dependency: mysql = 5.1.73-5.el6_6 <span class="keyword">for</span> package: mysql-server-5.1.73-5.el6_6.x86_64</span><br><span class="line">--&gt; Running transaction check</span><br><span class="line">---&gt; Package mysql-server.x86_64 0:5.1.73-5.el6_6 will be erased</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line"></span><br><span class="line">Dependencies Resolved</span><br><span class="line"></span><br><span class="line">=====================================================================================</span><br><span class="line"> Package               Arch            Version                  Repository      Size</span><br><span class="line">=====================================================================================</span><br><span class="line">Removing:</span><br><span class="line"> mysql                 x86_64          5.1.73-5.el6_6           @base          2.4 M</span><br><span class="line">Removing <span class="keyword">for</span> dependencies:</span><br><span class="line"> mysql-server          x86_64          5.1.73-5.el6_6           @base           25 M</span><br><span class="line"></span><br><span class="line">Transaction Summary</span><br><span class="line">=====================================================================================</span><br><span class="line">Remove        2 Package(s)</span><br><span class="line"></span><br><span class="line">Installed size: 27 M</span><br><span class="line">Is this ok [y/N]:</span><br><span class="line"><span class="comment">#卸载老版本的MySQL，默认会同时卸载掉对应的client端</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行上面的安装部分...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#启动数据库可能会出现下面的错误</span></span><br><span class="line">shell&gt; service mysqld restart</span><br><span class="line">Stopping mysqld:                                           [  OK  ]</span><br><span class="line">MySQL Daemon failed to start.</span><br><span class="line">Starting mysqld:                                           [FAILED]</span><br><span class="line"></span><br><span class="line">shell&gt; mysql</span><br><span class="line">ERROR 2002 (HY000): Can<span class="string">'t connect to local MySQL server through socket '</span>/var/lib/mysql/mysql.sock<span class="string">' (2)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#查看日志出现如下报错</span></span><br><span class="line"><span class="string">#[ERROR] Fatal error: mysql.user table is damaged. Please run mysql_upgrade.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#解决方法是重新初始化数据库</span></span><br><span class="line"><span class="string">shell&gt; rm -fr /var/lib/mysql</span></span><br><span class="line"><span class="string">shell&gt; mysqld --initialize --user=mysql</span></span><br><span class="line"><span class="string">shell&gt; service mysqld restart</span></span><br><span class="line"><span class="string">Stopping mysqld:                                           [  OK  ]</span></span><br><span class="line"><span class="string">Starting mysqld:                                           [  OK  ]</span></span><br></pre></td></tr></table></figure>

<hr>
<p>假如老版本的5.1由于某些原因，不能卸载或不允许卸载，那么安装5.7时，可以使用编译安装的方式，将新数据库启动的端口由3306改成3307，即可实现两个MySQL版本的数据库进程共存</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Grafana2.6+Zabbix3.0监控系统搭建</title>
    <url>/2016/03/04/Grafana-2-6-Zabbix-3-0-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍在CentOS6系列系统中，安装zabbix 3.0与grafana 2.5 搭配的监控系统<br>据了解在zabbix 3.0 LTS版本有50余项升级，zabbix是结合了众多监控系统的优点，是一款比较全面分布式监控系统。在与Grafana搭伙后，完美解决了Zabbix GUI审美疲劳的痛点，接下来进入正题（Zabbix 3.0安装部分完全按照官方文档的步骤实现）</p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ol>
<li>本文的Zabbix部分知识只介绍它的基础安装，Zabbix的使用以及配置优化并不在本文的介绍范围之内。</li>
<li>本文只介绍在CentOS6系列下的安装和部署，其他发行版与其他版本号暂不涉及</li>
<li>本文默认使用MySQL作为后端数据库支持</li>
</ol>
<hr>
<h1 id="CentOS-6-x-基础环境配置部分"><a href="#CentOS-6-x-基础环境配置部分" class="headerlink" title="CentOS 6.x 基础环境配置部分"></a>CentOS 6.x 基础环境配置部分</h1><h2 id="基础环境介绍"><a href="#基础环境介绍" class="headerlink" title="基础环境介绍"></a>基础环境介绍</h2><ul>
<li>CentOS 6.7 64bit</li>
<li>8CPU</li>
<li>1G Mem</li>
<li>MySQL InnoDB</li>
</ul>
<h2 id="基础依赖环境配置"><a href="#基础依赖环境配置" class="headerlink" title="基础依赖环境配置"></a>基础依赖环境配置</h2><h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><strong>1.Zabbix官方文档要求Apache的版本要在1.3.12之后</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install httpd -y</span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Setting up Install Process</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.neusoft.edu.cn</span><br><span class="line"> * epel: mirrors.yun-idc.com</span><br><span class="line"> * extras: mirrors.btte.net</span><br><span class="line"> * remi-safe: mirror.innosol.asia</span><br><span class="line"> * rpmforge: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.btte.net</span><br><span class="line">Package httpd-2.2.15-47.el6.centos.3.x86_64 already installed and latest version</span><br><span class="line">Nothing to <span class="keyword">do</span></span><br></pre></td></tr></table></figure>

<p> 我这里已经安装了<code>httpd 2.2</code>版本，符合官方文档中的要求</p>
<p><strong>2.启动httpd服务，并设置为开机自动启动</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; service httpd start</span><br><span class="line">shell&gt; chkconfig httpd on</span><br></pre></td></tr></table></figure>

<h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><p><strong>PHP的版本要求在5.4以上，但Linux 6.x系统自带repo中的PHP版本是5.3.3 不符合Zabbix官方文档的要求，需要使用Remi repo来安装更高版本的PHP</strong></p>
<h4 id="配置Remi-Repo来安装高版本的PHP"><a href="#配置Remi-Repo来安装高版本的PHP" class="headerlink" title="配置Remi Repo来安装高版本的PHP"></a>配置Remi Repo来安装高版本的PHP</h4><p><strong>1.下载Remi</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install http://rpms.famillecollet.com/enterprise/remi-release-6.rpm</span><br></pre></td></tr></table></figure>

<p><strong>2.配置Remi</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用习惯的文本编辑器（如 vim）打开 Remi 源配置文件 &#x2F;etc&#x2F;yum.repos.d&#x2F;remi.repo</span><br><span class="line">启用 Remi Repository修改 enabled&#x3D;0 为 enabled&#x3D;1</span><br><span class="line">为 Remi Repository 设置合适的优先级在 [remi] 那一节的结尾另起一行添加下面的代码：priority&#x3D;3</span><br></pre></td></tr></table></figure>

<p><strong>3.安装PHP</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install --enablerepo=remi php php-gd</span><br></pre></td></tr></table></figure>

<ul>
<li><p>因为php-gd和php版本可能有依赖，所以php-gd这个扩展也使用remi这个repo来安装</p>
</li>
<li><p>如果出现<code>Requires: libt1.so.5()(64bit)</code>这个报错，可以参考 <a href="http://docs.20150509.cn/2016/03/02/Requires-libt1-so-5-64bit/" target="_blank" rel="noopener">http://docs.20150509.cn/2016/03/02/Requires-libt1-so-5-64bit/</a> 这篇文章解决</p>
</li>
</ul>
<p><strong>4.根据Zabbix官方文档需求安装PHP扩展</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install php-bcmath php-ctype php-xml php-xmlreader php-xmlwriter php-session php-net-socket php-gettext php-mbstring php-gettext php-ldap php-mysql</span><br></pre></td></tr></table></figure>

<h3 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h3><p><strong>根据官方文档的要求，需要在服务器中安装一下软件支持</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install OpenIPMI OpenIPMI-devel libssh2 libssh2-devel fping libcurl libxml2 libxml2-devel net-snmp</span><br></pre></td></tr></table></figure>

<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><p><strong>官方文档要求MySQL的版本要在5.0.3以上，CentOS 6.7默认的repo里提供的MySQL版本为5.1.73 符合官方文档要求</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install mysql mysql-server mysql-devel</span><br><span class="line">shell&gt; service mysqld start  <span class="comment">#首次启动需要初始化</span></span><br><span class="line">shell&gt; chkconfig mysqld on  <span class="comment">#添加开机自动启动</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Zabbix安装部分"><a href="#Zabbix安装部分" class="headerlink" title="Zabbix安装部分"></a>Zabbix安装部分</h1><p><strong>Zabbix 3.0的安装参考了官方文档中源码编译安装的方式，软件包的方式比较简单，大家可以参考官方文档自行试验，时间关系，这里暂不介绍rpm包的安装方式，后续有时间会补充提供这种安装方式的说明</strong></p>
<h2 id="源码安装的方式"><a href="#源码安装的方式" class="headerlink" title="源码安装的方式"></a>源码安装的方式</h2><h3 id="下载Zabbix-3-0源码包并解压"><a href="#下载Zabbix-3-0源码包并解压" class="headerlink" title="下载Zabbix 3.0源码包并解压"></a>下载Zabbix 3.0源码包并解压</h3><p>Zabbix 3.0 源码官方下载地址： <a href="http://www.zabbix.com/download.php" target="_blank" rel="noopener">http://www.zabbix.com/download.php</a><br>选择<code>Zabbix Sources</code>下的<code>Zabbix 3.0 LTS</code>进行下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; tar -zxvf zabbix-3.0.0.tar.gz  <span class="comment">#解压缩</span></span><br></pre></td></tr></table></figure>

<h3 id="创建用户及组"><a href="#创建用户及组" class="headerlink" title="创建用户及组"></a>创建用户及组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; groupadd zabbix</span><br><span class="line">shell&gt; useradd -g zabbix zabbix</span><br></pre></td></tr></table></figure>

<h3 id="创建Zabbix数据库"><a href="#创建Zabbix数据库" class="headerlink" title="创建Zabbix数据库"></a>创建Zabbix数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p&lt;password&gt;</span><br><span class="line">mysql&gt; create database zabbix character <span class="built_in">set</span> utf8 collate utf8_bin;</span><br><span class="line">mysql&gt; grant all privileges on zabbix.* to zabbix@localhost identified by <span class="string">'&lt;password&gt;'</span>;</span><br><span class="line">mysql&gt; quit;</span><br><span class="line">shell&gt; <span class="built_in">cd</span> database/mysql  <span class="comment">#在解压缩后的zabbix-3.0.0文件夹中</span></span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;password&gt; zabbix &lt; schema.sql</span><br><span class="line"><span class="comment">#如果你是为Zabbix Proxy来创建数据库，那么到这里就必须停止了，下面的不需要执行</span></span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;password&gt; zabbix &lt; images.sql</span><br><span class="line">shell&gt; mysql -uzabbix -p&lt;password&gt; zabbix &lt; data.sql</span><br></pre></td></tr></table></figure>

<h3 id="编译安装Zabbix-Server和Zabbix-Agent"><a href="#编译安装Zabbix-Server和Zabbix-Agent" class="headerlink" title="编译安装Zabbix Server和Zabbix Agent"></a>编译安装Zabbix Server和Zabbix Agent</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; ./configure --<span class="built_in">help</span> <span class="comment">#可以查看编译的参数项</span></span><br><span class="line">shell&gt; ./configure --<span class="built_in">enable</span>-server --<span class="built_in">enable</span>-agent --with-mysql --<span class="built_in">enable</span>-ipv6 --with-net-snmp --with-libcurl --with-libxml2  <span class="comment">#Zabbix Server与Agent安装参数参考</span></span><br><span class="line">shell&gt; make install</span><br></pre></td></tr></table></figure>

<p>其他组件安装参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; ./configure --prefix=/usr --<span class="built_in">enable</span>-proxy --with-net-snmp --with-sqlite3 --with-ssh2  <span class="comment">#Zabbix Proxy安装参数参考</span></span><br><span class="line">shell&gt; ./configure --<span class="built_in">enable</span>-agent  <span class="comment">#Zabbix Agent安装参数参考</span></span><br></pre></td></tr></table></figure>

<h3 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h3><p>如果Server与Agent采用了AIO（All In One）的部署方式，作为测试，Agent的配置文件<code>可以不修改</code></p>
<p>接下来修改Server的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; vim /usr/<span class="built_in">local</span>/etc/zabbix_server.conf</span><br><span class="line"><span class="comment">#以下为修改完成后的项目</span></span><br><span class="line"><span class="comment">#DBName和DBUser保持以下默认参数即可，只需设置DBPassword一项</span></span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix  <span class="comment">#上面配置数据时，我设置zabbix用户的密码为zabbix</span></span><br></pre></td></tr></table></figure>

<h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; zabbix_server  <span class="comment">#启动Zabbix Server</span></span><br><span class="line">shell&gt; zabbix_agentd  <span class="comment">#启动Zabbix Agent</span></span><br></pre></td></tr></table></figure>

<p>启动其他服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; zabbix_proxy  <span class="comment">#启动Zabbix Proxy</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Zabbix网站页面接口"><a href="#安装Zabbix网站页面接口" class="headerlink" title="安装Zabbix网站页面接口"></a>安装Zabbix网站页面接口</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mkdir /var/www/html/zabbix</span><br><span class="line">shell&gt; <span class="built_in">cd</span> frontends/php  <span class="comment">#在解压缩后的zabbix-3.0.0文件夹中</span></span><br><span class="line">shell&gt; cp -a . /var/www/html/zabbix</span><br></pre></td></tr></table></figure>

<h3 id="配置Zabbix"><a href="#配置Zabbix" class="headerlink" title="配置Zabbix"></a>配置Zabbix</h3><ul>
<li><p><strong>在浏览器中打开如下网址： <a href="http://server_ip_or_name/zabbix" target="_blank" rel="noopener">http://server_ip_or_name/zabbix</a></strong></p>
</li>
<li><p>在打开的页面中看到“Welcome to Zabbix 3.0”几个大字就算成功了一半了！点击<code>Next step</code><img src="http://oss.20150509.cn/install_1.png" alt="Welcome"></p>
</li>
<li><p>第二个页面<code>Check of pre-requisites</code> 会检查PHP的一些配置参数（第一列是变量名；第二列是PHP配置文件实际值；第三项是Zabbix强制要求的最低值或固定值），默认情况下这个页面所有的检查项应该都是“OK”的，如果有红色的错误项，根据前面提示的变量名，去找PHP的配置文件，修改成“REQUIRED”要求的值就可以啦（默认PHP的配置文件<code>/etc/php.ini</code>）<img src="http://oss.20150509.cn/install_2.png" alt="Check of pre-requisites"></p>
</li>
<li><p>第三个页面<code>Configure DB connection</code> 这一步骤会去尝试连接数据库。第一项数据库类型选择<code>MySQL</code>；DB Host 保持默认的<code>localhost</code>（因为这里采用了AIO的安装方式，数据库没有单独分离）；DB Port修改成<code>3306</code>；DB Name：<code>zabbix</code>； User：<code>zabbix</code>；Password：<code>zabbix</code>。点击<code>Next step</code>如果出现报错，根据报错信息排查是否是配置错误（这些配置都是在前面设置过的，3306是MySQL默认的端口号）<img src="http://oss.20150509.cn/install_3.png" alt="Configure DB connection"></p>
</li>
<li><p>第四个页面<code>Zabbix server details</code> 保持默认的Host：<code>localhost</code>和Port：<code>10051</code>配置即可，Name可以自定义设置，为这套监控系统起个名字<img src="http://oss.20150509.cn/install_4.png" alt="Zabbix server details"></p>
</li>
<li><p>第五个页面<code>Pre-installation summary</code> 总览一下前面所有的配置<code>Next step</code><img src="http://oss.20150509.cn/install_5.png" alt="Pre-installation summary"></p>
</li>
<li><p>第六个页面<code>Install</code> 我在进入到这个页面后，出现了报错，提示<code>Can not create the configuration file</code> 下方官方也给出了手动解决这个问题的方法。按照提示，第一步点击给出的连接，下载zabbix官方提供的配置文件；第二步，根据提示，放在指定的位置保存为指定的文件，我这里提示保存为：<code>/usr/share/zabbix/conf/zabbix.conf.php</code> 按照提示操作完成后点击<code>Finish</code><img src="http://oss.20150509.cn/install_6.png" alt="Install"></p>
</li>
<li><p>如果上面配置的都没有问题，第七个页面将会出现<code>congratulations! ...</code> 点击<code>Finish</code><img src="http://oss.20150509.cn/install_7.png" alt="Install2"></p>
</li>
<li><p>第八个页面将会出现登陆页面，默认的登陆用户名为<code>Admin</code> 密码为<code>zabbix</code><img src="http://oss.20150509.cn/login.png" alt="login"></p>
</li>
</ul>
<h3 id="Zabbix的使用简介"><a href="#Zabbix的使用简介" class="headerlink" title="Zabbix的使用简介"></a>Zabbix的使用简介</h3><p>进入到Zabbix首页后，会发现3.0版本与之前的2.x版本的界面相比焕然一新，更养眼了，对解决2.x版本的审美疲劳起到了一定的作用。当然这只是最肤浅的外貌协会成员的结论，除了颜值高了，Zabbix还有50余项技术更新，变得愈发强大了<del>~</del></p>
<ul>
<li>在<code>Configuation</code>–&gt;<code>Hosts</code>–&gt;<code>status</code>中，将<code>Disabled</code>变成<code>Enabled</code>状态，稍等片刻，如果Zabbix Agent启动正常的话，<code>ZBX</code>的图标就会亮起，表示Server与Agent之间通信正常<img src="http://oss.20150509.cn/Zabbix_1.jpg" alt="Enabled"></li>
<li>监控首页会是如下状态（各个模块可以拖拽移动布局）<img src="http://oss.20150509.cn/Zabbix_2.jpg" alt="Dashboard"></li>
<li>再瞅一眼监控图表的效果~<img src="http://oss.20150509.cn/Zabbix_3.jpg" alt="Graphs1"></li>
</ul>
<p><strong>那么问题来了，虽然3.0换了一层扁平简约的外观，但是图表展示还是一样的丑……为了解决这个问题，Grafana可以帮上大忙，接下来的部分就详细介绍如何使用Grafana给Zabbix监控图表披上一层华丽的外衣</strong></p>
<h2 id="RPM包安装方式"><a href="#RPM包安装方式" class="headerlink" title="RPM包安装方式"></a>RPM包安装方式</h2><p><em>略</em></p>
<hr>
<h1 id="Grafana安装部分"><a href="#Grafana安装部分" class="headerlink" title="Grafana安装部分"></a>Grafana安装部分</h1><p>截止至我写这篇文档的时候，Grafana的最新版本是<code>2.6.0</code> 而Grafana原生是不支持获取Zabbix数据的，需要通过grafana-zabbix插件来实现，grafana-zabbix插件的最新版本是2.5.1，github上写的很清楚，该插件服务于Grafana的2.5版本。经过测试，成功在2.6.0的Grafana上使用了grafana-zabbix的2.5.1版本。所以这里你可以任意选择2.5或2.6版本的Grafana来安装。</p>
<h2 id="Grafana的下载及安装"><a href="#Grafana的下载及安装" class="headerlink" title="Grafana的下载及安装"></a>Grafana的下载及安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install https://grafanarel.s3.amazonaws.com/builds/grafana-2.6.0-1.x86_64.rpm  <span class="comment">#这里只提供了yum的安装方式，其他安装方式可以参考附录中的Grafana官方安装文档</span></span><br><span class="line">shell&gt; service grafana-server start  <span class="comment">#启动Grafana服务</span></span><br><span class="line">shell&gt; chkconfig grafana-server on  <span class="comment">#添加开机自动启动</span></span><br></pre></td></tr></table></figure>

<h2 id="Grafana-Zabbix插件的下载及安装"><a href="#Grafana-Zabbix插件的下载及安装" class="headerlink" title="Grafana Zabbix插件的下载及安装"></a>Grafana Zabbix插件的下载及安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#https://github.com/alexanderzobnin/grafana-zabbix/releases/latest  #请到该网址下载2.5.1版本的grafana-zabbix插件</span></span><br><span class="line">shell&gt; tar -xvzf grafana-zabbix-2.5.1.tar.gz</span><br><span class="line">shell&gt; cp -r grafana-zabbix-2.5.1/zabbix/  /usr/share/grafana/public/app/plugins/datasource/</span><br><span class="line">shell&gt; service grafana-server restart</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="Grafana-Zabbix联通部分"><a href="#Grafana-Zabbix联通部分" class="headerlink" title="Grafana + Zabbix联通部分"></a>Grafana + Zabbix联通部分</h1><ul>
<li>在浏览器地址栏输入 <code>http://IP:3000</code>就可以看到Grafana的登陆页面了。输入默认的用户名<code>admin</code> 密码<code>admin</code>登陆</li>
<li>点击左侧的<code>Data Sourses</code>–&gt;<code>Add new</code><ul>
<li>Type下拉框中选择<code>Zabbix</code></li>
<li>Name 可以自由发挥~~</li>
<li>Http settings–&gt;Url 填入<code>http://zabbix-server-ip/zabbix/api_jsonrpc.php</code> 这里填入的是Zabbix API接口</li>
<li>Http settings–&gt;Access 选择 <code>direct</code> 使用直接访问的方式</li>
<li>Zabbix API details–&gt;User 填入<code>Admin</code></li>
<li>Zabbix API details–&gt;Password 填入 <code>zabbix</code></li>
<li>点<code>Save</code>保存后再编辑，出现<code>Test Connection</code>按钮，点击可测试API配置是否正确。出现：Success Zabbix API version: 3.0.0 配置成功<img src="http://oss.20150509.cn/grafana_1.jpg" alt="enter image description here"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="Grafana配置部分"><a href="#Grafana配置部分" class="headerlink" title="Grafana配置部分"></a>Grafana配置部分</h1><p>至此仅差最后一步，将Zabbix的数据读取到Grafana来以图表展示，就打完收工啦！</p>
<ul>
<li>点击左侧的<code>Dashboards</code>–&gt;<code>Home</code>–&gt;在下拉菜单的底部选择<code>+ New</code>。这时新的页面中默认出现一个空的横行图表，左上角有绿色的竖线，右下角有<code>+ ADD ROW</code>添加新行的按钮。</li>
<li>鼠标放在左上角的绿色竖线上，点击后弹出一个菜单，选择<code>Add Panel</code>。下面有五个选项，下面选择四个常用的分别介绍</li>
<li>记得点击上面的<code>保存</code>按钮以保存新建的页面</li>
</ul>
<h2 id="Graph"><a href="#Graph" class="headerlink" title="Graph"></a>Graph</h2><p>这个选项是创建一个图表，类似于Zabbix的监控图表，是最常用的类型之一。</p>
<ul>
<li>General-Title：设置该图表的名称</li>
<li>Metrics：在该项的右下角，选择正确的数据源（之前在Data Sources配置的Name）</li>
<li>Metrics-Group/Host/Application/Item：这些项目是必填项目，需要依次下拉选择</li>
</ul>
<p><em>如果一张图需要展现两条线的数据，可以在左下角点击<code>+ Query</code></em></p>
<ul>
<li>Display Styles-Chart Options：这里可以选择以<code>竖线</code>展示，以<code>折线</code>展示或以<code>点</code>来展示数据<br><img src="http://oss.20150509.cn/grafana_2.jpg" alt="Grafana-Graph"></li>
</ul>
<h2 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h2><p>表格展示，类似于Excel表格的展现形式<br><img src="http://oss.20150509.cn/grafana_3.jpg" alt="enter image description here"></p>
<ul>
<li>点击 <code>- +</code> 号可以调整该模块的大小（横向伸缩）</li>
<li>点击<code>Edit</code>可以重新编辑该模块的数据源</li>
</ul>
<h2 id="Single-stat"><a href="#Single-stat" class="headerlink" title="Single stat"></a>Single stat</h2><p>单统计模块，从字面意思就可以知道，该种模块仅可以展示一种数据，统计一种数据。这里需要重点说明就是<code>Option</code>选项下的参数</p>
<p>以统计磁盘使用大小一项来举例</p>
<ul>
<li>Unit：要选择<code>data</code>下的<code>bytes</code>单位来统计</li>
<li>Decimals：小数设置保持默认的auto即可</li>
<li>Coloring：这里可以选择渲染背景色或字体色<ul>
<li>Colors控制着三个颜色，可以自由发挥，一般绿色代表正常，黄色代表预警，红色代表警告</li>
<li>Thresholds可以设置以逗号分隔的三个数字，分别表示三个状态的阈值</li>
<li>Spark lines有两种显示模式，<code>Show</code>会在数据的下方展示折线；<code>Background mode</code>会在整个模块的背景展示折线</li>
</ul>
</li>
</ul>
<h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><p>这个模块很好理解，就是一个现实文字的模块，支持markdown语法，可以放在每个页面的头部，标记当前图表信息的归类。</p>
<h2 id="Dashboards-list"><a href="#Dashboards-list" class="headerlink" title="Dashboards list"></a>Dashboards list</h2><p>这个模块是用来展示页面列表用的。举个例子，如果一个监控系统中，涉及到了多个页面展示监控图表，就会用到这个功能，这个模块会列出你需要展示的页面的列表，方便在当前页面中，快速的切换到其他监控页面。</p>
<h2 id="最终效果图"><a href="#最终效果图" class="headerlink" title="最终效果图"></a>最终效果图</h2><p><img src="http://oss.20150509.cn/grafana_5.jpg" alt="Final"></p>
<h2 id="页面自动刷新"><a href="#页面自动刷新" class="headerlink" title="页面自动刷新"></a>页面自动刷新</h2><p>点击右上角<code>Last 6 hours</code>, 在弹出的下拉框中，选择<code>Time range</code>下的<code>Refreshing every</code>选项，点击下拉框按钮，默认应该有<code>off</code> 和 <code>1m</code>两个选项。点击<code>1m</code> 然后<code>Apply</code>设置。即为每一分钟刷新一次数据的意思。<strong>设置成功后</strong>，在原来<code>Last 6 hours</code>的后面会出现<code>Refresh every 1m</code>的橙色文字！</p>
<hr>
<h1 id="附录：参考文档"><a href="#附录：参考文档" class="headerlink" title="附录：参考文档"></a>附录：参考文档</h1><p><a href="https://www.zabbix.com/documentation/3.0/manual/installation/requirements" target="_blank" rel="noopener">Zabbix 3.0官方文档</a></p>
<p><a href="http://cnzhx.net/blog/remi-repository/#i-2" target="_blank" rel="noopener">Remi官方文档</a></p>
<p><a href="http://grafana.org/" target="_blank" rel="noopener">Grafana官方网站</a></p>
<p><a href="http://docs.grafana.org/installation/rpm/" target="_blank" rel="noopener">Grafana官方安装文档</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Grafana</tag>
        <tag>Zabbix</tag>
        <tag>PHP</tag>
        <tag>Remi</tag>
      </tags>
  </entry>
  <entry>
    <title>Requires: libt1.so.5()(64bit)</title>
    <url>/2016/03/02/Requires-libt1-so-5-64bit/</url>
    <content><![CDATA[<blockquote>
<p>在使用yum安装php5.5的过程中，出现了如下依赖：<br>–&gt; Finished Dependency Resolution<br>Error: Package: php-gd-5.4.45-4.el6.remi.x86_64 (remi)<br>           Requires: libt1.so.5()(64bit)<br>通过yum provides 命令反查询后发现是由于缺少了t1lib这个软件包</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum install --enablerepo=remi php php-gd</span><br><span class="line">...</span><br><span class="line">--&gt; Processing Dependency: libt1.so.5()(64bit) <span class="keyword">for</span> package: php-gd-5.4.45-4.el6.remi.x86_64</span><br><span class="line">--&gt; Finished Dependency Resolution</span><br><span class="line">Error: Package: php-gd-5.4.45-4.el6.remi.x86_64 (remi)</span><br><span class="line">           Requires: libt1.so.5()(64bit)</span><br><span class="line"> You could try using --skip-broken to work around the problem</span><br><span class="line"> You could try running: rpm -Va --nofiles --nodigest</span><br></pre></td></tr></table></figure>

<p>安装php的过程中出现了不可解决的依赖软件<code>libt1.so.5()(64bit)</code></p>
<p>使用yum的反查询功能查出包含有这个库文件的软件包是哪一个<br>(在使用yum反查询后没有得到任何结果，后来排查得知是我yum的base repo设置有问题，导致yum读不到base中的软件库信息。多说一句，如果遇到以上问题，可以排查一下是不是服务器的base repo出现的问题，可以使用centos自带的centos-base.repo，也可以下载163的centos-base-163.repo库)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; yum provides <span class="string">"*/libt1.so.5"</span></span><br><span class="line">Loaded plugins: fastestmirror, refresh-packagekit, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.yun-idc.com</span><br><span class="line"> * epel: mirrors.opencas.cn</span><br><span class="line"> * extras: mirrors.yun-idc.com</span><br><span class="line"> * remi-safe: mirror.innosol.asia</span><br><span class="line"> * rpmforge: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.yun-idc.com</span><br><span class="line">t1lib-5.1.2-6.el6_2.1.x86_64 : PostScript Type 1 font rasterizer</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/lib64/libt1.so.5</span><br><span class="line"></span><br><span class="line">t1lib-5.1.2-6.el6_2.1.i686 : PostScript Type 1 font rasterizer</span><br><span class="line">Repo        : base</span><br><span class="line">Matched from:</span><br><span class="line">Filename    : /usr/lib/libt1.so.5</span><br></pre></td></tr></table></figure>

<p>接下来，解决这个问题只需<code>yum install t1lib -y</code>即可</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
        <tag>Error</tag>
        <tag>libt1.so.5</tag>
        <tag>t1lib</tag>
      </tags>
  </entry>
  <entry>
    <title>忘记MySQL密码</title>
    <url>/2016/02/03/%E5%BF%98%E8%AE%B0MySQL%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="Step1-修改配置文件"><a href="#Step1-修改配置文件" class="headerlink" title="Step1 修改配置文件"></a>Step1 修改配置文件</h1><p>修改MySQL的配置文件（默认为/etc/my.cnf）,在[mysqld]下添加一行skip-grant-tables</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@PolarSnow hexo]# cat &#x2F;etc&#x2F;my.cnf </span><br><span class="line">[mysqld]</span><br><span class="line">datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">socket&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock</span><br><span class="line">user&#x3D;mysql</span><br><span class="line"># Disabling symbolic-links is recommended to prevent assorted security risks</span><br><span class="line">symbolic-links&#x3D;0</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">innodb_file_per_table&#x3D;1</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure>

<h1 id="Step2-重启MySQL服务"><a href="#Step2-重启MySQL服务" class="headerlink" title="Step2 重启MySQL服务"></a>Step2 重启MySQL服务</h1><p><code>service mysqld restart</code></p>
<h1 id="Step3-再次进入MySQL命令行"><a href="#Step3-再次进入MySQL命令行" class="headerlink" title="Step3 再次进入MySQL命令行"></a>Step3 再次进入MySQL命令行</h1><p><code>mysql -uroot -p</code> 输入密码时直接回车，就会进入MySQL数据库了</p>
<p>接下来按照常规流程修改root密码即可</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>创建MySQL用户并授权</title>
    <url>/2016/02/03/%E5%88%9B%E5%BB%BAMySQL%E7%94%A8%E6%88%B7%E5%B9%B6%E6%8E%88%E6%9D%83/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@MasterDatabase ~]# mysql</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 161391</span><br><span class="line">Server version: 5.1.73-log Source distribution</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2013, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| test               |</span><br><span class="line">| zabbix             |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create user &#39;wordpress&#39;@&#39;%&#39; identified by &#39;wordpress&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; create database wordpress;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; grant all privileges on wordpress.* to &#39;wordpress&#39;@&#39;%&#39;;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建用户：</span><br><span class="line">CREATE USER &#39;username&#39;@&#39;host&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line"></span><br><span class="line">CREATE USER &#39;username&#39;@&#39;192.168.5.9&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line">CREATE USER &#39;username&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39;;</span><br><span class="line">CREATE USER &#39;username&#39;@&#39;%&#39; IDENTIFIED BY &#39;&#39;;</span><br><span class="line">CREATE USER &#39;username&#39;@&#39;%&#39;;</span><br><span class="line"></span><br><span class="line">授权：</span><br><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;;</span><br><span class="line"></span><br><span class="line">GRANT SELECT,INSERT ON DBname.tablename TO &#39;username&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON DBname.tablename TO &#39;username&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON DBname.* TO &#39;username&#39;@&#39;%&#39;;</span><br><span class="line">GRANT ALL ON *.* TO &#39;username&#39;@&#39;%&#39;;</span><br><span class="line">注意：使用以上命令授权的用户不能用来再给其他用户授权</span><br><span class="line">如果想让该用户可以为其他用户授权，可以使用如下命令：</span><br><span class="line">GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39; WITH GRANT OPTION;</span><br><span class="line"></span><br><span class="line">设置&#x2F;更改用户密码</span><br><span class="line">SET PASSWORD FOR &#39;username&#39;@&#39;host&#39;&#x3D;PASSWORD(&#39;newpassword&#39;);</span><br><span class="line">如果是修改当前登录的用户的密码，使用如下命令：</span><br><span class="line">SET PASSWDORD&#x3D;PASSWORD(&#39;newpassword&#39;)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>解决ImportError: No module named zlib</title>
    <url>/2016/01/21/%E8%A7%A3%E5%86%B3ImportError-No-module-named-zlib/</url>
    <content><![CDATA[<blockquote>
<p>常用的CentOS6.7中，默认自带的Python版本还是2.6.6，升级到2.7.11后，安装某些第三方的库提示<code>ImportError: No module named zlib</code> 百度了一下，按照前辈的方法果然解决了问题。特此记录下来！</p>
</blockquote>
<p><strong>bash部分</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install zlib zlib-devel openssl</span><br></pre></td></tr></table></figure>

<p><strong>python部分</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python2.7.11</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;python27</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import zlib</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><em>没有结果就是最好的结果！</em></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>zlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的高级特性</title>
    <url>/2015/12/09/Python%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">3</span>]: l = list(range(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#取前5个元素</span></span><br><span class="line">In [<span class="number">4</span>]: l[:<span class="number">5</span>]</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取后5个元素</span></span><br><span class="line">In [<span class="number">5</span>]: l[<span class="number">-5</span>:]</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="number">95</span>, <span class="number">96</span>, <span class="number">97</span>, <span class="number">98</span>, <span class="number">99</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取第11-20的元素</span></span><br><span class="line">In [<span class="number">6</span>]: l[<span class="number">11</span>:<span class="number">20</span>]</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取前10个元素，每2个取一个</span></span><br><span class="line">In [<span class="number">7</span>]: l[:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取第1-10的元素，每2个取一个</span></span><br><span class="line">In [<span class="number">8</span>]: l[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>]</span><br><span class="line">Out[<span class="number">8</span>]: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取全部的元素，每10个取一个</span></span><br><span class="line">In [<span class="number">9</span>]: l[::<span class="number">10</span>]</span><br><span class="line">Out[<span class="number">9</span>]: [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#取得全部元素</span></span><br><span class="line">In [<span class="number">10</span>]: l[:]</span><br><span class="line"></span><br><span class="line"><span class="comment">#记住最后一个元素的索引是-1</span></span><br><span class="line">In [<span class="number">11</span>]: l[<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">11</span>]: <span class="number">99</span></span><br></pre></td></tr></table></figure>

<h2 id="list切片"><a href="#list切片" class="headerlink" title="list切片"></a>list切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: l = [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>, <span class="string">'microsoft'</span>, <span class="string">'linkin'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: l</span><br><span class="line">Out[<span class="number">2</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>, <span class="string">'microsoft'</span>, <span class="string">'linkin'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: l[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">3</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: l[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">4</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: l[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">5</span>]: [<span class="string">'google'</span>, <span class="string">'facebook'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: l[<span class="number">-2</span>:]</span><br><span class="line">Out[<span class="number">6</span>]: [<span class="string">'microsoft'</span>, <span class="string">'linkin'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: l[<span class="number">-2</span>:<span class="number">-1</span>]</span><br><span class="line">Out[<span class="number">7</span>]: [<span class="string">'microsoft'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="tuple切片"><a href="#tuple切片" class="headerlink" title="tuple切片"></a>tuple切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">13</span>]: (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">13</span>]: (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h2 id="str切片"><a href="#str切片" class="headerlink" title="str切片"></a>str切片</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">14</span>]: <span class="string">'apple'</span>[:<span class="number">3</span>]</span><br><span class="line">Out[<span class="number">14</span>]: <span class="string">'app'</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h1><p>在Python中迭代是通过<code>for ... in ...</code>来实现的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">15</span>]: d = &#123;<span class="string">'apple'</span>:<span class="string">'pages'</span>, <span class="string">'google'</span>:<span class="string">'docs'</span>, <span class="string">'microsoft'</span>:<span class="string">'word'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: <span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">   ....:     <span class="keyword">print</span> key</span><br><span class="line">   ....:     </span><br><span class="line">google</span><br><span class="line">apple</span><br><span class="line">microsoft</span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: <span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">   ....:     <span class="keyword">print</span> value</span><br><span class="line">   ....:     </span><br><span class="line">docs</span><br><span class="line">pages</span><br><span class="line">word</span><br><span class="line"></span><br><span class="line">In [<span class="number">18</span>]: <span class="keyword">for</span> k, v <span class="keyword">in</span> d.items():</span><br><span class="line">   ....:     <span class="keyword">print</span> k,v</span><br><span class="line">   ....:     </span><br><span class="line">google docs</span><br><span class="line">apple pages</span><br><span class="line">microsoft word</span><br></pre></td></tr></table></figure>

<p>列表、元组、字典和字符串都是可迭代对象<br>判断一个对象是否是可迭代对象，通过collections模块的Iterable来判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">22</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: isinstance(<span class="string">'123'</span>, Iterable)</span><br><span class="line">Out[<span class="number">23</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: isinstance([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], Iterable)</span><br><span class="line">Out[<span class="number">24</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: isinstance((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), Iterable)</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: isinstance(&#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;, Iterable)</span><br><span class="line">Out[<span class="number">26</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h1><p>Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">27</span>]: <span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]):</span><br><span class="line">   ....:     print(i, value)</span><br><span class="line">   ....:    </span><br><span class="line">(<span class="number">0</span>, <span class="string">'A'</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="string">'B'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h1><p>列表生成式有自己的特殊语法<br>把要生成的元素放到<code>最前面</code>，后跟<code>for</code>循环，就可以创建一个<code>list</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n [<span class="number">29</span>]: [i * i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>)]</span><br><span class="line">Out[<span class="number">29</span>]: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#二层循环实现全排列</span></span><br><span class="line">In [<span class="number">30</span>]: [m + n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">'ABC'</span> <span class="keyword">for</span> n <span class="keyword">in</span> <span class="string">'XYZ'</span>]</span><br><span class="line">Out[<span class="number">30</span>]: [<span class="string">'AX'</span>, <span class="string">'AY'</span>, <span class="string">'AZ'</span>, <span class="string">'BX'</span>, <span class="string">'BY'</span>, <span class="string">'BZ'</span>, <span class="string">'CX'</span>, <span class="string">'CY'</span>, <span class="string">'CZ'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出根目录下的所有文件和文件夹</span></span><br><span class="line">In [<span class="number">37</span>]: [f <span class="keyword">for</span> f <span class="keyword">in</span> os.listdir(<span class="string">'/'</span>)]</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">[<span class="string">'.autorelabel'</span>,</span><br><span class="line"> <span class="string">'lib'</span>,</span><br><span class="line"> <span class="string">'sbin'</span>,</span><br><span class="line"> <span class="string">'proc'</span>,</span><br><span class="line"> <span class="string">'dev'</span>,</span><br><span class="line"> <span class="string">'lib64'</span>,</span><br><span class="line"> <span class="string">'mnt'</span>,</span><br><span class="line"> <span class="string">'usr'</span>,</span><br><span class="line"> <span class="string">'etc'</span>,</span><br><span class="line"> <span class="string">'var'</span>,</span><br><span class="line"> <span class="string">'selinux'</span>,</span><br><span class="line"> <span class="string">'.autofsck'</span>,</span><br><span class="line"> <span class="string">'sys'</span>,</span><br><span class="line"> <span class="string">'srv'</span>,</span><br><span class="line"> <span class="string">'media'</span>,</span><br><span class="line"> <span class="string">'tmp'</span>,</span><br><span class="line"> <span class="string">'data'</span>,</span><br><span class="line"> <span class="string">'boot'</span>,</span><br><span class="line"> <span class="string">'lost+found'</span>,</span><br><span class="line"> <span class="string">'home'</span>,</span><br><span class="line"> <span class="string">'root'</span>,</span><br><span class="line"> <span class="string">'opt'</span>,</span><br><span class="line"> <span class="string">'bin'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#列表生成式使用两个变量来生成列表</span></span><br><span class="line">In [<span class="number">38</span>]: d</span><br><span class="line">Out[<span class="number">38</span>]: &#123;<span class="string">'apple'</span>: <span class="string">'pages'</span>, <span class="string">'google'</span>: <span class="string">'docs'</span>, <span class="string">'microsoft'</span>: <span class="string">'word'</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: [k + <span class="string">'--&gt;'</span> + v <span class="keyword">for</span> k,v <span class="keyword">in</span> d.items()]</span><br><span class="line">Out[<span class="number">39</span>]: [<span class="string">'google--&gt;docs'</span>, <span class="string">'apple--&gt;pages'</span>, <span class="string">'microsoft--&gt;word'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#将列表中的元素全部转为小写或大写</span></span><br><span class="line">In [<span class="number">42</span>]: l = [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">43</span>]: [s.lower() <span class="keyword">for</span> s <span class="keyword">in</span> l]</span><br><span class="line">Out[<span class="number">43</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">44</span>]: [s.upper() <span class="keyword">for</span> s <span class="keyword">in</span> l]</span><br><span class="line">Out[<span class="number">44</span>]: [<span class="string">'APPLE'</span>, <span class="string">'GOOGLE'</span>, <span class="string">'FACEBOOK'</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">45</span>]: l.append(<span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">46</span>]: l</span><br><span class="line">Out[<span class="number">46</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>, <span class="number">59</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">47</span>]: [s.upper() <span class="keyword">for</span> s <span class="keyword">in</span> l]</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input<span class="number">-47</span><span class="number">-0e109</span>a4f23f3&gt; <span class="keyword">in</span> &lt;module&gt;()</span><br><span class="line">----&gt; 1 [s.upper() for s in l]</span><br><span class="line"></span><br><span class="line">AttributeError: <span class="string">'int'</span> object has no attribute <span class="string">'upper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面遇到列表中出现字符串和数字混合的情况，数字对象没有upper()或lower()方法</span></span><br><span class="line"><span class="comment">#这时需要使用判断来排除数字的情况</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: l</span><br><span class="line">Out[<span class="number">52</span>]: [<span class="string">'apple'</span>, <span class="string">'google'</span>, <span class="string">'facebook'</span>, <span class="number">59</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: [s.upper() <span class="keyword">for</span> s <span class="keyword">in</span> l <span class="keyword">if</span> isinstance(s, str)]</span><br><span class="line">Out[<span class="number">53</span>]: [<span class="string">'APPLE'</span>, <span class="string">'GOOGLE'</span>, <span class="string">'FACEBOOK'</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="生成器（yield）"><a href="#生成器（yield）" class="headerlink" title="生成器（yield）"></a>生成器（yield）</h1><p>生成器返回一个<code>可迭代的对象</code></p>
<p>生成器的关键字<code>yield</code>，与<code>return</code>的区别是</p>
<ul>
<li><p>return 立即返回结果并结束函数</p>
</li>
<li><p>yield 返回结果并暂停函数，等待<code>next()</code>的下一次调用</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">my_fun</span><span class="params">()</span>:</span></span><br><span class="line">   ...:         sum = <span class="number">1</span></span><br><span class="line">   ...:         <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">   ...:                 sum = sum + <span class="number">1</span></span><br><span class="line">   ...:                 <span class="keyword">yield</span> sum</span><br><span class="line">   ...:         </span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: m = my_fun()</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: m.next()</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: m.next()</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">3</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: m.next()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="number">4</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: m.next()</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">5</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: my_fun()</span><br><span class="line">Out[<span class="number">7</span>]: &lt;generator object my_fun at <span class="number">0x2767a00</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: my_fun().next()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">9</span>]: my_fun().next()</span><br><span class="line">Out[<span class="number">9</span>]: <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: my_fun().next()</span><br><span class="line">Out[<span class="number">10</span>]: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>上面介绍的<code>列表生成式</code>也可以变成<code>生成器生成式</code></p>
<p>只需把<code>中括号</code>换成<code>小括号</code>就变成了一个生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">11</span>]: L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: L</span><br><span class="line">Out[<span class="number">12</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">13</span>]: G = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: G</span><br><span class="line">Out[<span class="number">14</span>]: &lt;generator object &lt;genexpr&gt; at <span class="number">0x2767aa0</span>&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">15</span>]: G.next()</span><br><span class="line">Out[<span class="number">15</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: G.next()</span><br><span class="line">Out[<span class="number">16</span>]: <span class="number">1</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">17</span>]: G.next()</span><br><span class="line">Out[<span class="number">17</span>]: <span class="number">4</span></span><br></pre></td></tr></table></figure>

<p><strong>生成器保存的是算法，在使用时计算结果，节省内存空间</strong></p>
<hr>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>可以直接作用于<code>for</code>循环的数据类型有以下几种：</p>
<ul>
<li><p>集合数据类型。如<code>list</code> <code>tuple</code>  <code>dict</code> <code>set</code> <code>str</code>等</p>
</li>
<li><p>generator，包括生成器和带yield的generator function</p>
</li>
</ul>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象<code>Iterable</code></p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>可迭代对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">21</span>]: isinstance([],Iterable)</span><br><span class="line">Out[<span class="number">21</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>生成器</strong>不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，最后抛出<code>StopIteration</code>异常，表示已经结束，无法返回下一个值</p>
<p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器</strong>：<code>Iterator</code></p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">24</span>]: <span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line">Out[<span class="number">25</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: isinstance([], Iterator)</span><br><span class="line">Out[<span class="number">26</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="Iterator-和-Iterable的区别"><a href="#Iterator-和-Iterable的区别" class="headerlink" title="Iterator 和 Iterable的区别"></a>Iterator 和 Iterable的区别</h2><ul>
<li><p>生成器都是Iterator对象，但<code>list</code> <code>dict</code>等是Iterable，但不是Iterator</p>
</li>
<li><p>Iterator是迭代器，需要同时具备<code>__iter__</code>和<code>next</code>两个方法，它们表示一个惰性计算的序列</p>
</li>
<li><p>Iterable是可迭代对象，列表元组等数据结构同样是可迭代对象，具备<code>__iter__</code>方法，但不具备<code>next</code>方法</p>
</li>
</ul>
<p><strong>使用for循环遍历可迭代对象时，for循环自动调用next()函数，并在接收到结束异常时退出循环</strong></p>
<hr>
<p>参考文章：<a href="http://www.liaoxuefeng.com/" target="_blank" rel="noopener">http://www.liaoxuefeng.com/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>切片</tag>
        <tag>生成器</tag>
        <tag>迭代器</tag>
        <tag>Iterator</tag>
        <tag>Iterable</tag>
        <tag>yield</tag>
        <tag>列表生成式</tag>
        <tag>enumerate</tag>
        <tag>迭代</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数笔记</title>
    <url>/2015/12/08/Python%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_fun</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"run function"</span></span><br><span class="line">    <span class="keyword">return</span> arg * arg</span><br></pre></td></tr></table></figure>

<p>如果没有写<code>return</code>语句，函数执行之后会返回<code>None</code></p>
<h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>可以有多个返回值，但是多个返回值默认是以元组的方式返回，相当于返回了一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_fun3</span><span class="params">(arg1, arg2)</span>:</span></span><br><span class="line"><span class="meta">... </span>    x = arg1 + <span class="number">59</span></span><br><span class="line"><span class="meta">... </span>    y = arg2 + <span class="number">59</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x,y</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = my_fun3(<span class="number">12</span>,<span class="number">78</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(r)</span><br><span class="line">&lt;type <span class="string">'tuple'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r</span><br><span class="line">(<span class="number">71</span>, <span class="number">137</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r, t = my_fun3(<span class="number">56</span>, <span class="number">89</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> r,t</span><br><span class="line"><span class="number">115</span> <span class="number">148</span></span><br></pre></td></tr></table></figure>

<h2 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_fun2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h1 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h1><p><code>function_name()</code>是调用函数的基本语法</p>
<ul>
<li>function_name 是函数的名字（可以使自定义函数，可以使内置函数，可以使第三方模块中的函数）</li>
<li>() 括号里放的是该函数的参数，如果没有参数，可以为空</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_fun4</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"hello"</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"world"</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_fun4()</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"><span class="comment"># my_fun4函数里面只有两行打印语句，没有定义返回值，所以返回值默认为空（None）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = my_fun4()</span><br><span class="line">hello</span><br><span class="line">world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> s</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(s)</span><br><span class="line">&lt;type <span class="string">'NoneType'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_fun5</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"hello world"</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># my_fun5函数里面定义了返回值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ss = my_fun5()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> ss</span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(ss)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br></pre></td></tr></table></figure>

<h1 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h1><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>拿一个简单的幂运算举例<br><code>n=2</code>即为默认参数，在调用该函数时，如果只指定了一个参数，那变量<code>n</code>将默认等于<code>2</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_fun6</span><span class="params">(x, n=<span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** n</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_fun6(<span class="number">3</span>)</span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_fun6(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">27</span></span><br></pre></td></tr></table></figure>

<p>也可以将两个参数都设置有默认变量，这样该函数即使不传参，也能正常工作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_fun6()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: my_fun6() takes at least <span class="number">1</span> argument (<span class="number">0</span> given)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">my_fun7</span><span class="params">(x=<span class="number">3</span>,n=<span class="number">2</span>)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> x ** n</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_fun7()</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="使用默认参数的注意事项"><a href="#使用默认参数的注意事项" class="headerlink" title="使用默认参数的注意事项"></a>使用默认参数的注意事项</h3><ul>
<li><p>必选参数在前，默认参数在后，否则Python解释器会报错</p>
</li>
<li><p>当函数需要多个参数的时候，将变化较大的参数放在前面，变化小的放在后面作为默认参数</p>
</li>
<li><p>默认参数必须指向不可变对象（eg: int, string, float）</p>
</li>
</ul>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可以折衷地使用列表或元组实现可变长参数<br><em>(以下交互终端使用了ipython)</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(numbers)</span>:</span></span><br><span class="line">   ...:     sum = <span class="number">0</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">   ...:         sum = sum + i</span><br><span class="line">   ...:     <span class="keyword">return</span> sum</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: cal([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">Out[<span class="number">2</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: cal((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">Out[<span class="number">3</span>]: <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>可变参数的关键字为<code>*</code>星号。在设置函数的接收参数时，前面加上一个星号，则函数内部接收到的所有参数会自动转化为一个元组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">5</span>]: <span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">   ...:     sum = <span class="number">0</span></span><br><span class="line">   ...:     <span class="keyword">for</span> i <span class="keyword">in</span> numbers:</span><br><span class="line">   ...:         sum = sum + i</span><br><span class="line">   ...:     <span class="keyword">return</span> sum</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: cal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: cal()</span><br><span class="line">Out[<span class="number">7</span>]: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: cal(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">Out[<span class="number">8</span>]: <span class="number">21</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">9</span>]: <span class="function"><span class="keyword">def</span> <span class="title">cal</span><span class="params">(*numbers)</span>:</span></span><br><span class="line">   ...:     <span class="keyword">return</span> type(numbers)</span><br><span class="line">   ...: </span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: cal()</span><br><span class="line">Out[<span class="number">10</span>]: tuple</span><br></pre></td></tr></table></figure>

<h2 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h2><p>可变长参数传入到函数内部会自动转换成一个<code>元组</code>；而关键字参数传入到函数内部会自动转换成一个<code>字典</code><br>关键字参数的关键字是<code>**</code>两个星号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">12</span>]: <span class="function"><span class="keyword">def</span> <span class="title">person</span><span class="params">(name, age, **otherkeyword)</span>:</span></span><br><span class="line">   ....:     <span class="keyword">print</span> <span class="string">'name: '</span>, name, <span class="string">'\n'</span>, <span class="string">'age: '</span>, age, <span class="string">'\n'</span>, <span class="string">'otherInfo: '</span>, otherkeyword</span><br><span class="line">   ....:    </span><br><span class="line"> </span><br><span class="line">In [<span class="number">13</span>]: person(<span class="string">'ps'</span>,<span class="number">24</span>)</span><br><span class="line">name:  ps</span><br><span class="line">age:  <span class="number">24</span></span><br><span class="line">otherInfo:  &#123;&#125;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">14</span>]: person(<span class="string">'ps'</span>,<span class="number">24</span>,city=<span class="string">'BJ'</span>)</span><br><span class="line">name:  ps</span><br><span class="line">age:  <span class="number">24</span></span><br><span class="line">otherInfo:  &#123;<span class="string">'city'</span>: <span class="string">'BJ'</span>&#125;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">15</span>]: person(<span class="string">'ps'</span>,<span class="number">24</span>,city=<span class="string">'BJ'</span>,job=<span class="string">'Engineer'</span>)</span><br><span class="line">name:  ps</span><br><span class="line">age:  <span class="number">24</span></span><br><span class="line">otherInfo:  &#123;<span class="string">'city'</span>: <span class="string">'BJ'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">16</span>]: dict_kw = &#123;<span class="string">'city'</span>: <span class="string">'BJ'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">17</span>]: dict_kw</span><br><span class="line">Out[<span class="number">17</span>]: &#123;<span class="string">'city'</span>: <span class="string">'BJ'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br><span class="line"> </span><br><span class="line">In [<span class="number">18</span>]: person(<span class="string">'ps'</span>,<span class="number">24</span>,**dict_kw)</span><br><span class="line">name:  ps</span><br><span class="line">age:  <span class="number">24</span></span><br><span class="line">otherInfo:  &#123;<span class="string">'city'</span>: <span class="string">'BJ'</span>, <span class="string">'job'</span>: <span class="string">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h2><p>上面提到了四种参数（必选参数、默认参数、可变参数、关键字参数），这四种参数可以一起使用。<br>参数定义的顺序必须是：必须参数、默认参数、可变参数、关键字参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">21</span>]: <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">   ....:     <span class="keyword">print</span> <span class="string">'a:'</span>, a, <span class="string">'\n'</span>, <span class="string">'b:'</span>, b, <span class="string">'\n'</span>, <span class="string">'c:'</span>, c, <span class="string">'\n'</span>, <span class="string">'tuple_args:'</span>, args, <span class="string">'\n'</span>, <span class="string">'dict_kw:'</span>, kw</span><br><span class="line">   ....:     </span><br><span class="line"></span><br><span class="line">In [<span class="number">22</span>]: func(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">a: <span class="number">1</span> </span><br><span class="line">b: <span class="number">2</span> </span><br><span class="line">c: <span class="number">0</span> </span><br><span class="line">tuple_args: () </span><br><span class="line">dict_kw: &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">23</span>]: func(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line">a: <span class="number">1</span> </span><br><span class="line">b: <span class="number">2</span> </span><br><span class="line">c: <span class="number">3</span> </span><br><span class="line">tuple_args: () </span><br><span class="line">dict_kw: &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">24</span>]: func(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">  File <span class="string">"&lt;ipython-input-24-9272b7482bc9&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: non-keyword arg after keyword arg</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">a: <span class="number">1</span> </span><br><span class="line">b: <span class="number">2</span> </span><br><span class="line">c: <span class="number">3</span> </span><br><span class="line">tuple_args: (<span class="number">4</span>, <span class="number">5</span>) </span><br><span class="line">dict_kw: &#123;&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">26</span>]: func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,x=<span class="number">59</span>)</span><br><span class="line">a: <span class="number">1</span> </span><br><span class="line">b: <span class="number">2</span> </span><br><span class="line">c: <span class="number">3</span> </span><br><span class="line">tuple_args: (<span class="number">4</span>, <span class="number">5</span>) </span><br><span class="line">dict_kw: &#123;<span class="string">'x'</span>: <span class="number">59</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li><p>*args是可变参数，接收一个tuple</p>
</li>
<li><p>**kw是关键字参数，接收一个dict</p>
</li>
<li><p>在必选参数，默认参数，可变长参数和关键字参数混合使用时，默认参数在复制时不要指定参数名，如上例的<code>c=3</code> 否则会报错</p>
</li>
</ul>
<h1 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h1><h2 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h2><p><strong>isinstance函数判断对象类型</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">obj1</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>o = obj1()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'string'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="number">5.9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(o, obj1)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(t, tuple)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(l, list)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(d, dict)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(s, str)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(i, int)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> isinstance(f, float)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Built-in-Functions</tag>
      </tags>
  </entry>
  <entry>
    <title>Python下解析YAML文件</title>
    <url>/2015/12/07/Python%E4%B8%8B%E8%A7%A3%E6%9E%90YAML%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<blockquote>
<p>Python中解析YAML文件主要使用到两个方法，load()和dump()方法，使用方式类似于Python的pickle。熟悉在Python中解析YAML文件，对使用Python做saltstack自定义插件开发时会有很大的帮助</p>
</blockquote>
<h1 id="load"><a href="#load" class="headerlink" title="load"></a>load</h1><p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@PolarSnow saltstack]<span class="comment"># cat eg.yaml </span></span><br><span class="line">name: Tom Smith</span><br><span class="line">age: 37</span><br><span class="line">spouse:</span><br><span class="line">  name: Jane Smith</span><br><span class="line">  age: 25</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 15</span><br><span class="line">  - name1: Jenny Smith</span><br><span class="line">    age1: 12</span><br><span class="line"></span><br><span class="line">[root@PolarSnow saltstack]<span class="comment"># cat py_yaml.py</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">import yaml</span><br><span class="line"></span><br><span class="line">with open(<span class="string">'eg.yaml'</span>, <span class="string">'r'</span>) as loadfile:</span><br><span class="line">    <span class="built_in">print</span> yaml.load(loadfile)</span><br><span class="line"></span><br><span class="line">[root@PolarSnow saltstack]<span class="comment"># python py_yaml.py</span></span><br><span class="line">&#123;<span class="string">'age'</span>: 37, <span class="string">'spouse'</span>: &#123;<span class="string">'age'</span>: 25, <span class="string">'name'</span>: <span class="string">'Jane Smith'</span>&#125;, <span class="string">'name'</span>: <span class="string">'Tom Smith'</span>, <span class="string">'children'</span>: [&#123;<span class="string">'age'</span>: 15, <span class="string">'name'</span>: <span class="string">'Jimmy Smith'</span>&#125;, &#123;<span class="string">'age1'</span>: 12, <span class="string">'name1'</span>: <span class="string">'Jenny Smith'</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eg.yaml'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> loadfile:</span><br><span class="line">    <span class="keyword">print</span> yaml.load(loadfile)</span><br></pre></td></tr></table></figure>

<h1 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h1><p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@PolarSnow saltstack]<span class="comment"># cat eg.yaml </span></span><br><span class="line">name: Tom Smith</span><br><span class="line">age: 37</span><br><span class="line">spouse:</span><br><span class="line">  name: Jane Smith</span><br><span class="line">  age: 25</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 15</span><br><span class="line">  - name1: Jenny Smith</span><br><span class="line">    age1: 12</span><br><span class="line"></span><br><span class="line">[root@PolarSnow saltstack]<span class="comment"># cat py_yaml.py </span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">import yaml</span><br><span class="line">with open(<span class="string">'eg.yaml'</span>, <span class="string">'r'</span>) as loadfile:</span><br><span class="line">    y = yaml.load(loadfile)</span><br><span class="line">    <span class="built_in">print</span> y</span><br><span class="line">with open(<span class="string">'eg1.yaml'</span>,<span class="string">'w'</span>) as dumpfile:</span><br><span class="line">    dumpfile.write(yaml.dump(y))</span><br><span class="line">    <span class="built_in">print</span> yaml.dump(y)</span><br><span class="line"></span><br><span class="line">[root@PolarSnow saltstack]<span class="comment"># python py_yaml.py </span></span><br><span class="line">&#123;<span class="string">'age'</span>: 37, <span class="string">'spouse'</span>: &#123;<span class="string">'age'</span>: 25, <span class="string">'name'</span>: <span class="string">'Jane Smith'</span>&#125;, <span class="string">'name'</span>: <span class="string">'Tom Smith'</span>, <span class="string">'children'</span>: [&#123;<span class="string">'age'</span>: 15, <span class="string">'name'</span>: <span class="string">'Jimmy Smith'</span>&#125;, &#123;<span class="string">'age1'</span>: 12, <span class="string">'name1'</span>: <span class="string">'Jenny Smith'</span>&#125;]&#125;</span><br><span class="line">age: 37</span><br><span class="line">children:</span><br><span class="line">- &#123;age: 15, name: Jimmy Smith&#125;</span><br><span class="line">- &#123;age1: 12, name1: Jenny Smith&#125;</span><br><span class="line">name: Tom Smith</span><br><span class="line">spouse: &#123;age: 25, name: Jane Smith&#125;</span><br><span class="line"></span><br><span class="line">[root@PolarSnow saltstack]<span class="comment"># cat eg1.yaml </span></span><br><span class="line">age: 37</span><br><span class="line">children:</span><br><span class="line">- &#123;age: 15, name: Jimmy Smith&#125;</span><br><span class="line">- &#123;age1: 12, name1: Jenny Smith&#125;</span><br><span class="line">name: Tom Smith</span><br><span class="line">spouse: &#123;age: 25, name: Jane Smith&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#打开一个yaml文件将其解析，再将解析后的结构再转成yaml写入到新的文件</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eg.yaml'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> loadfile:</span><br><span class="line">    y = yaml.load(loadfile)</span><br><span class="line">    <span class="keyword">print</span> y</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eg1.yaml'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> dumpfile:</span><br><span class="line">    dumpfile.write(yaml.dump(y))</span><br><span class="line">    <span class="keyword">print</span> yaml.dump(y)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>saltstack</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础知识笔记</title>
    <url>/2015/12/04/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Python基础知识笔记"><a href="#Python基础知识笔记" class="headerlink" title="Python基础知识笔记"></a>Python基础知识笔记</h1><hr>
<h1 id="运行一个脚本后再进入交互终端-python-i"><a href="#运行一个脚本后再进入交互终端-python-i" class="headerlink" title="运行一个脚本后再进入交互终端 python -i"></a>运行一个脚本后再进入交互终端 python -i</h1><p>使用<strong>-i</strong>参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ echo <span class="string">"#!/usr/bin/env python</span></span><br><span class="line"><span class="string">import sys"</span> &gt; test.py</span><br><span class="line"></span><br><span class="line">$ python -i test.py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</span><br></pre></td></tr></table></figure>

<h1 id="print的内容禁止转义"><a href="#print的内容禁止转义" class="headerlink" title="print的内容禁止转义 \"></a>print的内容禁止转义 \</h1><p>使用 <code>r&#39; &#39;</code>使单引号中的所有字符禁止转义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'x\ny\tz'</span></span><br><span class="line">x</span><br><span class="line">y	z</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">r'x\ny\tz'</span></span><br><span class="line">x\ny\tz</span><br></pre></td></tr></table></figure>

<h1 id="打印多行-‘’’…’’’"><a href="#打印多行-‘’’…’’’" class="headerlink" title="打印多行 ‘’’…’’’"></a>打印多行 ‘’’…’’’</h1><p>使用<code>\n</code>输入多行时可能不太好阅读，可以通过<code>&#39;&#39;&#39; &#39;&#39;&#39;</code>三引号的方式来输出多行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'''line one</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line two</span></span><br><span class="line"><span class="string"><span class="meta">... </span>line three</span></span><br><span class="line"><span class="string"><span class="meta">... </span>'''</span></span><br><span class="line">line one</span><br><span class="line">line two</span><br><span class="line">line three</span><br></pre></td></tr></table></figure>

<h1 id="常量-PI"><a href="#常量-PI" class="headerlink" title="常量 PI"></a>常量 PI</h1><p>在Python中的常量也是一个变量，只不过为了显示这是个常量，约定俗成用大写表示常量<br>在Python中没有任何机制保证大写的变量不会被更改！</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PI = <span class="number">3.1415926</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串与数字间的转换（ASCII）"><a href="#字符串与数字间的转换（ASCII）" class="headerlink" title="字符串与数字间的转换（ASCII）"></a>字符串与数字间的转换（ASCII）</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'L'</span>)</span><br><span class="line"><span class="number">76</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">76</span>)</span><br><span class="line"><span class="string">'L'</span></span><br></pre></td></tr></table></figure>

<h1 id="在Python中使用Unicode编码"><a href="#在Python中使用Unicode编码" class="headerlink" title="在Python中使用Unicode编码"></a>在Python中使用Unicode编码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span></span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span></span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'中文'</span></span><br><span class="line">中文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'\u4e2d\u6587'</span></span><br><span class="line">中文</span><br></pre></td></tr></table></figure>

<h1 id="Unicode与禁止转义连用-print-ur’…’"><a href="#Unicode与禁止转义连用-print-ur’…’" class="headerlink" title="Unicode与禁止转义连用 print ur’…’"></a>Unicode与禁止转义连用 print ur’…’</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'中\t文'</span></span><br><span class="line">中    文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">ur'中\t文'</span></span><br><span class="line">中\t文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">ur'中\t文'</span></span><br><span class="line"><span class="string">u'\u4e2d\\t\u6587'</span></span><br></pre></td></tr></table></figure>

<h1 id="Unicode与utf-8字符编码间的转换"><a href="#Unicode与utf-8字符编码间的转换" class="headerlink" title="Unicode与utf-8字符编码间的转换"></a>Unicode与utf-8字符编码间的转换</h1><h2 id="Unicode-2-UTF-8"><a href="#Unicode-2-UTF-8" class="headerlink" title="Unicode 2 UTF-8"></a>Unicode 2 UTF-8</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'ABC'</span></span><br><span class="line"><span class="string">u'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'ABC'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span></span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">u'中文'</span>.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span></span><br></pre></td></tr></table></figure>

<h2 id="UTF-8-2-Unicode"><a href="#UTF-8-2-Unicode" class="headerlink" title="UTF-8 2 Unicode"></a>UTF-8 2 Unicode</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">u'\u4e2d\u6587'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">中文</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'\u4e2d\u6587'</span></span><br><span class="line">中文</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">u'ABC'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'ABC'</span>.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">ABC</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'ABC'</span></span><br><span class="line">ABC</span><br></pre></td></tr></table></figure>

<h1 id="Python文件中使用中文的声明-print-u’…’"><a href="#Python文件中使用中文的声明-print-u’…’" class="headerlink" title="Python文件中使用中文的声明 print u’…’"></a>Python文件中使用中文的声明 print u’…’</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">u'中文'</span></span><br></pre></td></tr></table></figure>

<h1 id="字符串格式化（占位符）"><a href="#字符串格式化（占位符）" class="headerlink" title="字符串格式化（占位符）"></a>字符串格式化（占位符）</h1><p>常见的占位符：</p>
<ul>
<li>%d    整数</li>
<li>%f    浮点数</li>
<li>%s    字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'Hi %s'</span> % <span class="string">'ps'</span></span><br><span class="line">Hi ps</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">'Hi %s, I have %d questions to ask you'</span> % (<span class="string">'ps'</span>, <span class="number">59</span>)</span><br><span class="line">Hi ps, I have <span class="number">59</span> questions to ask you</span><br></pre></td></tr></table></figure>

<p>对Unicode字符串进行占位时，字符编码需要前后保持一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">u'Hi %s, I have %d questions to ask you'</span> % (<span class="string">u'ps'</span>, <span class="number">59</span>)</span><br><span class="line">Hi ps, I have <span class="number">59</span> questions to ask you</span><br></pre></td></tr></table></figure>

<p>对占位符转义<code>%%</code>–&gt;’%’</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"update %d%"</span> % <span class="number">59</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: incomplete format</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"update %d%%"</span> % <span class="number">59</span></span><br><span class="line">update <span class="number">59</span>%</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist = [<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="取值-list-index"><a href="#取值-list-index" class="headerlink" title="取值 list[index]"></a>取值 list[index]</h2><p>列表中最后一个元素的位置是<code>len(testlist) - 1</code> or <code>testlist[-1]</code></p>
<p>以此类推，倒数第二个元素是<code>testlist[-2]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(testlist)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(testlist) - <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist[len(testlist) - <span class="number">1</span>]</span><br><span class="line"><span class="string">'Samaung'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'Samaung'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist[<span class="number">-2</span>]</span><br><span class="line"><span class="string">'Microsoft'</span></span><br></pre></td></tr></table></figure>

<h2 id="追加-append-value"><a href="#追加-append-value" class="headerlink" title="追加 append(value)"></a>追加 append(value)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist.append(<span class="string">'lastvalue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>, <span class="string">'lastvalue'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="插入-insert-index-value"><a href="#插入-insert-index-value" class="headerlink" title="插入 insert(index, value)"></a>插入 insert(index, value)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>, <span class="string">'lastvalue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist.insert(<span class="number">1</span>, <span class="string">'secondvalue'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'secondvalue'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>, <span class="string">'lastvalue'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="删除末尾及指定位置的元素-pop-index"><a href="#删除末尾及指定位置的元素-pop-index" class="headerlink" title="删除末尾及指定位置的元素 pop(index)"></a>删除末尾及指定位置的元素 pop(index)</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'secondvalue'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>, <span class="string">'lastvalue'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist.pop()</span><br><span class="line"><span class="string">'lastvalue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'secondvalue'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist.pop(<span class="number">1</span>)</span><br><span class="line"><span class="string">'secondvalue'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="替换元素"><a href="#替换元素" class="headerlink" title="替换元素"></a>替换元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#直接覆盖</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Samaung'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist[<span class="number">2</span>] = <span class="string">'Google'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[<span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>]</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line"><span class="comment">## 二维数组</span></span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist = [[<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[[<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(testlist)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">'iPad'</span></span><br></pre></td></tr></table></figure>

<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><h2 id="单个元素的元组"><a href="#单个元素的元组" class="headerlink" title="单个元素的元组"></a>单个元素的元组</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple = (<span class="string">'apple'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple</span><br><span class="line"><span class="string">'apple'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(testtuple)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple = (<span class="string">'apple'</span>, )</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple</span><br><span class="line">(<span class="string">'apple'</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(testtuple)</span><br><span class="line">&lt;type <span class="string">'tuple'</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="“可变元组”"><a href="#“可变元组”" class="headerlink" title="“可变元组”"></a>“可变元组”</h2><p>一般情况下元组是不可变的数据结构，如果需要实现让元组可变，可以在元组中加入列表来实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple = ([<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple</span><br><span class="line">([<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple[<span class="number">0</span>].append(<span class="string">'iPod'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple</span><br><span class="line">([<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>, <span class="string">'iPod'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple[<span class="number">0</span>][<span class="number">2</span>] = <span class="string">'MBP'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple</span><br><span class="line">([<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'MBP'</span>, <span class="string">'iPod'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>)</span><br><span class="line"><span class="comment">#元组的指向并没有变，所以这个元组可以认为仍然没有变化，变的是元组中list的元素</span></span><br></pre></td></tr></table></figure>

<h1 id="if判断语句"><a href="#if判断语句" class="headerlink" title="if判断语句"></a>if判断语句</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>results = <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> results &lt; <span class="number">0</span> <span class="keyword">or</span> results &gt; <span class="number">100</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"OMG!!!"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> <span class="number">0</span> &lt;= results &lt; <span class="number">60</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"Fail!!!"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> <span class="number">60</span> &lt;= results &lt; <span class="number">80</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"OK!!!"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">elif</span> results &gt;= <span class="number">80</span> <span class="keyword">and</span> results &lt;=<span class="number">100</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"good!!!"</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"Impossible!!!"</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">good!!!</span><br></pre></td></tr></table></figure>

<h2 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h2><p>只要<code>x</code>是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span> x:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'not null'</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">else</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">'null'</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line">null</span><br></pre></td></tr></table></figure>

<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for…in…"><a href="#for…in…" class="headerlink" title="for…in…"></a>for…in…</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>testtuple = ([<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> t <span class="keyword">in</span> testtuple:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> t</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">[<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>]</span><br><span class="line">Microsoft</span><br><span class="line">Google</span><br></pre></td></tr></table></figure>

<h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>start = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>end = <span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> start</span><br><span class="line"><span class="meta">... </span>    start = start + <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> start &gt; end:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<h1 id="raw-input"><a href="#raw-input" class="headerlink" title="raw_input"></a>raw_input</h1><p><code>num = raw_input(&#39;please input a num:&#39;)</code></p>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="基础语法-1"><a href="#基础语法-1" class="headerlink" title="基础语法"></a>基础语法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = &#123;<span class="string">'apple'</span>:<span class="string">'pages'</span>, <span class="string">'microsoft'</span>:<span class="string">'word'</span>, <span class="string">'google'</span>:<span class="string">'docs'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="string">'apple'</span>]</span><br><span class="line"><span class="string">'pages'</span></span><br></pre></td></tr></table></figure>

<h2 id="检查元素是否包含在字典中"><a href="#检查元素是否包含在字典中" class="headerlink" title="检查元素是否包含在字典中"></a>检查元素是否包含在字典中</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; p &#x3D; &#123;&#39;apple&#39;:&#39;pages&#39;, &#39;microsoft&#39;:&#39;word&#39;, &#39;google&#39;:&#39;docs&#39;&#125;</span><br><span class="line">&gt;&gt;&gt; p[&#39;apple&#39;]</span><br><span class="line">&#39;pages&#39;</span><br><span class="line">&gt;&gt;&gt; &#39;apple&#39; in p</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查找不到元素会返回None空</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.get(<span class="string">'google'</span>)</span><br><span class="line"><span class="string">'docs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.get(<span class="string">'baidu'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除一个key"><a href="#删除一个key" class="headerlink" title="删除一个key"></a>删除一个key</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p.pop(<span class="string">'google'</span>)</span><br><span class="line"><span class="string">'docs'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&#123;<span class="string">'apple'</span>: <span class="string">'pages'</span>, <span class="string">'microsoft'</span>: <span class="string">'word'</span>&#125;</span><br></pre></td></tr></table></figure>

<h1 id="in关键字"><a href="#in关键字" class="headerlink" title="in关键字"></a>in关键字</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#判断一个元素是否包含在一个字典中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = &#123;<span class="string">'apple'</span>:<span class="string">'pages'</span>, <span class="string">'microsoft'</span>:<span class="string">'word'</span>, <span class="string">'google'</span>:<span class="string">'docs'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p[<span class="string">'apple'</span>]</span><br><span class="line"><span class="string">'pages'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'apple'</span> <span class="keyword">in</span> p</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment">#判断一个元素是否包含在一个列表中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>testlist</span><br><span class="line">[[<span class="string">'iPhone'</span>, <span class="string">'iPad'</span>, <span class="string">'iMac'</span>], <span class="string">'Microsoft'</span>, <span class="string">'Google'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Google'</span> <span class="keyword">in</span> testlist</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><ul>
<li>可变集合（set）</li>
<li>不可变集合（frozenset）</li>
</ul>
<h2 id="集合的基本使用"><a href="#集合的基本使用" class="headerlink" title="集合的基本使用"></a>集合的基本使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(s)</span><br><span class="line">&lt;type <span class="string">'set'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">## 访问集合</span></span><br><span class="line"></span><br><span class="line">集合是无序的，所以不能对集合创建索引或切片的操作，只能循环遍历或使用<span class="keyword">in</span>、<span class="keyword">not</span> <span class="keyword">in</span>来访问或判断集合元素</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> <span class="keyword">in</span> s</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="集合中的元素不能重复，集合会自动过滤掉重复的元素"><a href="#集合中的元素不能重复，集合会自动过滤掉重复的元素" class="headerlink" title="集合中的元素不能重复，集合会自动过滤掉重复的元素"></a>集合中的元素不能重复，集合会自动过滤掉重复的元素</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.add(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="删除集合中的元素"><a href="#删除集合中的元素" class="headerlink" title="删除集合中的元素"></a>删除集合中的元素</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(2)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set([1, 3, 4])</span><br></pre></td></tr></table></figure>

<h2 id="交集与并集"><a href="#交集与并集" class="headerlink" title="交集与并集"></a>交集与并集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 &amp; s2</span><br><span class="line">set([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="子集（真子集）超集（真超集）"><a href="#子集（真子集）超集（真超集）" class="headerlink" title="子集（真子集）超集（真超集）"></a>子集（真子集）超集（真超集）</h2><p>子集包含集合本身,真子集不包含本身!如（1,2）的子集有：空集,（1）,（2）,（1,2）.而真子集有：空集,(1),(2)没有（12）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#子集(&lt;=)  真子集(&lt;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'shop'</span>) &lt; set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'shop'</span>) &lt;= set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &lt; set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &lt;= set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment">#超集(&gt;=)  真超集(&gt;)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &gt; set(<span class="string">'shop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &gt;= set(<span class="string">'shop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &gt; set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(<span class="string">'bookshop'</span>) &gt;= set(<span class="string">'bookshop'</span>)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 ^ s2</span><br><span class="line">set([<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1.symmetric_difference(s2)</span><br><span class="line">set([<span class="number">1</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<h2 id="差补-相对补集"><a href="#差补-相对补集" class="headerlink" title="差补/相对补集"></a>差补/相对补集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2</span><br><span class="line">set([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">set([<span class="number">1</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 - s2</span><br><span class="line">set([<span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 -s1</span><br><span class="line">set([<span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p><strong>集合的应用： 去重</strong></p>
<h1 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h1><h2 id="字典-1"><a href="#字典-1" class="headerlink" title="字典"></a>字典</h2><h3 id="字典-2-字符串"><a href="#字典-2-字符串" class="headerlink" title="字典 2 字符串"></a>字典 2 字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(str(d)), str(d)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt; &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字典-2-元组"><a href="#字典-2-元组" class="headerlink" title="字典 2 元组"></a>字典 2 元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> tuple(d)</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> tuple(d.values())</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="字典-2-列表"><a href="#字典-2-列表" class="headerlink" title="字典 2 列表"></a>字典 2 列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> list(d)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> list(d.values())</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="元组-1"><a href="#元组-1" class="headerlink" title="元组"></a>元组</h2><h3 id="元组-2-字符串"><a href="#元组-2-字符串" class="headerlink" title="元组 2 字符串"></a>元组 2 字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(str(t)), str(t)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="元组-2-列表"><a href="#元组-2-列表" class="headerlink" title="元组 2 列表"></a>元组 2 列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(list(t)), list(t)</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="元组-2-集合"><a href="#元组-2-集合" class="headerlink" title="元组 2 集合"></a>元组 2 集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(set(t)), set(t)</span><br><span class="line">&lt;type <span class="string">'set'</span>&gt; set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h3 id="元组不能转成字典"><a href="#元组不能转成字典" class="headerlink" title="元组不能转成字典"></a>元组不能转成字典</h3><h2 id="列表-1"><a href="#列表-1" class="headerlink" title="列表"></a>列表</h2><h3 id="列表-2-字符串"><a href="#列表-2-字符串" class="headerlink" title="列表 2 字符串"></a>列表 2 字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(str(l)), str(l)</span><br><span class="line">&lt;type <span class="string">'str'</span>&gt; [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="列表-2-元组"><a href="#列表-2-元组" class="headerlink" title="列表 2 元组"></a>列表 2 元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(tuple(l)), tuple(l)</span><br><span class="line">&lt;type <span class="string">'tuple'</span>&gt; (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="列表-2-集合"><a href="#列表-2-集合" class="headerlink" title="列表 2 集合"></a>列表 2 集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(set(l)), set(l)</span><br><span class="line">&lt;type <span class="string">'set'</span>&gt; set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h3 id="列表不能转成字典"><a href="#列表不能转成字典" class="headerlink" title="列表不能转成字典"></a>列表不能转成字典</h3><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串-2-列表"><a href="#字符串-2-列表" class="headerlink" title="字符串 2 列表"></a>字符串 2 列表</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"[[1,2], [3,4], [5,6], [7,8], [9,0]]"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">'[[1,2], [3,4], [5,6], [7,8], [9,0]]'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> list(s)</span><br><span class="line">[<span class="string">'['</span>, <span class="string">'['</span>, <span class="string">'1'</span>, <span class="string">','</span>, <span class="string">'2'</span>, <span class="string">']'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'['</span>, <span class="string">'3'</span>, <span class="string">','</span>, <span class="string">'4'</span>, <span class="string">']'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'['</span>, <span class="string">'5'</span>, <span class="string">','</span>, <span class="string">'6'</span>, <span class="string">']'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'['</span>, <span class="string">'7'</span>, <span class="string">','</span>, <span class="string">'8'</span>, <span class="string">']'</span>, <span class="string">','</span>, <span class="string">' '</span>, <span class="string">'['</span>, <span class="string">'9'</span>, <span class="string">','</span>, <span class="string">'0'</span>, <span class="string">']'</span>, <span class="string">']'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(eval(s)), eval(s)</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt; [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">0</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="字符串-2-字典"><a href="#字符串-2-字典" class="headerlink" title="字符串 2 字典"></a>字符串 2 字典</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"&#123;1: 'a', 2: 'b'&#125;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line"><span class="string">"&#123;1: 'a', 2: 'b'&#125;"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(eval(s)), eval(s)</span><br><span class="line">&lt;type <span class="string">'dict'</span>&gt; &#123;<span class="number">1</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串-2-元组"><a href="#字符串-2-元组" class="headerlink" title="字符串 2 元组"></a>字符串 2 元组</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"([1,2], [3,4], [5,6], [7,8], (9,0))"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(eval(s)), eval(s)</span><br><span class="line">&lt;type <span class="string">'tuple'</span>&gt; ([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>], (<span class="number">9</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<h3 id="字符串-2-集合"><a href="#字符串-2-集合" class="headerlink" title="字符串 2 集合"></a>字符串 2 集合</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">"test"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> type(set(s)), set(s)</span><br><span class="line">&lt;type <span class="string">'set'</span>&gt; set([<span class="string">'s'</span>, <span class="string">'e'</span>, <span class="string">'t'</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML语法简介</title>
    <url>/2015/12/03/YAML%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="YAML的数据结构"><a href="#YAML的数据结构" class="headerlink" title="YAML的数据结构"></a>YAML的数据结构</h1><p>YAML的设计者认为在配置文件中所要表达的数据内容有三种类型</p>
<ul>
<li>Scalars（标量，如字符串和数字等）</li>
<li>Sequence （序列，类似于Python中列表的概念）</li>
<li>Mapping （类似于Python中字典的概念）</li>
</ul>
<h2 id="Sequence-of-Scalars"><a href="#Sequence-of-Scalars" class="headerlink" title="Sequence of Scalars"></a>Sequence of Scalars</h2><p>YAML(ball players)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- Mark McGwire</span><br><span class="line">- Sammy Sosa</span><br><span class="line">- Ken Griffey</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">'Mark McGwire'</span>, <span class="string">'Sammy Sosa'</span>, <span class="string">'Ken Griffey'</span>]</span><br></pre></td></tr></table></figure>


<h2 id="Mapping-Scalars-to-Scalars"><a href="#Mapping-Scalars-to-Scalars" class="headerlink" title="Mapping Scalars to Scalars"></a>Mapping Scalars to Scalars</h2><p>YAML(player statistics)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hr:  65    # Home runs</span><br><span class="line">avg: 0.278 # Batting average</span><br><span class="line">rbi: 147   # Runs Batted In</span><br></pre></td></tr></table></figure>

<p>Pyhton(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'hr'</span>:<span class="number">65</span>, <span class="string">'avg'</span>:<span class="number">0.278</span>, <span class="string">'rbi'</span>:<span class="number">147</span>&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Mapping-Scalars-to-Sequences"><a href="#Mapping-Scalars-to-Sequences" class="headerlink" title="Mapping Scalars to Sequences"></a>Mapping Scalars to Sequences</h2><p>YAML(ball clubs in each league)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">american:</span><br><span class="line">  - Boston Red Sox</span><br><span class="line">  - Detroit Tigers</span><br><span class="line">  - New York Yankees</span><br><span class="line">national:</span><br><span class="line">  - New York Mets</span><br><span class="line">  - Chicago Cubs</span><br><span class="line">  - Atlanta Braves</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'american'</span>:[<span class="string">'Boston Red Sox'</span>, <span class="string">'Detroit Tigers'</span>, <span class="string">'New York Yankees'</span>], <span class="string">'national'</span>:[<span class="string">'New York Mets'</span>, <span class="string">'Chicago Cubs'</span>, <span class="string">'Atlanta Braves'</span>]&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Sequence-of-Mappings"><a href="#Sequence-of-Mappings" class="headerlink" title="Sequence of Mappings"></a>Sequence of Mappings</h2><p>YAML(players’ statistics)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-</span><br><span class="line">  name: Mark McGwire</span><br><span class="line">  hr:   65</span><br><span class="line">  avg:  0.278</span><br><span class="line">-</span><br><span class="line">  name: Sammy Sosa</span><br><span class="line">  hr:   63</span><br><span class="line">  avg:  0.288</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[&#123;<span class="string">'name'</span>:<span class="string">'Mark McGwire'</span>, <span class="string">'hr'</span>:<span class="number">65</span>, <span class="string">'avg'</span>:<span class="number">0.278</span>&#125;, &#123;<span class="string">'name'</span>:<span class="string">'Sammy Sosa'</span>, <span class="string">'hr'</span>:<span class="number">63</span>, <span class="string">'avg'</span>:<span class="number">0.288</span>&#125;]</span><br></pre></td></tr></table></figure>

<h2 id="Sequence-of-Sequences"><a href="#Sequence-of-Sequences" class="headerlink" title="Sequence of Sequences"></a>Sequence of Sequences</h2><p>YAML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [name        , hr, avg  ]</span><br><span class="line">- [Mark McGwire, 65, 0.278]</span><br><span class="line">- [Sammy Sosa  , 63, 0.288]</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="string">'name'</span>, <span class="string">'hr'</span>, <span class="string">'avg'</span>], [<span class="string">'Mark McGwire'</span>, <span class="number">65</span>, <span class="number">0.278</span>], [<span class="string">'Sammy Sosa'</span>, <span class="number">63</span>, <span class="number">0.288</span>]]</span><br></pre></td></tr></table></figure>


<h2 id="Mapping-of-Mappings"><a href="#Mapping-of-Mappings" class="headerlink" title="Mapping of Mappings"></a>Mapping of Mappings</h2><p>YAML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mark McGwire: &#123;hr: 65, avg: 0.278&#125;</span><br><span class="line">Sammy Sosa: &#123;</span><br><span class="line">    hr: 63,</span><br><span class="line">    avg: 0.288</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'Mark McGwire'</span>:&#123;<span class="string">'hr'</span>:<span class="number">65</span>, <span class="string">'avg'</span>:<span class="number">0.278</span>&#125;, <span class="string">'Sammy Sosa'</span>:&#123;<span class="string">'hr'</span>:<span class="number">63</span>, <span class="string">'avg'</span>:<span class="number">0.288</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="YAML中的注释"><a href="#YAML中的注释" class="headerlink" title="YAML中的注释"></a>YAML中的注释</h1><p>YAML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ball players</span><br><span class="line">- Mark McGwire</span><br><span class="line">- Sammy Sosa</span><br><span class="line">- Ken Griffey</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="YAML中的文档"><a href="#YAML中的文档" class="headerlink" title="YAML中的文档"></a>YAML中的文档</h1><p>在单一一个YAML文件中</p>
<ul>
<li>使用三个下划线<code>___</code>来分隔文档</li>
<li>使用三个句号<code>...</code>表示结束（一般在通信信道中使用）</li>
</ul>
<p>YAML(Two Documents in a Stream)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Ranking of 1998 home runs</span><br><span class="line">---</span><br><span class="line">- Mark McGwire</span><br><span class="line">- Sammy Sosa</span><br><span class="line">- Ken Griffey</span><br><span class="line"> </span><br><span class="line"># Team ranking</span><br><span class="line">---</span><br><span class="line">- Chicago Cubs</span><br><span class="line">- St Louis Cardinals</span><br></pre></td></tr></table></figure>

<p>YAML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">time: 20:03:20</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: strike (miss)</span><br><span class="line">...</span><br><span class="line">---</span><br><span class="line">time: 20:03:47</span><br><span class="line">player: Sammy Sosa</span><br><span class="line">action: grand slam</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><p>YAML</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用YAML来描述一本书《Linux命令行与shell脚本编程大全》</span><br><span class="line"> </span><br><span class="line"># 《Linux命令行与shell脚本编程大全》描述</span><br><span class="line">---  # begin of document</span><br><span class="line">书名: &#39;Linux命令行与shell脚本编程大全&#39;</span><br><span class="line">出版社: &#39;人民邮电出版社&#39;</span><br><span class="line">原作者: [&#39;Richard Blum&#39;, &#39;Christine Bresnahan&#39;]</span><br><span class="line">译者:</span><br><span class="line">    - 武海峰</span><br><span class="line">    - 朱巍</span><br><span class="line">前二章节:</span><br><span class="line">    - 第一章: 初识Linux Shell</span><br><span class="line">    - 第二章: 走进Shell</span><br><span class="line"> </span><br><span class="line">#end of document</span><br></pre></td></tr></table></figure>

<p>Python(YAML)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'书名'</span>:<span class="string">'Linux命令行与shell脚本编程大全'</span>, <span class="string">'出版社'</span>:<span class="string">'人民邮电出版社'</span>, <span class="string">'原作者'</span>:[<span class="string">'Richard Blum'</span>, <span class="string">'Christine Bresnahan'</span>], <span class="string">'译者'</span>:[<span class="string">'武海峰'</span>, <span class="string">'朱巍'</span>], <span class="string">'前二章节'</span>:&#123;<span class="string">'第一章'</span>:<span class="string">'初识Linux Shell'</span>, <span class="string">'第二章'</span>:<span class="string">'走进Shell'</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>参考文档：</p>
<ul>
<li><a href="http://yaml.org/spec/1.1/" target="_blank" rel="noopener">http://yaml.org/spec/1.1/</a></li>
<li><a href="http://www.cnblogs.com/chwkai/archive/2009/03/01/249924.html" target="_blank" rel="noopener">http://www.cnblogs.com/chwkai/archive/2009/03/01/249924.html</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>salt pkg.install报错:No module named yum</title>
    <url>/2015/11/24/salt-pkg-install%E6%8A%A5%E9%94%99-No-module-named-yum/</url>
    <content><![CDATA[<blockquote>
<p>在使用salt进行软件管理的时候，有些节点报 No module named yum 的错误。经过排查，发现是因为升级了minion端Python版本后产生的问题</p>
</blockquote>
<p><strong>msater</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ salt <span class="string">'vm3.salt.com'</span> pkg.install httpd</span><br><span class="line">vm3.salt.com:</span><br><span class="line">    ERROR: Traceback (most recent call last):</span><br><span class="line">      File <span class="string">"/usr/bin/repoquery"</span>, line 34, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">        import yum</span><br><span class="line">    ImportError: No module named yum</span><br></pre></td></tr></table></figure>

<p>服务器自带的Python版本是2.6.6 由于其他业务的需求，Python的版本升级到了2.7.10，升级后首先yum命令处于不可用的状态，通过修改<code>/usr/bin/yum</code>文件的第一行<code>#!/usr/bin/python</code>为<code>#!/usr/bin/python2.6</code>来修复yum命令的使用</p>
<p>由于系统默认的Python已经由2.6.6变更到了2.7.10</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ls -l /usr/bin/python</span><br><span class="line">lrwxrwxrwx 1 root root 34 Oct  9 02:16 /usr/bin/python -&gt; /usr/<span class="built_in">local</span>/python2.7/bin/python2.7</span><br></pre></td></tr></table></figure>

<p>salt master在派发任务后，minion接收到任务并在本地使用默认的Python来执行，实际使用了升级后默认的Python2.7.10，导致Python报找不到yum模块的错误</p>
<p>在网上搜索了很多方案，全部是修改yum默认使用的Python版本来解决问题，貌似不能通过让yum来支持高版本的Python来解决问题。so，要解决salt minion本地调用yum不报错，就必须要保证其使用Python2.6.6来执行！解决方案和yum命令的修复方式相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ head /usr/bin/repoquery</span><br><span class="line"><span class="comment">#!/usr/bin/python -tt</span></span><br><span class="line"><span class="comment">#... ...</span></span><br><span class="line"></span><br><span class="line">$ vim /usr/bin/repoquery </span><br><span class="line"></span><br><span class="line">$ head /usr/bin/repoquery</span><br><span class="line"><span class="comment">#!/usr/bin/python2.6 -tt</span></span><br><span class="line"><span class="comment">#... ...</span></span><br></pre></td></tr></table></figure>
<p>将<code>/usr/bin/repoquery</code>文件第一行的<code>#!/usr/bin/python -tt</code>更改为<code>#!/usr/bin/python2.6 -tt</code>即可</p>
]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title>saltstack key认证过程</title>
    <url>/2015/11/24/saltstack-key%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="密钥对儿的认证"><a href="#密钥对儿的认证" class="headerlink" title="密钥对儿的认证"></a>密钥对儿的认证</h1><p>当初始化安装 minion 启动服务启动后</p>
<ol>
<li>minion端生成一个秘钥对，并产生一个ID值，minion服务会安装ID值命名的公钥发送给 master ,直到接受为止;</li>
<li>master认证完毕后，会将minion 端发送来的，以ID值命名的公钥存放在 <code>/etc/salt/pki/master/minions</code> 目录中(无扩展名);</li>
<li>master认证完毕后，会将自身的公钥发送给 minion，并存储为 <code>/etc/salt/pki/minion/minion_master.pub</code></li>
</ol>
<hr>
<h1 id="minion-id的生成过程"><a href="#minion-id的生成过程" class="headerlink" title="minion id的生成过程"></a>minion id的生成过程</h1><p>minion 默认按照一定的顺序，试图找到一个不是localhost的值作为其ID</p>
<p>这里不需要知道salt是按照怎样的顺序取值的，只需要记住以下优先级即可</p>
<p><code>hostname</code> &lt; <code>/etc/salt/minion_id</code> &lt; <code>/etc/salt/minion文件中的id值</code></p>
<hr>
<h1 id="密钥对儿存放的位置"><a href="#密钥对儿存放的位置" class="headerlink" title="密钥对儿存放的位置"></a>密钥对儿存放的位置</h1><ul>
<li>master 秘钥对默认存储在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/salt/pki/master/master.pub </span><br><span class="line">/etc/salt/pki/master/master.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>master 端认证的公钥存储在：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/salt/pki/master/minions/</span><br></pre></td></tr></table></figure>

<ul>
<li>minion 秘钥对默认存储在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/salt/pki/minion/minion.pub </span><br><span class="line">/etc/salt/pki/minion/minion.pem</span><br></pre></td></tr></table></figure>

<ul>
<li>minion 存放的master公钥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/salt/pki/minion/minion_master.pub</span><br></pre></td></tr></table></figure>

<ul>
<li>minion_id 默认存储在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/salt/minion_id</span><br></pre></td></tr></table></figure>

<p>在实际使用过程中，minion端可能会遇到各种原因导致的密钥对儿不匹配的情况，造成在master端显示在denied keys列表中无法通过认证。</p>
<ul>
<li>[master]先在master端删除该id</li>
<li>[minion]再删除minion端的key文件</li>
<li>[minion]最后重启服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -fr /etc/salt/pki/minion/minion_master.pub</span><br><span class="line"><span class="comment">#通过上面的介绍可以得知，以上这个文件是在master端认证通过之后，发放到minion端的公钥</span></span><br><span class="line"><span class="comment">#造成出现这个文件情况是因为早期连接了一个其他的master，更换master导致原公钥无法匹配</span></span><br><span class="line"><span class="comment">#删除与旧master认证的公钥文件</span></span><br><span class="line">rm -fr /etc/salt/pki/minion/minion.pem    <span class="comment">#删除minion的私钥文件</span></span><br><span class="line">rm -fr /etc/salt/pki/minion/minion.pub    <span class="comment">#删除minion的公钥文件</span></span><br><span class="line">service salt-minion restart    <span class="comment">#重启服务 会自动重新生成新的密钥对儿</span></span><br><span class="line"><span class="comment">#此时master端查看keys时，新的主机已经出现在Unaccepted Keys的列表中了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考文章 <a href="http://my.oschina.net/u/877567/blog/201733" target="_blank" rel="noopener">salt key 认证过程</a></p>
</blockquote>
]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
        <tag>key</tag>
      </tags>
  </entry>
  <entry>
    <title>saltstack安装及配置</title>
    <url>/2015/11/23/saltstack%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="saltstack安装及配置"><a href="#saltstack安装及配置" class="headerlink" title="saltstack安装及配置"></a>saltstack安装及配置</h1><h2 id="首先安装epel源"><a href="#首先安装epel源" class="headerlink" title="首先安装epel源"></a>首先安装epel源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>

<h2 id="master"><a href="#master" class="headerlink" title="master"></a>master</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install salt-master -y</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>master端安装好后一般不需要任何设置，启动服务器即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service salt-master start</span><br><span class="line">chkconfig salt-master on</span><br></pre></td></tr></table></figure>

<h2 id="minion"><a href="#minion" class="headerlink" title="minion"></a>minion</h2><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install salt-minion</span><br></pre></td></tr></table></figure>

<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>minion端至少需要配置两项，id和master需要指定。</p>
<ul>
<li>id: 这台主机的唯一标识！ 就像mac地址一样！</li>
<li>master: 指定salt master的IP地址或域名！   </li>
</ul>
<p>注意：注意冒号后面一定要有一个空格。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ vim /etc/salt/minion</span><br><span class="line">id: node1.salt.com</span><br><span class="line">master: master.salt.com</span><br></pre></td></tr></table></figure>


<h2 id="master与minion的认证"><a href="#master与minion的认证" class="headerlink" title="master与minion的认证"></a>master与minion的认证</h2><p><strong>master</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">salt-key -L <span class="comment">#查看所有主机</span></span><br><span class="line"><span class="comment">#没有接受的key会显示在Unaccepted Keys下</span></span><br><span class="line">salt-key -A <span class="comment">#接受所有主机</span></span><br><span class="line">salt-key -D <span class="comment">#删除所有主机</span></span><br><span class="line">salt-key -a node1.salt.com  <span class="comment">#接受指定的主机</span></span><br><span class="line">salt-key -d node1.salt.com  <span class="comment">#删除指定的主机</span></span><br></pre></td></tr></table></figure>

<p>一般情况下，master不会在配置文件中开启自动授权</p>
<hr>
<h1 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h1><p><strong>master</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ salt <span class="string">'*'</span> test.ping</span><br><span class="line">node1.salt.com:</span><br><span class="line">    True</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Salt Master报错:Minion did not return. [No response]</title>
    <url>/2015/11/23/Salt-Master%E6%8A%A5%E9%94%99-Minion-did-not-return-No-response/</url>
    <content><![CDATA[<p>在salt master端执行salt ‘*’ test.ping时，某一节点出现如下报错：<br><code>Minion did not return. [No response]</code></p>
<p>登陆到这一节点查看minion的日志，发现如下的问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tail -f /var/<span class="built_in">log</span>/salt/minion</span><br><span class="line">The master may need to be updated <span class="keyword">if</span> it is a version of Salt lower than 2015.5.3, or</span><br><span class="line">If you are confident that you are connecting to a valid Salt Master, <span class="keyword">then</span> remove the master public key and restart the Salt Minion.</span><br><span class="line">The master public key can be found at:</span><br><span class="line">/etc/salt/pki/minion/minion_master.pub</span><br><span class="line">2015-11-23 23:30:02,645 [salt.crypt                               ][ERROR   ][3530] The Salt Master has cached the public key <span class="keyword">for</span> this node, this salt minion will <span class="built_in">wait</span> <span class="keyword">for</span> 10 seconds before attempting to re-authenticate</span><br><span class="line">2015-11-23 23:30:05,108 [salt.crypt                               ][ERROR   ][3586] The Salt Master has cached the public key <span class="keyword">for</span> this node, this salt minion will <span class="built_in">wait</span> <span class="keyword">for</span> 10 seconds before attempting to re-authenticate</span><br><span class="line">2015-11-23 23:30:15,136 [salt.crypt                               ][ERROR   ][3586] The Salt Master has cached the public key <span class="keyword">for</span> this node, this salt minion will <span class="built_in">wait</span> <span class="keyword">for</span> 10 seconds before attempting to re-authenticate</span><br></pre></td></tr></table></figure>

<p>大概的意思就是，minion端拿到的key与master端的不符，验证无法通过。<br>解决方法是删除minion端的key，再重新与master进行连接和认证。</p>
<p><strong>minion</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat pki/minion/minion_master.pub </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtzq0AjuyQsVEgsx692GN</span><br><span class="line">... ...</span><br><span class="line">7fbuudp4yu5vcYcqksKIFcm0J3E+OR+rx/NUIHt0ZL8HLxcSn4Si/S6dVp/vE7Oc</span><br><span class="line">swIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br><span class="line">[root@localhost salt]<span class="comment"># rm -fr pki/minion/minion_master.pub</span></span><br><span class="line"></span><br><span class="line">[root@localhost salt]<span class="comment"># service salt-minion restart</span></span><br><span class="line">Stopping salt-minion daemon:                               [  OK  ]</span><br><span class="line">Starting salt-minion daemon:                               [  OK  ]</span><br></pre></td></tr></table></figure>

<p><strong>master</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">salt-key -A</span><br></pre></td></tr></table></figure>

<p><strong>minion</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat pki/minion/minion_master.pub </span><br><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAy46TJvK9BUqjvaYzmt5Q</span><br><span class="line">... ...</span><br><span class="line">ADw0hU6B/A1kRBeUbb6Fy+HljiSjD3O+mhoK7RE8rCnvJCHfuZSX/qMtLEyoh0vN</span><br><span class="line">tQIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure>

<p>至此，master与minion端的通信正常。</p>
]]></content>
      <categories>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>saltstack</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中glob模块的使用</title>
    <url>/2015/11/20/Python%E4%B8%ADglob%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>本篇文章介绍Python中的glob模块的基本使用。glob模块可以按指定路径得到所有符合条件的文件的完整路径。<br>glob的使用体验类似于windows系统中常用的搜索功能。使用通配符进行搜索</p>
</blockquote>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>glob是Python中最简单的模块之一，功能很简单，类似于windows中的查找文件。使用如下通配符进行操作：</p>
<ul>
<li><code>*</code> 星号：表示匹配0个或多个字符</li>
<li><code>?</code> 问号：表示匹配单个字符</li>
<li><code>[]</code> 中括号： 匹配指定的范围。如[0-9]</li>
</ul>
<h1 id="glob-glob"><a href="#glob-glob" class="headerlink" title="glob.glob"></a>glob.glob</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files_path = glob.glob(<span class="string">"/tmp/npm*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(file_paths)</span><br><span class="line">&lt;type <span class="string">'list'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> files_path:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> f</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">/tmp/npm<span class="number">-7838</span><span class="number">-2</span>b67e940</span><br><span class="line">/tmp/npm<span class="number">-5331</span><span class="number">-1</span>d55c699</span><br><span class="line">/tmp/npm<span class="number">-6600</span><span class="number">-69</span>f3511a</span><br><span class="line">/tmp/npm<span class="number">-5116</span><span class="number">-69883</span>a41</span><br><span class="line">/tmp/npm<span class="number">-5009</span><span class="number">-8</span>ef54da7</span><br><span class="line">/tmp/npm<span class="number">-7792</span>-fec6155a</span><br><span class="line">/tmp/npm<span class="number">-3252</span><span class="number">-71</span>dc8e8e</span><br><span class="line">/tmp/npm<span class="number">-4344</span><span class="number">-50e90470</span></span><br><span class="line">/tmp/npm<span class="number">-6387</span><span class="number">-29</span>ec15b1</span><br><span class="line">/tmp/npm<span class="number">-4617</span>-fff22b70</span><br><span class="line">/tmp/npm<span class="number">-4456</span>-b90bb1d8</span><br><span class="line">/tmp/npm<span class="number">-6480</span>-cce3191b</span><br><span class="line">/tmp/npm<span class="number">-4062</span><span class="number">-60</span>f050ce</span><br><span class="line">/tmp/npm<span class="number">-4712</span><span class="number">-1</span>ca9017c</span><br><span class="line">/tmp/npm<span class="number">-3770</span>-aec98483</span><br><span class="line">/tmp/npm<span class="number">-3913</span><span class="number">-8678</span>ef60</span><br><span class="line">/tmp/npm<span class="number">-5235</span><span class="number">-03941</span>a1e</span><br></pre></td></tr></table></figure>

<p>重点看类型！ <strong>list !!!</strong> 返回的是一个列表</p>
<h1 id="glob-iglob"><a href="#glob-iglob" class="headerlink" title="glob.iglob"></a>glob.iglob</h1><p>iglob用来获取一个可迭代对象，再对其遍历。数据量非常大的时候比较适用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> glob</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>files_path = glob.iglob(<span class="string">"/tmp/npm*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(files_path)</span><br><span class="line">&lt;type <span class="string">'generator'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> f <span class="keyword">in</span> files_path:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> f</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">/tmp/npm<span class="number">-7838</span><span class="number">-2</span>b67e940</span><br><span class="line">/tmp/npm<span class="number">-5331</span><span class="number">-1</span>d55c699</span><br><span class="line">/tmp/npm<span class="number">-6600</span><span class="number">-69</span>f3511a</span><br><span class="line">/tmp/npm<span class="number">-5116</span><span class="number">-69883</span>a41</span><br><span class="line">/tmp/npm<span class="number">-5009</span><span class="number">-8</span>ef54da7</span><br><span class="line">/tmp/npm<span class="number">-7792</span>-fec6155a</span><br><span class="line">/tmp/npm<span class="number">-3252</span><span class="number">-71</span>dc8e8e</span><br><span class="line">/tmp/npm<span class="number">-4344</span><span class="number">-50e90470</span></span><br><span class="line">/tmp/npm<span class="number">-6387</span><span class="number">-29</span>ec15b1</span><br><span class="line">/tmp/npm<span class="number">-4617</span>-fff22b70</span><br><span class="line">/tmp/npm<span class="number">-4456</span>-b90bb1d8</span><br><span class="line">/tmp/npm<span class="number">-6480</span>-cce3191b</span><br><span class="line">/tmp/npm<span class="number">-4062</span><span class="number">-60</span>f050ce</span><br><span class="line">/tmp/npm<span class="number">-4712</span><span class="number">-1</span>ca9017c</span><br><span class="line">/tmp/npm<span class="number">-3770</span>-aec98483</span><br><span class="line">/tmp/npm<span class="number">-3913</span><span class="number">-8678</span>ef60</span><br><span class="line">/tmp/npm<span class="number">-5235</span><span class="number">-03941</span>a1e</span><br></pre></td></tr></table></figure>

<p>上面的实例可以看出使用glob.iglob返回的是一个可迭代对象，可以节省内存。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>glob</tag>
        <tag>PyModule</tag>
      </tags>
  </entry>
  <entry>
    <title>dstat工具的安装和使用</title>
    <url>/2015/11/19/dstat%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>dstat 是一款比较全面的性能监控工具，是排查服务器负载异常的利器！</p>
</blockquote>
<h1 id="dstat的安装"><a href="#dstat的安装" class="headerlink" title="dstat的安装"></a>dstat的安装</h1><p>dstat的安装在这里介绍三种方式</p>
<ul>
<li><p>使用”绿色版”安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://dstat.sourcearchive.com/downloads/0.7.0/dstat_0.7.0.orig.tar.gz</span><br><span class="line">tar -xvzf dstat_0.7.0.orig.tar.gz</span><br><span class="line"><span class="built_in">cd</span> dstat-0.7.0.orig/</span><br><span class="line"><span class="comment">#使用以下方式即可使用dstat</span></span><br><span class="line">./dstat -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用rpm安装</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://mirror.centos.org/centos/6/os/i386/Packages/dstat-0.7.0-2.el6.noarch.rpm</span><br><span class="line">rpm -ivh dstat-0.7.0-2.el6.noarch.rpm</span><br><span class="line"><span class="comment">#直接在系统中调用dstat即可</span></span><br><span class="line">dstat -V</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用yum安装</p>
<p>  <code>yum install dstat</code></p>
</li>
</ul>
<h1 id="dstat的使用"><a href="#dstat的使用" class="headerlink" title="dstat的使用"></a>dstat的使用</h1><p>dstat命令支持的参数这里就不再赘述啦，以下介绍一下个人比较常用的两种参数</p>
<ol>
<li>dstat -tcdrlmn –top-cpu –top=mem  #查看时间、CPU、磁盘读写、IO、负载、内存、网络、最高的CPU占用和最高的内存占用 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">----system---- ----total-cpu-usage---- -dsk&#x2F;total- --io&#x2F;total- ---load-avg--- ------memory-usage----- -net&#x2F;total- -most-expensive- --most-expensive-</span><br><span class="line">  date&#x2F;time   |usr sys idl wai hiq siq| read  writ| read  writ| 1m   5m  15m | used  buff  cach  free| recv  send|  cpu process   |  memory process </span><br><span class="line">19-11 21:49:25|  0   0 100   0   0   0|1055B 1810B|0.02  0.07 |0.02 0.01    0| 236M  131M 2961M 4527M|   0     0 |kipmi0       0.0|sshd: root@p4488k</span><br><span class="line">19-11 21:49:26|  0   0 100   0   0   0|   0     0 |   0     0 |0.02 0.01    0| 236M  131M 2961M 4527M| 398B 1532B|                |sshd: root@p4488k</span><br><span class="line">19-11 21:49:27|  0   0 100   0   0   0|   0     0 |   0     0 |0.02 0.01    0| 236M  131M 2961M 4527M| 352B  542B|                |sshd: root@p4488k</span><br><span class="line">19-11 21:49:28|  0   0 100   0   0   0|   0     0 |   0     0 |0.02 0.01    0| 236M  131M 2961M 4527M| 850B  542B|                |sshd: root@p4488k</span><br><span class="line">19-11 21:49:29|  0   0 100   0   0   0|   0     0 |   0     0 |0.02 0.01    0| 236M  131M 2961M 4527M| 256B  542B|                |sshd: root@p4488k</span><br></pre></td></tr></table></figure></li>
<li>dstat -cl -C 0,1,2,3,4,5,6,7 –top-cpu   #查看8颗核心，每颗核心的使用情况和CPU使用情况 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	-------cpu0-usage--------------cpu1-usage--------------cpu2-usage--------------cpu3-usage--------------cpu4-usage--------------cpu5-usage--------------cpu6-usage--------------cpu7-usage------ ---load-avg--- -most-expensive-</span><br><span class="line">usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq:usr sys idl wai hiq siq| 1m   5m  15m |  cpu process   </span><br><span class="line">  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|kipmi0       0.0</span><br><span class="line">  0   0 100   0   0   0:  0   0 100   0   0   0:  0   1  99   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|                </span><br><span class="line">  0   0 100   0   0   0:  0   0 100   0   0   0:  1   1  98   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|kipmi0       0.1</span><br><span class="line">  0   1  99   0   0   0:  0   0 100   0   0   0:  2   0  98   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|events&#x2F;3     0.1</span><br><span class="line">  0   0 100   0   0   0:  0   0 100   0   0   0:  1   1  98   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|                </span><br><span class="line">  0   0 100   0   0   0:  0   0 100   0   0   0:  1   0  99   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0:  0   0 100   0   0   0|0.07 0.02    0|kipmi0       0.1</span><br></pre></td></tr></table></figure>


</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>dstat</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下Python的升级-pip以及fabric的安装</title>
    <url>/2015/11/19/CentOS%E4%B8%8BPython%E7%9A%84%E5%8D%87%E7%BA%A7-pip%E4%BB%A5%E5%8F%8Afabric%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍在CentOS系统下升级Python，安装pip, fabric的操作</p>
</blockquote>
<h1 id="安装Python部分"><a href="#安装Python部分" class="headerlink" title="安装Python部分"></a>安装Python部分</h1><ol>
<li>第一步当然是下载最新版本的Python了！<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://www.python.org/ftp/python/2.7.8/Python-2.7.8.tgz</span><br></pre></td></tr></table></figure></li>
<li>解压、编译、安装<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">tar -xvzf Python-2.7.8.tgz</span><br><span class="line"><span class="built_in">cd</span> Python2.7.8</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python2.7</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></li>
<li>创建链接使系统默认的Python变成Python2.7<br><code>ln -fs /usr/local/python2.7/bin/python2.7 /usr/bin/python</code></li>
<li>查看一下Python的版本<br><code>python -V</code></li>
<li>修改yum配置（否则更新了默认Python后的yum无法正常运行）<br><code>vim /usr/bin/yum</code></li>
</ol>
<p><strong>将第一行#!/usr/bin/python 修改为原有的Python2.6版本</strong><br><code>#!/usr/bin/python2.6</code><br>—&gt; <em>CentOS系统升级Python成功完成</em></p>
<h1 id="安装pip部分"><a href="#安装pip部分" class="headerlink" title="安装pip部分"></a>安装pip部分</h1><ol start="6">
<li>下载自动安装pip的脚本<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src/</span><br><span class="line">wget https://raw.github.com/pypa/pip/master/contrib/get-pip.py</span><br></pre></td></tr></table></figure></li>
<li>执行安装pip的命令<br><code>python get-pip.py</code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">第一次执行pythonget-pip.py报错：</span><br><span class="line">zipimport.ZipImportError: can&#39;t decompress data; zlib not available</span><br><span class="line"></span><br><span class="line">解决zlib的问题：</span><br><span class="line"># yum install zlib zlib-devel</span><br><span class="line">然后重新编译Python（.&#x2F;configure&amp;&amp; make &amp;&amp; make install）</span><br><span class="line">    </span><br><span class="line">第二次执行python get-pip.py报错：</span><br><span class="line">ImportError: cannot import name HTTPSHandler</span><br><span class="line"></span><br><span class="line"># yum install openssl openssl-devel</span><br><span class="line">然后重新编译Python（.&#x2F;configure&amp;&amp; make &amp;&amp; make install）</span><br></pre></td></tr></table></figure></li>
<li>创建使用pip的链接<br><code>ln -s /usr/local/python2.7/bin/pip /usr/bin/pip</code></li>
</ol>
<h2 id="安装fabric部分"><a href="#安装fabric部分" class="headerlink" title="安装fabric部分"></a>安装fabric部分</h2><ol start="9">
<li>执行安装fabric的命令<br><code>pip install fabric</code></li>
<li>创建使用fab命令的链接<br><code>ln -s /usr/local/python2.7/bin/fab /usr/bin/fab</code></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>pip</tag>
        <tag>fabric</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS与RHEL系列安装epel和rpmforce源</title>
    <url>/2015/11/18/CentOS%E4%B8%8ERHEL%E7%B3%BB%E5%88%97%E5%AE%89%E8%A3%85epel%E5%92%8Crpmforce%E6%BA%90/</url>
    <content><![CDATA[<blockquote>
<p>很多时候，使用CentOS自带的软件源并不能解决所有的软件依赖包。这里介绍在CentOS或RHEL系列中安装epel源和rpmforce源</p>
</blockquote>
<h1 id="安装epel源"><a href="#安装epel源" class="headerlink" title="安装epel源"></a>安装epel源</h1><hr>
<p>CentOS<code>5</code> Or RHEL<code>5</code> <code>32</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/5/i386/epel-release-5-4.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>5</code> Or RHEL<code>5</code> <code>64</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/5/x86_64/epel-release-5-4.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>6</code> Or RHEL<code>6</code> <code>32</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/6/i386/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>6</code> Or RHEL<code>6</code> <code>64</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>7</code> Or RHEL<code>7</code> <code>64</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://mirrors.kernel.org/fedora-epel/7/x86_64/e/epel-release-7-5.noarch.rpm</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@rhel65-test-1 ~]<span class="comment"># yum repolist</span></span><br><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirror.bit.edu.cn</span><br><span class="line"> * epel: mirrors.opencas.cn</span><br><span class="line"> * extras: mirrors.yun-idc.com</span><br><span class="line"> * updates: mirrors.yun-idc.com</span><br><span class="line">repo id         repo name                                         status                            </span><br><span class="line">base            CentOS-6 - Base                                   6,575                                               </span><br><span class="line">epel            Extra Packages <span class="keyword">for</span> Enterprise Linux 6 - x86_64    11,780                                              </span><br><span class="line">extras          CentOS-6 - Extras                                 43                                                  </span><br><span class="line">updates         CentOS-6 - Updates                                439                                                 </span><br><span class="line">repolist: 18,837</span><br></pre></td></tr></table></figure>

<p>#安装rpmforce源</p>
<hr>
<p>CentOS<code>5</code> Or RHEL<code>5</code> <code>32</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el5.rf.i386.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>5</code> Or RHEL<code>5</code> <code>64</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el5.rf.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>6</code> Or RHEL<code>6</code> <code>32</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.i686.rpm</span><br></pre></td></tr></table></figure>

<p>CentOS<code>6</code> Or RHEL<code>6</code> <code>64</code>bit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.3-1.el6.rf.x86_64.rpm</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@rhel65-test-1 ~]<span class="comment"># yum repolist</span></span><br><span class="line">Loaded plugins: fastestmirror, security</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirror.bit.edu.cn</span><br><span class="line"> * epel: mirrors.opencas.cn</span><br><span class="line"> * extras: mirrors.yun-idc.com</span><br><span class="line"> * rpmforge: mirrors.neusoft.edu.cn</span><br><span class="line"> * updates: mirrors.yun-idc.com</span><br><span class="line">repo id        repo name                                        status           </span><br><span class="line">base           CentOS-6 - Base                                  6,575            </span><br><span class="line">epel           Extra Packages <span class="keyword">for</span> Enterprise Linux 6 - x86_64   11,780           </span><br><span class="line">extras         CentOS-6 - Extras                                43               </span><br><span class="line">rpmforge       RHEL 6 - RPMforge.net - dag                      4,718            </span><br><span class="line">updates        CentOS-6 - Updates                               439              </span><br><span class="line">repolist: 23,555</span><br></pre></td></tr></table></figure>

<p><strong>附录：内置源替换为163源</strong></p>
<ul>
<li><p>收录架构</p>
<p>i386<br>x86_64<br>SRPMS</p>
</li>
<li><p>收录版本</p>
<p>所有版本</p>
</li>
<li><p>更新时间</p>
<p>每4小时更新一次</p>
</li>
<li><p>使用说明</p>
<p>首先备份<code>/etc/yum.repos.d/CentOS-Base.repo</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure>
<ul>
<li>下载对应版本repo文件, 放入/etc/yum.repos.d/(操作前请做好相应备份)</li>
</ul>
<p><a href="http://mirrors.163.com/.help/CentOS7-Base-163.repo" target="_blank" rel="noopener">CentOS7</a><br><a href="http://mirrors.163.com/.help/CentOS6-Base-163.repo" target="_blank" rel="noopener">CentOS6</a><br><a href="http://mirrors.163.com/.help/CentOS5-Base-163.repo" target="_blank" rel="noopener">CentOS5</a></p>
<ul>
<li>运行以下命令生成缓存</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>
<p>相关连接：<a href="http://mirrors.163.com/.help/centos.html" target="_blank" rel="noopener">163yum源官方帮助</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>epel</tag>
        <tag>rpmforce</tag>
        <tag>163yum</tag>
      </tags>
  </entry>
  <entry>
    <title>vim跳到最后一行和跳到首行</title>
    <url>/2015/11/18/vim%E8%B7%B3%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E8%A1%8C%E5%92%8C%E8%B7%B3%E5%88%B0%E9%A6%96%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p>在vim或vi的编辑器中，经常需要跳转到文件的最后一行，或跳转至文件首行的情况。下面介绍两种方式实现跳转</p>
</blockquote>
<p><strong>第一种方式</strong></p>
<hr>
<ul>
<li>:$ 跳转到最后一行</li>
<li>:1 跳转到第一行</li>
</ul>
<p><strong>第二种方式</strong></p>
<hr>
<ul>
<li>shift+g 跳转到最后一行</li>
<li>gg 跳转到第一行</li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>使用forever让node.js持久运行</title>
    <url>/2015/11/18/%E4%BD%BF%E7%94%A8forever%E8%AE%A9node-js%E6%8C%81%E4%B9%85%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p>nodejs一般是当成一条命令执行的，当用户断开session，nodejs也就停止了运行。如何让nodejs持续在后台运行呢？</p>
</blockquote>
<p>#最简单粗暴的方法是使用Linux本身后台执行的特性</p>
<hr>
<p>使用&amp;符号后台执行，并利用nohup命令实现进程禁止挂起</p>
<p><code>nohup node app.js &amp;</code></p>
<p>#使用forever让node.js持久运行</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install forever -g   <span class="comment">#安装</span></span><br><span class="line">forever start app.js  <span class="comment">#启动应用</span></span><br><span class="line">forever stop app.js  <span class="comment">#关闭应用</span></span><br><span class="line">forever restartall  <span class="comment">#重启所有应用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#输出日志和错误</span></span><br><span class="line">forever start -l forever.log -o out.log -e err.log app.js   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定forever信息输出文件，当然，默认它会放到~/.forever/forever.log</span></span><br><span class="line">forever start -l forever.log app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定app.js中的日志信息和错误日志输出文件，  </span></span><br><span class="line"><span class="comment"># -o 就是console.log输出的信息，-e 就是console.error输出的信息</span></span><br><span class="line">forever start -o out.log -e err.log app.js </span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加日志，forever默认是不能覆盖上次的启动日志，  </span></span><br><span class="line"><span class="comment"># 所以如果第二次启动不加-a，则会不让运行  </span></span><br><span class="line">forever start -l forever.log -a app.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听当前文件夹下的所有文件改动（不太建议这样）  </span></span><br><span class="line">forever start -w app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有运行的服务 </span></span><br><span class="line">forever list  </span><br><span class="line"></span><br><span class="line"><span class="comment">######停止操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止所有运行的node App  </span></span><br><span class="line">forever stopall  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 停止其中一个node App  </span></span><br><span class="line">forever stop app.js  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 当然还可以这样  </span></span><br><span class="line"><span class="comment"># forever list 找到对应的id，然后：  </span></span><br><span class="line">forever stop [id]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开发环境下  </span></span><br><span class="line">NODE_ENV=development forever start -l forever.log -e err.log -a app.js  </span><br><span class="line"><span class="comment"># 线上环境下  </span></span><br><span class="line">NODE_ENV=production forever start -l ~/.forever/forever.log -e ~/.forever/err.log -w -a app.js</span><br><span class="line"><span class="comment">#上面加上NODE_ENV为了让app.js辨认当前是什么环境用的</span></span><br></pre></td></tr></table></figure>

<p>The End</p>
<hr>
<ul>
<li>参考1: <a href="https://cnodejs.org/topic/5021c2cff767cc9a51e684e3" target="_blank" rel="noopener">https://cnodejs.org/topic/5021c2cff767cc9a51e684e3</a></li>
<li>参考2: <a href="http://tcrct.iteye.com/blog/2043644" target="_blank" rel="noopener">http://tcrct.iteye.com/blog/2043644</a></li>
<li>forever github: <a href="https://github.com/foreverjs/forever" target="_blank" rel="noopener">https://github.com/foreverjs/forever</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Node.js</tag>
        <tag>forever</tag>
      </tags>
  </entry>
  <entry>
    <title>yum provides 反查询</title>
    <url>/2015/11/18/yum-provides-%E5%8F%8D%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<blockquote>
<p>在日常运维工作中，常常遇到需要安装一些依赖的库文件。在实际工作中，一次在Linux中安装SQL Server ODBC驱动时，遇到一个依赖的库文件需要安装（libcrypto.so.6）</p>
</blockquote>
<p>可是使用yum provides命令查询<code>libcrypto.so.6</code>文件包含在哪个软件包中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@manage final]<span class="comment"># yum provides libcrypto.so.6</span></span><br><span class="line">已加载插件：dellsysid, fastestmirror, refresh-packagekit, security</span><br><span class="line">Repository base is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Repository updates is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Repository extras is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Repository centosplus is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Repository contrib is listed more than once <span class="keyword">in</span> the configuration</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.btte.net</span><br><span class="line"> * epel: mirrors.opencas.cn</span><br><span class="line"> * extras: mirrors.btte.net</span><br><span class="line"> * rpmforge: ftp.riken.jp</span><br><span class="line"> * updates: mirrors.yun-idc.com</span><br><span class="line">openssl098e-0.9.8e-18.el6_5.2.i686 : A compatibility version of a general cryptography and TLS library</span><br><span class="line">Repo        : base</span><br><span class="line">匹配来自于:</span><br><span class="line">Other       : libcrypto.so.6</span><br></pre></td></tr></table></figure>

<p>通过查询可以看出，<code>libcrypto.so.6</code>文件包含在<code>openssl098e</code>的软件包中，接下来只需要使用yum安装openssl098e即可解决依赖问题</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>Liunx下更改MySQL用户密码</title>
    <url>/2015/11/18/Liunx%E4%B8%8B%E6%9B%B4%E6%94%B9MySQL%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    <content><![CDATA[<h1 id="方法1：-用SET-PASSWORD命令"><a href="#方法1：-用SET-PASSWORD命令" class="headerlink" title="方法1： 用SET PASSWORD命令"></a>方法1： 用SET PASSWORD命令</h1><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">mysql&gt; SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'newpass'</span>);</span><br></pre></td></tr></table></figure>

<h1 id="方法2：用mysqladmin"><a href="#方法2：用mysqladmin" class="headerlink" title="方法2：用mysqladmin"></a>方法2：用mysqladmin</h1><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root password <span class="string">"newpass"</span></span><br><span class="line"><span class="comment">#如果root已经设置过密码，采用如下方法</span></span><br><span class="line">mysqladmin -u root password oldpass <span class="string">"newpass"</span></span><br></pre></td></tr></table></figure>

<h1 id="方法3：-用UPDATE直接编辑user表"><a href="#方法3：-用UPDATE直接编辑user表" class="headerlink" title="方法3： 用UPDATE直接编辑user表"></a>方法3： 用UPDATE直接编辑user表</h1><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">mysql&gt; use mysql;</span><br><span class="line">mysql&gt; UPDATE user SET Password = PASSWORD(<span class="string">'newpass'</span>) WHERE user = <span class="string">'root'</span>;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<h1 id="在丢失root密码的时候，可以这样"><a href="#在丢失root密码的时候，可以这样" class="headerlink" title="在丢失root密码的时候，可以这样"></a>在丢失root密码的时候，可以这样</h1><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqld_safe --skip-grant-tables&amp;</span><br><span class="line">mysql -u root mysql</span><br><span class="line">mysql&gt; UPDATE user SET password=PASSWORD(<span class="string">"new password"</span>) WHERE user=<span class="string">'root'</span>;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>The End</p>
<hr>
<ul>
<li>转载自百度经验：<a href="http://jingyan.baidu.com/article/0320e2c198ad5f1b87507bc8.html" target="_blank" rel="noopener">MySQL修改root密码的多种方法</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>MySQL</tag>
        <tag>修改密码</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下升级Python版本</title>
    <url>/2015/11/18/Linux%E4%B8%8B%E5%8D%87%E7%BA%A7Python%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="1-第一步当然是下载最新版本的Python了！"><a href="#1-第一步当然是下载最新版本的Python了！" class="headerlink" title="1.第一步当然是下载最新版本的Python了！"></a>1.第一步当然是下载最新版本的Python了！</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line">wget https://www.python.org/ftp/python/2.7.10/Python-2.7.10.tgz</span><br></pre></td></tr></table></figure>

<h3 id="2-解压、编译、安装"><a href="#2-解压、编译、安装" class="headerlink" title="2.解压、编译、安装"></a>2.解压、编译、安装</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install gcc</span><br><span class="line">tar -xvzf Python-2.7.10.tgz</span><br><span class="line"><span class="built_in">cd</span> Python-2.7.10</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/python2.7</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<h3 id="3-创建链接使系统默认的Python变成Python2-7"><a href="#3-创建链接使系统默认的Python变成Python2-7" class="headerlink" title="3.创建链接使系统默认的Python变成Python2.7"></a>3.创建链接使系统默认的Python变成Python2.7</h3><hr>
<p> <code>ln -fs /usr/local/python2.7/bin/python2.7 /usr/bin/python</code></p>
<h3 id="4-查看一下Python的版本"><a href="#4-查看一下Python的版本" class="headerlink" title="4.查看一下Python的版本"></a>4.查看一下Python的版本</h3><hr>
<p> <code>python -V</code></p>
<h3 id="5-修改yum配置（否则更新了默认Python后的yum无法正常运行）"><a href="#5-修改yum配置（否则更新了默认Python后的yum无法正常运行）" class="headerlink" title="5.修改yum配置（否则更新了默认Python后的yum无法正常运行）"></a>5.修改yum配置（否则更新了默认Python后的yum无法正常运行）</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/bin/yum</span><br><span class="line">将第一行<span class="comment">#!/usr/bin/python 修改为原有的Python2.6版本 #!/usr/bin/python2.6</span></span><br><span class="line">CentOS系统升级Python成功完成</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>部署专业的开源云存储平台-Seafile</title>
    <url>/2015/11/18/%E9%83%A8%E7%BD%B2%E4%B8%93%E4%B8%9A%E7%9A%84%E5%BC%80%E6%BA%90%E4%BA%91%E5%AD%98%E5%82%A8%E5%B9%B3%E5%8F%B0-Seafile/</url>
    <content><![CDATA[<blockquote>
<p>本文介绍在CentOS6系列下使用MySQL部署Seafile服务器</p>
</blockquote>
<p>#1.下载服务器版本的安装包</p>
<hr>
<ul>
<li><p>可以在这个页面中下载最新的服务器安装包 <a href="https://www.seafile.com/download/" target="_blank" rel="noopener">Seafile官方下载页面</a></p>
</li>
<li><p>也可以使用<code>wget</code>命令直接下载：</p>
</li>
</ul>
<p><code>wget http://download-cn.seafile.com/seafile-server_4.4.1_x86-64.tar.gz</code></p>
<p>#2.创建服务根目录</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /FileCloud/installed</span><br><span class="line"><span class="built_in">cd</span> /FileCloud/installed</span><br><span class="line">wget http://download-cn.seafile.com/seafile-server_4.4.1_x86-64.tar.gz</span><br><span class="line">tar -xvzf seafile-server_4.4.1_x86-64.tar.gz</span><br></pre></td></tr></table></figure>

<p>#3.依赖包</p>
<hr>
<p>##3.1升级Python</p>
<p>默认的Python为2.6.6版本，这里将其升级至2.7以上版本</p>
<p><a href="http://docs.20150509.cn/2015/10/08/linuxxia-sheng-ji-pythonban-ben/" target="_blank" rel="noopener">升级Python过程详见此篇文档</a></p>
<p>##3.2 依赖包</p>
<p>安装MySQL服务并开机自启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install mysql-server</span><br><span class="line">service mysqld start</span><br><span class="line">chkconfig mysqld on</span><br></pre></td></tr></table></figure>

<p>为MySQL中的的root用户设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root</span><br><span class="line">mysql&gt; SET PASSWORD FOR <span class="string">'root'</span>@<span class="string">'localhost'</span> = PASSWORD(<span class="string">'password'</span>);</span><br><span class="line">mysql&gt; quit</span><br></pre></td></tr></table></figure>

<p>其他依赖包的安装</p>
<p><code>yum install MySQL-python python-setuptools python-imaging</code></p>
<p>#4.安装Seafile组件</p>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /FileCloud/installed/seafile-server-4.4.1</span><br><span class="line">./setup-seafile-mysql.sh</span><br></pre></td></tr></table></figure>

<p>进入到文本交互界面，如下仅供参考：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Press ENTER to <span class="built_in">continue</span></span><br><span class="line">Enter</span><br><span class="line"></span><br><span class="line">What is the name of the server? It will be displayed on the client.</span><br><span class="line">3 - 15 letters or digits</span><br><span class="line">[ server name ] xxFileCloud</span><br><span class="line"></span><br><span class="line">What is the ip or domain of the server?</span><br><span class="line">For example: www.mycompany.com, 192.168.1.101</span><br><span class="line">[ This server<span class="string">'s ip or domain ] 192.168.3.131</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Where do you want to put your seafile data?</span></span><br><span class="line"><span class="string">Please use a volume with enough free space</span></span><br><span class="line"><span class="string">[ default "/FileCloud/installed/seafile-data" ] Enter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Which port do you want to use for the seafile fileserver?</span></span><br><span class="line"><span class="string">[ default "8082" ] Enter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------------------------------------------</span></span><br><span class="line"><span class="string">Please choose a way to initialize seafile databases:</span></span><br><span class="line"><span class="string">------------------------------------------------------------------</span></span><br><span class="line"><span class="string">[1] Create new ccnet/seafile/seahub databases</span></span><br><span class="line"><span class="string">[2] Use existing ccnet/seafile/seahub databases</span></span><br><span class="line"><span class="string">[ 1 or 2 ] 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">What is the host of mysql server?</span></span><br><span class="line"><span class="string">[ default "localhost" ] Enter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">What is the port of mysql server?</span></span><br><span class="line"><span class="string">[ default "3306" ] Enter</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">What is the password of the mysql root user?</span></span><br><span class="line"><span class="string">[ root password ] "root'</span>s password of mysql<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">verifying password of user root ...  done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter the name for mysql user of seafile. It would be created if not exists.</span></span><br><span class="line"><span class="string">[ default "</span>root<span class="string">" ] `Enter`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter the database name for ccnet-server:</span></span><br><span class="line"><span class="string">[ default "</span>ccnet-db<span class="string">" ] `Enter`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter the database name for seafile-server:</span></span><br><span class="line"><span class="string">[ default "</span>seafile-db<span class="string">" ] `Enter`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Enter the database name for seahub:</span></span><br><span class="line"><span class="string">[ default "</span>seahub-db<span class="string">" ] `Enter`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string">This is your configuration</span></span><br><span class="line"><span class="string">---------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    server name:            xxFileCloud</span></span><br><span class="line"><span class="string">    server ip/domain:       192.168.3.131</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    seafile data dir:       /FileCloud/installed/seafile-data</span></span><br><span class="line"><span class="string">    fileserver port:        8082</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    database:               create new</span></span><br><span class="line"><span class="string">    ccnet database:         ccnet-db</span></span><br><span class="line"><span class="string">    seafile database:       seafile-db</span></span><br><span class="line"><span class="string">    seahub database:        seahub-db</span></span><br><span class="line"><span class="string">    database user:          root</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------------------------------------------</span></span><br><span class="line"><span class="string">Press ENTER to continue, or Ctrl-C to abort</span></span><br><span class="line"><span class="string">------------------------------------------------------------------</span></span><br><span class="line"><span class="string">Generating ccnet configuration ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">Successly create configuration dir /kfc/installed/ccnet.</span></span><br><span class="line"><span class="string">Generating seafile configuration ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Done.</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string">Generating seahub configuration ...</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string">Now creating seahub database tables ...</span></span><br><span class="line"><span class="string">-------------------------------------------------------------</span></span><br><span class="line"><span class="string">creating seafile-server-latest symbolic link ...  done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">------------------------------------------------------------------</span></span><br><span class="line"><span class="string">Your seafile server configuration has been finished successfully.</span></span><br><span class="line"><span class="string">-------------------------------------------------------------------</span></span><br><span class="line"><span class="string">run seafile server:     ./seafile.sh &#123; start | stop | restart &#125;</span></span><br><span class="line"><span class="string">run seahub  server:     ./seahub.sh  &#123; start &lt;port&gt; | stop | restart &lt;port&gt; &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-------------------------------------------------------------------</span></span><br><span class="line"><span class="string">If you are behind a firewall, remember to allow input/output of these tcp ports:</span></span><br><span class="line"><span class="string">--------------------------------------------------------------------</span></span><br><span class="line"><span class="string">port of seafile fileserver:   8082</span></span><br><span class="line"><span class="string">port of seahub:               8000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">When problems occur, Refer to</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        https://github.com/haiwen/seafile/wiki</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for information.</span></span><br></pre></td></tr></table></figure>

<p>#开启Seafile服务</p>
<hr>
<p>##设置打开文件描述符的最大数量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 65535</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ulimit -n 65535"</span> &gt;&gt; /etc/rc.local</span><br></pre></td></tr></table></figure>

<p>##启动 Seafile 服务器和 Seahub 网站</p>
<ul>
<li><p>启动Seafile服务</p>
<p><code>cd /FileCloud/installed/seafile-server-4.4.1 &amp;&amp; ./seafile.sh start</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost seafile-server-4.4.1]<span class="comment"># ./seafile.sh start</span></span><br><span class="line"></span><br><span class="line">Starting seafile server, please <span class="built_in">wait</span> ...</span><br><span class="line">Seafile server started</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<ul>
<li><p>启动Seahub服务(不加端口号默认运行在8000端口，可改配置文件)</p>
<p><code>cd /FileCloud/installed/seafile-server-4.4.1 &amp;&amp; ./seahub.sh start 80</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@kfc seafile-server-4.4.1]<span class="comment"># ./seahub.sh start 80</span></span><br><span class="line"></span><br><span class="line">LC_ALL is not <span class="built_in">set</span> <span class="keyword">in</span> ENV, <span class="built_in">set</span> to en_US.UTF-8</span><br><span class="line">Starting seahub at port 80 ...</span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">It<span class="string">'s the first time you start the seafile server. Now let'</span>s create the admin account</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line">What is the email <span class="keyword">for</span> the admin account?</span><br><span class="line">[ admin email ] polarsnow@20150509.cn  <span class="comment">#这里的账号最好填写能收到邮件的邮箱用于忘记密码后找回密码使用</span></span><br><span class="line"></span><br><span class="line">What is the password <span class="keyword">for</span> the admin account?  <span class="comment">#这里的密码是自定义的Seafile的密码</span></span><br><span class="line">[ admin password ] </span><br><span class="line"></span><br><span class="line">Enter the password again:</span><br><span class="line">[ admin password again ] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------</span><br><span class="line">Successfully created seafile admin</span><br><span class="line">----------------------------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Seahub is started</span><br><span class="line"></span><br><span class="line">Done.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：你第一次启动 seahub 时，seahub.sh 脚本会提示你创建一个 seafile 管理员帐号</p>
</blockquote>
<p>#访问云存储页面</p>
<hr>
<p>使用浏览器打开<code>http://192.168.3.131</code>输入刚刚创建的用户名的密码即可。</p>
<p>#Seafile的关闭和重启</p>
<hr>
<p>##关闭</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./seahub.sh stop <span class="comment"># 停止 Seahub</span></span><br><span class="line">./seafile.sh stop <span class="comment"># 停止 Seafile 进程</span></span><br></pre></td></tr></table></figure>

<p>##重启</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./seafile.sh restart <span class="comment"># 停止当前的 Seafile 进程，然后重启 Seafile</span></span><br><span class="line">./seahub.sh restart  <span class="comment"># 停止当前的 Seahub 进程，并在 8000 端口重新启动 Seahub</span></span><br></pre></td></tr></table></figure>

<p>#在另一端口上运行 Seahub</p>
<hr>
<blockquote>
<p>如果你不想在默认的 8000 端口上运行 Seahub, 而是想自定义端口（比如8001）中运行，请按以下步骤操作:</p>
</blockquote>
<ul>
<li>关闭 Seafile 服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./seahub.sh stop <span class="comment"># 停止 Seafile 进程</span></span><br><span class="line">./seafile.sh stop <span class="comment"># 停止 Seahub</span></span><br><span class="line">更改haiwen/ccnet/ccnet.conf文件中SERVICE_URL 的值(假设你的 ip 或者域名时192.168.1.100), 如下:</span><br><span class="line">SERVICE_URL = http://192.168.1.100:8001</span><br></pre></td></tr></table></figure>

<ul>
<li>重启 Seafile 服务器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./seafile.sh start <span class="comment"># 启动 Seafile 服务</span></span><br><span class="line">./seahub.sh start 8001 <span class="comment"># 启动 Seahub 网站 （运行在8001端口上）</span></span><br></pre></td></tr></table></figure>

<p>#如果停止/重启的脚本运行失败</p>
<hr>
<blockquote>
<p>大多数情况下 seafile.sh seahub.sh 脚本可以正常工作。如果遇到问题：</p>
</blockquote>
<p>使用pgrep命令检查 seafile/seahub 进程是否还在运行中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pgrep -f seafile-controller <span class="comment"># 查看 Seafile 进程</span></span><br><span class="line">pgrep -f <span class="string">"manage.py run_gunicorn"</span> <span class="comment"># 查看 Seahub 进程</span></span><br></pre></td></tr></table></figure>

<p>使用pkill命令杀掉相关进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pkill -f seafile-controller <span class="comment"># 结束 Seafile 进程</span></span><br><span class="line">pkill -f <span class="string">"manage.py run_gunicorn"</span> <span class="comment"># 结束 Seafile 进程</span></span><br></pre></td></tr></table></figure>

<p>#The End</p>
<hr>
<ul>
<li>至此你已经成功掌握了Seafile最基本的搭建和使用</li>
<li>本文参考Seafile官方文档搭建<a href="https://www.seafile.com/home/" target="_blank" rel="noopener">Seafile官网</a></li>
<li>如需下载客户端，可登陆Seafile官网进行下载</li>
</ul>
<hr>
<p>also you can connnect me: <a href="mailto:&#x70;&#x6f;&#108;&#97;&#x72;&#x73;&#x6e;&#x6f;&#119;&#x40;&#50;&#48;&#49;&#53;&#48;&#x35;&#48;&#57;&#x2e;&#x63;&#110;">&#x70;&#x6f;&#108;&#97;&#x72;&#x73;&#x6e;&#x6f;&#119;&#x40;&#50;&#48;&#49;&#53;&#48;&#x35;&#48;&#57;&#x2e;&#x63;&#110;</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Seafile</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown常用语法</title>
    <url>/2015/11/18/Markdown%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="标题的使用"><a href="#标题的使用" class="headerlink" title="标题的使用"></a>标题的使用</h1><hr>
<p>顶格写前面一个<code>#</code>号是一级标题 # 这个是一级标题</p>
<p>顶格写前面两个<code>#</code>号是二级标题 ## 这个是二级标题</p>
<p>以此类推可以写到六级标题</p>
<p>例如：</p>
<h2 id="这个是二级标题"><a href="#这个是二级标题" class="headerlink" title="这个是二级标题"></a>这个是二级标题</h2><h3 id="这个是三级标题"><a href="#这个是三级标题" class="headerlink" title="这个是三级标题"></a>这个是三级标题</h3><h4 id="这个是四级标题"><a href="#这个是四级标题" class="headerlink" title="这个是四级标题"></a>这个是四级标题</h4><p><strong>注意：</strong>在markdown的标准语法中，标题的井号标识符必须写<code>顶格</code>在文字的最前面且紧跟<code>一个空格</code>，否则无效</p>
<h1 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h1><hr>
<p>在markdown中直接回车并不能出现换行的效果，需要两个回车才是换行！例如：<br>我被写在了第二行，但我不会被显示在第二行<del>~</del></p>
<p>这个才是第二行，我需要两个回车（与上文隔开至少一行/段我才是第二行/段）</p>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><hr>
<p>分割线至少是由三个连续的<code>-</code>组成</p>
<h1 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h1><hr>
<p>在需要加粗的文字两头加上两个<code>*</code>号即可实现字体加粗</p>
<p>例如： <strong>这个是加粗的字体</strong></p>
<h1 id="斜体字"><a href="#斜体字" class="headerlink" title="斜体字"></a>斜体字</h1><hr>
<p>在需要设置为斜体字的文字两头加上一个<code>*</code>号即可实现斜体效果</p>
<p>例如：<em>这个是斜体</em></p>
<h1 id="区块引用"><a href="#区块引用" class="headerlink" title="区块引用"></a>区块引用</h1><hr>
<p>在每一行或每一段文字的最前面定格写一个<code>&gt;</code>符号</p>
<blockquote>
<p>Oh，YES！  —LR名言</p>
</blockquote>
<h1 id="链接和Email地址"><a href="#链接和Email地址" class="headerlink" title="链接和Email地址"></a>链接和Email地址</h1><hr>
<ol>
<li><p>使用<code>&lt;&gt;</code>符号括起来的且符合邮件地址格式，即会在文章中以邮件链接显示</p>
<p> 例如： 这 <a href="mailto:&#112;&#x6f;&#108;&#x61;&#114;&#115;&#x6f;&#110;&#x77;&#x40;&#50;&#48;&#49;&#53;&#48;&#x35;&#48;&#57;&#x2e;&#x63;&#x6e;">&#112;&#x6f;&#108;&#x61;&#114;&#115;&#x6f;&#110;&#x77;&#x40;&#50;&#48;&#49;&#53;&#48;&#x35;&#48;&#57;&#x2e;&#x63;&#x6e;</a> 就是我的邮件地址</p>
</li>
<li><p>网址同样适用于这个规则，但必须符合网址的格式</p>
<p> 例如： 这 <a href="http://www.20150509.cn" target="_blank" rel="noopener">http://www.20150509.cn</a> 是我的网站</p>
</li>
<li><p>当然你也可以使用链接文字，在网址前使用<code>[]</code>符号设置文字，并将上面的<code>&lt;&gt;</code>符号更换为<code>( )</code>符号写入地址即可</p>
<p> 例如： 点击访问 <a href="http://www.20150509.cn" target="_blank" rel="noopener">我的网站</a></p>
</li>
</ol>
<h1 id="代码和代码块"><a href="#代码和代码块" class="headerlink" title="代码和代码块"></a>代码和代码块</h1><hr>
<p>引用代码的方式很简单，使用两个反引号引起来即可，写过shell的应该很熟悉这种用法</p>
<p>例如：<code>我是两个反引号中的代码，反引号一般在键盘ESC的正下方，和飘号是同一按键~</code></p>
<p>引用代码块，需要使用一对儿三个反引号引起来，加在一起有六个反引号组成</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line">cp /tmp/1.txt /home/lr/</span><br><span class="line">mv /home/lr/2.txt /tmp/</span><br><span class="line"><span class="built_in">history</span></span><br><span class="line"><span class="built_in">echo</span> &gt; /etc/rc.local</span><br><span class="line">dstat -tcdrlmn --top-cpu --top-mem</span><br></pre></td></tr></table></figure>

<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><hr>
<ol>
<li>数字编号的列表，<code>数字</code> + <code>英文字符点</code> + <code>一个空格</code> + <code>正文</code>即可<br> 例如：<ol>
<li>第一要吃饭</li>
<li>第二要吃饭</li>
<li>第三还是要吃饭</li>
</ol>
</li>
<li>项目符号列表，<code>-</code> +<code>一个空格</code> + <code>正文</code>即可<ul>
<li>喝水</li>
<li>喝水</li>
<li>还要喝水</li>
</ul>
</li>
</ol>
<h1 id="字体、颜色和字号的设置"><a href="#字体、颜色和字号的设置" class="headerlink" title="字体、颜色和字号的设置"></a>字体、颜色和字号的设置</h1><hr>
<p>markdown语法是不支持修改文字的字体、颜色和字号的，凡是markdown语法本身就是HTML的一种实现，markdown文档中是支持HTML语言标记的，所以，可以直接通过HTML标签修改文字属性。</p>
<p>例如：</p>
<p>修改<font color="green">文字颜色</font></p>
<p>修改<font size="5">文字大小</font></p>
<p>修改<font face="verdana">verdana字体</font> 和 <font face="Calibri">Calibri字体</font></p>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><hr>
<p>markdown的表格用起来还是非常给（fei）力的</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| ID     |    姓名  |   性别  |</span><br><span class="line">| ----- | ------- | ------- |</span><br><span class="line">| 007   |     LR    | 纯MAN |</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>ID</th>
<th>姓名</th>
<th>性别</th>
</tr>
</thead>
<tbody><tr>
<td>007</td>
<td>LR</td>
<td>纯MAN</td>
</tr>
</tbody></table>
<p>上面就是markdown语法的表格书写格式，对于想要对其他们的强迫症患者来说真的是一场灾难</p>
<h1 id="禁止转义"><a href="#禁止转义" class="headerlink" title="禁止转义"></a>禁止转义</h1><hr>
<p>在文章中，如果需要用到类似于星号、井号、反引号、减号等markdown标记语言特殊字符的时候，会出现转义的情况，markdown会把相应的文字根据其语法做特殊的处理。当我们仅仅是需要使用一对文本的反引号时，可以在反引号前面加反斜杠来禁止markdown进行转义。</p>
<p>例如：</p>
<p>date=`date +%Y+%m+%d`</p>
<p>通过使用反斜杠，上面这条bash shell命令中的反引号就没有被markdown转义成代码</p>
]]></content>
      <categories>
        <category>Other</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
</search>
